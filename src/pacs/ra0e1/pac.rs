#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![doc = "Peripheral access API (generated using chiptool v0.1.0 (d771c7b 2025-03-27))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "0 - ICU Interrupt 0"]
    IEL0 = 0,
    #[doc = "1 - ICU Interrupt 1"]
    IEL1 = 1,
    #[doc = "2 - ICU Interrupt 2"]
    IEL2 = 2,
    #[doc = "3 - ICU Interrupt 3"]
    IEL3 = 3,
    #[doc = "4 - ICU Interrupt 4"]
    IEL4 = 4,
    #[doc = "5 - ICU Interrupt 5"]
    IEL5 = 5,
    #[doc = "6 - ICU Interrupt 6"]
    IEL6 = 6,
    #[doc = "7 - ICU Interrupt 7"]
    IEL7 = 7,
    #[doc = "8 - ICU Interrupt 8"]
    IEL8 = 8,
    #[doc = "9 - ICU Interrupt 9"]
    IEL9 = 9,
    #[doc = "10 - ICU Interrupt 10"]
    IEL10 = 10,
    #[doc = "11 - ICU Interrupt 11"]
    IEL11 = 11,
    #[doc = "12 - ICU Interrupt 12"]
    IEL12 = 12,
    #[doc = "13 - ICU Interrupt 13"]
    IEL13 = 13,
    #[doc = "14 - ICU Interrupt 14"]
    IEL14 = 14,
    #[doc = "15 - ICU Interrupt 15"]
    IEL15 = 15,
    #[doc = "16 - ICU Interrupt 16"]
    IEL16 = 16,
    #[doc = "17 - ICU Interrupt 17"]
    IEL17 = 17,
    #[doc = "18 - ICU Interrupt 18"]
    IEL18 = 18,
    #[doc = "19 - ICU Interrupt 19"]
    IEL19 = 19,
    #[doc = "20 - ICU Interrupt 20"]
    IEL20 = 20,
    #[doc = "21 - ICU Interrupt 21"]
    IEL21 = 21,
    #[doc = "22 - ICU Interrupt 22"]
    IEL22 = 22,
    #[doc = "23 - ICU Interrupt 23"]
    IEL23 = 23,
    #[doc = "24 - ICU Interrupt 24"]
    IEL24 = 24,
    #[doc = "25 - ICU Interrupt 25"]
    IEL25 = 25,
    #[doc = "26 - ICU Interrupt 26"]
    IEL26 = 26,
    #[doc = "27 - ICU Interrupt 27"]
    IEL27 = 27,
    #[doc = "28 - ICU Interrupt 28"]
    IEL28 = 28,
    #[doc = "29 - ICU Interrupt 29"]
    IEL29 = 29,
    #[doc = "30 - ICU Interrupt 30"]
    IEL30 = 30,
    #[doc = "31 - ICU Interrupt 31"]
    IEL31 = 31,
    #[doc = "32 - ICU Interrupt 32"]
    IEL32 = 32,
    #[doc = "33 - ICU Interrupt 33"]
    IEL33 = 33,
    #[doc = "34 - ICU Interrupt 34"]
    IEL34 = 34,
    #[doc = "35 - ICU Interrupt 35"]
    IEL35 = 35,
    #[doc = "36 - ICU Interrupt 36"]
    IEL36 = 36,
    #[doc = "37 - ICU Interrupt 37"]
    IEL37 = 37,
    #[doc = "38 - ICU Interrupt 38"]
    IEL38 = 38,
    #[doc = "39 - ICU Interrupt 39"]
    IEL39 = 39,
    #[doc = "40 - ICU Interrupt 40"]
    IEL40 = 40,
    #[doc = "41 - ICU Interrupt 41"]
    IEL41 = 41,
    #[doc = "42 - ICU Interrupt 42"]
    IEL42 = 42,
    #[doc = "43 - ICU Interrupt 43"]
    IEL43 = 43,
    #[doc = "44 - ICU Interrupt 44"]
    IEL44 = 44,
    #[doc = "45 - ICU Interrupt 45"]
    IEL45 = 45,
    #[doc = "46 - ICU Interrupt 46"]
    IEL46 = 46,
    #[doc = "47 - ICU Interrupt 47"]
    IEL47 = 47,
    #[doc = "48 - ICU Interrupt 48"]
    IEL48 = 48,
    #[doc = "49 - ICU Interrupt 49"]
    IEL49 = 49,
    #[doc = "50 - ICU Interrupt 50"]
    IEL50 = 50,
    #[doc = "51 - ICU Interrupt 51"]
    IEL51 = 51,
    #[doc = "52 - ICU Interrupt 52"]
    IEL52 = 52,
    #[doc = "53 - ICU Interrupt 53"]
    IEL53 = 53,
    #[doc = "54 - ICU Interrupt 54"]
    IEL54 = 54,
    #[doc = "55 - ICU Interrupt 55"]
    IEL55 = 55,
    #[doc = "56 - ICU Interrupt 56"]
    IEL56 = 56,
    #[doc = "57 - ICU Interrupt 57"]
    IEL57 = 57,
    #[doc = "58 - ICU Interrupt 58"]
    IEL58 = 58,
    #[doc = "59 - ICU Interrupt 59"]
    IEL59 = 59,
    #[doc = "60 - ICU Interrupt 60"]
    IEL60 = 60,
    #[doc = "61 - ICU Interrupt 61"]
    IEL61 = 61,
    #[doc = "62 - ICU Interrupt 62"]
    IEL62 = 62,
    #[doc = "63 - ICU Interrupt 63"]
    IEL63 = 63,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    extern "C" {
        fn IEL0();
        fn IEL1();
        fn IEL2();
        fn IEL3();
        fn IEL4();
        fn IEL5();
        fn IEL6();
        fn IEL7();
        fn IEL8();
        fn IEL9();
        fn IEL10();
        fn IEL11();
        fn IEL12();
        fn IEL13();
        fn IEL14();
        fn IEL15();
        fn IEL16();
        fn IEL17();
        fn IEL18();
        fn IEL19();
        fn IEL20();
        fn IEL21();
        fn IEL22();
        fn IEL23();
        fn IEL24();
        fn IEL25();
        fn IEL26();
        fn IEL27();
        fn IEL28();
        fn IEL29();
        fn IEL30();
        fn IEL31();
        fn IEL32();
        fn IEL33();
        fn IEL34();
        fn IEL35();
        fn IEL36();
        fn IEL37();
        fn IEL38();
        fn IEL39();
        fn IEL40();
        fn IEL41();
        fn IEL42();
        fn IEL43();
        fn IEL44();
        fn IEL45();
        fn IEL46();
        fn IEL47();
        fn IEL48();
        fn IEL49();
        fn IEL50();
        fn IEL51();
        fn IEL52();
        fn IEL53();
        fn IEL54();
        fn IEL55();
        fn IEL56();
        fn IEL57();
        fn IEL58();
        fn IEL59();
        fn IEL60();
        fn IEL61();
        fn IEL62();
        fn IEL63();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    pub static __INTERRUPTS: [Vector; 64] = [
        Vector { _handler: IEL0 },
        Vector { _handler: IEL1 },
        Vector { _handler: IEL2 },
        Vector { _handler: IEL3 },
        Vector { _handler: IEL4 },
        Vector { _handler: IEL5 },
        Vector { _handler: IEL6 },
        Vector { _handler: IEL7 },
        Vector { _handler: IEL8 },
        Vector { _handler: IEL9 },
        Vector { _handler: IEL10 },
        Vector { _handler: IEL11 },
        Vector { _handler: IEL12 },
        Vector { _handler: IEL13 },
        Vector { _handler: IEL14 },
        Vector { _handler: IEL15 },
        Vector { _handler: IEL16 },
        Vector { _handler: IEL17 },
        Vector { _handler: IEL18 },
        Vector { _handler: IEL19 },
        Vector { _handler: IEL20 },
        Vector { _handler: IEL21 },
        Vector { _handler: IEL22 },
        Vector { _handler: IEL23 },
        Vector { _handler: IEL24 },
        Vector { _handler: IEL25 },
        Vector { _handler: IEL26 },
        Vector { _handler: IEL27 },
        Vector { _handler: IEL28 },
        Vector { _handler: IEL29 },
        Vector { _handler: IEL30 },
        Vector { _handler: IEL31 },
        Vector { _handler: IEL32 },
        Vector { _handler: IEL33 },
        Vector { _handler: IEL34 },
        Vector { _handler: IEL35 },
        Vector { _handler: IEL36 },
        Vector { _handler: IEL37 },
        Vector { _handler: IEL38 },
        Vector { _handler: IEL39 },
        Vector { _handler: IEL40 },
        Vector { _handler: IEL41 },
        Vector { _handler: IEL42 },
        Vector { _handler: IEL43 },
        Vector { _handler: IEL44 },
        Vector { _handler: IEL45 },
        Vector { _handler: IEL46 },
        Vector { _handler: IEL47 },
        Vector { _handler: IEL48 },
        Vector { _handler: IEL49 },
        Vector { _handler: IEL50 },
        Vector { _handler: IEL51 },
        Vector { _handler: IEL52 },
        Vector { _handler: IEL53 },
        Vector { _handler: IEL54 },
        Vector { _handler: IEL55 },
        Vector { _handler: IEL56 },
        Vector { _handler: IEL57 },
        Vector { _handler: IEL58 },
        Vector { _handler: IEL59 },
        Vector { _handler: IEL60 },
        Vector { _handler: IEL61 },
        Vector { _handler: IEL62 },
        Vector { _handler: IEL63 },
    ];
}
#[doc = "SRAM Control"]
pub const SRAM: sram::Sram = unsafe { sram::Sram::from_ptr(0x4000_2000usize as _) };
#[doc = "BUS Control"]
pub const BUS: bus::Bus = unsafe { bus::Bus::from_ptr(0x4000_3000usize as _) };
#[doc = "Data Transfer Controller"]
pub const DTC: dtc::Dtc = unsafe { dtc::Dtc::from_ptr(0x4000_5400usize as _) };
#[doc = "Interrupt Controller"]
pub const ICU: icu::Icu = unsafe { icu::Icu::from_ptr(0x4000_6000usize as _) };
#[doc = "Debug Function"]
pub const DBG: dbg::Dbg = unsafe { dbg::Dbg::from_ptr(0x4001_b000usize as _) };
#[doc = "System Control"]
pub const SYSC: sysc::Sysc = unsafe { sysc::Sysc::from_ptr(0x4001_e000usize as _) };
#[doc = "Event Link Controller"]
pub const ELC: elc::Elc = unsafe { elc::Elc::from_ptr(0x4004_1000usize as _) };
#[doc = "Independent Watchdog Timer"]
pub const IWDT: iwdt::Iwdt = unsafe { iwdt::Iwdt::from_ptr(0x4004_4400usize as _) };
#[doc = "Module Stop Control"]
pub const MSTP: mstp::Mstp = unsafe { mstp::Mstp::from_ptr(0x4004_7000usize as _) };
#[doc = "CRC Calculator"]
pub const CRC: crc::Crc = unsafe { crc::Crc::from_ptr(0x4007_4000usize as _) };
#[doc = "Port 0 Control"]
pub const PORT0: port0::Port0 = unsafe { port0::Port0::from_ptr(0x400a_0000usize as _) };
#[doc = "Port 1 Control"]
pub const PORT1: port1::Port1 = unsafe { port1::Port1::from_ptr(0x400a_0020usize as _) };
#[doc = "Port 2 Control"]
pub const PORT2: port2::Port2 = unsafe { port2::Port2::from_ptr(0x400a_0040usize as _) };
#[doc = "Port 3 Control"]
pub const PORT3: port3::Port3 = unsafe { port3::Port3::from_ptr(0x400a_0060usize as _) };
#[doc = "Port 4 Control"]
pub const PORT4: port4::Port4 = unsafe { port4::Port4::from_ptr(0x400a_0080usize as _) };
#[doc = "Port 9 Control"]
pub const PORT9: port9::Port9 = unsafe { port9::Port9::from_ptr(0x400a_0120usize as _) };
#[doc = "Pmn Pin Function Select"]
pub const PFS_A: pfs_a::PfsA = unsafe { pfs_a::PfsA::from_ptr(0x400a_0200usize as _) };
#[doc = "Product Organize"]
pub const PORGA: porga::Porga = unsafe { porga::Porga::from_ptr(0x400a_1000usize as _) };
#[doc = "A/D Converter"]
pub const ADC_D: adc_d::AdcD = unsafe { adc_d::AdcD::from_ptr(0x400a_1800usize as _) };
#[doc = "Serial Array Unit 0"]
pub const SAU0: sau0::Sau0 = unsafe { sau0::Sau0::from_ptr(0x400a_2000usize as _) };
#[doc = "Serial Array Unit 1"]
pub const SAU1: sau1::Sau1 = unsafe { sau1::Sau1::from_ptr(0x400a_2200usize as _) };
#[doc = "Timer Array Unit"]
pub const TAU: tau::Tau = unsafe { tau::Tau::from_ptr(0x400a_2600usize as _) };
#[doc = "Realtime Clock"]
pub const RTC_C: rtc_c::RtcC = unsafe { rtc_c::RtcC::from_ptr(0x400a_2c00usize as _) };
#[doc = "Serial Interface IICA"]
pub const IICA: iica::Iica = unsafe { iica::Iica::from_ptr(0x400a_3000usize as _) };
#[doc = "Serial Interface UARTA"]
pub const UARTA: uarta::Uarta = unsafe { uarta::Uarta::from_ptr(0x400a_3400usize as _) };
#[doc = "32-bit Interval Timer"]
pub const TML32: tml32::Tml32 = unsafe { tml32::Tml32::from_ptr(0x400a_3800usize as _) };
#[doc = "Clock Output/Buzzer Output Controller"]
pub const PCLBUZ: pclbuz::Pclbuz = unsafe { pclbuz::Pclbuz::from_ptr(0x400a_3b00usize as _) };
#[doc = "True Random Number Generator"]
pub const TRNG: trng::Trng = unsafe { trng::Trng::from_ptr(0x400d_1000usize as _) };
#[doc = "Flash I/O Registers"]
pub const FLCN: flcn::Flcn = unsafe { flcn::Flcn::from_ptr(0x407e_c000usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
#[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
pub mod adc_d {
    #[doc = "A/D Converter"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct AdcD {
        ptr: *mut u8,
    }
    unsafe impl Send for AdcD {}
    unsafe impl Sync for AdcD {}
    impl AdcD {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A/D Converter Mode Register 0"]
        #[inline(always)]
        pub const fn adm0(self) -> crate::common::Reg<regs::Adm0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Analog Input Channel Specification Register"]
        #[inline(always)]
        pub const fn ads(self) -> crate::common::Reg<regs::Ads, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "A/D Converter Mode Register 1"]
        #[inline(always)]
        pub const fn adm1(self) -> crate::common::Reg<regs::Adm1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "12-bit or 10-bit A/D Conversion Result Register"]
        #[inline(always)]
        pub const fn adcr(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "8-bit A/D Conversion Result Register"]
        #[inline(always)]
        pub const fn adcrh(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "A/D Converter Mode Register 2"]
        #[inline(always)]
        pub const fn adm2(self) -> crate::common::Reg<regs::Adm2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Conversion Result Comparison Upper Limit Setting Register"]
        #[inline(always)]
        pub const fn adul(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0111usize) as _) }
        }
        #[doc = "Conversion Result Comparison Lower Limit Setting Register"]
        #[inline(always)]
        pub const fn adll(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0112usize) as _) }
        }
        #[doc = "A/D Test Register"]
        #[inline(always)]
        pub const fn adtes(self) -> crate::common::Reg<regs::Adtes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0113usize) as _) }
        }
        #[doc = "12-bit or 10-bit A/D Conversion Result Register 0"]
        #[inline(always)]
        pub const fn adcr0(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "8-bit A/D Conversion Result Register 0"]
        #[inline(always)]
        pub const fn adcr0h(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0121usize) as _) }
        }
        #[doc = "12-bit or 10-bit A/D Conversion Result Register 1"]
        #[inline(always)]
        pub const fn adcr1(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0122usize) as _) }
        }
        #[doc = "8-bit A/D Conversion Result Register 1"]
        #[inline(always)]
        pub const fn adcr1h(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0123usize) as _) }
        }
        #[doc = "12-bit or 10-bit A/D Conversion Result Register 2"]
        #[inline(always)]
        pub const fn adcr2(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "8-bit A/D Conversion Result Register 2"]
        #[inline(always)]
        pub const fn adcr2h(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0125usize) as _) }
        }
        #[doc = "12-bit or 10-bit A/D Conversion Result Register 3"]
        #[inline(always)]
        pub const fn adcr3(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0126usize) as _) }
        }
        #[doc = "8-bit A/D Conversion Result Register 3"]
        #[inline(always)]
        pub const fn adcr3h(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0127usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "A/D Converter Mode Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adm0(pub u8);
        impl Adm0 {
            #[doc = "A/D voltage comparator operation control"]
            #[inline(always)]
            pub const fn adce(&self) -> super::vals::Adce {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Adce::from_bits(val as u8)
            }
            #[doc = "A/D voltage comparator operation control"]
            #[inline(always)]
            pub fn set_adce(&mut self, val: super::vals::Adce) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Select Operation voltage mode"]
            #[inline(always)]
            pub const fn lv(&self) -> super::vals::Lv {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Lv::from_bits(val as u8)
            }
            #[doc = "Select Operation voltage mode"]
            #[inline(always)]
            pub fn set_lv(&mut self, val: super::vals::Lv) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u8) & 0x03) << 1usize);
            }
            #[doc = "Select Conversion Clock (fAD)"]
            #[inline(always)]
            pub const fn fr(&self) -> super::vals::Fr {
                let val = (self.0 >> 3usize) & 0x07;
                super::vals::Fr::from_bits(val as u8)
            }
            #[doc = "Select Conversion Clock (fAD)"]
            #[inline(always)]
            pub fn set_fr(&mut self, val: super::vals::Fr) {
                self.0 = (self.0 & !(0x07 << 3usize)) | (((val.to_bits() as u8) & 0x07) << 3usize);
            }
            #[doc = "Specification of the A/D conversion channel selection mode"]
            #[inline(always)]
            pub const fn admd(&self) -> super::vals::Admd {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Admd::from_bits(val as u8)
            }
            #[doc = "Specification of the A/D conversion channel selection mode"]
            #[inline(always)]
            pub fn set_admd(&mut self, val: super::vals::Admd) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "A/D conversion operation control"]
            #[inline(always)]
            pub const fn adcs(&self) -> super::vals::Adcs {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Adcs::from_bits(val as u8)
            }
            #[doc = "A/D conversion operation control"]
            #[inline(always)]
            pub fn set_adcs(&mut self, val: super::vals::Adcs) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Adm0 {
            #[inline(always)]
            fn default() -> Adm0 {
                Adm0(0)
            }
        }
        impl core::fmt::Debug for Adm0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adm0")
                    .field("adce", &self.adce())
                    .field("lv", &self.lv())
                    .field("fr", &self.fr())
                    .field("admd", &self.admd())
                    .field("adcs", &self.adcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adm0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adm0 {{ adce: {:?}, lv: {:?}, fr: {:?}, admd: {:?}, adcs: {:?} }}",
                    self.adce(),
                    self.lv(),
                    self.fr(),
                    self.admd(),
                    self.adcs()
                )
            }
        }
        #[doc = "A/D Converter Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adm1(pub u8);
        impl Adm1 {
            #[doc = "Selection of the Hardware Trigger Signal"]
            #[inline(always)]
            pub const fn adtrs(&self) -> super::vals::Adtrs {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Adtrs::from_bits(val as u8)
            }
            #[doc = "Selection of the Hardware Trigger Signal"]
            #[inline(always)]
            pub fn set_adtrs(&mut self, val: super::vals::Adtrs) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "PCLKB Input Frequency Setting"]
            #[inline(always)]
            pub const fn adlsp(&self) -> super::vals::Adlsp {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Adlsp::from_bits(val as u8)
            }
            #[doc = "PCLKB Input Frequency Setting"]
            #[inline(always)]
            pub fn set_adlsp(&mut self, val: super::vals::Adlsp) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Specification of the A/D Conversion Mode"]
            #[inline(always)]
            pub const fn adscm(&self) -> super::vals::Adscm {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Adscm::from_bits(val as u8)
            }
            #[doc = "Specification of the A/D Conversion Mode"]
            #[inline(always)]
            pub fn set_adscm(&mut self, val: super::vals::Adscm) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Selection of the A/D Conversion Trigger Mode"]
            #[inline(always)]
            pub const fn adtmd(&self) -> super::vals::Adtmd {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Adtmd::from_bits(val as u8)
            }
            #[doc = "Selection of the A/D Conversion Trigger Mode"]
            #[inline(always)]
            pub fn set_adtmd(&mut self, val: super::vals::Adtmd) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Adm1 {
            #[inline(always)]
            fn default() -> Adm1 {
                Adm1(0)
            }
        }
        impl core::fmt::Debug for Adm1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adm1")
                    .field("adtrs", &self.adtrs())
                    .field("adlsp", &self.adlsp())
                    .field("adscm", &self.adscm())
                    .field("adtmd", &self.adtmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adm1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adm1 {{ adtrs: {:?}, adlsp: {:?}, adscm: {:?}, adtmd: {:?} }}",
                    self.adtrs(),
                    self.adlsp(),
                    self.adscm(),
                    self.adtmd()
                )
            }
        }
        #[doc = "A/D Converter Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adm2(pub u8);
        impl Adm2 {
            #[inline(always)]
            pub const fn adtyp(&self) -> super::vals::Adtyp {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Adtyp::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_adtyp(&mut self, val: super::vals::Adtyp) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[inline(always)]
            pub const fn awc(&self) -> super::vals::Awc {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Awc::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_awc(&mut self, val: super::vals::Awc) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn adrck(&self) -> super::vals::Adrck {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Adrck::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_adrck(&mut self, val: super::vals::Adrck) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[inline(always)]
            pub const fn adrefm(&self) -> super::vals::Adrefm {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Adrefm::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_adrefm(&mut self, val: super::vals::Adrefm) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn adrefp(&self) -> super::vals::Adrefp {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Adrefp::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_adrefp(&mut self, val: super::vals::Adrefp) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Adm2 {
            #[inline(always)]
            fn default() -> Adm2 {
                Adm2(0)
            }
        }
        impl core::fmt::Debug for Adm2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adm2")
                    .field("adtyp", &self.adtyp())
                    .field("awc", &self.awc())
                    .field("adrck", &self.adrck())
                    .field("adrefm", &self.adrefm())
                    .field("adrefp", &self.adrefp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adm2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adm2 {{ adtyp: {:?}, awc: {:?}, adrck: {:?}, adrefm: {:?}, adrefp: {:?} }}",
                    self.adtyp(),
                    self.awc(),
                    self.adrck(),
                    self.adrefm(),
                    self.adrefp()
                )
            }
        }
        #[doc = "Analog Input Channel Specification Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ads(pub u8);
        impl Ads {
            #[doc = "Selection of the Analog Input Channel (See to )"]
            #[inline(always)]
            pub const fn ads(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Selection of the Analog Input Channel (See to )"]
            #[inline(always)]
            pub fn set_ads(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "Select Internal or External of Analog Input (See to )"]
            #[inline(always)]
            pub const fn adiss(&self) -> super::vals::Adiss {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Adiss::from_bits(val as u8)
            }
            #[doc = "Select Internal or External of Analog Input (See to )"]
            #[inline(always)]
            pub fn set_adiss(&mut self, val: super::vals::Adiss) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ads {
            #[inline(always)]
            fn default() -> Ads {
                Ads(0)
            }
        }
        impl core::fmt::Debug for Ads {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ads")
                    .field("ads", &self.ads())
                    .field("adiss", &self.adiss())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ads {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ads {{ ads: {=u8:?}, adiss: {:?} }}",
                    self.ads(),
                    self.adiss()
                )
            }
        }
        #[doc = "A/D Test Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adtes(pub u8);
        impl Adtes {
            #[doc = "Selection of A/D Conversion Target for Testing"]
            #[inline(always)]
            pub const fn adtes(&self) -> super::vals::Adtes {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Adtes::from_bits(val as u8)
            }
            #[doc = "Selection of A/D Conversion Target for Testing"]
            #[inline(always)]
            pub fn set_adtes(&mut self, val: super::vals::Adtes) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Adtes {
            #[inline(always)]
            fn default() -> Adtes {
                Adtes(0)
            }
        }
        impl core::fmt::Debug for Adtes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adtes")
                    .field("adtes", &self.adtes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adtes {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adtes {{ adtes: {:?} }}", self.adtes())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adce {
            #[inline(always)]
            fn from(val: u8) -> Adce {
                Adce::from_bits(val)
            }
        }
        impl From<Adce> for u8 {
            #[inline(always)]
            fn from(val: Adce) -> u8 {
                Adce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adcs {
            #[inline(always)]
            fn from(val: u8) -> Adcs {
                Adcs::from_bits(val)
            }
        }
        impl From<Adcs> for u8 {
            #[inline(always)]
            fn from(val: Adcs) -> u8 {
                Adcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adiss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adiss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adiss {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adiss {
            #[inline(always)]
            fn from(val: u8) -> Adiss {
                Adiss::from_bits(val)
            }
        }
        impl From<Adiss> for u8 {
            #[inline(always)]
            fn from(val: Adiss) -> u8 {
                Adiss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adlsp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adlsp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adlsp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adlsp {
            #[inline(always)]
            fn from(val: u8) -> Adlsp {
                Adlsp::from_bits(val)
            }
        }
        impl From<Adlsp> for u8 {
            #[inline(always)]
            fn from(val: Adlsp) -> u8 {
                Adlsp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Admd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Admd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Admd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Admd {
            #[inline(always)]
            fn from(val: u8) -> Admd {
                Admd::from_bits(val)
            }
        }
        impl From<Admd> for u8 {
            #[inline(always)]
            fn from(val: Admd) -> u8 {
                Admd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adrck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adrck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adrck {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adrck {
            #[inline(always)]
            fn from(val: u8) -> Adrck {
                Adrck::from_bits(val)
            }
        }
        impl From<Adrck> for u8 {
            #[inline(always)]
            fn from(val: Adrck) -> u8 {
                Adrck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adrefm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adrefm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adrefm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adrefm {
            #[inline(always)]
            fn from(val: u8) -> Adrefm {
                Adrefm::from_bits(val)
            }
        }
        impl From<Adrefm> for u8 {
            #[inline(always)]
            fn from(val: Adrefm) -> u8 {
                Adrefm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adrefp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Adrefp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adrefp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adrefp {
            #[inline(always)]
            fn from(val: u8) -> Adrefp {
                Adrefp::from_bits(val)
            }
        }
        impl From<Adrefp> for u8 {
            #[inline(always)]
            fn from(val: Adrefp) -> u8 {
                Adrefp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adscm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adscm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adscm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adscm {
            #[inline(always)]
            fn from(val: u8) -> Adscm {
                Adscm::from_bits(val)
            }
        }
        impl From<Adscm> for u8 {
            #[inline(always)]
            fn from(val: Adscm) -> u8 {
                Adscm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adtes {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Adtes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adtes {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adtes {
            #[inline(always)]
            fn from(val: u8) -> Adtes {
                Adtes::from_bits(val)
            }
        }
        impl From<Adtes> for u8 {
            #[inline(always)]
            fn from(val: Adtes) -> u8 {
                Adtes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adtmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Adtmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adtmd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adtmd {
            #[inline(always)]
            fn from(val: u8) -> Adtmd {
                Adtmd::from_bits(val)
            }
        }
        impl From<Adtmd> for u8 {
            #[inline(always)]
            fn from(val: Adtmd) -> u8 {
                Adtmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adtrs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Adtrs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adtrs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adtrs {
            #[inline(always)]
            fn from(val: u8) -> Adtrs {
                Adtrs::from_bits(val)
            }
        }
        impl From<Adtrs> for u8 {
            #[inline(always)]
            fn from(val: Adtrs) -> u8 {
                Adtrs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adtyp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Adtyp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adtyp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adtyp {
            #[inline(always)]
            fn from(val: u8) -> Adtyp {
                Adtyp::from_bits(val)
            }
        }
        impl From<Adtyp> for u8 {
            #[inline(always)]
            fn from(val: Adtyp) -> u8 {
                Adtyp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Awc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Awc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Awc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Awc {
            #[inline(always)]
            fn from(val: u8) -> Awc {
                Awc::from_bits(val)
            }
        }
        impl From<Awc> for u8 {
            #[inline(always)]
            fn from(val: Awc) -> u8 {
                Awc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fr {
            #[inline(always)]
            fn from(val: u8) -> Fr {
                Fr::from_bits(val)
            }
        }
        impl From<Fr> for u8 {
            #[inline(always)]
            fn from(val: Fr) -> u8 {
                Fr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lv {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lv {
            #[inline(always)]
            fn from(val: u8) -> Lv {
                Lv::from_bits(val)
            }
        }
        impl From<Lv> for u8 {
            #[inline(always)]
            fn from(val: Lv) -> u8 {
                Lv::to_bits(val)
            }
        }
    }
}
pub mod bus {
    #[doc = "BUS Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bus {
        ptr: *mut u8,
    }
    unsafe impl Send for Bus {}
    unsafe impl Sync for Bus {}
    impl Bus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Master Bus Control Register SYS"]
        #[inline(always)]
        pub const fn busmcntsys(self) -> crate::common::Reg<regs::Busmcntsys, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1008usize) as _) }
        }
        #[doc = "Master Bus Control Register DMA"]
        #[inline(always)]
        pub const fn busmcntdma(self) -> crate::common::Reg<regs::Busmcntdma, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x100cusize) as _) }
        }
        #[doc = "Bus Error Address Register 3"]
        #[inline(always)]
        pub const fn bus3erradd(self) -> crate::common::Reg<regs::Bus3erradd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1820usize) as _) }
        }
        #[doc = "BUS Error Status Register 3"]
        #[inline(always)]
        pub const fn bus3errstat(self) -> crate::common::Reg<regs::Bus3errstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1824usize) as _) }
        }
        #[doc = "Bus Error Address Register 4"]
        #[inline(always)]
        pub const fn bus4erradd(self) -> crate::common::Reg<regs::Bus4erradd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1830usize) as _) }
        }
        #[doc = "BUS Error Status Register 4"]
        #[inline(always)]
        pub const fn bus4errstat(self) -> crate::common::Reg<regs::Bus4errstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1834usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bus Error Address Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus3erradd(pub u32);
        impl Bus3erradd {
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub const fn berad(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub fn set_berad(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bus3erradd {
            #[inline(always)]
            fn default() -> Bus3erradd {
                Bus3erradd(0)
            }
        }
        impl core::fmt::Debug for Bus3erradd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus3erradd")
                    .field("berad", &self.berad())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus3erradd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bus3erradd {{ berad: {=u32:?} }}", self.berad())
            }
        }
        #[doc = "BUS Error Status Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus3errstat(pub u8);
        impl Bus3errstat {
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub const fn accstat(&self) -> super::vals::Bus3errstatAccstat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bus3errstatAccstat::from_bits(val as u8)
            }
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub fn set_accstat(&mut self, val: super::vals::Bus3errstatAccstat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub const fn errstat(&self) -> super::vals::Bus3errstatErrstat {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bus3errstatErrstat::from_bits(val as u8)
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub fn set_errstat(&mut self, val: super::vals::Bus3errstatErrstat) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Bus3errstat {
            #[inline(always)]
            fn default() -> Bus3errstat {
                Bus3errstat(0)
            }
        }
        impl core::fmt::Debug for Bus3errstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus3errstat")
                    .field("accstat", &self.accstat())
                    .field("errstat", &self.errstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus3errstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bus3errstat {{ accstat: {:?}, errstat: {:?} }}",
                    self.accstat(),
                    self.errstat()
                )
            }
        }
        #[doc = "Bus Error Address Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus4erradd(pub u32);
        impl Bus4erradd {
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub const fn berad(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub fn set_berad(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bus4erradd {
            #[inline(always)]
            fn default() -> Bus4erradd {
                Bus4erradd(0)
            }
        }
        impl core::fmt::Debug for Bus4erradd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus4erradd")
                    .field("berad", &self.berad())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus4erradd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bus4erradd {{ berad: {=u32:?} }}", self.berad())
            }
        }
        #[doc = "BUS Error Status Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus4errstat(pub u8);
        impl Bus4errstat {
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub const fn accstat(&self) -> super::vals::Bus4errstatAccstat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bus4errstatAccstat::from_bits(val as u8)
            }
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub fn set_accstat(&mut self, val: super::vals::Bus4errstatAccstat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub const fn errstat(&self) -> super::vals::Bus4errstatErrstat {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bus4errstatErrstat::from_bits(val as u8)
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub fn set_errstat(&mut self, val: super::vals::Bus4errstatErrstat) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Bus4errstat {
            #[inline(always)]
            fn default() -> Bus4errstat {
                Bus4errstat(0)
            }
        }
        impl core::fmt::Debug for Bus4errstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus4errstat")
                    .field("accstat", &self.accstat())
                    .field("errstat", &self.errstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus4errstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bus4errstat {{ accstat: {:?}, errstat: {:?} }}",
                    self.accstat(),
                    self.errstat()
                )
            }
        }
        #[doc = "Master Bus Control Register DMA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busmcntdma(pub u16);
        impl Busmcntdma {
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub const fn ieres(&self) -> super::vals::BusmcntdmaIeres {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::BusmcntdmaIeres::from_bits(val as u8)
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub fn set_ieres(&mut self, val: super::vals::BusmcntdmaIeres) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Busmcntdma {
            #[inline(always)]
            fn default() -> Busmcntdma {
                Busmcntdma(0)
            }
        }
        impl core::fmt::Debug for Busmcntdma {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busmcntdma")
                    .field("ieres", &self.ieres())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busmcntdma {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Busmcntdma {{ ieres: {:?} }}", self.ieres())
            }
        }
        #[doc = "Master Bus Control Register SYS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busmcntsys(pub u16);
        impl Busmcntsys {
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub const fn ieres(&self) -> super::vals::BusmcntsysIeres {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::BusmcntsysIeres::from_bits(val as u8)
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub fn set_ieres(&mut self, val: super::vals::BusmcntsysIeres) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Busmcntsys {
            #[inline(always)]
            fn default() -> Busmcntsys {
                Busmcntsys(0)
            }
        }
        impl core::fmt::Debug for Busmcntsys {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busmcntsys")
                    .field("ieres", &self.ieres())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busmcntsys {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Busmcntsys {{ ieres: {:?} }}", self.ieres())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus3errstatAccstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus3errstatAccstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus3errstatAccstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus3errstatAccstat {
            #[inline(always)]
            fn from(val: u8) -> Bus3errstatAccstat {
                Bus3errstatAccstat::from_bits(val)
            }
        }
        impl From<Bus3errstatAccstat> for u8 {
            #[inline(always)]
            fn from(val: Bus3errstatAccstat) -> u8 {
                Bus3errstatAccstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus3errstatErrstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus3errstatErrstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus3errstatErrstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus3errstatErrstat {
            #[inline(always)]
            fn from(val: u8) -> Bus3errstatErrstat {
                Bus3errstatErrstat::from_bits(val)
            }
        }
        impl From<Bus3errstatErrstat> for u8 {
            #[inline(always)]
            fn from(val: Bus3errstatErrstat) -> u8 {
                Bus3errstatErrstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus4errstatAccstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus4errstatAccstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus4errstatAccstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus4errstatAccstat {
            #[inline(always)]
            fn from(val: u8) -> Bus4errstatAccstat {
                Bus4errstatAccstat::from_bits(val)
            }
        }
        impl From<Bus4errstatAccstat> for u8 {
            #[inline(always)]
            fn from(val: Bus4errstatAccstat) -> u8 {
                Bus4errstatAccstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus4errstatErrstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus4errstatErrstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus4errstatErrstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus4errstatErrstat {
            #[inline(always)]
            fn from(val: u8) -> Bus4errstatErrstat {
                Bus4errstatErrstat::from_bits(val)
            }
        }
        impl From<Bus4errstatErrstat> for u8 {
            #[inline(always)]
            fn from(val: Bus4errstatErrstat) -> u8 {
                Bus4errstatErrstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusmcntdmaIeres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl BusmcntdmaIeres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusmcntdmaIeres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusmcntdmaIeres {
            #[inline(always)]
            fn from(val: u8) -> BusmcntdmaIeres {
                BusmcntdmaIeres::from_bits(val)
            }
        }
        impl From<BusmcntdmaIeres> for u8 {
            #[inline(always)]
            fn from(val: BusmcntdmaIeres) -> u8 {
                BusmcntdmaIeres::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusmcntsysIeres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl BusmcntsysIeres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusmcntsysIeres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusmcntsysIeres {
            #[inline(always)]
            fn from(val: u8) -> BusmcntsysIeres {
                BusmcntsysIeres::from_bits(val)
            }
        }
        impl From<BusmcntsysIeres> for u8 {
            #[inline(always)]
            fn from(val: BusmcntsysIeres) -> u8 {
                BusmcntsysIeres::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = Default::default();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = self.read();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
}
pub mod crc {
    #[doc = "CRC Calculator"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Crc {
        ptr: *mut u8,
    }
    unsafe impl Send for Crc {}
    unsafe impl Sync for Crc {}
    impl Crc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CRC Control Register 0"]
        #[inline(always)]
        pub const fn crccr0(self) -> crate::common::Reg<regs::Crccr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CRC Data Input Register"]
        #[inline(always)]
        pub const fn crcdir(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CRC Data Input Register"]
        #[inline(always)]
        pub const fn crcdir_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CRC Data Output Register"]
        #[inline(always)]
        pub const fn crcdor(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CRC Data Output Register"]
        #[inline(always)]
        pub const fn crcdor_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CRC Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccr0(pub u8);
        impl Crccr0 {
            #[doc = "CRC Generating Polynomial Switching"]
            #[inline(always)]
            pub const fn gps(&self) -> super::vals::Gps {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Gps::from_bits(val as u8)
            }
            #[doc = "CRC Generating Polynomial Switching"]
            #[inline(always)]
            pub fn set_gps(&mut self, val: super::vals::Gps) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "CRCDOR/CRCDOR_HA Register Clear"]
            #[inline(always)]
            pub const fn dorclr(&self) -> super::vals::Dorclr {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dorclr::from_bits(val as u8)
            }
            #[doc = "CRCDOR/CRCDOR_HA Register Clear"]
            #[inline(always)]
            pub fn set_dorclr(&mut self, val: super::vals::Dorclr) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Crccr0 {
            #[inline(always)]
            fn default() -> Crccr0 {
                Crccr0(0)
            }
        }
        impl core::fmt::Debug for Crccr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccr0")
                    .field("gps", &self.gps())
                    .field("dorclr", &self.dorclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crccr0 {{ gps: {:?}, dorclr: {:?} }}",
                    self.gps(),
                    self.dorclr()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dorclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dorclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dorclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dorclr {
            #[inline(always)]
            fn from(val: u8) -> Dorclr {
                Dorclr::from_bits(val)
            }
        }
        impl From<Dorclr> for u8 {
            #[inline(always)]
            fn from(val: Dorclr) -> u8 {
                Dorclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gps {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gps {
            #[inline(always)]
            fn from(val: u8) -> Gps {
                Gps::from_bits(val)
            }
        }
        impl From<Gps> for u8 {
            #[inline(always)]
            fn from(val: Gps) -> u8 {
                Gps::to_bits(val)
            }
        }
    }
}
pub mod dbg {
    #[doc = "Debug Function"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dbg {
        ptr: *mut u8,
    }
    unsafe impl Send for Dbg {}
    unsafe impl Sync for Dbg {}
    impl Dbg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Debug Status Register"]
        #[inline(always)]
        pub const fn dbgstr(self) -> crate::common::Reg<regs::Dbgstr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug Stop Control Register"]
        #[inline(always)]
        pub const fn dbgstopcr(self) -> crate::common::Reg<regs::Dbgstopcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug Stop Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgstopcr(pub u32);
        impl Dbgstopcr {
            #[doc = "Mask Bit for IWDT Reset/Interrupt in the OCD Run Mode"]
            #[inline(always)]
            pub const fn dbgstop_iwdt(&self) -> super::vals::DbgstopIwdt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DbgstopIwdt::from_bits(val as u8)
            }
            #[doc = "Mask Bit for IWDT Reset/Interrupt in the OCD Run Mode"]
            #[inline(always)]
            pub fn set_dbgstop_iwdt(&mut self, val: super::vals::DbgstopIwdt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[inline(always)]
            pub const fn dbgstop_tim(&self) -> super::vals::DbgstopTim {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::DbgstopTim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_dbgstop_tim(&mut self, val: super::vals::DbgstopTim) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Mask Bit for SAU, IICA, UARTA, PORT_IRQ0-5 Reset/Interrupt in the OCD brake mode. In the OCD break mode, the reset/interrupt is masked and each operation is stopped."]
            #[inline(always)]
            pub const fn dbgstop_sir(&self) -> super::vals::DbgstopSir {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::DbgstopSir::from_bits(val as u8)
            }
            #[doc = "Mask Bit for SAU, IICA, UARTA, PORT_IRQ0-5 Reset/Interrupt in the OCD brake mode. In the OCD break mode, the reset/interrupt is masked and each operation is stopped."]
            #[inline(always)]
            pub fn set_dbgstop_sir(&mut self, val: super::vals::DbgstopSir) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Mask Bit for LVD0 Reset"]
            #[inline(always)]
            pub const fn dbgstop_lvd0(&self) -> super::vals::DbgstopLvd0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::DbgstopLvd0::from_bits(val as u8)
            }
            #[doc = "Mask Bit for LVD0 Reset"]
            #[inline(always)]
            pub fn set_dbgstop_lvd0(&mut self, val: super::vals::DbgstopLvd0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Mask Bit for LVD1 Reset/Interrupt"]
            #[inline(always)]
            pub const fn dbgstop_lvd1(&self) -> super::vals::DbgstopLvd1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::DbgstopLvd1::from_bits(val as u8)
            }
            #[doc = "Mask Bit for LVD1 Reset/Interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_lvd1(&mut self, val: super::vals::DbgstopLvd1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Mask Bit for SRAM Parity Error Reset/Interrupt"]
            #[inline(always)]
            pub const fn dbgstop_rper(&self) -> super::vals::DbgstopRper {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::DbgstopRper::from_bits(val as u8)
            }
            #[doc = "Mask Bit for SRAM Parity Error Reset/Interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_rper(&mut self, val: super::vals::DbgstopRper) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Dbgstopcr {
            #[inline(always)]
            fn default() -> Dbgstopcr {
                Dbgstopcr(0)
            }
        }
        impl core::fmt::Debug for Dbgstopcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgstopcr")
                    .field("dbgstop_iwdt", &self.dbgstop_iwdt())
                    .field("dbgstop_tim", &self.dbgstop_tim())
                    .field("dbgstop_sir", &self.dbgstop_sir())
                    .field("dbgstop_lvd0", &self.dbgstop_lvd0())
                    .field("dbgstop_lvd1", &self.dbgstop_lvd1())
                    .field("dbgstop_rper", &self.dbgstop_rper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgstopcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dbgstopcr {{ dbgstop_iwdt: {:?}, dbgstop_tim: {:?}, dbgstop_sir: {:?}, dbgstop_lvd0: {:?}, dbgstop_lvd1: {:?}, dbgstop_rper: {:?} }}" , self . dbgstop_iwdt () , self . dbgstop_tim () , self . dbgstop_sir () , self . dbgstop_lvd0 () , self . dbgstop_lvd1 () , self . dbgstop_rper ())
            }
        }
        #[doc = "Debug Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgstr(pub u32);
        impl Dbgstr {
            #[doc = "Debug Power,up Request"]
            #[inline(always)]
            pub const fn cdbgpwrupreq(&self) -> super::vals::Cdbgpwrupreq {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Cdbgpwrupreq::from_bits(val as u8)
            }
            #[doc = "Debug Power,up Request"]
            #[inline(always)]
            pub fn set_cdbgpwrupreq(&mut self, val: super::vals::Cdbgpwrupreq) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Debug Power,up Acknowledge"]
            #[inline(always)]
            pub const fn cdbgpwrupack(&self) -> super::vals::Cdbgpwrupack {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Cdbgpwrupack::from_bits(val as u8)
            }
            #[doc = "Debug Power,up Acknowledge"]
            #[inline(always)]
            pub fn set_cdbgpwrupack(&mut self, val: super::vals::Cdbgpwrupack) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Dbgstr {
            #[inline(always)]
            fn default() -> Dbgstr {
                Dbgstr(0)
            }
        }
        impl core::fmt::Debug for Dbgstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgstr")
                    .field("cdbgpwrupreq", &self.cdbgpwrupreq())
                    .field("cdbgpwrupack", &self.cdbgpwrupack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgstr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dbgstr {{ cdbgpwrupreq: {:?}, cdbgpwrupack: {:?} }}",
                    self.cdbgpwrupreq(),
                    self.cdbgpwrupack()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdbgpwrupack {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdbgpwrupack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdbgpwrupack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdbgpwrupack {
            #[inline(always)]
            fn from(val: u8) -> Cdbgpwrupack {
                Cdbgpwrupack::from_bits(val)
            }
        }
        impl From<Cdbgpwrupack> for u8 {
            #[inline(always)]
            fn from(val: Cdbgpwrupack) -> u8 {
                Cdbgpwrupack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdbgpwrupreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdbgpwrupreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdbgpwrupreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdbgpwrupreq {
            #[inline(always)]
            fn from(val: u8) -> Cdbgpwrupreq {
                Cdbgpwrupreq::from_bits(val)
            }
        }
        impl From<Cdbgpwrupreq> for u8 {
            #[inline(always)]
            fn from(val: Cdbgpwrupreq) -> u8 {
                Cdbgpwrupreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopIwdt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopIwdt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopIwdt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopIwdt {
            #[inline(always)]
            fn from(val: u8) -> DbgstopIwdt {
                DbgstopIwdt::from_bits(val)
            }
        }
        impl From<DbgstopIwdt> for u8 {
            #[inline(always)]
            fn from(val: DbgstopIwdt) -> u8 {
                DbgstopIwdt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopLvd0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopLvd0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopLvd0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopLvd0 {
            #[inline(always)]
            fn from(val: u8) -> DbgstopLvd0 {
                DbgstopLvd0::from_bits(val)
            }
        }
        impl From<DbgstopLvd0> for u8 {
            #[inline(always)]
            fn from(val: DbgstopLvd0) -> u8 {
                DbgstopLvd0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopLvd1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopLvd1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopLvd1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopLvd1 {
            #[inline(always)]
            fn from(val: u8) -> DbgstopLvd1 {
                DbgstopLvd1::from_bits(val)
            }
        }
        impl From<DbgstopLvd1> for u8 {
            #[inline(always)]
            fn from(val: DbgstopLvd1) -> u8 {
                DbgstopLvd1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopRper {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopRper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopRper {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopRper {
            #[inline(always)]
            fn from(val: u8) -> DbgstopRper {
                DbgstopRper::from_bits(val)
            }
        }
        impl From<DbgstopRper> for u8 {
            #[inline(always)]
            fn from(val: DbgstopRper) -> u8 {
                DbgstopRper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopSir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopSir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopSir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopSir {
            #[inline(always)]
            fn from(val: u8) -> DbgstopSir {
                DbgstopSir::from_bits(val)
            }
        }
        impl From<DbgstopSir> for u8 {
            #[inline(always)]
            fn from(val: DbgstopSir) -> u8 {
                DbgstopSir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopTim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopTim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopTim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopTim {
            #[inline(always)]
            fn from(val: u8) -> DbgstopTim {
                DbgstopTim::from_bits(val)
            }
        }
        impl From<DbgstopTim> for u8 {
            #[inline(always)]
            fn from(val: DbgstopTim) -> u8 {
                DbgstopTim::to_bits(val)
            }
        }
    }
}
pub mod dtc {
    #[doc = "Data Transfer Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Dtc {}
    unsafe impl Sync for Dtc {}
    impl Dtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "DTC Control Register"]
        #[inline(always)]
        pub const fn dtccr(self) -> crate::common::Reg<regs::Dtccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "DTC Vector Base Register"]
        #[inline(always)]
        pub const fn dtcvbr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "DTC Module Start Register"]
        #[inline(always)]
        pub const fn dtcst(self) -> crate::common::Reg<regs::Dtcst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DTC Status Register"]
        #[inline(always)]
        pub const fn dtcsts(self) -> crate::common::Reg<regs::Dtcsts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "DTC Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtccr(pub u8);
        impl Dtccr {
            #[doc = "DTC Transfer Information Read Skip Enable"]
            #[inline(always)]
            pub const fn rrs(&self) -> super::vals::Rrs {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rrs::from_bits(val as u8)
            }
            #[doc = "DTC Transfer Information Read Skip Enable"]
            #[inline(always)]
            pub fn set_rrs(&mut self, val: super::vals::Rrs) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Dtccr {
            #[inline(always)]
            fn default() -> Dtccr {
                Dtccr(0)
            }
        }
        impl core::fmt::Debug for Dtccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtccr").field("rrs", &self.rrs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dtccr {{ rrs: {:?} }}", self.rrs())
            }
        }
        #[doc = "DTC Module Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcst(pub u8);
        impl Dtcst {
            #[doc = "DTC Module Start"]
            #[inline(always)]
            pub const fn dtcst(&self) -> super::vals::Dtcst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dtcst::from_bits(val as u8)
            }
            #[doc = "DTC Module Start"]
            #[inline(always)]
            pub fn set_dtcst(&mut self, val: super::vals::Dtcst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Dtcst {
            #[inline(always)]
            fn default() -> Dtcst {
                Dtcst(0)
            }
        }
        impl core::fmt::Debug for Dtcst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcst")
                    .field("dtcst", &self.dtcst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dtcst {{ dtcst: {:?} }}", self.dtcst())
            }
        }
        #[doc = "DTC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcsts(pub u16);
        impl Dtcsts {
            #[doc = "DTC,Activating Vector Number Monitoring"]
            #[inline(always)]
            pub const fn vecn(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DTC,Activating Vector Number Monitoring"]
            #[inline(always)]
            pub fn set_vecn(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "DTC Active Flag"]
            #[inline(always)]
            pub const fn act(&self) -> super::vals::Act {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Act::from_bits(val as u8)
            }
            #[doc = "DTC Active Flag"]
            #[inline(always)]
            pub fn set_act(&mut self, val: super::vals::Act) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Dtcsts {
            #[inline(always)]
            fn default() -> Dtcsts {
                Dtcsts(0)
            }
        }
        impl core::fmt::Debug for Dtcsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcsts")
                    .field("vecn", &self.vecn())
                    .field("act", &self.act())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtcsts {{ vecn: {=u8:?}, act: {:?} }}",
                    self.vecn(),
                    self.act()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Act {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Act {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Act {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Act {
            #[inline(always)]
            fn from(val: u8) -> Act {
                Act::from_bits(val)
            }
        }
        impl From<Act> for u8 {
            #[inline(always)]
            fn from(val: Act) -> u8 {
                Act::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtcst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtcst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtcst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtcst {
            #[inline(always)]
            fn from(val: u8) -> Dtcst {
                Dtcst::from_bits(val)
            }
        }
        impl From<Dtcst> for u8 {
            #[inline(always)]
            fn from(val: Dtcst) -> u8 {
                Dtcst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rrs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rrs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rrs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rrs {
            #[inline(always)]
            fn from(val: u8) -> Rrs {
                Rrs::from_bits(val)
            }
        }
        impl From<Rrs> for u8 {
            #[inline(always)]
            fn from(val: Rrs) -> u8 {
                Rrs::to_bits(val)
            }
        }
    }
}
pub mod elc {
    #[doc = "Event Link Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Elc {
        ptr: *mut u8,
    }
    unsafe impl Send for Elc {}
    unsafe impl Sync for Elc {}
    impl Elc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Event Link Controller Register"]
        #[inline(always)]
        pub const fn elcr(self) -> crate::common::Reg<regs::Elcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Event Link Software Event Generation Register %s"]
        #[inline(always)]
        pub const fn elsegr(self, n: usize) -> crate::common::Reg<regs::Elsegr, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize + n * 2usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr(self, n: usize) -> crate::common::Reg<regs::Elsr, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Event Link Controller Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elcr(pub u8);
        impl Elcr {
            #[doc = "All Event Link Enable"]
            #[inline(always)]
            pub const fn elcon(&self) -> super::vals::Elcon {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Elcon::from_bits(val as u8)
            }
            #[doc = "All Event Link Enable"]
            #[inline(always)]
            pub fn set_elcon(&mut self, val: super::vals::Elcon) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Elcr {
            #[inline(always)]
            fn default() -> Elcr {
                Elcr(0)
            }
        }
        impl core::fmt::Debug for Elcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elcr")
                    .field("elcon", &self.elcon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elcr {{ elcon: {:?} }}", self.elcon())
            }
        }
        #[doc = "Event Link Software Event Generation Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsegr(pub u8);
        impl Elsegr {
            #[doc = "Software Event Generation"]
            #[inline(always)]
            pub const fn seg(&self) -> super::vals::Seg {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Seg::from_bits(val as u8)
            }
            #[doc = "Software Event Generation"]
            #[inline(always)]
            pub fn set_seg(&mut self, val: super::vals::Seg) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SEG Bit Write Enable"]
            #[inline(always)]
            pub const fn we(&self) -> super::vals::We {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::We::from_bits(val as u8)
            }
            #[doc = "SEG Bit Write Enable"]
            #[inline(always)]
            pub fn set_we(&mut self, val: super::vals::We) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "ELSEGR Register Write Disable"]
            #[inline(always)]
            pub const fn wi(&self) -> super::vals::Wi {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wi::from_bits(val as u8)
            }
            #[doc = "ELSEGR Register Write Disable"]
            #[inline(always)]
            pub fn set_wi(&mut self, val: super::vals::Wi) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Elsegr {
            #[inline(always)]
            fn default() -> Elsegr {
                Elsegr(0)
            }
        }
        impl core::fmt::Debug for Elsegr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsegr")
                    .field("seg", &self.seg())
                    .field("we", &self.we())
                    .field("wi", &self.wi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsegr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsegr {{ seg: {:?}, we: {:?}, wi: {:?} }}",
                    self.seg(),
                    self.we(),
                    self.wi()
                )
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr(pub u16);
        impl Elsr {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u16) & 0x3f) << 0usize);
            }
        }
        impl Default for Elsr {
            #[inline(always)]
            fn default() -> Elsr {
                Elsr(0)
            }
        }
        impl core::fmt::Debug for Elsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr").field("els", &self.els()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elsr {{ els: {=u8:?} }}", self.els())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Elcon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Elcon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Elcon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Elcon {
            #[inline(always)]
            fn from(val: u8) -> Elcon {
                Elcon::from_bits(val)
            }
        }
        impl From<Elcon> for u8 {
            #[inline(always)]
            fn from(val: Elcon) -> u8 {
                Elcon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Seg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Seg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Seg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Seg {
            #[inline(always)]
            fn from(val: u8) -> Seg {
                Seg::from_bits(val)
            }
        }
        impl From<Seg> for u8 {
            #[inline(always)]
            fn from(val: Seg) -> u8 {
                Seg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum We {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl We {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> We {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for We {
            #[inline(always)]
            fn from(val: u8) -> We {
                We::from_bits(val)
            }
        }
        impl From<We> for u8 {
            #[inline(always)]
            fn from(val: We) -> u8 {
                We::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wi {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wi {
            #[inline(always)]
            fn from(val: u8) -> Wi {
                Wi::from_bits(val)
            }
        }
        impl From<Wi> for u8 {
            #[inline(always)]
            fn from(val: Wi) -> u8 {
                Wi::to_bits(val)
            }
        }
    }
}
pub mod flcn {
    #[doc = "Flash I/O Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Flcn {
        ptr: *mut u8,
    }
    unsafe impl Send for Flcn {}
    unsafe impl Sync for Flcn {}
    impl Flcn {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data Flash Control Register"]
        #[inline(always)]
        pub const fn dflctl(self) -> crate::common::Reg<regs::Dflctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Flash P/E Mode Control Register"]
        #[inline(always)]
        pub const fn fpmcr(self) -> crate::common::Reg<regs::Fpmcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Flash Area Select Register"]
        #[inline(always)]
        pub const fn fasr(self) -> crate::common::Reg<regs::Fasr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Flash Processing Start Address Register L"]
        #[inline(always)]
        pub const fn fsarl(self) -> crate::common::Reg<regs::Fsarl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Flash Processing Start Address Register H"]
        #[inline(always)]
        pub const fn fsarh(self) -> crate::common::Reg<regs::Fsarh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Flash Control Register"]
        #[inline(always)]
        pub const fn fcr(self) -> crate::common::Reg<regs::Fcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Flash Processing End Address Register L"]
        #[inline(always)]
        pub const fn fearl(self) -> crate::common::Reg<regs::Fearl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Flash Processing End Address Register H"]
        #[inline(always)]
        pub const fn fearh(self) -> crate::common::Reg<regs::Fearh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Flash Reset Register"]
        #[inline(always)]
        pub const fn fresetr(self) -> crate::common::Reg<regs::Fresetr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Flash Status Register 1"]
        #[inline(always)]
        pub const fn fstatr1(self) -> crate::common::Reg<regs::Fstatr1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "Flash Write Buffer Register L0"]
        #[inline(always)]
        pub const fn fwbl0(self) -> crate::common::Reg<regs::Fwbl0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Flash Write Buffer Register H0"]
        #[inline(always)]
        pub const fn fwbh0(self) -> crate::common::Reg<regs::Fwbh0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Protection Unlock Register"]
        #[inline(always)]
        pub const fn fpr(self) -> crate::common::Reg<regs::Fpr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Protection Unlock Status Register"]
        #[inline(always)]
        pub const fn fpsr(self) -> crate::common::Reg<regs::Fpsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Flash Startup Setting Monitor Register"]
        #[inline(always)]
        pub const fn fscmr(self) -> crate::common::Reg<regs::Fscmr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[doc = "Flash Access Window Start Address Monitor Register"]
        #[inline(always)]
        pub const fn fawsmr(self) -> crate::common::Reg<regs::Fawsmr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c8usize) as _) }
        }
        #[doc = "Flash Access Window End Address Monitor Register"]
        #[inline(always)]
        pub const fn fawemr(self) -> crate::common::Reg<regs::Fawemr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d0usize) as _) }
        }
        #[doc = "Flash Initial Setting Register"]
        #[inline(always)]
        pub const fn fisr(self) -> crate::common::Reg<regs::Fisr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d8usize) as _) }
        }
        #[doc = "Flash Extra Area Control Register"]
        #[inline(always)]
        pub const fn fexcr(self) -> crate::common::Reg<regs::Fexcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01dcusize) as _) }
        }
        #[doc = "Flash Error Address Monitor Register L"]
        #[inline(always)]
        pub const fn feaml(self) -> crate::common::Reg<regs::Feaml, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01e0usize) as _) }
        }
        #[doc = "Flash Error Address Monitor Register H"]
        #[inline(always)]
        pub const fn feamh(self) -> crate::common::Reg<regs::Feamh, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01e8usize) as _) }
        }
        #[doc = "Flash Status Register 2"]
        #[inline(always)]
        pub const fn fstatr2(self) -> crate::common::Reg<regs::Fstatr2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01f0usize) as _) }
        }
        #[doc = "High,speed On,chip Oscillator Trimming Register"]
        #[inline(always)]
        pub const fn hiotrm(self) -> crate::common::Reg<regs::Hiotrm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Flash Operating Mode Control Register"]
        #[inline(always)]
        pub const fn flmode(self) -> crate::common::Reg<regs::Flmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020ausize) as _) }
        }
        #[doc = "Flash Operating Mode Protect Register"]
        #[inline(always)]
        pub const fn flmwrp(self) -> crate::common::Reg<regs::Flmwrp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020busize) as _) }
        }
        #[doc = "Flash P/E Mode Entry Register"]
        #[inline(always)]
        pub const fn fentryr(self) -> crate::common::Reg<regs::Fentryr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x021ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Data Flash Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dflctl(pub u8);
        impl Dflctl {
            #[doc = "Data Flash Access Enable"]
            #[inline(always)]
            pub const fn dflen(&self) -> super::vals::Dflen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dflen::from_bits(val as u8)
            }
            #[doc = "Data Flash Access Enable"]
            #[inline(always)]
            pub fn set_dflen(&mut self, val: super::vals::Dflen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Dflctl {
            #[inline(always)]
            fn default() -> Dflctl {
                Dflctl(0)
            }
        }
        impl core::fmt::Debug for Dflctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dflctl")
                    .field("dflen", &self.dflen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dflctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dflctl {{ dflen: {:?} }}", self.dflen())
            }
        }
        #[doc = "Flash Area Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fasr(pub u8);
        impl Fasr {
            #[doc = "Extra Area Select"]
            #[inline(always)]
            pub const fn exs(&self) -> super::vals::Exs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Exs::from_bits(val as u8)
            }
            #[doc = "Extra Area Select"]
            #[inline(always)]
            pub fn set_exs(&mut self, val: super::vals::Exs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fasr {
            #[inline(always)]
            fn default() -> Fasr {
                Fasr(0)
            }
        }
        impl core::fmt::Debug for Fasr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fasr").field("exs", &self.exs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fasr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fasr {{ exs: {:?} }}", self.exs())
            }
        }
        #[doc = "Flash Access Window End Address Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fawemr(pub u16);
        impl Fawemr {
            #[doc = "Access Window End Address"]
            #[inline(always)]
            pub const fn fawe(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Access Window End Address"]
            #[inline(always)]
            pub fn set_fawe(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u16) & 0x07ff) << 0usize);
            }
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub const fn sasmf(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub fn set_sasmf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Fawemr {
            #[inline(always)]
            fn default() -> Fawemr {
                Fawemr(0)
            }
        }
        impl core::fmt::Debug for Fawemr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fawemr")
                    .field("fawe", &self.fawe())
                    .field("sasmf", &self.sasmf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fawemr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fawemr {{ fawe: {=u16:?}, sasmf: {=bool:?} }}",
                    self.fawe(),
                    self.sasmf()
                )
            }
        }
        #[doc = "Flash Access Window Start Address Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fawsmr(pub u16);
        impl Fawsmr {
            #[doc = "Access Window Start Address"]
            #[inline(always)]
            pub const fn faws(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Access Window Start Address"]
            #[inline(always)]
            pub fn set_faws(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u16) & 0x07ff) << 0usize);
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub const fn fspr(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub fn set_fspr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Fawsmr {
            #[inline(always)]
            fn default() -> Fawsmr {
                Fawsmr(0)
            }
        }
        impl core::fmt::Debug for Fawsmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fawsmr")
                    .field("faws", &self.faws())
                    .field("fspr", &self.fspr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fawsmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fawsmr {{ faws: {=u16:?}, fspr: {=bool:?} }}",
                    self.faws(),
                    self.fspr()
                )
            }
        }
        #[doc = "Flash Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fcr(pub u8);
        impl Fcr {
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub const fn cmd(&self) -> super::vals::FcrCmd {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::FcrCmd::from_bits(val as u8)
            }
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub fn set_cmd(&mut self, val: super::vals::FcrCmd) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u8) & 0x0f) << 0usize);
            }
            #[doc = "Forced Processing Stop"]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Forced Processing Stop"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub const fn opst(&self) -> super::vals::FcrOpst {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::FcrOpst::from_bits(val as u8)
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub fn set_opst(&mut self, val: super::vals::FcrOpst) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Fcr {
            #[inline(always)]
            fn default() -> Fcr {
                Fcr(0)
            }
        }
        impl core::fmt::Debug for Fcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fcr")
                    .field("cmd", &self.cmd())
                    .field("stop", &self.stop())
                    .field("opst", &self.opst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fcr {{ cmd: {:?}, stop: {=bool:?}, opst: {:?} }}",
                    self.cmd(),
                    self.stop(),
                    self.opst()
                )
            }
        }
        #[doc = "Flash Error Address Monitor Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Feamh(pub u16);
        impl Feamh {
            #[doc = "Flash Error Address Monitor Register H"]
            #[inline(always)]
            pub const fn feamh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Error Address Monitor Register H"]
            #[inline(always)]
            pub fn set_feamh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Feamh {
            #[inline(always)]
            fn default() -> Feamh {
                Feamh(0)
            }
        }
        impl core::fmt::Debug for Feamh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Feamh")
                    .field("feamh", &self.feamh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Feamh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Feamh {{ feamh: {=u16:?} }}", self.feamh())
            }
        }
        #[doc = "Flash Error Address Monitor Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Feaml(pub u16);
        impl Feaml {
            #[doc = "Flash Error Address Monitor Register L"]
            #[inline(always)]
            pub const fn feaml(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Error Address Monitor Register L"]
            #[inline(always)]
            pub fn set_feaml(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Feaml {
            #[inline(always)]
            fn default() -> Feaml {
                Feaml(0)
            }
        }
        impl core::fmt::Debug for Feaml {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Feaml")
                    .field("feaml", &self.feaml())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Feaml {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Feaml {{ feaml: {=u16:?} }}", self.feaml())
            }
        }
        #[doc = "Flash Processing End Address Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fearh(pub u16);
        impl Fearh {
            #[doc = "Flash Processing End Address H"]
            #[inline(always)]
            pub const fn fearh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing End Address H"]
            #[inline(always)]
            pub fn set_fearh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fearh {
            #[inline(always)]
            fn default() -> Fearh {
                Fearh(0)
            }
        }
        impl core::fmt::Debug for Fearh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fearh")
                    .field("fearh", &self.fearh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fearh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fearh {{ fearh: {=u16:?} }}", self.fearh())
            }
        }
        #[doc = "Flash Processing End Address Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fearl(pub u16);
        impl Fearl {
            #[doc = "Flash Processing End Address L"]
            #[inline(always)]
            pub const fn fearl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing End Address L"]
            #[inline(always)]
            pub fn set_fearl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fearl {
            #[inline(always)]
            fn default() -> Fearl {
                Fearl(0)
            }
        }
        impl core::fmt::Debug for Fearl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fearl")
                    .field("fearl", &self.fearl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fearl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fearl {{ fearl: {=u16:?} }}", self.fearl())
            }
        }
        #[doc = "Flash P/E Mode Entry Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fentryr(pub u16);
        impl Fentryr {
            #[doc = "Code Flash P/E Mode Entry 0"]
            #[inline(always)]
            pub const fn fentry0(&self) -> super::vals::Fentry0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fentry0::from_bits(val as u8)
            }
            #[doc = "Code Flash P/E Mode Entry 0"]
            #[inline(always)]
            pub fn set_fentry0(&mut self, val: super::vals::Fentry0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Data Flash P/E Mode Entry"]
            #[inline(always)]
            pub const fn fentryd(&self) -> super::vals::Fentryd {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Fentryd::from_bits(val as u8)
            }
            #[doc = "Data Flash P/E Mode Entry"]
            #[inline(always)]
            pub fn set_fentryd(&mut self, val: super::vals::Fentryd) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn fekey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_fekey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Fentryr {
            #[inline(always)]
            fn default() -> Fentryr {
                Fentryr(0)
            }
        }
        impl core::fmt::Debug for Fentryr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fentryr")
                    .field("fentry0", &self.fentry0())
                    .field("fentryd", &self.fentryd())
                    .field("fekey", &self.fekey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fentryr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fentryr {{ fentry0: {:?}, fentryd: {:?}, fekey: {=u8:?} }}",
                    self.fentry0(),
                    self.fentryd(),
                    self.fekey()
                )
            }
        }
        #[doc = "Flash Extra Area Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fexcr(pub u8);
        impl Fexcr {
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub const fn cmd(&self) -> super::vals::FexcrCmd {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::FexcrCmd::from_bits(val as u8)
            }
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub fn set_cmd(&mut self, val: super::vals::FexcrCmd) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub const fn opst(&self) -> super::vals::FexcrOpst {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::FexcrOpst::from_bits(val as u8)
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub fn set_opst(&mut self, val: super::vals::FexcrOpst) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Fexcr {
            #[inline(always)]
            fn default() -> Fexcr {
                Fexcr(0)
            }
        }
        impl core::fmt::Debug for Fexcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fexcr")
                    .field("cmd", &self.cmd())
                    .field("opst", &self.opst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fexcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fexcr {{ cmd: {:?}, opst: {:?} }}",
                    self.cmd(),
                    self.opst()
                )
            }
        }
        #[doc = "Flash Initial Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fisr(pub u8);
        impl Fisr {
            #[doc = "Flash,IF Clock Notification"]
            #[inline(always)]
            pub const fn pcka(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Flash,IF Clock Notification"]
            #[inline(always)]
            pub fn set_pcka(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "Startup Area Select"]
            #[inline(always)]
            pub const fn sas(&self) -> super::vals::Sas {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Sas::from_bits(val as u8)
            }
            #[doc = "Startup Area Select"]
            #[inline(always)]
            pub fn set_sas(&mut self, val: super::vals::Sas) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Fisr {
            #[inline(always)]
            fn default() -> Fisr {
                Fisr(0)
            }
        }
        impl core::fmt::Debug for Fisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fisr")
                    .field("pcka", &self.pcka())
                    .field("sas", &self.sas())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fisr {{ pcka: {=u8:?}, sas: {:?} }}",
                    self.pcka(),
                    self.sas()
                )
            }
        }
        #[doc = "Flash Operating Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Flmode(pub u8);
        impl Flmode {
            #[doc = "Operating Mode Select"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Operating Mode Select"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Flmode {
            #[inline(always)]
            fn default() -> Flmode {
                Flmode(0)
            }
        }
        impl core::fmt::Debug for Flmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Flmode")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Flmode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Flmode {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "Flash Operating Mode Protect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Flmwrp(pub u8);
        impl Flmwrp {
            #[doc = "Control of Flash Operation Mode Select Register"]
            #[inline(always)]
            pub const fn flmwen(&self) -> super::vals::Flmwen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Flmwen::from_bits(val as u8)
            }
            #[doc = "Control of Flash Operation Mode Select Register"]
            #[inline(always)]
            pub fn set_flmwen(&mut self, val: super::vals::Flmwen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Flmwrp {
            #[inline(always)]
            fn default() -> Flmwrp {
                Flmwrp(0)
            }
        }
        impl core::fmt::Debug for Flmwrp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Flmwrp")
                    .field("flmwen", &self.flmwen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Flmwrp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Flmwrp {{ flmwen: {:?} }}", self.flmwen())
            }
        }
        #[doc = "Flash P/E Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpmcr(pub u8);
        impl Fpmcr {
            #[doc = "Flash Operating Mode Select 0"]
            #[inline(always)]
            pub const fn fms0(&self) -> super::vals::Fms0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Fms0::from_bits(val as u8)
            }
            #[doc = "Flash Operating Mode Select 0"]
            #[inline(always)]
            pub fn set_fms0(&mut self, val: super::vals::Fms0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Code Flash P/E Disable"]
            #[inline(always)]
            pub const fn rpdis(&self) -> super::vals::Rpdis {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rpdis::from_bits(val as u8)
            }
            #[doc = "Code Flash P/E Disable"]
            #[inline(always)]
            pub fn set_rpdis(&mut self, val: super::vals::Rpdis) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Flash Operating Mode Select 1"]
            #[inline(always)]
            pub const fn fms1(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Operating Mode Select 1"]
            #[inline(always)]
            pub fn set_fms1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Fpmcr {
            #[inline(always)]
            fn default() -> Fpmcr {
                Fpmcr(0)
            }
        }
        impl core::fmt::Debug for Fpmcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpmcr")
                    .field("fms0", &self.fms0())
                    .field("rpdis", &self.rpdis())
                    .field("fms1", &self.fms1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpmcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fpmcr {{ fms0: {:?}, rpdis: {:?}, fms1: {=bool:?} }}",
                    self.fms0(),
                    self.rpdis(),
                    self.fms1()
                )
            }
        }
        #[doc = "Protection Unlock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpr(pub u8);
        impl Fpr {
            #[doc = "Protection Unlock"]
            #[inline(always)]
            pub const fn fpr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Protection Unlock"]
            #[inline(always)]
            pub fn set_fpr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Fpr {
            #[inline(always)]
            fn default() -> Fpr {
                Fpr(0)
            }
        }
        impl core::fmt::Debug for Fpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpr").field("fpr", &self.fpr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fpr {{ fpr: {=u8:?} }}", self.fpr())
            }
        }
        #[doc = "Protection Unlock Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpsr(pub u8);
        impl Fpsr {
            #[doc = "Protect Error Flag"]
            #[inline(always)]
            pub const fn perr(&self) -> super::vals::Perr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Perr::from_bits(val as u8)
            }
            #[doc = "Protect Error Flag"]
            #[inline(always)]
            pub fn set_perr(&mut self, val: super::vals::Perr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fpsr {
            #[inline(always)]
            fn default() -> Fpsr {
                Fpsr(0)
            }
        }
        impl core::fmt::Debug for Fpsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpsr").field("perr", &self.perr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fpsr {{ perr: {:?} }}", self.perr())
            }
        }
        #[doc = "Flash Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fresetr(pub u8);
        impl Fresetr {
            #[doc = "Software Reset of the Registers"]
            #[inline(always)]
            pub const fn freset(&self) -> super::vals::Freset {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Freset::from_bits(val as u8)
            }
            #[doc = "Software Reset of the Registers"]
            #[inline(always)]
            pub fn set_freset(&mut self, val: super::vals::Freset) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fresetr {
            #[inline(always)]
            fn default() -> Fresetr {
                Fresetr(0)
            }
        }
        impl core::fmt::Debug for Fresetr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fresetr")
                    .field("freset", &self.freset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fresetr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fresetr {{ freset: {:?} }}", self.freset())
            }
        }
        #[doc = "Flash Processing Start Address Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fsarh(pub u16);
        impl Fsarh {
            #[doc = "Flash Processing Start Address H"]
            #[inline(always)]
            pub const fn fsarh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing Start Address H"]
            #[inline(always)]
            pub fn set_fsarh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fsarh {
            #[inline(always)]
            fn default() -> Fsarh {
                Fsarh(0)
            }
        }
        impl core::fmt::Debug for Fsarh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fsarh")
                    .field("fsarh", &self.fsarh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fsarh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fsarh {{ fsarh: {=u16:?} }}", self.fsarh())
            }
        }
        #[doc = "Flash Processing Start Address Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fsarl(pub u16);
        impl Fsarl {
            #[doc = "Flash Processing Start Address L"]
            #[inline(always)]
            pub const fn fsarl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing Start Address L"]
            #[inline(always)]
            pub fn set_fsarl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fsarl {
            #[inline(always)]
            fn default() -> Fsarl {
                Fsarl(0)
            }
        }
        impl core::fmt::Debug for Fsarl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fsarl")
                    .field("fsarl", &self.fsarl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fsarl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fsarl {{ fsarl: {=u16:?} }}", self.fsarl())
            }
        }
        #[doc = "Flash Startup Setting Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fscmr(pub u16);
        impl Fscmr {
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub const fn sasmf(&self) -> super::vals::Sasmf {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Sasmf::from_bits(val as u8)
            }
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub fn set_sasmf(&mut self, val: super::vals::Sasmf) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub const fn fspr(&self) -> super::vals::Fspr {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Fspr::from_bits(val as u8)
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub fn set_fspr(&mut self, val: super::vals::Fspr) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
        }
        impl Default for Fscmr {
            #[inline(always)]
            fn default() -> Fscmr {
                Fscmr(0)
            }
        }
        impl core::fmt::Debug for Fscmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fscmr")
                    .field("sasmf", &self.sasmf())
                    .field("fspr", &self.fspr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fscmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fscmr {{ sasmf: {:?}, fspr: {:?} }}",
                    self.sasmf(),
                    self.fspr()
                )
            }
        }
        #[doc = "Flash Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fstatr1(pub u8);
        impl Fstatr1 {
            #[doc = "Flash Ready Flag"]
            #[inline(always)]
            pub const fn frdy(&self) -> super::vals::Frdy {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Frdy::from_bits(val as u8)
            }
            #[doc = "Flash Ready Flag"]
            #[inline(always)]
            pub fn set_frdy(&mut self, val: super::vals::Frdy) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Extra Area Ready Flag"]
            #[inline(always)]
            pub const fn exrdy(&self) -> super::vals::Exrdy {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Exrdy::from_bits(val as u8)
            }
            #[doc = "Extra Area Ready Flag"]
            #[inline(always)]
            pub fn set_exrdy(&mut self, val: super::vals::Exrdy) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Fstatr1 {
            #[inline(always)]
            fn default() -> Fstatr1 {
                Fstatr1(0)
            }
        }
        impl core::fmt::Debug for Fstatr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fstatr1")
                    .field("frdy", &self.frdy())
                    .field("exrdy", &self.exrdy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fstatr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fstatr1 {{ frdy: {:?}, exrdy: {:?} }}",
                    self.frdy(),
                    self.exrdy()
                )
            }
        }
        #[doc = "Flash Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fstatr2(pub u16);
        impl Fstatr2 {
            #[doc = "Erase Error Flag"]
            #[inline(always)]
            pub const fn ererr(&self) -> super::vals::Ererr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ererr::from_bits(val as u8)
            }
            #[doc = "Erase Error Flag"]
            #[inline(always)]
            pub fn set_ererr(&mut self, val: super::vals::Ererr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Program Error Flag"]
            #[inline(always)]
            pub const fn prgerr(&self) -> super::vals::Prgerr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Prgerr::from_bits(val as u8)
            }
            #[doc = "Program Error Flag"]
            #[inline(always)]
            pub fn set_prgerr(&mut self, val: super::vals::Prgerr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Blank Check Error Flag"]
            #[inline(always)]
            pub const fn bcerr(&self) -> super::vals::Bcerr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bcerr::from_bits(val as u8)
            }
            #[doc = "Blank Check Error Flag"]
            #[inline(always)]
            pub fn set_bcerr(&mut self, val: super::vals::Bcerr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Illegal Command Error Flag"]
            #[inline(always)]
            pub const fn ilglerr(&self) -> super::vals::Ilglerr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ilglerr::from_bits(val as u8)
            }
            #[doc = "Illegal Command Error Flag"]
            #[inline(always)]
            pub fn set_ilglerr(&mut self, val: super::vals::Ilglerr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Extra Area Illegal Command Error Flag"]
            #[inline(always)]
            pub const fn eilglerr(&self) -> super::vals::Eilglerr {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Eilglerr::from_bits(val as u8)
            }
            #[doc = "Extra Area Illegal Command Error Flag"]
            #[inline(always)]
            pub fn set_eilglerr(&mut self, val: super::vals::Eilglerr) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
        }
        impl Default for Fstatr2 {
            #[inline(always)]
            fn default() -> Fstatr2 {
                Fstatr2(0)
            }
        }
        impl core::fmt::Debug for Fstatr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fstatr2")
                    .field("ererr", &self.ererr())
                    .field("prgerr", &self.prgerr())
                    .field("bcerr", &self.bcerr())
                    .field("ilglerr", &self.ilglerr())
                    .field("eilglerr", &self.eilglerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fstatr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fstatr2 {{ ererr: {:?}, prgerr: {:?}, bcerr: {:?}, ilglerr: {:?}, eilglerr: {:?} }}" , self . ererr () , self . prgerr () , self . bcerr () , self . ilglerr () , self . eilglerr ())
            }
        }
        #[doc = "Flash Write Buffer Register H0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fwbh0(pub u16);
        impl Fwbh0 {
            #[doc = "Flash Write Buffer H0"]
            #[inline(always)]
            pub const fn wdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Write Buffer H0"]
            #[inline(always)]
            pub fn set_wdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fwbh0 {
            #[inline(always)]
            fn default() -> Fwbh0 {
                Fwbh0(0)
            }
        }
        impl core::fmt::Debug for Fwbh0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fwbh0")
                    .field("wdata", &self.wdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fwbh0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fwbh0 {{ wdata: {=u16:?} }}", self.wdata())
            }
        }
        #[doc = "Flash Write Buffer Register L0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fwbl0(pub u16);
        impl Fwbl0 {
            #[doc = "Flash Write Buffer L0"]
            #[inline(always)]
            pub const fn wdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Write Buffer L0"]
            #[inline(always)]
            pub fn set_wdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fwbl0 {
            #[inline(always)]
            fn default() -> Fwbl0 {
                Fwbl0(0)
            }
        }
        impl core::fmt::Debug for Fwbl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fwbl0")
                    .field("wdata", &self.wdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fwbl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fwbl0 {{ wdata: {=u16:?} }}", self.wdata())
            }
        }
        #[doc = "High,speed On,chip Oscillator Trimming Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hiotrm(pub u8);
        impl Hiotrm {
            #[doc = "HOCO User Trimming"]
            #[inline(always)]
            pub const fn hiotrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "HOCO User Trimming"]
            #[inline(always)]
            pub fn set_hiotrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
        }
        impl Default for Hiotrm {
            #[inline(always)]
            fn default() -> Hiotrm {
                Hiotrm(0)
            }
        }
        impl core::fmt::Debug for Hiotrm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hiotrm")
                    .field("hiotrm", &self.hiotrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hiotrm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hiotrm {{ hiotrm: {=u8:?} }}", self.hiotrm())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bcerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcerr {
            #[inline(always)]
            fn from(val: u8) -> Bcerr {
                Bcerr::from_bits(val)
            }
        }
        impl From<Bcerr> for u8 {
            #[inline(always)]
            fn from(val: Bcerr) -> u8 {
                Bcerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dflen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dflen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dflen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dflen {
            #[inline(always)]
            fn from(val: u8) -> Dflen {
                Dflen::from_bits(val)
            }
        }
        impl From<Dflen> for u8 {
            #[inline(always)]
            fn from(val: Dflen) -> u8 {
                Dflen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eilglerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eilglerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eilglerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eilglerr {
            #[inline(always)]
            fn from(val: u8) -> Eilglerr {
                Eilglerr::from_bits(val)
            }
        }
        impl From<Eilglerr> for u8 {
            #[inline(always)]
            fn from(val: Eilglerr) -> u8 {
                Eilglerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ererr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ererr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ererr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ererr {
            #[inline(always)]
            fn from(val: u8) -> Ererr {
                Ererr::from_bits(val)
            }
        }
        impl From<Ererr> for u8 {
            #[inline(always)]
            fn from(val: Ererr) -> u8 {
                Ererr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Exrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exrdy {
            #[inline(always)]
            fn from(val: u8) -> Exrdy {
                Exrdy::from_bits(val)
            }
        }
        impl From<Exrdy> for u8 {
            #[inline(always)]
            fn from(val: Exrdy) -> u8 {
                Exrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Exs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exs {
            #[inline(always)]
            fn from(val: u8) -> Exs {
                Exs::from_bits(val)
            }
        }
        impl From<Exs> for u8 {
            #[inline(always)]
            fn from(val: Exs) -> u8 {
                Exs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FcrCmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl FcrCmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FcrCmd {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FcrCmd {
            #[inline(always)]
            fn from(val: u8) -> FcrCmd {
                FcrCmd::from_bits(val)
            }
        }
        impl From<FcrCmd> for u8 {
            #[inline(always)]
            fn from(val: FcrCmd) -> u8 {
                FcrCmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FcrOpst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FcrOpst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FcrOpst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FcrOpst {
            #[inline(always)]
            fn from(val: u8) -> FcrOpst {
                FcrOpst::from_bits(val)
            }
        }
        impl From<FcrOpst> for u8 {
            #[inline(always)]
            fn from(val: FcrOpst) -> u8 {
                FcrOpst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fentry0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fentry0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fentry0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fentry0 {
            #[inline(always)]
            fn from(val: u8) -> Fentry0 {
                Fentry0::from_bits(val)
            }
        }
        impl From<Fentry0> for u8 {
            #[inline(always)]
            fn from(val: Fentry0) -> u8 {
                Fentry0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fentryd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fentryd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fentryd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fentryd {
            #[inline(always)]
            fn from(val: u8) -> Fentryd {
                Fentryd::from_bits(val)
            }
        }
        impl From<Fentryd> for u8 {
            #[inline(always)]
            fn from(val: Fentryd) -> u8 {
                Fentryd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FexcrCmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl FexcrCmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FexcrCmd {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FexcrCmd {
            #[inline(always)]
            fn from(val: u8) -> FexcrCmd {
                FexcrCmd::from_bits(val)
            }
        }
        impl From<FexcrCmd> for u8 {
            #[inline(always)]
            fn from(val: FexcrCmd) -> u8 {
                FexcrCmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FexcrOpst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FexcrOpst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FexcrOpst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FexcrOpst {
            #[inline(always)]
            fn from(val: u8) -> FexcrOpst {
                FexcrOpst::from_bits(val)
            }
        }
        impl From<FexcrOpst> for u8 {
            #[inline(always)]
            fn from(val: FexcrOpst) -> u8 {
                FexcrOpst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flmwen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Flmwen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flmwen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flmwen {
            #[inline(always)]
            fn from(val: u8) -> Flmwen {
                Flmwen::from_bits(val)
            }
        }
        impl From<Flmwen> for u8 {
            #[inline(always)]
            fn from(val: Flmwen) -> u8 {
                Flmwen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fms0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fms0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fms0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fms0 {
            #[inline(always)]
            fn from(val: u8) -> Fms0 {
                Fms0::from_bits(val)
            }
        }
        impl From<Fms0> for u8 {
            #[inline(always)]
            fn from(val: Fms0) -> u8 {
                Fms0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Frdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Frdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Frdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Frdy {
            #[inline(always)]
            fn from(val: u8) -> Frdy {
                Frdy::from_bits(val)
            }
        }
        impl From<Frdy> for u8 {
            #[inline(always)]
            fn from(val: Frdy) -> u8 {
                Frdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Freset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Freset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Freset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Freset {
            #[inline(always)]
            fn from(val: u8) -> Freset {
                Freset::from_bits(val)
            }
        }
        impl From<Freset> for u8 {
            #[inline(always)]
            fn from(val: Freset) -> u8 {
                Freset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fspr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fspr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fspr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fspr {
            #[inline(always)]
            fn from(val: u8) -> Fspr {
                Fspr::from_bits(val)
            }
        }
        impl From<Fspr> for u8 {
            #[inline(always)]
            fn from(val: Fspr) -> u8 {
                Fspr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ilglerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ilglerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ilglerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ilglerr {
            #[inline(always)]
            fn from(val: u8) -> Ilglerr {
                Ilglerr::from_bits(val)
            }
        }
        impl From<Ilglerr> for u8 {
            #[inline(always)]
            fn from(val: Ilglerr) -> u8 {
                Ilglerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Perr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Perr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Perr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Perr {
            #[inline(always)]
            fn from(val: u8) -> Perr {
                Perr::from_bits(val)
            }
        }
        impl From<Perr> for u8 {
            #[inline(always)]
            fn from(val: Perr) -> u8 {
                Perr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prgerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prgerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prgerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prgerr {
            #[inline(always)]
            fn from(val: u8) -> Prgerr {
                Prgerr::from_bits(val)
            }
        }
        impl From<Prgerr> for u8 {
            #[inline(always)]
            fn from(val: Prgerr) -> u8 {
                Prgerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpdis {
            #[inline(always)]
            fn from(val: u8) -> Rpdis {
                Rpdis::from_bits(val)
            }
        }
        impl From<Rpdis> for u8 {
            #[inline(always)]
            fn from(val: Rpdis) -> u8 {
                Rpdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sas {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sas {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sas {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sas {
            #[inline(always)]
            fn from(val: u8) -> Sas {
                Sas::from_bits(val)
            }
        }
        impl From<Sas> for u8 {
            #[inline(always)]
            fn from(val: Sas) -> u8 {
                Sas::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sasmf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sasmf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sasmf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sasmf {
            #[inline(always)]
            fn from(val: u8) -> Sasmf {
                Sasmf::from_bits(val)
            }
        }
        impl From<Sasmf> for u8 {
            #[inline(always)]
            fn from(val: Sasmf) -> u8 {
                Sasmf::to_bits(val)
            }
        }
    }
}
pub mod icu {
    #[doc = "Interrupt Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Icu {
        ptr: *mut u8,
    }
    unsafe impl Send for Icu {}
    unsafe impl Sync for Icu {}
    impl Icu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IRQ Control Register %s"]
        #[inline(always)]
        pub const fn irqcr(self, n: usize) -> crate::common::Reg<regs::Irqcr, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 1usize) as _) }
        }
        #[doc = "NMI Pin Interrupt Control Register"]
        #[inline(always)]
        pub const fn nmicr(self) -> crate::common::Reg<regs::Nmicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Non,maskable Interrupt Enable Register"]
        #[inline(always)]
        pub const fn nmier(self) -> crate::common::Reg<regs::Nmier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Non,maskable Interrupt Status Clear Register"]
        #[inline(always)]
        pub const fn nmiclr(self) -> crate::common::Reg<regs::Nmiclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Non,maskable Interrupt Status Register"]
        #[inline(always)]
        pub const fn nmisr(self) -> crate::common::Reg<regs::Nmisr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "DTC Enable Status Register 0"]
        #[inline(always)]
        pub const fn dtcenst0(self) -> crate::common::Reg<regs::Dtcenst0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "DTC Enable Status Register 1"]
        #[inline(always)]
        pub const fn dtcenst1(self) -> crate::common::Reg<regs::Dtcenst1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "DTC Enable Set Register 0"]
        #[inline(always)]
        pub const fn dtcenset0(self) -> crate::common::Reg<regs::Dtcenset0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0310usize) as _) }
        }
        #[doc = "DTC Enable Set Register 1"]
        #[inline(always)]
        pub const fn dtcenset1(self) -> crate::common::Reg<regs::Dtcenset1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0314usize) as _) }
        }
        #[doc = "DTC Enable Clear Register 0"]
        #[inline(always)]
        pub const fn dtcenclr0(self) -> crate::common::Reg<regs::Dtcenclr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0320usize) as _) }
        }
        #[doc = "DTC Enable Clear Register 1"]
        #[inline(always)]
        pub const fn dtcenclr1(self) -> crate::common::Reg<regs::Dtcenclr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0324usize) as _) }
        }
        #[doc = "Interrupt Request Flag Monitor Register 0"]
        #[inline(always)]
        pub const fn intflag0(self) -> crate::common::Reg<regs::Intflag0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "Interrupt Request Flag Monitor Register 1"]
        #[inline(always)]
        pub const fn intflag1(self) -> crate::common::Reg<regs::Intflag1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0334usize) as _) }
        }
        #[doc = "Software Standby/Snooze End Control Register 0"]
        #[inline(always)]
        pub const fn sbyedcr0(self) -> crate::common::Reg<regs::Sbyedcr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0340usize) as _) }
        }
        #[doc = "Software Standby/Snooze End Control Register 1"]
        #[inline(always)]
        pub const fn sbyedcr1(self) -> crate::common::Reg<regs::Sbyedcr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0344usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "DTC Enable Clear Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcenclr0(pub u32);
        impl Dtcenclr0 {
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr1(&self) -> super::vals::Clr1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Clr1::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr1(&mut self, val: super::vals::Clr1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr2(&self) -> super::vals::Clr2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Clr2::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr2(&mut self, val: super::vals::Clr2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr3(&self) -> super::vals::Clr3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Clr3::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr3(&mut self, val: super::vals::Clr3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr4(&self) -> super::vals::Clr4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Clr4::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr4(&mut self, val: super::vals::Clr4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr5(&self) -> super::vals::Clr5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Clr5::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr5(&mut self, val: super::vals::Clr5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr6(&self) -> super::vals::Clr6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Clr6::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr6(&mut self, val: super::vals::Clr6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr7(&self) -> super::vals::Clr7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Clr7::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr7(&mut self, val: super::vals::Clr7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr12(&self) -> super::vals::Clr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Clr12::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr12(&mut self, val: super::vals::Clr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr13(&self) -> super::vals::Clr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Clr13::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr13(&mut self, val: super::vals::Clr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr15(&self) -> super::vals::Clr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Clr15::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr15(&mut self, val: super::vals::Clr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr16(&self) -> super::vals::Clr16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Clr16::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr16(&mut self, val: super::vals::Clr16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr18(&self) -> super::vals::Clr18 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Clr18::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr18(&mut self, val: super::vals::Clr18) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr19(&self) -> super::vals::Clr19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Clr19::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr19(&mut self, val: super::vals::Clr19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr22(&self) -> super::vals::Clr22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Clr22::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr22(&mut self, val: super::vals::Clr22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr23(&self) -> super::vals::Clr23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Clr23::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr23(&mut self, val: super::vals::Clr23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr27(&self) -> super::vals::Clr27 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Clr27::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr27(&mut self, val: super::vals::Clr27) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr28(&self) -> super::vals::Clr28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Clr28::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr28(&mut self, val: super::vals::Clr28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr29(&self) -> super::vals::Clr29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Clr29::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr29(&mut self, val: super::vals::Clr29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr30(&self) -> super::vals::Clr30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Clr30::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr30(&mut self, val: super::vals::Clr30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr31(&self) -> super::vals::Clr31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Clr31::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr31(&mut self, val: super::vals::Clr31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Dtcenclr0 {
            #[inline(always)]
            fn default() -> Dtcenclr0 {
                Dtcenclr0(0)
            }
        }
        impl core::fmt::Debug for Dtcenclr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcenclr0")
                    .field("clr1", &self.clr1())
                    .field("clr2", &self.clr2())
                    .field("clr3", &self.clr3())
                    .field("clr4", &self.clr4())
                    .field("clr5", &self.clr5())
                    .field("clr6", &self.clr6())
                    .field("clr7", &self.clr7())
                    .field("clr12", &self.clr12())
                    .field("clr13", &self.clr13())
                    .field("clr15", &self.clr15())
                    .field("clr16", &self.clr16())
                    .field("clr18", &self.clr18())
                    .field("clr19", &self.clr19())
                    .field("clr22", &self.clr22())
                    .field("clr23", &self.clr23())
                    .field("clr27", &self.clr27())
                    .field("clr28", &self.clr28())
                    .field("clr29", &self.clr29())
                    .field("clr30", &self.clr30())
                    .field("clr31", &self.clr31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcenclr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dtcenclr0 {{ clr1: {:?}, clr2: {:?}, clr3: {:?}, clr4: {:?}, clr5: {:?}, clr6: {:?}, clr7: {:?}, clr12: {:?}, clr13: {:?}, clr15: {:?}, clr16: {:?}, clr18: {:?}, clr19: {:?}, clr22: {:?}, clr23: {:?}, clr27: {:?}, clr28: {:?}, clr29: {:?}, clr30: {:?}, clr31: {:?} }}" , self . clr1 () , self . clr2 () , self . clr3 () , self . clr4 () , self . clr5 () , self . clr6 () , self . clr7 () , self . clr12 () , self . clr13 () , self . clr15 () , self . clr16 () , self . clr18 () , self . clr19 () , self . clr22 () , self . clr23 () , self . clr27 () , self . clr28 () , self . clr29 () , self . clr30 () , self . clr31 ())
            }
        }
        #[doc = "DTC Enable Clear Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcenclr1(pub u32);
        impl Dtcenclr1 {
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr32(&self) -> super::vals::Clr32 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Clr32::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr32(&mut self, val: super::vals::Clr32) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr33(&self) -> super::vals::Clr33 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Clr33::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr33(&mut self, val: super::vals::Clr33) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr34(&self) -> super::vals::Clr34 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Clr34::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr34(&mut self, val: super::vals::Clr34) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr35(&self) -> super::vals::Clr35 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Clr35::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr35(&mut self, val: super::vals::Clr35) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr36(&self) -> super::vals::Clr36 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Clr36::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr36(&mut self, val: super::vals::Clr36) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr37(&self) -> super::vals::Clr37 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Clr37::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr37(&mut self, val: super::vals::Clr37) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr38(&self) -> super::vals::Clr38 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Clr38::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr38(&mut self, val: super::vals::Clr38) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr40(&self) -> super::vals::Clr40 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Clr40::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr40(&mut self, val: super::vals::Clr40) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub const fn clr41(&self) -> super::vals::Clr41 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Clr41::from_bits(val as u8)
            }
            #[doc = "DTC Enable Clear by Event Number i"]
            #[inline(always)]
            pub fn set_clr41(&mut self, val: super::vals::Clr41) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Dtcenclr1 {
            #[inline(always)]
            fn default() -> Dtcenclr1 {
                Dtcenclr1(0)
            }
        }
        impl core::fmt::Debug for Dtcenclr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcenclr1")
                    .field("clr32", &self.clr32())
                    .field("clr33", &self.clr33())
                    .field("clr34", &self.clr34())
                    .field("clr35", &self.clr35())
                    .field("clr36", &self.clr36())
                    .field("clr37", &self.clr37())
                    .field("clr38", &self.clr38())
                    .field("clr40", &self.clr40())
                    .field("clr41", &self.clr41())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcenclr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dtcenclr1 {{ clr32: {:?}, clr33: {:?}, clr34: {:?}, clr35: {:?}, clr36: {:?}, clr37: {:?}, clr38: {:?}, clr40: {:?}, clr41: {:?} }}" , self . clr32 () , self . clr33 () , self . clr34 () , self . clr35 () , self . clr36 () , self . clr37 () , self . clr38 () , self . clr40 () , self . clr41 ())
            }
        }
        #[doc = "DTC Enable Set Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcenset0(pub u32);
        impl Dtcenset0 {
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set1(&self) -> super::vals::Set1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Set1::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set1(&mut self, val: super::vals::Set1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set2(&self) -> super::vals::Set2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Set2::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set2(&mut self, val: super::vals::Set2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set3(&self) -> super::vals::Set3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Set3::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set3(&mut self, val: super::vals::Set3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set4(&self) -> super::vals::Set4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Set4::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set4(&mut self, val: super::vals::Set4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set5(&self) -> super::vals::Set5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Set5::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set5(&mut self, val: super::vals::Set5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set6(&self) -> super::vals::Set6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Set6::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set6(&mut self, val: super::vals::Set6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set7(&self) -> super::vals::Set7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Set7::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set7(&mut self, val: super::vals::Set7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set12(&self) -> super::vals::Set12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Set12::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set12(&mut self, val: super::vals::Set12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set13(&self) -> super::vals::Set13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Set13::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set13(&mut self, val: super::vals::Set13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set15(&self) -> super::vals::Set15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Set15::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set15(&mut self, val: super::vals::Set15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set16(&self) -> super::vals::Set16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Set16::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set16(&mut self, val: super::vals::Set16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set18(&self) -> super::vals::Set18 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Set18::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set18(&mut self, val: super::vals::Set18) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set19(&self) -> super::vals::Set19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Set19::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set19(&mut self, val: super::vals::Set19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set22(&self) -> super::vals::Set22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Set22::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set22(&mut self, val: super::vals::Set22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set23(&self) -> super::vals::Set23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Set23::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set23(&mut self, val: super::vals::Set23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set27(&self) -> super::vals::Set27 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Set27::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set27(&mut self, val: super::vals::Set27) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set28(&self) -> super::vals::Set28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Set28::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set28(&mut self, val: super::vals::Set28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set29(&self) -> super::vals::Set29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Set29::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set29(&mut self, val: super::vals::Set29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set30(&self) -> super::vals::Set30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Set30::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set30(&mut self, val: super::vals::Set30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set31(&self) -> super::vals::Set31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Set31::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set31(&mut self, val: super::vals::Set31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Dtcenset0 {
            #[inline(always)]
            fn default() -> Dtcenset0 {
                Dtcenset0(0)
            }
        }
        impl core::fmt::Debug for Dtcenset0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcenset0")
                    .field("set1", &self.set1())
                    .field("set2", &self.set2())
                    .field("set3", &self.set3())
                    .field("set4", &self.set4())
                    .field("set5", &self.set5())
                    .field("set6", &self.set6())
                    .field("set7", &self.set7())
                    .field("set12", &self.set12())
                    .field("set13", &self.set13())
                    .field("set15", &self.set15())
                    .field("set16", &self.set16())
                    .field("set18", &self.set18())
                    .field("set19", &self.set19())
                    .field("set22", &self.set22())
                    .field("set23", &self.set23())
                    .field("set27", &self.set27())
                    .field("set28", &self.set28())
                    .field("set29", &self.set29())
                    .field("set30", &self.set30())
                    .field("set31", &self.set31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcenset0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dtcenset0 {{ set1: {:?}, set2: {:?}, set3: {:?}, set4: {:?}, set5: {:?}, set6: {:?}, set7: {:?}, set12: {:?}, set13: {:?}, set15: {:?}, set16: {:?}, set18: {:?}, set19: {:?}, set22: {:?}, set23: {:?}, set27: {:?}, set28: {:?}, set29: {:?}, set30: {:?}, set31: {:?} }}" , self . set1 () , self . set2 () , self . set3 () , self . set4 () , self . set5 () , self . set6 () , self . set7 () , self . set12 () , self . set13 () , self . set15 () , self . set16 () , self . set18 () , self . set19 () , self . set22 () , self . set23 () , self . set27 () , self . set28 () , self . set29 () , self . set30 () , self . set31 ())
            }
        }
        #[doc = "DTC Enable Set Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcenset1(pub u32);
        impl Dtcenset1 {
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set32(&self) -> super::vals::Set32 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Set32::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set32(&mut self, val: super::vals::Set32) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set33(&self) -> super::vals::Set33 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Set33::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set33(&mut self, val: super::vals::Set33) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set34(&self) -> super::vals::Set34 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Set34::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set34(&mut self, val: super::vals::Set34) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set35(&self) -> super::vals::Set35 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Set35::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set35(&mut self, val: super::vals::Set35) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set36(&self) -> super::vals::Set36 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Set36::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set36(&mut self, val: super::vals::Set36) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set37(&self) -> super::vals::Set37 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Set37::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set37(&mut self, val: super::vals::Set37) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set38(&self) -> super::vals::Set38 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Set38::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set38(&mut self, val: super::vals::Set38) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set40(&self) -> super::vals::Set40 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Set40::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set40(&mut self, val: super::vals::Set40) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub const fn set41(&self) -> super::vals::Set41 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Set41::from_bits(val as u8)
            }
            #[doc = "DTC Enable Set by Event Number i"]
            #[inline(always)]
            pub fn set_set41(&mut self, val: super::vals::Set41) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Dtcenset1 {
            #[inline(always)]
            fn default() -> Dtcenset1 {
                Dtcenset1(0)
            }
        }
        impl core::fmt::Debug for Dtcenset1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcenset1")
                    .field("set32", &self.set32())
                    .field("set33", &self.set33())
                    .field("set34", &self.set34())
                    .field("set35", &self.set35())
                    .field("set36", &self.set36())
                    .field("set37", &self.set37())
                    .field("set38", &self.set38())
                    .field("set40", &self.set40())
                    .field("set41", &self.set41())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcenset1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dtcenset1 {{ set32: {:?}, set33: {:?}, set34: {:?}, set35: {:?}, set36: {:?}, set37: {:?}, set38: {:?}, set40: {:?}, set41: {:?} }}" , self . set32 () , self . set33 () , self . set34 () , self . set35 () , self . set36 () , self . set37 () , self . set38 () , self . set40 () , self . set41 ())
            }
        }
        #[doc = "DTC Enable Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcenst0(pub u32);
        impl Dtcenst0 {
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st1(&self) -> super::vals::St1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::St1::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st1(&mut self, val: super::vals::St1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st2(&self) -> super::vals::St2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::St2::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st2(&mut self, val: super::vals::St2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st3(&self) -> super::vals::St3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::St3::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st3(&mut self, val: super::vals::St3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st4(&self) -> super::vals::St4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::St4::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st4(&mut self, val: super::vals::St4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st5(&self) -> super::vals::St5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::St5::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st5(&mut self, val: super::vals::St5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st6(&self) -> super::vals::St6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::St6::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st6(&mut self, val: super::vals::St6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st7(&self) -> super::vals::St7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::St7::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st7(&mut self, val: super::vals::St7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st12(&self) -> super::vals::St12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::St12::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st12(&mut self, val: super::vals::St12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st13(&self) -> super::vals::St13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::St13::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st13(&mut self, val: super::vals::St13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st15(&self) -> super::vals::St15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::St15::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st15(&mut self, val: super::vals::St15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st16(&self) -> super::vals::St16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::St16::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st16(&mut self, val: super::vals::St16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st18(&self) -> super::vals::St18 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::St18::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st18(&mut self, val: super::vals::St18) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st19(&self) -> super::vals::St19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::St19::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st19(&mut self, val: super::vals::St19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st22(&self) -> super::vals::St22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::St22::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st22(&mut self, val: super::vals::St22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st23(&self) -> super::vals::St23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::St23::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st23(&mut self, val: super::vals::St23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st27(&self) -> super::vals::St27 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::St27::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st27(&mut self, val: super::vals::St27) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st28(&self) -> super::vals::St28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::St28::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st28(&mut self, val: super::vals::St28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st29(&self) -> super::vals::St29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::St29::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st29(&mut self, val: super::vals::St29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st30(&self) -> super::vals::St30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::St30::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st30(&mut self, val: super::vals::St30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st31(&self) -> super::vals::St31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::St31::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st31(&mut self, val: super::vals::St31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Dtcenst0 {
            #[inline(always)]
            fn default() -> Dtcenst0 {
                Dtcenst0(0)
            }
        }
        impl core::fmt::Debug for Dtcenst0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcenst0")
                    .field("st1", &self.st1())
                    .field("st2", &self.st2())
                    .field("st3", &self.st3())
                    .field("st4", &self.st4())
                    .field("st5", &self.st5())
                    .field("st6", &self.st6())
                    .field("st7", &self.st7())
                    .field("st12", &self.st12())
                    .field("st13", &self.st13())
                    .field("st15", &self.st15())
                    .field("st16", &self.st16())
                    .field("st18", &self.st18())
                    .field("st19", &self.st19())
                    .field("st22", &self.st22())
                    .field("st23", &self.st23())
                    .field("st27", &self.st27())
                    .field("st28", &self.st28())
                    .field("st29", &self.st29())
                    .field("st30", &self.st30())
                    .field("st31", &self.st31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcenst0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dtcenst0 {{ st1: {:?}, st2: {:?}, st3: {:?}, st4: {:?}, st5: {:?}, st6: {:?}, st7: {:?}, st12: {:?}, st13: {:?}, st15: {:?}, st16: {:?}, st18: {:?}, st19: {:?}, st22: {:?}, st23: {:?}, st27: {:?}, st28: {:?}, st29: {:?}, st30: {:?}, st31: {:?} }}" , self . st1 () , self . st2 () , self . st3 () , self . st4 () , self . st5 () , self . st6 () , self . st7 () , self . st12 () , self . st13 () , self . st15 () , self . st16 () , self . st18 () , self . st19 () , self . st22 () , self . st23 () , self . st27 () , self . st28 () , self . st29 () , self . st30 () , self . st31 ())
            }
        }
        #[doc = "DTC Enable Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcenst1(pub u32);
        impl Dtcenst1 {
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st32(&self) -> super::vals::St32 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::St32::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st32(&mut self, val: super::vals::St32) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st33(&self) -> super::vals::St33 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::St33::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st33(&mut self, val: super::vals::St33) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st34(&self) -> super::vals::St34 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::St34::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st34(&mut self, val: super::vals::St34) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st35(&self) -> super::vals::St35 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::St35::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st35(&mut self, val: super::vals::St35) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st36(&self) -> super::vals::St36 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::St36::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st36(&mut self, val: super::vals::St36) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st37(&self) -> super::vals::St37 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::St37::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st37(&mut self, val: super::vals::St37) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st38(&self) -> super::vals::St38 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::St38::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st38(&mut self, val: super::vals::St38) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st40(&self) -> super::vals::St40 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::St40::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st40(&mut self, val: super::vals::St40) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub const fn st41(&self) -> super::vals::St41 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::St41::from_bits(val as u8)
            }
            #[doc = "DTC Enable Status by Event Number i"]
            #[inline(always)]
            pub fn set_st41(&mut self, val: super::vals::St41) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Dtcenst1 {
            #[inline(always)]
            fn default() -> Dtcenst1 {
                Dtcenst1(0)
            }
        }
        impl core::fmt::Debug for Dtcenst1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcenst1")
                    .field("st32", &self.st32())
                    .field("st33", &self.st33())
                    .field("st34", &self.st34())
                    .field("st35", &self.st35())
                    .field("st36", &self.st36())
                    .field("st37", &self.st37())
                    .field("st38", &self.st38())
                    .field("st40", &self.st40())
                    .field("st41", &self.st41())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcenst1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dtcenst1 {{ st32: {:?}, st33: {:?}, st34: {:?}, st35: {:?}, st36: {:?}, st37: {:?}, st38: {:?}, st40: {:?}, st41: {:?} }}" , self . st32 () , self . st33 () , self . st34 () , self . st35 () , self . st36 () , self . st37 () , self . st38 () , self . st40 () , self . st41 ())
            }
        }
        #[doc = "Interrupt Request Flag Monitor Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intflag0(pub u32);
        impl Intflag0 {
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if0(&self) -> super::vals::If0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::If0::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if0(&mut self, val: super::vals::If0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if1(&self) -> super::vals::If1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::If1::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if1(&mut self, val: super::vals::If1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if2(&self) -> super::vals::If2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::If2::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if2(&mut self, val: super::vals::If2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if3(&self) -> super::vals::If3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::If3::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if3(&mut self, val: super::vals::If3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if4(&self) -> super::vals::If4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::If4::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if4(&mut self, val: super::vals::If4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if5(&self) -> super::vals::If5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::If5::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if5(&mut self, val: super::vals::If5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if6(&self) -> super::vals::If6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::If6::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if6(&mut self, val: super::vals::If6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if7(&self) -> super::vals::If7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::If7::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if7(&mut self, val: super::vals::If7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if10(&self) -> super::vals::If10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::If10::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if10(&mut self, val: super::vals::If10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if11(&self) -> super::vals::If11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::If11::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if11(&mut self, val: super::vals::If11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if12(&self) -> super::vals::If12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::If12::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if12(&mut self, val: super::vals::If12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if13(&self) -> super::vals::If13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::If13::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if13(&mut self, val: super::vals::If13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if14(&self) -> super::vals::If14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::If14::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if14(&mut self, val: super::vals::If14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if15(&self) -> super::vals::If15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::If15::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if15(&mut self, val: super::vals::If15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if16(&self) -> super::vals::If16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::If16::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if16(&mut self, val: super::vals::If16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if17(&self) -> super::vals::If17 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::If17::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if17(&mut self, val: super::vals::If17) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if18(&self) -> super::vals::If18 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::If18::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if18(&mut self, val: super::vals::If18) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if19(&self) -> super::vals::If19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::If19::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if19(&mut self, val: super::vals::If19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if20(&self) -> super::vals::If20 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::If20::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if20(&mut self, val: super::vals::If20) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if21(&self) -> super::vals::If21 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::If21::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if21(&mut self, val: super::vals::If21) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if22(&self) -> super::vals::If22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::If22::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if22(&mut self, val: super::vals::If22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if23(&self) -> super::vals::If23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::If23::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if23(&mut self, val: super::vals::If23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if24(&self) -> super::vals::If24 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::If24::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if24(&mut self, val: super::vals::If24) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if25(&self) -> super::vals::If25 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::If25::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if25(&mut self, val: super::vals::If25) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if26(&self) -> super::vals::If26 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::If26::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if26(&mut self, val: super::vals::If26) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if27(&self) -> super::vals::If27 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::If27::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if27(&mut self, val: super::vals::If27) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if28(&self) -> super::vals::If28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::If28::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if28(&mut self, val: super::vals::If28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if29(&self) -> super::vals::If29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::If29::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if29(&mut self, val: super::vals::If29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if30(&self) -> super::vals::If30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::If30::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if30(&mut self, val: super::vals::If30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if31(&self) -> super::vals::If31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::If31::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if31(&mut self, val: super::vals::If31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Intflag0 {
            #[inline(always)]
            fn default() -> Intflag0 {
                Intflag0(0)
            }
        }
        impl core::fmt::Debug for Intflag0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intflag0")
                    .field("if0", &self.if0())
                    .field("if1", &self.if1())
                    .field("if2", &self.if2())
                    .field("if3", &self.if3())
                    .field("if4", &self.if4())
                    .field("if5", &self.if5())
                    .field("if6", &self.if6())
                    .field("if7", &self.if7())
                    .field("if10", &self.if10())
                    .field("if11", &self.if11())
                    .field("if12", &self.if12())
                    .field("if13", &self.if13())
                    .field("if14", &self.if14())
                    .field("if15", &self.if15())
                    .field("if16", &self.if16())
                    .field("if17", &self.if17())
                    .field("if18", &self.if18())
                    .field("if19", &self.if19())
                    .field("if20", &self.if20())
                    .field("if21", &self.if21())
                    .field("if22", &self.if22())
                    .field("if23", &self.if23())
                    .field("if24", &self.if24())
                    .field("if25", &self.if25())
                    .field("if26", &self.if26())
                    .field("if27", &self.if27())
                    .field("if28", &self.if28())
                    .field("if29", &self.if29())
                    .field("if30", &self.if30())
                    .field("if31", &self.if31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intflag0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intflag0 {{ if0: {:?}, if1: {:?}, if2: {:?}, if3: {:?}, if4: {:?}, if5: {:?}, if6: {:?}, if7: {:?}, if10: {:?}, if11: {:?}, if12: {:?}, if13: {:?}, if14: {:?}, if15: {:?}, if16: {:?}, if17: {:?}, if18: {:?}, if19: {:?}, if20: {:?}, if21: {:?}, if22: {:?}, if23: {:?}, if24: {:?}, if25: {:?}, if26: {:?}, if27: {:?}, if28: {:?}, if29: {:?}, if30: {:?}, if31: {:?} }}" , self . if0 () , self . if1 () , self . if2 () , self . if3 () , self . if4 () , self . if5 () , self . if6 () , self . if7 () , self . if10 () , self . if11 () , self . if12 () , self . if13 () , self . if14 () , self . if15 () , self . if16 () , self . if17 () , self . if18 () , self . if19 () , self . if20 () , self . if21 () , self . if22 () , self . if23 () , self . if24 () , self . if25 () , self . if26 () , self . if27 () , self . if28 () , self . if29 () , self . if30 () , self . if31 ())
            }
        }
        #[doc = "Interrupt Request Flag Monitor Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intflag1(pub u32);
        impl Intflag1 {
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if32(&self) -> super::vals::If32 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::If32::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if32(&mut self, val: super::vals::If32) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if33(&self) -> super::vals::If33 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::If33::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if33(&mut self, val: super::vals::If33) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if34(&self) -> super::vals::If34 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::If34::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if34(&mut self, val: super::vals::If34) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if35(&self) -> super::vals::If35 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::If35::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if35(&mut self, val: super::vals::If35) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if36(&self) -> super::vals::If36 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::If36::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if36(&mut self, val: super::vals::If36) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if37(&self) -> super::vals::If37 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::If37::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if37(&mut self, val: super::vals::If37) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if38(&self) -> super::vals::If38 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::If38::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if38(&mut self, val: super::vals::If38) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if39(&self) -> super::vals::If39 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::If39::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if39(&mut self, val: super::vals::If39) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if40(&self) -> super::vals::If40 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::If40::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if40(&mut self, val: super::vals::If40) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub const fn if41(&self) -> super::vals::If41 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::If41::from_bits(val as u8)
            }
            #[doc = "Interrupt Request Flag Monitor"]
            #[inline(always)]
            pub fn set_if41(&mut self, val: super::vals::If41) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Intflag1 {
            #[inline(always)]
            fn default() -> Intflag1 {
                Intflag1(0)
            }
        }
        impl core::fmt::Debug for Intflag1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intflag1")
                    .field("if32", &self.if32())
                    .field("if33", &self.if33())
                    .field("if34", &self.if34())
                    .field("if35", &self.if35())
                    .field("if36", &self.if36())
                    .field("if37", &self.if37())
                    .field("if38", &self.if38())
                    .field("if39", &self.if39())
                    .field("if40", &self.if40())
                    .field("if41", &self.if41())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intflag1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intflag1 {{ if32: {:?}, if33: {:?}, if34: {:?}, if35: {:?}, if36: {:?}, if37: {:?}, if38: {:?}, if39: {:?}, if40: {:?}, if41: {:?} }}" , self . if32 () , self . if33 () , self . if34 () , self . if35 () , self . if36 () , self . if37 () , self . if38 () , self . if39 () , self . if40 () , self . if41 ())
            }
        }
        #[doc = "IRQ Control Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Irqcr(pub u8);
        impl Irqcr {
            #[doc = "IRQi Detection Sense Select"]
            #[inline(always)]
            pub const fn irqmd(&self) -> super::vals::Irqmd {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Irqmd::from_bits(val as u8)
            }
            #[doc = "IRQi Detection Sense Select"]
            #[inline(always)]
            pub fn set_irqmd(&mut self, val: super::vals::Irqmd) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Irqcr {
            #[inline(always)]
            fn default() -> Irqcr {
                Irqcr(0)
            }
        }
        impl core::fmt::Debug for Irqcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Irqcr")
                    .field("irqmd", &self.irqmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Irqcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Irqcr {{ irqmd: {:?} }}", self.irqmd())
            }
        }
        #[doc = "Non,maskable Interrupt Status Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmiclr(pub u16);
        impl Nmiclr {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn iwdtclr(&self) -> super::vals::Iwdtclr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtclr::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_iwdtclr(&mut self, val: super::vals::Iwdtclr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn lvd1clr(&self) -> super::vals::Lvd1clr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1clr::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_lvd1clr(&mut self, val: super::vals::Lvd1clr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "NMI Pin Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn nmiclr(&self) -> super::vals::Nmiclr {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmiclr::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_nmiclr(&mut self, val: super::vals::Nmiclr) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn rpeclr(&self) -> super::vals::Rpeclr {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpeclr::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_rpeclr(&mut self, val: super::vals::Rpeclr) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
        }
        impl Default for Nmiclr {
            #[inline(always)]
            fn default() -> Nmiclr {
                Nmiclr(0)
            }
        }
        impl core::fmt::Debug for Nmiclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmiclr")
                    .field("iwdtclr", &self.iwdtclr())
                    .field("lvd1clr", &self.lvd1clr())
                    .field("nmiclr", &self.nmiclr())
                    .field("rpeclr", &self.rpeclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmiclr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nmiclr {{ iwdtclr: {:?}, lvd1clr: {:?}, nmiclr: {:?}, rpeclr: {:?} }}",
                    self.iwdtclr(),
                    self.lvd1clr(),
                    self.nmiclr(),
                    self.rpeclr()
                )
            }
        }
        #[doc = "NMI Pin Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmicr(pub u8);
        impl Nmicr {
            #[doc = "NMI Detection Set"]
            #[inline(always)]
            pub const fn nmimd(&self) -> super::vals::Nmimd {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Nmimd::from_bits(val as u8)
            }
            #[doc = "NMI Detection Set"]
            #[inline(always)]
            pub fn set_nmimd(&mut self, val: super::vals::Nmimd) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Nmicr {
            #[inline(always)]
            fn default() -> Nmicr {
                Nmicr(0)
            }
        }
        impl core::fmt::Debug for Nmicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmicr")
                    .field("nmimd", &self.nmimd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmicr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Nmicr {{ nmimd: {:?} }}", self.nmimd())
            }
        }
        #[doc = "Non,maskable Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmier(pub u16);
        impl Nmier {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub const fn iwdten(&self) -> super::vals::Iwdten {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdten::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_iwdten(&mut self, val: super::vals::Iwdten) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Enable"]
            #[inline(always)]
            pub const fn lvd1en(&self) -> super::vals::Lvd1en {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1en::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Enable"]
            #[inline(always)]
            pub fn set_lvd1en(&mut self, val: super::vals::Lvd1en) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "NMI Pin Interrupt Enable"]
            #[inline(always)]
            pub const fn nmien(&self) -> super::vals::Nmien {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmien::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Enable"]
            #[inline(always)]
            pub fn set_nmien(&mut self, val: super::vals::Nmien) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Interrupt Enable"]
            #[inline(always)]
            pub const fn rpeen(&self) -> super::vals::Rpeen {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpeen::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_rpeen(&mut self, val: super::vals::Rpeen) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
        }
        impl Default for Nmier {
            #[inline(always)]
            fn default() -> Nmier {
                Nmier(0)
            }
        }
        impl core::fmt::Debug for Nmier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmier")
                    .field("iwdten", &self.iwdten())
                    .field("lvd1en", &self.lvd1en())
                    .field("nmien", &self.nmien())
                    .field("rpeen", &self.rpeen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmier {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nmier {{ iwdten: {:?}, lvd1en: {:?}, nmien: {:?}, rpeen: {:?} }}",
                    self.iwdten(),
                    self.lvd1en(),
                    self.nmien(),
                    self.rpeen()
                )
            }
        }
        #[doc = "Non,maskable Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmisr(pub u16);
        impl Nmisr {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn iwdtst(&self) -> super::vals::Iwdtst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtst::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_iwdtst(&mut self, val: super::vals::Iwdtst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag"]
            #[inline(always)]
            pub const fn lvd1st(&self) -> super::vals::Lvd1st {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1st::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_lvd1st(&mut self, val: super::vals::Lvd1st) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "NMI Pin Interrupt Status Flag"]
            #[inline(always)]
            pub const fn nmist(&self) -> super::vals::Nmist {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmist::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_nmist(&mut self, val: super::vals::Nmist) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn rpest(&self) -> super::vals::Rpest {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpest::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_rpest(&mut self, val: super::vals::Rpest) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
        }
        impl Default for Nmisr {
            #[inline(always)]
            fn default() -> Nmisr {
                Nmisr(0)
            }
        }
        impl core::fmt::Debug for Nmisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmisr")
                    .field("iwdtst", &self.iwdtst())
                    .field("lvd1st", &self.lvd1st())
                    .field("nmist", &self.nmist())
                    .field("rpest", &self.rpest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nmisr {{ iwdtst: {:?}, lvd1st: {:?}, nmist: {:?}, rpest: {:?} }}",
                    self.iwdtst(),
                    self.lvd1st(),
                    self.nmist(),
                    self.rpest()
                )
            }
        }
        #[doc = "Software Standby/Snooze End Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sbyedcr0(pub u32);
        impl Sbyedcr0 {
            #[doc = "IWDT Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn iwdted(&self) -> super::vals::Iwdted {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdted::from_bits(val as u8)
            }
            #[doc = "IWDT Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_iwdted(&mut self, val: super::vals::Iwdted) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "LVD1 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn lvd1ed(&self) -> super::vals::Lvd1ed {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd1ed::from_bits(val as u8)
            }
            #[doc = "LVD1 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_lvd1ed(&mut self, val: super::vals::Lvd1ed) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn irq0ed(&self) -> super::vals::Irq0ed {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Irq0ed::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_irq0ed(&mut self, val: super::vals::Irq0ed) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn irq1ed(&self) -> super::vals::Irq1ed {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Irq1ed::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_irq1ed(&mut self, val: super::vals::Irq1ed) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[inline(always)]
            pub const fn irq2ed(&self) -> super::vals::Irq2ed {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Irq2ed::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_irq2ed(&mut self, val: super::vals::Irq2ed) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn irq3ed(&self) -> super::vals::Irq3ed {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Irq3ed::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_irq3ed(&mut self, val: super::vals::Irq3ed) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn irq4ed(&self) -> super::vals::Irq4ed {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Irq4ed::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_irq4ed(&mut self, val: super::vals::Irq4ed) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[inline(always)]
            pub const fn irq5ed(&self) -> super::vals::Irq5ed {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Irq5ed::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_irq5ed(&mut self, val: super::vals::Irq5ed) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "DTC Transfer Complete Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn dtced(&self) -> super::vals::Dtced {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Dtced::from_bits(val as u8)
            }
            #[doc = "DTC Transfer Complete Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_dtced(&mut self, val: super::vals::Dtced) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "SPI00 Transfer End or Buffer Empty Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn spi00rxed(&self) -> super::vals::Spi00rxed {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Spi00rxed::from_bits(val as u8)
            }
            #[doc = "SPI00 Transfer End or Buffer Empty Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_spi00rxed(&mut self, val: super::vals::Spi00rxed) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "UART0 Reception Communication Error Occurrence Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn uart0erred(&self) -> super::vals::Uart0erred {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Uart0erred::from_bits(val as u8)
            }
            #[doc = "UART0 Reception Communication Error Occurrence Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_uart0erred(&mut self, val: super::vals::Uart0erred) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "IICA0 Address Match Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn iica0ed(&self) -> super::vals::Iica0ed {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Iica0ed::from_bits(val as u8)
            }
            #[doc = "IICA0 Address Match Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_iica0ed(&mut self, val: super::vals::Iica0ed) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "UART0 Reception Transfer End Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn uart0rxed(&self) -> super::vals::Uart0rxed {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Uart0rxed::from_bits(val as u8)
            }
            #[doc = "UART0 Reception Transfer End Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_uart0rxed(&mut self, val: super::vals::Uart0rxed) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "End of A/D Conversion Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn adc12ed(&self) -> super::vals::Adc12ed {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Adc12ed::from_bits(val as u8)
            }
            #[doc = "End of A/D Conversion Interrupt Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_adc12ed(&mut self, val: super::vals::Adc12ed) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Sbyedcr0 {
            #[inline(always)]
            fn default() -> Sbyedcr0 {
                Sbyedcr0(0)
            }
        }
        impl core::fmt::Debug for Sbyedcr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sbyedcr0")
                    .field("iwdted", &self.iwdted())
                    .field("lvd1ed", &self.lvd1ed())
                    .field("irq0ed", &self.irq0ed())
                    .field("irq1ed", &self.irq1ed())
                    .field("irq2ed", &self.irq2ed())
                    .field("irq3ed", &self.irq3ed())
                    .field("irq4ed", &self.irq4ed())
                    .field("irq5ed", &self.irq5ed())
                    .field("dtced", &self.dtced())
                    .field("spi00rxed", &self.spi00rxed())
                    .field("uart0erred", &self.uart0erred())
                    .field("iica0ed", &self.iica0ed())
                    .field("uart0rxed", &self.uart0rxed())
                    .field("adc12ed", &self.adc12ed())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sbyedcr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sbyedcr0 {{ iwdted: {:?}, lvd1ed: {:?}, irq0ed: {:?}, irq1ed: {:?}, irq2ed: {:?}, irq3ed: {:?}, irq4ed: {:?}, irq5ed: {:?}, dtced: {:?}, spi00rxed: {:?}, uart0erred: {:?}, iica0ed: {:?}, uart0rxed: {:?}, adc12ed: {:?} }}" , self . iwdted () , self . lvd1ed () , self . irq0ed () , self . irq1ed () , self . irq2ed () , self . irq3ed () , self . irq4ed () , self . irq5ed () , self . dtced () , self . spi00rxed () , self . uart0erred () , self . iica0ed () , self . uart0rxed () , self . adc12ed ())
            }
        }
        #[doc = "Software Standby/Snooze End Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sbyedcr1(pub u32);
        impl Sbyedcr1 {
            #[doc = "RTC Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn rtced(&self) -> super::vals::Rtced {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rtced::from_bits(val as u8)
            }
            #[doc = "RTC Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_rtced(&mut self, val: super::vals::Rtced) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Interval Signal of 32-bit Interval Timer Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn itled(&self) -> super::vals::Itled {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Itled::from_bits(val as u8)
            }
            #[doc = "Interval Signal of 32-bit Interval Timer Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_itled(&mut self, val: super::vals::Itled) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "UARTA0 Reception Communication Error Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn ure0ed(&self) -> super::vals::Ure0ed {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ure0ed::from_bits(val as u8)
            }
            #[doc = "UARTA0 Reception Communication Error Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_ure0ed(&mut self, val: super::vals::Ure0ed) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "UARTA0 Transmission Transfer End or Buffer Empty Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn ut0ed(&self) -> super::vals::Ut0ed {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ut0ed::from_bits(val as u8)
            }
            #[doc = "UARTA0 Transmission Transfer End or Buffer Empty Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_ut0ed(&mut self, val: super::vals::Ut0ed) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "UARTA0 Reception Transfer End Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn ur0ed(&self) -> super::vals::Ur0ed {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ur0ed::from_bits(val as u8)
            }
            #[doc = "UARTA0 Reception Transfer End Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_ur0ed(&mut self, val: super::vals::Ur0ed) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Sbyedcr1 {
            #[inline(always)]
            fn default() -> Sbyedcr1 {
                Sbyedcr1(0)
            }
        }
        impl core::fmt::Debug for Sbyedcr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sbyedcr1")
                    .field("rtced", &self.rtced())
                    .field("itled", &self.itled())
                    .field("ure0ed", &self.ure0ed())
                    .field("ut0ed", &self.ut0ed())
                    .field("ur0ed", &self.ur0ed())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sbyedcr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sbyedcr1 {{ rtced: {:?}, itled: {:?}, ure0ed: {:?}, ut0ed: {:?}, ur0ed: {:?} }}" , self . rtced () , self . itled () , self . ure0ed () , self . ut0ed () , self . ur0ed ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adc12ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adc12ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adc12ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adc12ed {
            #[inline(always)]
            fn from(val: u8) -> Adc12ed {
                Adc12ed::from_bits(val)
            }
        }
        impl From<Adc12ed> for u8 {
            #[inline(always)]
            fn from(val: Adc12ed) -> u8 {
                Adc12ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr1 {
            #[inline(always)]
            fn from(val: u8) -> Clr1 {
                Clr1::from_bits(val)
            }
        }
        impl From<Clr1> for u8 {
            #[inline(always)]
            fn from(val: Clr1) -> u8 {
                Clr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr12 {
            #[inline(always)]
            fn from(val: u8) -> Clr12 {
                Clr12::from_bits(val)
            }
        }
        impl From<Clr12> for u8 {
            #[inline(always)]
            fn from(val: Clr12) -> u8 {
                Clr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr13 {
            #[inline(always)]
            fn from(val: u8) -> Clr13 {
                Clr13::from_bits(val)
            }
        }
        impl From<Clr13> for u8 {
            #[inline(always)]
            fn from(val: Clr13) -> u8 {
                Clr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr15 {
            #[inline(always)]
            fn from(val: u8) -> Clr15 {
                Clr15::from_bits(val)
            }
        }
        impl From<Clr15> for u8 {
            #[inline(always)]
            fn from(val: Clr15) -> u8 {
                Clr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr16 {
            #[inline(always)]
            fn from(val: u8) -> Clr16 {
                Clr16::from_bits(val)
            }
        }
        impl From<Clr16> for u8 {
            #[inline(always)]
            fn from(val: Clr16) -> u8 {
                Clr16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr18 {
            #[inline(always)]
            fn from(val: u8) -> Clr18 {
                Clr18::from_bits(val)
            }
        }
        impl From<Clr18> for u8 {
            #[inline(always)]
            fn from(val: Clr18) -> u8 {
                Clr18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr19 {
            #[inline(always)]
            fn from(val: u8) -> Clr19 {
                Clr19::from_bits(val)
            }
        }
        impl From<Clr19> for u8 {
            #[inline(always)]
            fn from(val: Clr19) -> u8 {
                Clr19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr2 {
            #[inline(always)]
            fn from(val: u8) -> Clr2 {
                Clr2::from_bits(val)
            }
        }
        impl From<Clr2> for u8 {
            #[inline(always)]
            fn from(val: Clr2) -> u8 {
                Clr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr22 {
            #[inline(always)]
            fn from(val: u8) -> Clr22 {
                Clr22::from_bits(val)
            }
        }
        impl From<Clr22> for u8 {
            #[inline(always)]
            fn from(val: Clr22) -> u8 {
                Clr22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr23 {
            #[inline(always)]
            fn from(val: u8) -> Clr23 {
                Clr23::from_bits(val)
            }
        }
        impl From<Clr23> for u8 {
            #[inline(always)]
            fn from(val: Clr23) -> u8 {
                Clr23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr27 {
            #[inline(always)]
            fn from(val: u8) -> Clr27 {
                Clr27::from_bits(val)
            }
        }
        impl From<Clr27> for u8 {
            #[inline(always)]
            fn from(val: Clr27) -> u8 {
                Clr27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr28 {
            #[inline(always)]
            fn from(val: u8) -> Clr28 {
                Clr28::from_bits(val)
            }
        }
        impl From<Clr28> for u8 {
            #[inline(always)]
            fn from(val: Clr28) -> u8 {
                Clr28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr29 {
            #[inline(always)]
            fn from(val: u8) -> Clr29 {
                Clr29::from_bits(val)
            }
        }
        impl From<Clr29> for u8 {
            #[inline(always)]
            fn from(val: Clr29) -> u8 {
                Clr29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr3 {
            #[inline(always)]
            fn from(val: u8) -> Clr3 {
                Clr3::from_bits(val)
            }
        }
        impl From<Clr3> for u8 {
            #[inline(always)]
            fn from(val: Clr3) -> u8 {
                Clr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr30 {
            #[inline(always)]
            fn from(val: u8) -> Clr30 {
                Clr30::from_bits(val)
            }
        }
        impl From<Clr30> for u8 {
            #[inline(always)]
            fn from(val: Clr30) -> u8 {
                Clr30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr31 {
            #[inline(always)]
            fn from(val: u8) -> Clr31 {
                Clr31::from_bits(val)
            }
        }
        impl From<Clr31> for u8 {
            #[inline(always)]
            fn from(val: Clr31) -> u8 {
                Clr31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr32 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr32 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr32 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr32 {
            #[inline(always)]
            fn from(val: u8) -> Clr32 {
                Clr32::from_bits(val)
            }
        }
        impl From<Clr32> for u8 {
            #[inline(always)]
            fn from(val: Clr32) -> u8 {
                Clr32::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr33 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr33 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr33 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr33 {
            #[inline(always)]
            fn from(val: u8) -> Clr33 {
                Clr33::from_bits(val)
            }
        }
        impl From<Clr33> for u8 {
            #[inline(always)]
            fn from(val: Clr33) -> u8 {
                Clr33::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr34 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr34 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr34 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr34 {
            #[inline(always)]
            fn from(val: u8) -> Clr34 {
                Clr34::from_bits(val)
            }
        }
        impl From<Clr34> for u8 {
            #[inline(always)]
            fn from(val: Clr34) -> u8 {
                Clr34::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr35 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr35 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr35 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr35 {
            #[inline(always)]
            fn from(val: u8) -> Clr35 {
                Clr35::from_bits(val)
            }
        }
        impl From<Clr35> for u8 {
            #[inline(always)]
            fn from(val: Clr35) -> u8 {
                Clr35::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr36 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr36 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr36 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr36 {
            #[inline(always)]
            fn from(val: u8) -> Clr36 {
                Clr36::from_bits(val)
            }
        }
        impl From<Clr36> for u8 {
            #[inline(always)]
            fn from(val: Clr36) -> u8 {
                Clr36::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr37 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr37 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr37 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr37 {
            #[inline(always)]
            fn from(val: u8) -> Clr37 {
                Clr37::from_bits(val)
            }
        }
        impl From<Clr37> for u8 {
            #[inline(always)]
            fn from(val: Clr37) -> u8 {
                Clr37::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr38 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr38 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr38 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr38 {
            #[inline(always)]
            fn from(val: u8) -> Clr38 {
                Clr38::from_bits(val)
            }
        }
        impl From<Clr38> for u8 {
            #[inline(always)]
            fn from(val: Clr38) -> u8 {
                Clr38::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr4 {
            #[inline(always)]
            fn from(val: u8) -> Clr4 {
                Clr4::from_bits(val)
            }
        }
        impl From<Clr4> for u8 {
            #[inline(always)]
            fn from(val: Clr4) -> u8 {
                Clr4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr40 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr40 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr40 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr40 {
            #[inline(always)]
            fn from(val: u8) -> Clr40 {
                Clr40::from_bits(val)
            }
        }
        impl From<Clr40> for u8 {
            #[inline(always)]
            fn from(val: Clr40) -> u8 {
                Clr40::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr41 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr41 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr41 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr41 {
            #[inline(always)]
            fn from(val: u8) -> Clr41 {
                Clr41::from_bits(val)
            }
        }
        impl From<Clr41> for u8 {
            #[inline(always)]
            fn from(val: Clr41) -> u8 {
                Clr41::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr5 {
            #[inline(always)]
            fn from(val: u8) -> Clr5 {
                Clr5::from_bits(val)
            }
        }
        impl From<Clr5> for u8 {
            #[inline(always)]
            fn from(val: Clr5) -> u8 {
                Clr5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr6 {
            #[inline(always)]
            fn from(val: u8) -> Clr6 {
                Clr6::from_bits(val)
            }
        }
        impl From<Clr6> for u8 {
            #[inline(always)]
            fn from(val: Clr6) -> u8 {
                Clr6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clr7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr7 {
            #[inline(always)]
            fn from(val: u8) -> Clr7 {
                Clr7::from_bits(val)
            }
        }
        impl From<Clr7> for u8 {
            #[inline(always)]
            fn from(val: Clr7) -> u8 {
                Clr7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtced {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtced {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtced {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtced {
            #[inline(always)]
            fn from(val: u8) -> Dtced {
                Dtced::from_bits(val)
            }
        }
        impl From<Dtced> for u8 {
            #[inline(always)]
            fn from(val: Dtced) -> u8 {
                Dtced::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If0 {
            #[inline(always)]
            fn from(val: u8) -> If0 {
                If0::from_bits(val)
            }
        }
        impl From<If0> for u8 {
            #[inline(always)]
            fn from(val: If0) -> u8 {
                If0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If1 {
            #[inline(always)]
            fn from(val: u8) -> If1 {
                If1::from_bits(val)
            }
        }
        impl From<If1> for u8 {
            #[inline(always)]
            fn from(val: If1) -> u8 {
                If1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If10 {
            #[inline(always)]
            fn from(val: u8) -> If10 {
                If10::from_bits(val)
            }
        }
        impl From<If10> for u8 {
            #[inline(always)]
            fn from(val: If10) -> u8 {
                If10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If11 {
            #[inline(always)]
            fn from(val: u8) -> If11 {
                If11::from_bits(val)
            }
        }
        impl From<If11> for u8 {
            #[inline(always)]
            fn from(val: If11) -> u8 {
                If11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If12 {
            #[inline(always)]
            fn from(val: u8) -> If12 {
                If12::from_bits(val)
            }
        }
        impl From<If12> for u8 {
            #[inline(always)]
            fn from(val: If12) -> u8 {
                If12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If13 {
            #[inline(always)]
            fn from(val: u8) -> If13 {
                If13::from_bits(val)
            }
        }
        impl From<If13> for u8 {
            #[inline(always)]
            fn from(val: If13) -> u8 {
                If13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If14 {
            #[inline(always)]
            fn from(val: u8) -> If14 {
                If14::from_bits(val)
            }
        }
        impl From<If14> for u8 {
            #[inline(always)]
            fn from(val: If14) -> u8 {
                If14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If15 {
            #[inline(always)]
            fn from(val: u8) -> If15 {
                If15::from_bits(val)
            }
        }
        impl From<If15> for u8 {
            #[inline(always)]
            fn from(val: If15) -> u8 {
                If15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If16 {
            #[inline(always)]
            fn from(val: u8) -> If16 {
                If16::from_bits(val)
            }
        }
        impl From<If16> for u8 {
            #[inline(always)]
            fn from(val: If16) -> u8 {
                If16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If17 {
            #[inline(always)]
            fn from(val: u8) -> If17 {
                If17::from_bits(val)
            }
        }
        impl From<If17> for u8 {
            #[inline(always)]
            fn from(val: If17) -> u8 {
                If17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If18 {
            #[inline(always)]
            fn from(val: u8) -> If18 {
                If18::from_bits(val)
            }
        }
        impl From<If18> for u8 {
            #[inline(always)]
            fn from(val: If18) -> u8 {
                If18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If19 {
            #[inline(always)]
            fn from(val: u8) -> If19 {
                If19::from_bits(val)
            }
        }
        impl From<If19> for u8 {
            #[inline(always)]
            fn from(val: If19) -> u8 {
                If19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If2 {
            #[inline(always)]
            fn from(val: u8) -> If2 {
                If2::from_bits(val)
            }
        }
        impl From<If2> for u8 {
            #[inline(always)]
            fn from(val: If2) -> u8 {
                If2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If20 {
            #[inline(always)]
            fn from(val: u8) -> If20 {
                If20::from_bits(val)
            }
        }
        impl From<If20> for u8 {
            #[inline(always)]
            fn from(val: If20) -> u8 {
                If20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If21 {
            #[inline(always)]
            fn from(val: u8) -> If21 {
                If21::from_bits(val)
            }
        }
        impl From<If21> for u8 {
            #[inline(always)]
            fn from(val: If21) -> u8 {
                If21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If22 {
            #[inline(always)]
            fn from(val: u8) -> If22 {
                If22::from_bits(val)
            }
        }
        impl From<If22> for u8 {
            #[inline(always)]
            fn from(val: If22) -> u8 {
                If22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If23 {
            #[inline(always)]
            fn from(val: u8) -> If23 {
                If23::from_bits(val)
            }
        }
        impl From<If23> for u8 {
            #[inline(always)]
            fn from(val: If23) -> u8 {
                If23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If24 {
            #[inline(always)]
            fn from(val: u8) -> If24 {
                If24::from_bits(val)
            }
        }
        impl From<If24> for u8 {
            #[inline(always)]
            fn from(val: If24) -> u8 {
                If24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If25 {
            #[inline(always)]
            fn from(val: u8) -> If25 {
                If25::from_bits(val)
            }
        }
        impl From<If25> for u8 {
            #[inline(always)]
            fn from(val: If25) -> u8 {
                If25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If26 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If26 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If26 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If26 {
            #[inline(always)]
            fn from(val: u8) -> If26 {
                If26::from_bits(val)
            }
        }
        impl From<If26> for u8 {
            #[inline(always)]
            fn from(val: If26) -> u8 {
                If26::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If27 {
            #[inline(always)]
            fn from(val: u8) -> If27 {
                If27::from_bits(val)
            }
        }
        impl From<If27> for u8 {
            #[inline(always)]
            fn from(val: If27) -> u8 {
                If27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If28 {
            #[inline(always)]
            fn from(val: u8) -> If28 {
                If28::from_bits(val)
            }
        }
        impl From<If28> for u8 {
            #[inline(always)]
            fn from(val: If28) -> u8 {
                If28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If29 {
            #[inline(always)]
            fn from(val: u8) -> If29 {
                If29::from_bits(val)
            }
        }
        impl From<If29> for u8 {
            #[inline(always)]
            fn from(val: If29) -> u8 {
                If29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If3 {
            #[inline(always)]
            fn from(val: u8) -> If3 {
                If3::from_bits(val)
            }
        }
        impl From<If3> for u8 {
            #[inline(always)]
            fn from(val: If3) -> u8 {
                If3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If30 {
            #[inline(always)]
            fn from(val: u8) -> If30 {
                If30::from_bits(val)
            }
        }
        impl From<If30> for u8 {
            #[inline(always)]
            fn from(val: If30) -> u8 {
                If30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If31 {
            #[inline(always)]
            fn from(val: u8) -> If31 {
                If31::from_bits(val)
            }
        }
        impl From<If31> for u8 {
            #[inline(always)]
            fn from(val: If31) -> u8 {
                If31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If32 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If32 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If32 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If32 {
            #[inline(always)]
            fn from(val: u8) -> If32 {
                If32::from_bits(val)
            }
        }
        impl From<If32> for u8 {
            #[inline(always)]
            fn from(val: If32) -> u8 {
                If32::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If33 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If33 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If33 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If33 {
            #[inline(always)]
            fn from(val: u8) -> If33 {
                If33::from_bits(val)
            }
        }
        impl From<If33> for u8 {
            #[inline(always)]
            fn from(val: If33) -> u8 {
                If33::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If34 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If34 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If34 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If34 {
            #[inline(always)]
            fn from(val: u8) -> If34 {
                If34::from_bits(val)
            }
        }
        impl From<If34> for u8 {
            #[inline(always)]
            fn from(val: If34) -> u8 {
                If34::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If35 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If35 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If35 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If35 {
            #[inline(always)]
            fn from(val: u8) -> If35 {
                If35::from_bits(val)
            }
        }
        impl From<If35> for u8 {
            #[inline(always)]
            fn from(val: If35) -> u8 {
                If35::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If36 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If36 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If36 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If36 {
            #[inline(always)]
            fn from(val: u8) -> If36 {
                If36::from_bits(val)
            }
        }
        impl From<If36> for u8 {
            #[inline(always)]
            fn from(val: If36) -> u8 {
                If36::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If37 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If37 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If37 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If37 {
            #[inline(always)]
            fn from(val: u8) -> If37 {
                If37::from_bits(val)
            }
        }
        impl From<If37> for u8 {
            #[inline(always)]
            fn from(val: If37) -> u8 {
                If37::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If38 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If38 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If38 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If38 {
            #[inline(always)]
            fn from(val: u8) -> If38 {
                If38::from_bits(val)
            }
        }
        impl From<If38> for u8 {
            #[inline(always)]
            fn from(val: If38) -> u8 {
                If38::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If39 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If39 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If39 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If39 {
            #[inline(always)]
            fn from(val: u8) -> If39 {
                If39::from_bits(val)
            }
        }
        impl From<If39> for u8 {
            #[inline(always)]
            fn from(val: If39) -> u8 {
                If39::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If4 {
            #[inline(always)]
            fn from(val: u8) -> If4 {
                If4::from_bits(val)
            }
        }
        impl From<If4> for u8 {
            #[inline(always)]
            fn from(val: If4) -> u8 {
                If4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If40 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If40 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If40 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If40 {
            #[inline(always)]
            fn from(val: u8) -> If40 {
                If40::from_bits(val)
            }
        }
        impl From<If40> for u8 {
            #[inline(always)]
            fn from(val: If40) -> u8 {
                If40::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If41 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If41 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If41 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If41 {
            #[inline(always)]
            fn from(val: u8) -> If41 {
                If41::from_bits(val)
            }
        }
        impl From<If41> for u8 {
            #[inline(always)]
            fn from(val: If41) -> u8 {
                If41::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If5 {
            #[inline(always)]
            fn from(val: u8) -> If5 {
                If5::from_bits(val)
            }
        }
        impl From<If5> for u8 {
            #[inline(always)]
            fn from(val: If5) -> u8 {
                If5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If6 {
            #[inline(always)]
            fn from(val: u8) -> If6 {
                If6::from_bits(val)
            }
        }
        impl From<If6> for u8 {
            #[inline(always)]
            fn from(val: If6) -> u8 {
                If6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum If7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl If7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> If7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for If7 {
            #[inline(always)]
            fn from(val: u8) -> If7 {
                If7::from_bits(val)
            }
        }
        impl From<If7> for u8 {
            #[inline(always)]
            fn from(val: If7) -> u8 {
                If7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iica0ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iica0ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iica0ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iica0ed {
            #[inline(always)]
            fn from(val: u8) -> Iica0ed {
                Iica0ed::from_bits(val)
            }
        }
        impl From<Iica0ed> for u8 {
            #[inline(always)]
            fn from(val: Iica0ed) -> u8 {
                Iica0ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irq0ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irq0ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irq0ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irq0ed {
            #[inline(always)]
            fn from(val: u8) -> Irq0ed {
                Irq0ed::from_bits(val)
            }
        }
        impl From<Irq0ed> for u8 {
            #[inline(always)]
            fn from(val: Irq0ed) -> u8 {
                Irq0ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irq1ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irq1ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irq1ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irq1ed {
            #[inline(always)]
            fn from(val: u8) -> Irq1ed {
                Irq1ed::from_bits(val)
            }
        }
        impl From<Irq1ed> for u8 {
            #[inline(always)]
            fn from(val: Irq1ed) -> u8 {
                Irq1ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irq2ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irq2ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irq2ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irq2ed {
            #[inline(always)]
            fn from(val: u8) -> Irq2ed {
                Irq2ed::from_bits(val)
            }
        }
        impl From<Irq2ed> for u8 {
            #[inline(always)]
            fn from(val: Irq2ed) -> u8 {
                Irq2ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irq3ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irq3ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irq3ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irq3ed {
            #[inline(always)]
            fn from(val: u8) -> Irq3ed {
                Irq3ed::from_bits(val)
            }
        }
        impl From<Irq3ed> for u8 {
            #[inline(always)]
            fn from(val: Irq3ed) -> u8 {
                Irq3ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irq4ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irq4ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irq4ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irq4ed {
            #[inline(always)]
            fn from(val: u8) -> Irq4ed {
                Irq4ed::from_bits(val)
            }
        }
        impl From<Irq4ed> for u8 {
            #[inline(always)]
            fn from(val: Irq4ed) -> u8 {
                Irq4ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irq5ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irq5ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irq5ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irq5ed {
            #[inline(always)]
            fn from(val: u8) -> Irq5ed {
                Irq5ed::from_bits(val)
            }
        }
        impl From<Irq5ed> for u8 {
            #[inline(always)]
            fn from(val: Irq5ed) -> u8 {
                Irq5ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Irqmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqmd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqmd {
            #[inline(always)]
            fn from(val: u8) -> Irqmd {
                Irqmd::from_bits(val)
            }
        }
        impl From<Irqmd> for u8 {
            #[inline(always)]
            fn from(val: Irqmd) -> u8 {
                Irqmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Itled {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Itled {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Itled {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Itled {
            #[inline(always)]
            fn from(val: u8) -> Itled {
                Itled::from_bits(val)
            }
        }
        impl From<Itled> for u8 {
            #[inline(always)]
            fn from(val: Itled) -> u8 {
                Itled::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtclr {
            #[inline(always)]
            fn from(val: u8) -> Iwdtclr {
                Iwdtclr::from_bits(val)
            }
        }
        impl From<Iwdtclr> for u8 {
            #[inline(always)]
            fn from(val: Iwdtclr) -> u8 {
                Iwdtclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdted {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdted {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdted {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdted {
            #[inline(always)]
            fn from(val: u8) -> Iwdted {
                Iwdted::from_bits(val)
            }
        }
        impl From<Iwdted> for u8 {
            #[inline(always)]
            fn from(val: Iwdted) -> u8 {
                Iwdted::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdten {
            #[inline(always)]
            fn from(val: u8) -> Iwdten {
                Iwdten::from_bits(val)
            }
        }
        impl From<Iwdten> for u8 {
            #[inline(always)]
            fn from(val: Iwdten) -> u8 {
                Iwdten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtst {
            #[inline(always)]
            fn from(val: u8) -> Iwdtst {
                Iwdtst::from_bits(val)
            }
        }
        impl From<Iwdtst> for u8 {
            #[inline(always)]
            fn from(val: Iwdtst) -> u8 {
                Iwdtst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1clr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1clr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1clr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1clr {
            #[inline(always)]
            fn from(val: u8) -> Lvd1clr {
                Lvd1clr::from_bits(val)
            }
        }
        impl From<Lvd1clr> for u8 {
            #[inline(always)]
            fn from(val: Lvd1clr) -> u8 {
                Lvd1clr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1ed {
            #[inline(always)]
            fn from(val: u8) -> Lvd1ed {
                Lvd1ed::from_bits(val)
            }
        }
        impl From<Lvd1ed> for u8 {
            #[inline(always)]
            fn from(val: Lvd1ed) -> u8 {
                Lvd1ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1en {
            #[inline(always)]
            fn from(val: u8) -> Lvd1en {
                Lvd1en::from_bits(val)
            }
        }
        impl From<Lvd1en> for u8 {
            #[inline(always)]
            fn from(val: Lvd1en) -> u8 {
                Lvd1en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1st {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1st {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1st {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1st {
            #[inline(always)]
            fn from(val: u8) -> Lvd1st {
                Lvd1st::from_bits(val)
            }
        }
        impl From<Lvd1st> for u8 {
            #[inline(always)]
            fn from(val: Lvd1st) -> u8 {
                Lvd1st::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmiclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmiclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmiclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmiclr {
            #[inline(always)]
            fn from(val: u8) -> Nmiclr {
                Nmiclr::from_bits(val)
            }
        }
        impl From<Nmiclr> for u8 {
            #[inline(always)]
            fn from(val: Nmiclr) -> u8 {
                Nmiclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmien {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmien {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmien {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmien {
            #[inline(always)]
            fn from(val: u8) -> Nmien {
                Nmien::from_bits(val)
            }
        }
        impl From<Nmien> for u8 {
            #[inline(always)]
            fn from(val: Nmien) -> u8 {
                Nmien::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmimd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmimd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmimd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmimd {
            #[inline(always)]
            fn from(val: u8) -> Nmimd {
                Nmimd::from_bits(val)
            }
        }
        impl From<Nmimd> for u8 {
            #[inline(always)]
            fn from(val: Nmimd) -> u8 {
                Nmimd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmist {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmist {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmist {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmist {
            #[inline(always)]
            fn from(val: u8) -> Nmist {
                Nmist::from_bits(val)
            }
        }
        impl From<Nmist> for u8 {
            #[inline(always)]
            fn from(val: Nmist) -> u8 {
                Nmist::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpeclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpeclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpeclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpeclr {
            #[inline(always)]
            fn from(val: u8) -> Rpeclr {
                Rpeclr::from_bits(val)
            }
        }
        impl From<Rpeclr> for u8 {
            #[inline(always)]
            fn from(val: Rpeclr) -> u8 {
                Rpeclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpeen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpeen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpeen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpeen {
            #[inline(always)]
            fn from(val: u8) -> Rpeen {
                Rpeen::from_bits(val)
            }
        }
        impl From<Rpeen> for u8 {
            #[inline(always)]
            fn from(val: Rpeen) -> u8 {
                Rpeen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpest {
            #[inline(always)]
            fn from(val: u8) -> Rpest {
                Rpest::from_bits(val)
            }
        }
        impl From<Rpest> for u8 {
            #[inline(always)]
            fn from(val: Rpest) -> u8 {
                Rpest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtced {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtced {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtced {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtced {
            #[inline(always)]
            fn from(val: u8) -> Rtced {
                Rtced::from_bits(val)
            }
        }
        impl From<Rtced> for u8 {
            #[inline(always)]
            fn from(val: Rtced) -> u8 {
                Rtced::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set1 {
            #[inline(always)]
            fn from(val: u8) -> Set1 {
                Set1::from_bits(val)
            }
        }
        impl From<Set1> for u8 {
            #[inline(always)]
            fn from(val: Set1) -> u8 {
                Set1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set12 {
            #[inline(always)]
            fn from(val: u8) -> Set12 {
                Set12::from_bits(val)
            }
        }
        impl From<Set12> for u8 {
            #[inline(always)]
            fn from(val: Set12) -> u8 {
                Set12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set13 {
            #[inline(always)]
            fn from(val: u8) -> Set13 {
                Set13::from_bits(val)
            }
        }
        impl From<Set13> for u8 {
            #[inline(always)]
            fn from(val: Set13) -> u8 {
                Set13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set15 {
            #[inline(always)]
            fn from(val: u8) -> Set15 {
                Set15::from_bits(val)
            }
        }
        impl From<Set15> for u8 {
            #[inline(always)]
            fn from(val: Set15) -> u8 {
                Set15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set16 {
            #[inline(always)]
            fn from(val: u8) -> Set16 {
                Set16::from_bits(val)
            }
        }
        impl From<Set16> for u8 {
            #[inline(always)]
            fn from(val: Set16) -> u8 {
                Set16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set18 {
            #[inline(always)]
            fn from(val: u8) -> Set18 {
                Set18::from_bits(val)
            }
        }
        impl From<Set18> for u8 {
            #[inline(always)]
            fn from(val: Set18) -> u8 {
                Set18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set19 {
            #[inline(always)]
            fn from(val: u8) -> Set19 {
                Set19::from_bits(val)
            }
        }
        impl From<Set19> for u8 {
            #[inline(always)]
            fn from(val: Set19) -> u8 {
                Set19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set2 {
            #[inline(always)]
            fn from(val: u8) -> Set2 {
                Set2::from_bits(val)
            }
        }
        impl From<Set2> for u8 {
            #[inline(always)]
            fn from(val: Set2) -> u8 {
                Set2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set22 {
            #[inline(always)]
            fn from(val: u8) -> Set22 {
                Set22::from_bits(val)
            }
        }
        impl From<Set22> for u8 {
            #[inline(always)]
            fn from(val: Set22) -> u8 {
                Set22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set23 {
            #[inline(always)]
            fn from(val: u8) -> Set23 {
                Set23::from_bits(val)
            }
        }
        impl From<Set23> for u8 {
            #[inline(always)]
            fn from(val: Set23) -> u8 {
                Set23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set27 {
            #[inline(always)]
            fn from(val: u8) -> Set27 {
                Set27::from_bits(val)
            }
        }
        impl From<Set27> for u8 {
            #[inline(always)]
            fn from(val: Set27) -> u8 {
                Set27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set28 {
            #[inline(always)]
            fn from(val: u8) -> Set28 {
                Set28::from_bits(val)
            }
        }
        impl From<Set28> for u8 {
            #[inline(always)]
            fn from(val: Set28) -> u8 {
                Set28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set29 {
            #[inline(always)]
            fn from(val: u8) -> Set29 {
                Set29::from_bits(val)
            }
        }
        impl From<Set29> for u8 {
            #[inline(always)]
            fn from(val: Set29) -> u8 {
                Set29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set3 {
            #[inline(always)]
            fn from(val: u8) -> Set3 {
                Set3::from_bits(val)
            }
        }
        impl From<Set3> for u8 {
            #[inline(always)]
            fn from(val: Set3) -> u8 {
                Set3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set30 {
            #[inline(always)]
            fn from(val: u8) -> Set30 {
                Set30::from_bits(val)
            }
        }
        impl From<Set30> for u8 {
            #[inline(always)]
            fn from(val: Set30) -> u8 {
                Set30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set31 {
            #[inline(always)]
            fn from(val: u8) -> Set31 {
                Set31::from_bits(val)
            }
        }
        impl From<Set31> for u8 {
            #[inline(always)]
            fn from(val: Set31) -> u8 {
                Set31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set32 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set32 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set32 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set32 {
            #[inline(always)]
            fn from(val: u8) -> Set32 {
                Set32::from_bits(val)
            }
        }
        impl From<Set32> for u8 {
            #[inline(always)]
            fn from(val: Set32) -> u8 {
                Set32::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set33 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set33 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set33 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set33 {
            #[inline(always)]
            fn from(val: u8) -> Set33 {
                Set33::from_bits(val)
            }
        }
        impl From<Set33> for u8 {
            #[inline(always)]
            fn from(val: Set33) -> u8 {
                Set33::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set34 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set34 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set34 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set34 {
            #[inline(always)]
            fn from(val: u8) -> Set34 {
                Set34::from_bits(val)
            }
        }
        impl From<Set34> for u8 {
            #[inline(always)]
            fn from(val: Set34) -> u8 {
                Set34::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set35 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set35 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set35 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set35 {
            #[inline(always)]
            fn from(val: u8) -> Set35 {
                Set35::from_bits(val)
            }
        }
        impl From<Set35> for u8 {
            #[inline(always)]
            fn from(val: Set35) -> u8 {
                Set35::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set36 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set36 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set36 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set36 {
            #[inline(always)]
            fn from(val: u8) -> Set36 {
                Set36::from_bits(val)
            }
        }
        impl From<Set36> for u8 {
            #[inline(always)]
            fn from(val: Set36) -> u8 {
                Set36::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set37 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set37 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set37 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set37 {
            #[inline(always)]
            fn from(val: u8) -> Set37 {
                Set37::from_bits(val)
            }
        }
        impl From<Set37> for u8 {
            #[inline(always)]
            fn from(val: Set37) -> u8 {
                Set37::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set38 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set38 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set38 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set38 {
            #[inline(always)]
            fn from(val: u8) -> Set38 {
                Set38::from_bits(val)
            }
        }
        impl From<Set38> for u8 {
            #[inline(always)]
            fn from(val: Set38) -> u8 {
                Set38::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set4 {
            #[inline(always)]
            fn from(val: u8) -> Set4 {
                Set4::from_bits(val)
            }
        }
        impl From<Set4> for u8 {
            #[inline(always)]
            fn from(val: Set4) -> u8 {
                Set4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set40 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set40 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set40 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set40 {
            #[inline(always)]
            fn from(val: u8) -> Set40 {
                Set40::from_bits(val)
            }
        }
        impl From<Set40> for u8 {
            #[inline(always)]
            fn from(val: Set40) -> u8 {
                Set40::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set41 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set41 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set41 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set41 {
            #[inline(always)]
            fn from(val: u8) -> Set41 {
                Set41::from_bits(val)
            }
        }
        impl From<Set41> for u8 {
            #[inline(always)]
            fn from(val: Set41) -> u8 {
                Set41::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set5 {
            #[inline(always)]
            fn from(val: u8) -> Set5 {
                Set5::from_bits(val)
            }
        }
        impl From<Set5> for u8 {
            #[inline(always)]
            fn from(val: Set5) -> u8 {
                Set5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set6 {
            #[inline(always)]
            fn from(val: u8) -> Set6 {
                Set6::from_bits(val)
            }
        }
        impl From<Set6> for u8 {
            #[inline(always)]
            fn from(val: Set6) -> u8 {
                Set6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Set7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set7 {
            #[inline(always)]
            fn from(val: u8) -> Set7 {
                Set7::from_bits(val)
            }
        }
        impl From<Set7> for u8 {
            #[inline(always)]
            fn from(val: Set7) -> u8 {
                Set7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spi00rxed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spi00rxed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spi00rxed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spi00rxed {
            #[inline(always)]
            fn from(val: u8) -> Spi00rxed {
                Spi00rxed::from_bits(val)
            }
        }
        impl From<Spi00rxed> for u8 {
            #[inline(always)]
            fn from(val: Spi00rxed) -> u8 {
                Spi00rxed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St1 {
            #[inline(always)]
            fn from(val: u8) -> St1 {
                St1::from_bits(val)
            }
        }
        impl From<St1> for u8 {
            #[inline(always)]
            fn from(val: St1) -> u8 {
                St1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St12 {
            #[inline(always)]
            fn from(val: u8) -> St12 {
                St12::from_bits(val)
            }
        }
        impl From<St12> for u8 {
            #[inline(always)]
            fn from(val: St12) -> u8 {
                St12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St13 {
            #[inline(always)]
            fn from(val: u8) -> St13 {
                St13::from_bits(val)
            }
        }
        impl From<St13> for u8 {
            #[inline(always)]
            fn from(val: St13) -> u8 {
                St13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St15 {
            #[inline(always)]
            fn from(val: u8) -> St15 {
                St15::from_bits(val)
            }
        }
        impl From<St15> for u8 {
            #[inline(always)]
            fn from(val: St15) -> u8 {
                St15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St16 {
            #[inline(always)]
            fn from(val: u8) -> St16 {
                St16::from_bits(val)
            }
        }
        impl From<St16> for u8 {
            #[inline(always)]
            fn from(val: St16) -> u8 {
                St16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St18 {
            #[inline(always)]
            fn from(val: u8) -> St18 {
                St18::from_bits(val)
            }
        }
        impl From<St18> for u8 {
            #[inline(always)]
            fn from(val: St18) -> u8 {
                St18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St19 {
            #[inline(always)]
            fn from(val: u8) -> St19 {
                St19::from_bits(val)
            }
        }
        impl From<St19> for u8 {
            #[inline(always)]
            fn from(val: St19) -> u8 {
                St19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St2 {
            #[inline(always)]
            fn from(val: u8) -> St2 {
                St2::from_bits(val)
            }
        }
        impl From<St2> for u8 {
            #[inline(always)]
            fn from(val: St2) -> u8 {
                St2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St22 {
            #[inline(always)]
            fn from(val: u8) -> St22 {
                St22::from_bits(val)
            }
        }
        impl From<St22> for u8 {
            #[inline(always)]
            fn from(val: St22) -> u8 {
                St22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St23 {
            #[inline(always)]
            fn from(val: u8) -> St23 {
                St23::from_bits(val)
            }
        }
        impl From<St23> for u8 {
            #[inline(always)]
            fn from(val: St23) -> u8 {
                St23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St27 {
            #[inline(always)]
            fn from(val: u8) -> St27 {
                St27::from_bits(val)
            }
        }
        impl From<St27> for u8 {
            #[inline(always)]
            fn from(val: St27) -> u8 {
                St27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St28 {
            #[inline(always)]
            fn from(val: u8) -> St28 {
                St28::from_bits(val)
            }
        }
        impl From<St28> for u8 {
            #[inline(always)]
            fn from(val: St28) -> u8 {
                St28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St29 {
            #[inline(always)]
            fn from(val: u8) -> St29 {
                St29::from_bits(val)
            }
        }
        impl From<St29> for u8 {
            #[inline(always)]
            fn from(val: St29) -> u8 {
                St29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St3 {
            #[inline(always)]
            fn from(val: u8) -> St3 {
                St3::from_bits(val)
            }
        }
        impl From<St3> for u8 {
            #[inline(always)]
            fn from(val: St3) -> u8 {
                St3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St30 {
            #[inline(always)]
            fn from(val: u8) -> St30 {
                St30::from_bits(val)
            }
        }
        impl From<St30> for u8 {
            #[inline(always)]
            fn from(val: St30) -> u8 {
                St30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St31 {
            #[inline(always)]
            fn from(val: u8) -> St31 {
                St31::from_bits(val)
            }
        }
        impl From<St31> for u8 {
            #[inline(always)]
            fn from(val: St31) -> u8 {
                St31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St32 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St32 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St32 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St32 {
            #[inline(always)]
            fn from(val: u8) -> St32 {
                St32::from_bits(val)
            }
        }
        impl From<St32> for u8 {
            #[inline(always)]
            fn from(val: St32) -> u8 {
                St32::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St33 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St33 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St33 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St33 {
            #[inline(always)]
            fn from(val: u8) -> St33 {
                St33::from_bits(val)
            }
        }
        impl From<St33> for u8 {
            #[inline(always)]
            fn from(val: St33) -> u8 {
                St33::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St34 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St34 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St34 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St34 {
            #[inline(always)]
            fn from(val: u8) -> St34 {
                St34::from_bits(val)
            }
        }
        impl From<St34> for u8 {
            #[inline(always)]
            fn from(val: St34) -> u8 {
                St34::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St35 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St35 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St35 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St35 {
            #[inline(always)]
            fn from(val: u8) -> St35 {
                St35::from_bits(val)
            }
        }
        impl From<St35> for u8 {
            #[inline(always)]
            fn from(val: St35) -> u8 {
                St35::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St36 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St36 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St36 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St36 {
            #[inline(always)]
            fn from(val: u8) -> St36 {
                St36::from_bits(val)
            }
        }
        impl From<St36> for u8 {
            #[inline(always)]
            fn from(val: St36) -> u8 {
                St36::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St37 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St37 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St37 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St37 {
            #[inline(always)]
            fn from(val: u8) -> St37 {
                St37::from_bits(val)
            }
        }
        impl From<St37> for u8 {
            #[inline(always)]
            fn from(val: St37) -> u8 {
                St37::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St38 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St38 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St38 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St38 {
            #[inline(always)]
            fn from(val: u8) -> St38 {
                St38::from_bits(val)
            }
        }
        impl From<St38> for u8 {
            #[inline(always)]
            fn from(val: St38) -> u8 {
                St38::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St4 {
            #[inline(always)]
            fn from(val: u8) -> St4 {
                St4::from_bits(val)
            }
        }
        impl From<St4> for u8 {
            #[inline(always)]
            fn from(val: St4) -> u8 {
                St4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St40 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St40 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St40 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St40 {
            #[inline(always)]
            fn from(val: u8) -> St40 {
                St40::from_bits(val)
            }
        }
        impl From<St40> for u8 {
            #[inline(always)]
            fn from(val: St40) -> u8 {
                St40::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St41 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St41 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St41 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St41 {
            #[inline(always)]
            fn from(val: u8) -> St41 {
                St41::from_bits(val)
            }
        }
        impl From<St41> for u8 {
            #[inline(always)]
            fn from(val: St41) -> u8 {
                St41::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St5 {
            #[inline(always)]
            fn from(val: u8) -> St5 {
                St5::from_bits(val)
            }
        }
        impl From<St5> for u8 {
            #[inline(always)]
            fn from(val: St5) -> u8 {
                St5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St6 {
            #[inline(always)]
            fn from(val: u8) -> St6 {
                St6::from_bits(val)
            }
        }
        impl From<St6> for u8 {
            #[inline(always)]
            fn from(val: St6) -> u8 {
                St6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St7 {
            #[inline(always)]
            fn from(val: u8) -> St7 {
                St7::from_bits(val)
            }
        }
        impl From<St7> for u8 {
            #[inline(always)]
            fn from(val: St7) -> u8 {
                St7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uart0erred {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uart0erred {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uart0erred {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uart0erred {
            #[inline(always)]
            fn from(val: u8) -> Uart0erred {
                Uart0erred::from_bits(val)
            }
        }
        impl From<Uart0erred> for u8 {
            #[inline(always)]
            fn from(val: Uart0erred) -> u8 {
                Uart0erred::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uart0rxed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uart0rxed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uart0rxed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uart0rxed {
            #[inline(always)]
            fn from(val: u8) -> Uart0rxed {
                Uart0rxed::from_bits(val)
            }
        }
        impl From<Uart0rxed> for u8 {
            #[inline(always)]
            fn from(val: Uart0rxed) -> u8 {
                Uart0rxed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ur0ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ur0ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ur0ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ur0ed {
            #[inline(always)]
            fn from(val: u8) -> Ur0ed {
                Ur0ed::from_bits(val)
            }
        }
        impl From<Ur0ed> for u8 {
            #[inline(always)]
            fn from(val: Ur0ed) -> u8 {
                Ur0ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ure0ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ure0ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ure0ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ure0ed {
            #[inline(always)]
            fn from(val: u8) -> Ure0ed {
                Ure0ed::from_bits(val)
            }
        }
        impl From<Ure0ed> for u8 {
            #[inline(always)]
            fn from(val: Ure0ed) -> u8 {
                Ure0ed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ut0ed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ut0ed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ut0ed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ut0ed {
            #[inline(always)]
            fn from(val: u8) -> Ut0ed {
                Ut0ed::from_bits(val)
            }
        }
        impl From<Ut0ed> for u8 {
            #[inline(always)]
            fn from(val: Ut0ed) -> u8 {
                Ut0ed::to_bits(val)
            }
        }
    }
}
pub mod iica {
    #[doc = "Serial Interface IICA"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iica {
        ptr: *mut u8,
    }
    unsafe impl Send for Iica {}
    unsafe impl Sync for Iica {}
    impl Iica {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IICA Shift Register 0"]
        #[inline(always)]
        pub const fn iica0(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "IICA Status Register 0"]
        #[inline(always)]
        pub const fn iics0(self) -> crate::common::Reg<regs::Iics0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "IICA Flag Register 0"]
        #[inline(always)]
        pub const fn iicf0(self) -> crate::common::Reg<regs::Iicf0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "IICA Control Register 00"]
        #[inline(always)]
        pub const fn iicctl00(self) -> crate::common::Reg<regs::Iicctl00, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "IICA Control Register 01"]
        #[inline(always)]
        pub const fn iicctl01(self) -> crate::common::Reg<regs::Iicctl01, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0101usize) as _) }
        }
        #[doc = "IICA Low,level Width Setting Register 0"]
        #[inline(always)]
        pub const fn iicwl0(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize) as _) }
        }
        #[doc = "IICA High,level Width Setting Register 0"]
        #[inline(always)]
        pub const fn iicwh0(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0103usize) as _) }
        }
        #[doc = "Slave Address Register 0"]
        #[inline(always)]
        pub const fn sva0(self) -> crate::common::Reg<regs::Sva0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "IICA Control Register 00"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iicctl00(pub u8);
        impl Iicctl00 {
            #[doc = "Stop Condition Trigger"]
            #[inline(always)]
            pub const fn spt(&self) -> super::vals::Spt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Spt::from_bits(val as u8)
            }
            #[doc = "Stop Condition Trigger"]
            #[inline(always)]
            pub fn set_spt(&mut self, val: super::vals::Spt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Start Condition Trigger"]
            #[inline(always)]
            pub const fn stt(&self) -> super::vals::Stt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Stt::from_bits(val as u8)
            }
            #[doc = "Start Condition Trigger"]
            #[inline(always)]
            pub fn set_stt(&mut self, val: super::vals::Stt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Acknowledgment Control"]
            #[inline(always)]
            pub const fn acke(&self) -> super::vals::Acke {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Acke::from_bits(val as u8)
            }
            #[doc = "Acknowledgment Control"]
            #[inline(always)]
            pub fn set_acke(&mut self, val: super::vals::Acke) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Control of Clock Stretching and Interrupt Request Generation"]
            #[inline(always)]
            pub const fn wtim(&self) -> super::vals::Wtim {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Wtim::from_bits(val as u8)
            }
            #[doc = "Control of Clock Stretching and Interrupt Request Generation"]
            #[inline(always)]
            pub fn set_wtim(&mut self, val: super::vals::Wtim) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Enable and Disable Generation of Interrupt Request when Stop Condition is Detected"]
            #[inline(always)]
            pub const fn spie(&self) -> super::vals::Spie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Spie::from_bits(val as u8)
            }
            #[doc = "Enable and Disable Generation of Interrupt Request when Stop Condition is Detected"]
            #[inline(always)]
            pub fn set_spie(&mut self, val: super::vals::Spie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Release from the Clock Stretch State"]
            #[inline(always)]
            pub const fn wrel(&self) -> super::vals::Wrel {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Wrel::from_bits(val as u8)
            }
            #[doc = "Release from the Clock Stretch State"]
            #[inline(always)]
            pub fn set_wrel(&mut self, val: super::vals::Wrel) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Exit from Communications"]
            #[inline(always)]
            pub const fn lrel(&self) -> super::vals::Lrel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lrel::from_bits(val as u8)
            }
            #[doc = "Exit from Communications"]
            #[inline(always)]
            pub fn set_lrel(&mut self, val: super::vals::Lrel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "I2C Operation Enable"]
            #[inline(always)]
            pub const fn iice(&self) -> super::vals::Iice {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Iice::from_bits(val as u8)
            }
            #[doc = "I2C Operation Enable"]
            #[inline(always)]
            pub fn set_iice(&mut self, val: super::vals::Iice) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iicctl00 {
            #[inline(always)]
            fn default() -> Iicctl00 {
                Iicctl00(0)
            }
        }
        impl core::fmt::Debug for Iicctl00 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iicctl00")
                    .field("spt", &self.spt())
                    .field("stt", &self.stt())
                    .field("acke", &self.acke())
                    .field("wtim", &self.wtim())
                    .field("spie", &self.spie())
                    .field("wrel", &self.wrel())
                    .field("lrel", &self.lrel())
                    .field("iice", &self.iice())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iicctl00 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Iicctl00 {{ spt: {:?}, stt: {:?}, acke: {:?}, wtim: {:?}, spie: {:?}, wrel: {:?}, lrel: {:?}, iice: {:?} }}" , self . spt () , self . stt () , self . acke () , self . wtim () , self . spie () , self . wrel () , self . lrel () , self . iice ())
            }
        }
        #[doc = "IICA Control Register 01"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iicctl01(pub u8);
        impl Iicctl01 {
            #[doc = "IICA Operation Clock (fMCK)"]
            #[inline(always)]
            pub const fn prs(&self) -> super::vals::Prs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Prs::from_bits(val as u8)
            }
            #[doc = "IICA Operation Clock (fMCK)"]
            #[inline(always)]
            pub fn set_prs(&mut self, val: super::vals::Prs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Digital Filter Operation Control"]
            #[inline(always)]
            pub const fn dfc(&self) -> super::vals::Dfc {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dfc::from_bits(val as u8)
            }
            #[doc = "Digital Filter Operation Control"]
            #[inline(always)]
            pub fn set_dfc(&mut self, val: super::vals::Dfc) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Operation Mode Switching"]
            #[inline(always)]
            pub const fn smc(&self) -> super::vals::Smc {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smc::from_bits(val as u8)
            }
            #[doc = "Operation Mode Switching"]
            #[inline(always)]
            pub fn set_smc(&mut self, val: super::vals::Smc) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Detection of SDAA0 Pin Level (Valid Only when IICCTL00.IICE = 1)"]
            #[inline(always)]
            pub const fn dad(&self) -> super::vals::Dad {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dad::from_bits(val as u8)
            }
            #[doc = "Detection of SDAA0 Pin Level (Valid Only when IICCTL00.IICE = 1)"]
            #[inline(always)]
            pub fn set_dad(&mut self, val: super::vals::Dad) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Detection of SCLA0 Pin Level (Valid Only when IICCTL00.IICE = 1)"]
            #[inline(always)]
            pub const fn cld(&self) -> super::vals::Cld {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cld::from_bits(val as u8)
            }
            #[doc = "Detection of SCLA0 Pin Level (Valid Only when IICCTL00.IICE = 1)"]
            #[inline(always)]
            pub fn set_cld(&mut self, val: super::vals::Cld) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Address Match Disabling Flag"]
            #[inline(always)]
            pub const fn svadis(&self) -> super::vals::Svadis {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Svadis::from_bits(val as u8)
            }
            #[doc = "Address Match Disabling Flag"]
            #[inline(always)]
            pub fn set_svadis(&mut self, val: super::vals::Svadis) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Control of Address Match Wakeup"]
            #[inline(always)]
            pub const fn wup(&self) -> super::vals::Wup {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wup::from_bits(val as u8)
            }
            #[doc = "Control of Address Match Wakeup"]
            #[inline(always)]
            pub fn set_wup(&mut self, val: super::vals::Wup) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iicctl01 {
            #[inline(always)]
            fn default() -> Iicctl01 {
                Iicctl01(0)
            }
        }
        impl core::fmt::Debug for Iicctl01 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iicctl01")
                    .field("prs", &self.prs())
                    .field("dfc", &self.dfc())
                    .field("smc", &self.smc())
                    .field("dad", &self.dad())
                    .field("cld", &self.cld())
                    .field("svadis", &self.svadis())
                    .field("wup", &self.wup())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iicctl01 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Iicctl01 {{ prs: {:?}, dfc: {:?}, smc: {:?}, dad: {:?}, cld: {:?}, svadis: {:?}, wup: {:?} }}" , self . prs () , self . dfc () , self . smc () , self . dad () , self . cld () , self . svadis () , self . wup ())
            }
        }
        #[doc = "IICA Flag Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iicf0(pub u8);
        impl Iicf0 {
            #[doc = "Communication Reservation Function Disable Bit"]
            #[inline(always)]
            pub const fn iicrsv(&self) -> super::vals::Iicrsv {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicrsv::from_bits(val as u8)
            }
            #[doc = "Communication Reservation Function Disable Bit"]
            #[inline(always)]
            pub fn set_iicrsv(&mut self, val: super::vals::Iicrsv) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Initial Start Enable Trigger"]
            #[inline(always)]
            pub const fn stcen(&self) -> super::vals::Stcen {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Stcen::from_bits(val as u8)
            }
            #[doc = "Initial Start Enable Trigger"]
            #[inline(always)]
            pub fn set_stcen(&mut self, val: super::vals::Stcen) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "I2C Bus Status Flag"]
            #[inline(always)]
            pub const fn iicbsy(&self) -> super::vals::Iicbsy {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Iicbsy::from_bits(val as u8)
            }
            #[doc = "I2C Bus Status Flag"]
            #[inline(always)]
            pub fn set_iicbsy(&mut self, val: super::vals::Iicbsy) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "IICCTL00.STT Clear Flag"]
            #[inline(always)]
            pub const fn stcf(&self) -> super::vals::Stcf {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Stcf::from_bits(val as u8)
            }
            #[doc = "IICCTL00.STT Clear Flag"]
            #[inline(always)]
            pub fn set_stcf(&mut self, val: super::vals::Stcf) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iicf0 {
            #[inline(always)]
            fn default() -> Iicf0 {
                Iicf0(0)
            }
        }
        impl core::fmt::Debug for Iicf0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iicf0")
                    .field("iicrsv", &self.iicrsv())
                    .field("stcen", &self.stcen())
                    .field("iicbsy", &self.iicbsy())
                    .field("stcf", &self.stcf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iicf0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Iicf0 {{ iicrsv: {:?}, stcen: {:?}, iicbsy: {:?}, stcf: {:?} }}",
                    self.iicrsv(),
                    self.stcen(),
                    self.iicbsy(),
                    self.stcf()
                )
            }
        }
        #[doc = "IICA Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iics0(pub u8);
        impl Iics0 {
            #[doc = "Detection of Stop Condition"]
            #[inline(always)]
            pub const fn spd(&self) -> super::vals::Spd {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Spd::from_bits(val as u8)
            }
            #[doc = "Detection of Stop Condition"]
            #[inline(always)]
            pub fn set_spd(&mut self, val: super::vals::Spd) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Detection of Start Condition"]
            #[inline(always)]
            pub const fn std(&self) -> super::vals::Std {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Std::from_bits(val as u8)
            }
            #[doc = "Detection of Start Condition"]
            #[inline(always)]
            pub fn set_std(&mut self, val: super::vals::Std) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Detection of Acknowledge (ACK)"]
            #[inline(always)]
            pub const fn ackd(&self) -> super::vals::Ackd {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ackd::from_bits(val as u8)
            }
            #[doc = "Detection of Acknowledge (ACK)"]
            #[inline(always)]
            pub fn set_ackd(&mut self, val: super::vals::Ackd) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Detection of Transmit and Receive Status"]
            #[inline(always)]
            pub const fn trc(&self) -> super::vals::Trc {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Trc::from_bits(val as u8)
            }
            #[doc = "Detection of Transmit and Receive Status"]
            #[inline(always)]
            pub fn set_trc(&mut self, val: super::vals::Trc) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Detection of Matching Addresses"]
            #[inline(always)]
            pub const fn coi(&self) -> super::vals::Coi {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Coi::from_bits(val as u8)
            }
            #[doc = "Detection of Matching Addresses"]
            #[inline(always)]
            pub fn set_coi(&mut self, val: super::vals::Coi) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Detection of Extension Code Reception"]
            #[inline(always)]
            pub const fn exc(&self) -> super::vals::Exc {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Exc::from_bits(val as u8)
            }
            #[doc = "Detection of Extension Code Reception"]
            #[inline(always)]
            pub fn set_exc(&mut self, val: super::vals::Exc) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Detection of Arbitration Loss"]
            #[inline(always)]
            pub const fn ald(&self) -> super::vals::Ald {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ald::from_bits(val as u8)
            }
            #[doc = "Detection of Arbitration Loss"]
            #[inline(always)]
            pub fn set_ald(&mut self, val: super::vals::Ald) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Master Status Check Flag"]
            #[inline(always)]
            pub const fn msts(&self) -> super::vals::Msts {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Msts::from_bits(val as u8)
            }
            #[doc = "Master Status Check Flag"]
            #[inline(always)]
            pub fn set_msts(&mut self, val: super::vals::Msts) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iics0 {
            #[inline(always)]
            fn default() -> Iics0 {
                Iics0(0)
            }
        }
        impl core::fmt::Debug for Iics0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iics0")
                    .field("spd", &self.spd())
                    .field("std", &self.std())
                    .field("ackd", &self.ackd())
                    .field("trc", &self.trc())
                    .field("coi", &self.coi())
                    .field("exc", &self.exc())
                    .field("ald", &self.ald())
                    .field("msts", &self.msts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iics0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Iics0 {{ spd: {:?}, std: {:?}, ackd: {:?}, trc: {:?}, coi: {:?}, exc: {:?}, ald: {:?}, msts: {:?} }}" , self . spd () , self . std () , self . ackd () , self . trc () , self . coi () , self . exc () , self . ald () , self . msts ())
            }
        }
        #[doc = "Slave Address Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sva0(pub u8);
        impl Sva0 {
            #[doc = "7-bit Local Address when in Slave Mode of Unit 0"]
            #[inline(always)]
            pub const fn a(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "7-bit Local Address when in Slave Mode of Unit 0"]
            #[inline(always)]
            pub fn set_a(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Sva0 {
            #[inline(always)]
            fn default() -> Sva0 {
                Sva0(0)
            }
        }
        impl core::fmt::Debug for Sva0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sva0").field("a", &self.a()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sva0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sva0 {{ a: {=u8:?} }}", self.a())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackd {
            #[inline(always)]
            fn from(val: u8) -> Ackd {
                Ackd::from_bits(val)
            }
        }
        impl From<Ackd> for u8 {
            #[inline(always)]
            fn from(val: Ackd) -> u8 {
                Ackd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Acke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Acke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Acke {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Acke {
            #[inline(always)]
            fn from(val: u8) -> Acke {
                Acke::from_bits(val)
            }
        }
        impl From<Acke> for u8 {
            #[inline(always)]
            fn from(val: Acke) -> u8 {
                Acke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ald {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ald {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ald {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ald {
            #[inline(always)]
            fn from(val: u8) -> Ald {
                Ald::from_bits(val)
            }
        }
        impl From<Ald> for u8 {
            #[inline(always)]
            fn from(val: Ald) -> u8 {
                Ald::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cld {
            #[inline(always)]
            fn from(val: u8) -> Cld {
                Cld::from_bits(val)
            }
        }
        impl From<Cld> for u8 {
            #[inline(always)]
            fn from(val: Cld) -> u8 {
                Cld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Coi {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Coi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Coi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Coi {
            #[inline(always)]
            fn from(val: u8) -> Coi {
                Coi::from_bits(val)
            }
        }
        impl From<Coi> for u8 {
            #[inline(always)]
            fn from(val: Coi) -> u8 {
                Coi::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dad {
            #[inline(always)]
            fn from(val: u8) -> Dad {
                Dad::from_bits(val)
            }
        }
        impl From<Dad> for u8 {
            #[inline(always)]
            fn from(val: Dad) -> u8 {
                Dad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfc {
            #[inline(always)]
            fn from(val: u8) -> Dfc {
                Dfc::from_bits(val)
            }
        }
        impl From<Dfc> for u8 {
            #[inline(always)]
            fn from(val: Dfc) -> u8 {
                Dfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Exc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exc {
            #[inline(always)]
            fn from(val: u8) -> Exc {
                Exc::from_bits(val)
            }
        }
        impl From<Exc> for u8 {
            #[inline(always)]
            fn from(val: Exc) -> u8 {
                Exc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicbsy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicbsy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicbsy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicbsy {
            #[inline(always)]
            fn from(val: u8) -> Iicbsy {
                Iicbsy::from_bits(val)
            }
        }
        impl From<Iicbsy> for u8 {
            #[inline(always)]
            fn from(val: Iicbsy) -> u8 {
                Iicbsy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iice {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iice {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iice {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iice {
            #[inline(always)]
            fn from(val: u8) -> Iice {
                Iice::from_bits(val)
            }
        }
        impl From<Iice> for u8 {
            #[inline(always)]
            fn from(val: Iice) -> u8 {
                Iice::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicrsv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicrsv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicrsv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicrsv {
            #[inline(always)]
            fn from(val: u8) -> Iicrsv {
                Iicrsv::from_bits(val)
            }
        }
        impl From<Iicrsv> for u8 {
            #[inline(always)]
            fn from(val: Iicrsv) -> u8 {
                Iicrsv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lrel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lrel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lrel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lrel {
            #[inline(always)]
            fn from(val: u8) -> Lrel {
                Lrel::from_bits(val)
            }
        }
        impl From<Lrel> for u8 {
            #[inline(always)]
            fn from(val: Lrel) -> u8 {
                Lrel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Msts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Msts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Msts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Msts {
            #[inline(always)]
            fn from(val: u8) -> Msts {
                Msts::from_bits(val)
            }
        }
        impl From<Msts> for u8 {
            #[inline(always)]
            fn from(val: Msts) -> u8 {
                Msts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prs {
            #[inline(always)]
            fn from(val: u8) -> Prs {
                Prs::from_bits(val)
            }
        }
        impl From<Prs> for u8 {
            #[inline(always)]
            fn from(val: Prs) -> u8 {
                Prs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smc {
            #[inline(always)]
            fn from(val: u8) -> Smc {
                Smc::from_bits(val)
            }
        }
        impl From<Smc> for u8 {
            #[inline(always)]
            fn from(val: Smc) -> u8 {
                Smc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spd {
            #[inline(always)]
            fn from(val: u8) -> Spd {
                Spd::from_bits(val)
            }
        }
        impl From<Spd> for u8 {
            #[inline(always)]
            fn from(val: Spd) -> u8 {
                Spd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spie {
            #[inline(always)]
            fn from(val: u8) -> Spie {
                Spie::from_bits(val)
            }
        }
        impl From<Spie> for u8 {
            #[inline(always)]
            fn from(val: Spie) -> u8 {
                Spie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spt {
            #[inline(always)]
            fn from(val: u8) -> Spt {
                Spt::from_bits(val)
            }
        }
        impl From<Spt> for u8 {
            #[inline(always)]
            fn from(val: Spt) -> u8 {
                Spt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stcen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stcen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stcen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stcen {
            #[inline(always)]
            fn from(val: u8) -> Stcen {
                Stcen::from_bits(val)
            }
        }
        impl From<Stcen> for u8 {
            #[inline(always)]
            fn from(val: Stcen) -> u8 {
                Stcen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stcf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stcf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stcf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stcf {
            #[inline(always)]
            fn from(val: u8) -> Stcf {
                Stcf::from_bits(val)
            }
        }
        impl From<Stcf> for u8 {
            #[inline(always)]
            fn from(val: Stcf) -> u8 {
                Stcf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Std {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Std {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Std {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Std {
            #[inline(always)]
            fn from(val: u8) -> Std {
                Std::from_bits(val)
            }
        }
        impl From<Std> for u8 {
            #[inline(always)]
            fn from(val: Std) -> u8 {
                Std::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stt {
            #[inline(always)]
            fn from(val: u8) -> Stt {
                Stt::from_bits(val)
            }
        }
        impl From<Stt> for u8 {
            #[inline(always)]
            fn from(val: Stt) -> u8 {
                Stt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Svadis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Svadis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Svadis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Svadis {
            #[inline(always)]
            fn from(val: u8) -> Svadis {
                Svadis::from_bits(val)
            }
        }
        impl From<Svadis> for u8 {
            #[inline(always)]
            fn from(val: Svadis) -> u8 {
                Svadis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trc {
            #[inline(always)]
            fn from(val: u8) -> Trc {
                Trc::from_bits(val)
            }
        }
        impl From<Trc> for u8 {
            #[inline(always)]
            fn from(val: Trc) -> u8 {
                Trc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wrel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wrel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wrel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wrel {
            #[inline(always)]
            fn from(val: u8) -> Wrel {
                Wrel::from_bits(val)
            }
        }
        impl From<Wrel> for u8 {
            #[inline(always)]
            fn from(val: Wrel) -> u8 {
                Wrel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wtim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wtim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wtim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wtim {
            #[inline(always)]
            fn from(val: u8) -> Wtim {
                Wtim::from_bits(val)
            }
        }
        impl From<Wtim> for u8 {
            #[inline(always)]
            fn from(val: Wtim) -> u8 {
                Wtim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wup {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wup {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wup {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wup {
            #[inline(always)]
            fn from(val: u8) -> Wup {
                Wup::from_bits(val)
            }
        }
        impl From<Wup> for u8 {
            #[inline(always)]
            fn from(val: Wup) -> u8 {
                Wup::to_bits(val)
            }
        }
    }
}
pub mod iwdt {
    #[doc = "Independent Watchdog Timer"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iwdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Iwdt {}
    unsafe impl Sync for Iwdt {}
    impl Iwdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IWDT Refresh Register"]
        #[inline(always)]
        pub const fn iwdtrr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "IWDT Status Register"]
        #[inline(always)]
        pub const fn iwdtsr(self) -> crate::common::Reg<regs::Iwdtsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "IWDT Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iwdtsr(pub u16);
        impl Iwdtsr {
            #[doc = "Down,counter Value"]
            #[inline(always)]
            pub const fn cntval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Down,counter Value"]
            #[inline(always)]
            pub fn set_cntval(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u16) & 0x3fff) << 0usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn undff(&self) -> super::vals::Undff {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Undff::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_undff(&mut self, val: super::vals::Undff) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub const fn refef(&self) -> super::vals::Refef {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Refef::from_bits(val as u8)
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub fn set_refef(&mut self, val: super::vals::Refef) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Iwdtsr {
            #[inline(always)]
            fn default() -> Iwdtsr {
                Iwdtsr(0)
            }
        }
        impl core::fmt::Debug for Iwdtsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iwdtsr")
                    .field("cntval", &self.cntval())
                    .field("undff", &self.undff())
                    .field("refef", &self.refef())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iwdtsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Iwdtsr {{ cntval: {=u16:?}, undff: {:?}, refef: {:?} }}",
                    self.cntval(),
                    self.undff(),
                    self.refef()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Refef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refef {
            #[inline(always)]
            fn from(val: u8) -> Refef {
                Refef::from_bits(val)
            }
        }
        impl From<Refef> for u8 {
            #[inline(always)]
            fn from(val: Refef) -> u8 {
                Refef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Undff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Undff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Undff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Undff {
            #[inline(always)]
            fn from(val: u8) -> Undff {
                Undff::from_bits(val)
            }
        }
        impl From<Undff> for u8 {
            #[inline(always)]
            fn from(val: Undff) -> u8 {
                Undff::to_bits(val)
            }
        }
    }
}
pub mod mstp {
    #[doc = "Module Stop Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mstp {
        ptr: *mut u8,
    }
    unsafe impl Send for Mstp {}
    unsafe impl Sync for Mstp {}
    impl Mstp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Module Stop Control Register B"]
        #[inline(always)]
        pub const fn mstpcrb(self) -> crate::common::Reg<regs::Mstpcrb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Module Stop Control Register C"]
        #[inline(always)]
        pub const fn mstpcrc(self) -> crate::common::Reg<regs::Mstpcrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Module Stop Control Register D"]
        #[inline(always)]
        pub const fn mstpcrd(self) -> crate::common::Reg<regs::Mstpcrd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Module Stop Control Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrb(pub u32);
        impl Mstpcrb {
            #[doc = "Serial Array Unit 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb6(&self) -> super::vals::Mstpb6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mstpb6::from_bits(val as u8)
            }
            #[doc = "Serial Array Unit 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb6(&mut self, val: super::vals::Mstpb6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Serial Array Unit 1 Module Stop"]
            #[inline(always)]
            pub const fn mstpb7(&self) -> super::vals::Mstpb7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Mstpb7::from_bits(val as u8)
            }
            #[doc = "Serial Array Unit 1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb7(&mut self, val: super::vals::Mstpb7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "I2C Bus Interface Module Stop"]
            #[inline(always)]
            pub const fn mstpb10(&self) -> super::vals::Mstpb10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Mstpb10::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface Module Stop"]
            #[inline(always)]
            pub fn set_mstpb10(&mut self, val: super::vals::Mstpb10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Serial Interface UARTA Module Stop"]
            #[inline(always)]
            pub const fn mstpb15(&self) -> super::vals::Mstpb15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Mstpb15::from_bits(val as u8)
            }
            #[doc = "Serial Interface UARTA Module Stop"]
            #[inline(always)]
            pub fn set_mstpb15(&mut self, val: super::vals::Mstpb15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Mstpcrb {
            #[inline(always)]
            fn default() -> Mstpcrb {
                Mstpcrb(0)
            }
        }
        impl core::fmt::Debug for Mstpcrb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrb")
                    .field("mstpb6", &self.mstpb6())
                    .field("mstpb7", &self.mstpb7())
                    .field("mstpb10", &self.mstpb10())
                    .field("mstpb15", &self.mstpb15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mstpcrb {{ mstpb6: {:?}, mstpb7: {:?}, mstpb10: {:?}, mstpb15: {:?} }}",
                    self.mstpb6(),
                    self.mstpb7(),
                    self.mstpb10(),
                    self.mstpb15()
                )
            }
        }
        #[doc = "Module Stop Control Register C"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrc(pub u32);
        impl Mstpcrc {
            #[doc = "Cyclic Redundancy Check Calculator Module Stop"]
            #[inline(always)]
            pub const fn mstpc1(&self) -> super::vals::Mstpc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mstpc1::from_bits(val as u8)
            }
            #[doc = "Cyclic Redundancy Check Calculator Module Stop"]
            #[inline(always)]
            pub fn set_mstpc1(&mut self, val: super::vals::Mstpc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Event Link Controller Module Stop"]
            #[inline(always)]
            pub const fn mstpc14(&self) -> super::vals::Mstpc14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Mstpc14::from_bits(val as u8)
            }
            #[doc = "Event Link Controller Module Stop"]
            #[inline(always)]
            pub fn set_mstpc14(&mut self, val: super::vals::Mstpc14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "True Random Number Generator Module Stop"]
            #[inline(always)]
            pub const fn mstpc28(&self) -> super::vals::Mstpc28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Mstpc28::from_bits(val as u8)
            }
            #[doc = "True Random Number Generator Module Stop"]
            #[inline(always)]
            pub fn set_mstpc28(&mut self, val: super::vals::Mstpc28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Mstpcrc {
            #[inline(always)]
            fn default() -> Mstpcrc {
                Mstpcrc(0)
            }
        }
        impl core::fmt::Debug for Mstpcrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrc")
                    .field("mstpc1", &self.mstpc1())
                    .field("mstpc14", &self.mstpc14())
                    .field("mstpc28", &self.mstpc28())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mstpcrc {{ mstpc1: {:?}, mstpc14: {:?}, mstpc28: {:?} }}",
                    self.mstpc1(),
                    self.mstpc14(),
                    self.mstpc28()
                )
            }
        }
        #[doc = "Module Stop Control Register D"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrd(pub u32);
        impl Mstpcrd {
            #[doc = "Timer Array Unit 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpd0(&self) -> super::vals::Mstpd0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mstpd0::from_bits(val as u8)
            }
            #[doc = "Timer Array Unit 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd0(&mut self, val: super::vals::Mstpd0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "32-bit Interval Timer Module Stop"]
            #[inline(always)]
            pub const fn mstpd4(&self) -> super::vals::Mstpd4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mstpd4::from_bits(val as u8)
            }
            #[doc = "32-bit Interval Timer Module Stop"]
            #[inline(always)]
            pub fn set_mstpd4(&mut self, val: super::vals::Mstpd4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "A/D Converter Module Stop"]
            #[inline(always)]
            pub const fn mstpd16(&self) -> super::vals::Mstpd16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Mstpd16::from_bits(val as u8)
            }
            #[doc = "A/D Converter Module Stop"]
            #[inline(always)]
            pub fn set_mstpd16(&mut self, val: super::vals::Mstpd16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Realtime Clock Module Stop"]
            #[inline(always)]
            pub const fn mstpd23(&self) -> super::vals::Mstpd23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Mstpd23::from_bits(val as u8)
            }
            #[doc = "Realtime Clock Module Stop"]
            #[inline(always)]
            pub fn set_mstpd23(&mut self, val: super::vals::Mstpd23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Mstpcrd {
            #[inline(always)]
            fn default() -> Mstpcrd {
                Mstpcrd(0)
            }
        }
        impl core::fmt::Debug for Mstpcrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrd")
                    .field("mstpd0", &self.mstpd0())
                    .field("mstpd4", &self.mstpd4())
                    .field("mstpd16", &self.mstpd16())
                    .field("mstpd23", &self.mstpd23())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mstpcrd {{ mstpd0: {:?}, mstpd4: {:?}, mstpd16: {:?}, mstpd23: {:?} }}",
                    self.mstpd0(),
                    self.mstpd4(),
                    self.mstpd16(),
                    self.mstpd23()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb10 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb10 {
                Mstpb10::from_bits(val)
            }
        }
        impl From<Mstpb10> for u8 {
            #[inline(always)]
            fn from(val: Mstpb10) -> u8 {
                Mstpb10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb15 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb15 {
                Mstpb15::from_bits(val)
            }
        }
        impl From<Mstpb15> for u8 {
            #[inline(always)]
            fn from(val: Mstpb15) -> u8 {
                Mstpb15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb6 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb6 {
                Mstpb6::from_bits(val)
            }
        }
        impl From<Mstpb6> for u8 {
            #[inline(always)]
            fn from(val: Mstpb6) -> u8 {
                Mstpb6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb7 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb7 {
                Mstpb7::from_bits(val)
            }
        }
        impl From<Mstpb7> for u8 {
            #[inline(always)]
            fn from(val: Mstpb7) -> u8 {
                Mstpb7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc1 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc1 {
                Mstpc1::from_bits(val)
            }
        }
        impl From<Mstpc1> for u8 {
            #[inline(always)]
            fn from(val: Mstpc1) -> u8 {
                Mstpc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc14 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc14 {
                Mstpc14::from_bits(val)
            }
        }
        impl From<Mstpc14> for u8 {
            #[inline(always)]
            fn from(val: Mstpc14) -> u8 {
                Mstpc14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc28 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc28 {
                Mstpc28::from_bits(val)
            }
        }
        impl From<Mstpc28> for u8 {
            #[inline(always)]
            fn from(val: Mstpc28) -> u8 {
                Mstpc28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd0 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd0 {
                Mstpd0::from_bits(val)
            }
        }
        impl From<Mstpd0> for u8 {
            #[inline(always)]
            fn from(val: Mstpd0) -> u8 {
                Mstpd0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd16 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd16 {
                Mstpd16::from_bits(val)
            }
        }
        impl From<Mstpd16> for u8 {
            #[inline(always)]
            fn from(val: Mstpd16) -> u8 {
                Mstpd16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd23 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd23 {
                Mstpd23::from_bits(val)
            }
        }
        impl From<Mstpd23> for u8 {
            #[inline(always)]
            fn from(val: Mstpd23) -> u8 {
                Mstpd23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd4 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd4 {
                Mstpd4::from_bits(val)
            }
        }
        impl From<Mstpd4> for u8 {
            #[inline(always)]
            fn from(val: Mstpd4) -> u8 {
                Mstpd4::to_bits(val)
            }
        }
    }
}
pub mod pclbuz {
    #[doc = "Clock Output/Buzzer Output Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pclbuz {
        ptr: *mut u8,
    }
    unsafe impl Send for Pclbuz {}
    unsafe impl Sync for Pclbuz {}
    impl Pclbuz {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Clock Out Control Register 0"]
        #[inline(always)]
        pub const fn cks0(self) -> crate::common::Reg<regs::Cks0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Clock Out Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cks0(pub u8);
        impl Cks0 {
            #[doc = "Clock Out Divide Select"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Ccs {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ccs::from_bits(val as u8)
            }
            #[doc = "Clock Out Divide Select"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Ccs) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Clock Out Select"]
            #[inline(always)]
            pub const fn csel(&self) -> super::vals::Csel {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Csel::from_bits(val as u8)
            }
            #[doc = "Clock Out Select"]
            #[inline(always)]
            pub fn set_csel(&mut self, val: super::vals::Csel) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Clock Out Enable"]
            #[inline(always)]
            pub const fn pcloe(&self) -> super::vals::Pcloe {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcloe::from_bits(val as u8)
            }
            #[doc = "Clock Out Enable"]
            #[inline(always)]
            pub fn set_pcloe(&mut self, val: super::vals::Pcloe) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Cks0 {
            #[inline(always)]
            fn default() -> Cks0 {
                Cks0(0)
            }
        }
        impl core::fmt::Debug for Cks0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cks0")
                    .field("ccs", &self.ccs())
                    .field("csel", &self.csel())
                    .field("pcloe", &self.pcloe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cks0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cks0 {{ ccs: {:?}, csel: {:?}, pcloe: {:?} }}",
                    self.ccs(),
                    self.csel(),
                    self.pcloe()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccs {
            #[inline(always)]
            fn from(val: u8) -> Ccs {
                Ccs::from_bits(val)
            }
        }
        impl From<Ccs> for u8 {
            #[inline(always)]
            fn from(val: Ccs) -> u8 {
                Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csel {
            #[inline(always)]
            fn from(val: u8) -> Csel {
                Csel::from_bits(val)
            }
        }
        impl From<Csel> for u8 {
            #[inline(always)]
            fn from(val: Csel) -> u8 {
                Csel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcloe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcloe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcloe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcloe {
            #[inline(always)]
            fn from(val: u8) -> Pcloe {
                Pcloe::from_bits(val)
            }
        }
        impl From<Pcloe> for u8 {
            #[inline(always)]
            fn from(val: Pcloe) -> u8 {
                Pcloe::to_bits(val)
            }
        }
    }
}
pub mod pfs_a {
    #[doc = "Pmn Pin Function Select"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PfsA {
        ptr: *mut u8,
    }
    unsafe impl Send for PfsA {}
    unsafe impl Sync for PfsA {}
    impl PfsA {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p00pfs_a(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P00pfsA, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 2usize) as _) }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs_a(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P0pfsA, crate::common::RW> {
            assert!(n < 5usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize + n * 2usize) as _) }
        }
        #[doc = "Port 015 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p015pfs_a(self) -> crate::common::Reg<regs::P015pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1eusize) as _) }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p10pfs_a(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P10pfsA, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 2usize) as _) }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p10pfs_a_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P10pfsA1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize + n * 2usize) as _) }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p108pfs_a(self) -> crate::common::Reg<regs::P108pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p109pfs_a(self) -> crate::common::Reg<regs::P109pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x32usize) as _) }
        }
        #[doc = "Port 110 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p110pfs_a(self) -> crate::common::Reg<regs::P110pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Port 112 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p112pfs_a(self) -> crate::common::Reg<regs::P112pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p200pfs_a(self) -> crate::common::Reg<regs::P200pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p201pfs_a(self) -> crate::common::Reg<regs::P201pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x42usize) as _) }
        }
        #[doc = "Port 206 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p206pfs_a(self) -> crate::common::Reg<regs::P206pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "Port 20%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p20pfs_a(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P20pfsA, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4eusize + n * 2usize) as _) }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p2pfs_a(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P2pfsA, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize + n * 2usize) as _) }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p2pfs_a_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P2pfsA1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize + n * 2usize) as _) }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p300pfs_a(self) -> crate::common::Reg<regs::P300pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Port 407 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p407pfs_a(self) -> crate::common::Reg<regs::P407pfsA, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8eusize) as _) }
        }
        #[doc = "Port 9%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p9pfs_a(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P9pfsA, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013ausize + n * 2usize) as _) }
        }
        #[doc = "Write,Protect Register"]
        #[inline(always)]
        pub const fn pwpr(self) -> crate::common::Reg<regs::Pwpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port 00%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P00pfsA(pub u16);
        impl P00pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P00pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P00pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P00pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P00pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P00pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P00pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P00pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P00pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P00pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P00pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P00pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P00pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P00pfsA {
            #[inline(always)]
            fn default() -> P00pfsA {
                P00pfsA(0)
            }
        }
        impl core::fmt::Debug for P00pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P00pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("psel", &self.psel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P00pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P00pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, psel: {=u8:?}, pmc: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.psel(),
                    self.pmc()
                )
            }
        }
        #[doc = "Port 015 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P015pfsA(pub u16);
        impl P015pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P015pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P015pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P015pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P015pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P015pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P015pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P015pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P015pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P015pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P015pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P015pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P015pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P015pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P015pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P015pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P015pfsA {
            #[inline(always)]
            fn default() -> P015pfsA {
                P015pfsA(0)
            }
        }
        impl core::fmt::Debug for P015pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P015pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P015pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P015pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfsA(pub u16);
        impl P0pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P0pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P0pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P0pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P0pfsA {
            #[inline(always)]
            fn default() -> P0pfsA {
                P0pfsA(0)
            }
        }
        impl core::fmt::Debug for P0pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("psel", &self.psel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P0pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, psel: {=u8:?}, pmc: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.psel(),
                    self.pmc()
                )
            }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P108pfsA(pub u16);
        impl P108pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P108pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P108pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P108pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P108pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P108pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P108pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P108pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P108pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P108pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P108pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P108pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P108pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P108pfsAPim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P108pfsAPim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P108pfsAPim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P108pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P108pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P108pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P108pfsA {
            #[inline(always)]
            fn default() -> P108pfsA {
                P108pfsA(0)
            }
        }
        impl core::fmt::Debug for P108pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P108pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("psel", &self.psel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P108pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P108pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, psel: {=u8:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . psel () , self . pmc ())
            }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P109pfsA(pub u16);
        impl P109pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P109pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P109pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P109pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P109pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P109pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P109pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P109pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P109pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P109pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P109pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P109pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P109pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P109pfsAPim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P109pfsAPim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P109pfsAPim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P109pfsANcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P109pfsANcodr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P109pfsANcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P109pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P109pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P109pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P109pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P109pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P109pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P109pfsA {
            #[inline(always)]
            fn default() -> P109pfsA {
                P109pfsA(0)
            }
        }
        impl core::fmt::Debug for P109pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P109pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("ncodr", &self.ncodr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P109pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P109pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, ncodr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . ncodr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P10pfsA(pub u16);
        impl P10pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P10pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P10pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P10pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P10pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P10pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P10pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P10pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P10pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P10pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P10pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P10pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P10pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P10pfsAPim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P10pfsAPim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P10pfsAPim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P10pfsANcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P10pfsANcodr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P10pfsANcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P10pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P10pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P10pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P10pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P10pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P10pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P10pfsA {
            #[inline(always)]
            fn default() -> P10pfsA {
                P10pfsA(0)
            }
        }
        impl core::fmt::Debug for P10pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P10pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("ncodr", &self.ncodr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P10pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P10pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, ncodr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . ncodr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P10pfsA1(pub u16);
        impl P10pfsA1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P10pfsA1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P10pfsA1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P10pfsA1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P10pfsA1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P10pfsA1Pidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P10pfsA1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P10pfsA1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P10pfsA1Pdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P10pfsA1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P10pfsA1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P10pfsA1Pcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P10pfsA1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P10pfsA1Pim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P10pfsA1Pim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P10pfsA1Pim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P10pfsA1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P10pfsA1Ncodr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P10pfsA1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P10pfsA1Isel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P10pfsA1Isel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P10pfsA1Isel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P10pfsA1Pmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P10pfsA1Pmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P10pfsA1Pmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P10pfsA1 {
            #[inline(always)]
            fn default() -> P10pfsA1 {
                P10pfsA1(0)
            }
        }
        impl core::fmt::Debug for P10pfsA1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P10pfsA1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("ncodr", &self.ncodr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P10pfsA1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P10pfsA1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, ncodr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . ncodr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 110 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P110pfsA(pub u16);
        impl P110pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P110pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P110pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P110pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P110pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P110pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P110pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P110pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P110pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P110pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P110pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P110pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P110pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P110pfsAPim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P110pfsAPim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P110pfsAPim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P110pfsANcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P110pfsANcodr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P110pfsANcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P110pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P110pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P110pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P110pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P110pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P110pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P110pfsA {
            #[inline(always)]
            fn default() -> P110pfsA {
                P110pfsA(0)
            }
        }
        impl core::fmt::Debug for P110pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P110pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("ncodr", &self.ncodr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P110pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P110pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, ncodr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . ncodr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 112 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P112pfsA(pub u16);
        impl P112pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P112pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P112pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P112pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P112pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P112pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P112pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P112pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P112pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P112pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P112pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P112pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P112pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P112pfsAPim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P112pfsAPim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P112pfsAPim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P112pfsANcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P112pfsANcodr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P112pfsANcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P112pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P112pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P112pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P112pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P112pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P112pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P112pfsA {
            #[inline(always)]
            fn default() -> P112pfsA {
                P112pfsA(0)
            }
        }
        impl core::fmt::Debug for P112pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P112pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("ncodr", &self.ncodr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P112pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P112pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, ncodr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . ncodr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P200pfsA(pub u16);
        impl P200pfsA {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P200pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P200pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P200pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P200pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P200pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P200pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P200pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P200pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P200pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P200pfsA {
            #[inline(always)]
            fn default() -> P200pfsA {
                P200pfsA(0)
            }
        }
        impl core::fmt::Debug for P200pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P200pfsA")
                    .field("pidr", &self.pidr())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P200pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P200pfsA {{ pidr: {:?}, isel: {:?}, pmc: {:?} }}",
                    self.pidr(),
                    self.isel(),
                    self.pmc()
                )
            }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P201pfsA(pub u16);
        impl P201pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P201pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P201pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P201pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P201pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P201pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P201pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P201pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P201pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P201pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P201pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P201pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P201pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P201pfsAPim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P201pfsAPim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P201pfsAPim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P201pfsANcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P201pfsANcodr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P201pfsANcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P201pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P201pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P201pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P201pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P201pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P201pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P201pfsA {
            #[inline(always)]
            fn default() -> P201pfsA {
                P201pfsA(0)
            }
        }
        impl core::fmt::Debug for P201pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P201pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("ncodr", &self.ncodr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P201pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P201pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, ncodr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . ncodr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 206 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P206pfsA(pub u16);
        impl P206pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P206pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P206pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P206pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P206pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P206pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P206pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P206pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P206pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P206pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P206pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P206pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P206pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
        }
        impl Default for P206pfsA {
            #[inline(always)]
            fn default() -> P206pfsA {
                P206pfsA(0)
            }
        }
        impl core::fmt::Debug for P206pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P206pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P206pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P206pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr()
                )
            }
        }
        #[doc = "Port 20%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P20pfsA(pub u16);
        impl P20pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P20pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P20pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P20pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P20pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P20pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P20pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P20pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P20pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P20pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P20pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P20pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P20pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P20pfsAPim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P20pfsAPim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P20pfsAPim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P20pfsANcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P20pfsANcodr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P20pfsANcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P20pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P20pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P20pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P20pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P20pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P20pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P20pfsA {
            #[inline(always)]
            fn default() -> P20pfsA {
                P20pfsA(0)
            }
        }
        impl core::fmt::Debug for P20pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P20pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("ncodr", &self.ncodr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P20pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P20pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, ncodr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . ncodr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P2pfsA(pub u16);
        impl P2pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P2pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P2pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P2pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P2pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P2pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P2pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P2pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P2pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P2pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P2pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P2pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P2pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P2pfsANcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P2pfsANcodr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P2pfsANcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P2pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P2pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P2pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P2pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P2pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P2pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P2pfsA {
            #[inline(always)]
            fn default() -> P2pfsA {
                P2pfsA(0)
            }
        }
        impl core::fmt::Debug for P2pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P2pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P2pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P2pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P2pfsA1(pub u16);
        impl P2pfsA1 {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P2pfsA1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P2pfsA1Pidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P2pfsA1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
        }
        impl Default for P2pfsA1 {
            #[inline(always)]
            fn default() -> P2pfsA1 {
                P2pfsA1(0)
            }
        }
        impl core::fmt::Debug for P2pfsA1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P2pfsA1")
                    .field("pidr", &self.pidr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P2pfsA1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "P2pfsA1 {{ pidr: {:?} }}", self.pidr())
            }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P300pfsA(pub u16);
        impl P300pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P300pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P300pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P300pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P300pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P300pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P300pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P300pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P300pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P300pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P300pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P300pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P300pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P300pfsAPim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P300pfsAPim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P300pfsAPim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P300pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P300pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P300pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P300pfsA {
            #[inline(always)]
            fn default() -> P300pfsA {
                P300pfsA(0)
            }
        }
        impl core::fmt::Debug for P300pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P300pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("psel", &self.psel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P300pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P300pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, psel: {=u8:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . psel () , self . pmc ())
            }
        }
        #[doc = "Port 407 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P407pfsA(pub u16);
        impl P407pfsA {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P407pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P407pfsAPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P407pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P407pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P407pfsAPidr::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P407pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P407pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P407pfsAPdr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P407pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P407pfsAPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P407pfsAPcr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P407pfsAPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pim(&self) -> super::vals::P407pfsAPim {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::P407pfsAPim::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_pim(&mut self, val: super::vals::P407pfsAPim) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P407pfsANcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P407pfsANcodr::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P407pfsANcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "These bits select the peripheral function. For individual pin functions, see the associated tables in this chapter."]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P407pfsAIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P407pfsAIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P407pfsAIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P407pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P407pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin mode control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P407pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P407pfsA {
            #[inline(always)]
            fn default() -> P407pfsA {
                P407pfsA(0)
            }
        }
        impl core::fmt::Debug for P407pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P407pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("pim", &self.pim())
                    .field("ncodr", &self.ncodr())
                    .field("psel", &self.psel())
                    .field("isel", &self.isel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P407pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P407pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, pim: {:?}, ncodr: {:?}, psel: {=u8:?}, isel: {:?}, pmc: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . pim () , self . ncodr () , self . psel () , self . isel () , self . pmc ())
            }
        }
        #[doc = "Port 9%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P9pfsA(pub u16);
        impl P9pfsA {
            #[doc = "P9n Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P9pfsAPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P9pfsAPodr::from_bits(val as u8)
            }
            #[doc = "P9n Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P9pfsAPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "P9n State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P9pfsAPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P9pfsAPidr::from_bits(val as u8)
            }
            #[doc = "P9n State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P9pfsAPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P9n Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P9pfsAPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P9pfsAPdr::from_bits(val as u8)
            }
            #[doc = "P9n Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P9pfsAPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u16) & 0x07) << 8usize);
            }
            #[doc = "Pin Mode Control"]
            #[inline(always)]
            pub const fn pmc(&self) -> super::vals::P9pfsAPmc {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P9pfsAPmc::from_bits(val as u8)
            }
            #[doc = "Pin Mode Control"]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: super::vals::P9pfsAPmc) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P9pfsA {
            #[inline(always)]
            fn default() -> P9pfsA {
                P9pfsA(0)
            }
        }
        impl core::fmt::Debug for P9pfsA {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P9pfsA")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("psel", &self.psel())
                    .field("pmc", &self.pmc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P9pfsA {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P9pfsA {{ podr: {:?}, pidr: {:?}, pdr: {:?}, psel: {=u8:?}, pmc: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.psel(),
                    self.pmc()
                )
            }
        }
        #[doc = "Write,Protect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwpr(pub u8);
        impl Pwpr {
            #[doc = "PmnPFS_A Register Write Enable"]
            #[inline(always)]
            pub const fn pfswe(&self) -> super::vals::Pfswe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pfswe::from_bits(val as u8)
            }
            #[doc = "PmnPFS_A Register Write Enable"]
            #[inline(always)]
            pub fn set_pfswe(&mut self, val: super::vals::Pfswe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "PFSWE Bit Write Disable"]
            #[inline(always)]
            pub const fn b0wi(&self) -> super::vals::B0wi {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::B0wi::from_bits(val as u8)
            }
            #[doc = "PFSWE Bit Write Disable"]
            #[inline(always)]
            pub fn set_b0wi(&mut self, val: super::vals::B0wi) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Pwpr {
            #[inline(always)]
            fn default() -> Pwpr {
                Pwpr(0)
            }
        }
        impl core::fmt::Debug for Pwpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwpr")
                    .field("pfswe", &self.pfswe())
                    .field("b0wi", &self.b0wi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pwpr {{ pfswe: {:?}, b0wi: {:?} }}",
                    self.pfswe(),
                    self.b0wi()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum B0wi {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl B0wi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> B0wi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for B0wi {
            #[inline(always)]
            fn from(val: u8) -> B0wi {
                B0wi::from_bits(val)
            }
        }
        impl From<B0wi> for u8 {
            #[inline(always)]
            fn from(val: B0wi) -> u8 {
                B0wi::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsAPdr {
                P00pfsAPdr::from_bits(val)
            }
        }
        impl From<P00pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsAPdr) -> u8 {
                P00pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsAPidr {
                P00pfsAPidr::from_bits(val)
            }
        }
        impl From<P00pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsAPidr) -> u8 {
                P00pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P00pfsAPmc {
                P00pfsAPmc::from_bits(val)
            }
        }
        impl From<P00pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P00pfsAPmc) -> u8 {
                P00pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsAPodr {
                P00pfsAPodr::from_bits(val)
            }
        }
        impl From<P00pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsAPodr) -> u8 {
                P00pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P015pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P015pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P015pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P015pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P015pfsAIsel {
                P015pfsAIsel::from_bits(val)
            }
        }
        impl From<P015pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P015pfsAIsel) -> u8 {
                P015pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P015pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P015pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P015pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P015pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P015pfsAPdr {
                P015pfsAPdr::from_bits(val)
            }
        }
        impl From<P015pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P015pfsAPdr) -> u8 {
                P015pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P015pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P015pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P015pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P015pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P015pfsAPidr {
                P015pfsAPidr::from_bits(val)
            }
        }
        impl From<P015pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P015pfsAPidr) -> u8 {
                P015pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P015pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P015pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P015pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P015pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P015pfsAPmc {
                P015pfsAPmc::from_bits(val)
            }
        }
        impl From<P015pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P015pfsAPmc) -> u8 {
                P015pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P015pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P015pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P015pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P015pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P015pfsAPodr {
                P015pfsAPodr::from_bits(val)
            }
        }
        impl From<P015pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P015pfsAPodr) -> u8 {
                P015pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsAPdr {
                P0pfsAPdr::from_bits(val)
            }
        }
        impl From<P0pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsAPdr) -> u8 {
                P0pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsAPidr {
                P0pfsAPidr::from_bits(val)
            }
        }
        impl From<P0pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsAPidr) -> u8 {
                P0pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P0pfsAPmc {
                P0pfsAPmc::from_bits(val)
            }
        }
        impl From<P0pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P0pfsAPmc) -> u8 {
                P0pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsAPodr {
                P0pfsAPodr::from_bits(val)
            }
        }
        impl From<P0pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsAPodr) -> u8 {
                P0pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsAPcr {
                P108pfsAPcr::from_bits(val)
            }
        }
        impl From<P108pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsAPcr) -> u8 {
                P108pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsAPdr {
                P108pfsAPdr::from_bits(val)
            }
        }
        impl From<P108pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsAPdr) -> u8 {
                P108pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsAPidr {
                P108pfsAPidr::from_bits(val)
            }
        }
        impl From<P108pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsAPidr) -> u8 {
                P108pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsAPim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsAPim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsAPim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsAPim {
            #[inline(always)]
            fn from(val: u8) -> P108pfsAPim {
                P108pfsAPim::from_bits(val)
            }
        }
        impl From<P108pfsAPim> for u8 {
            #[inline(always)]
            fn from(val: P108pfsAPim) -> u8 {
                P108pfsAPim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P108pfsAPmc {
                P108pfsAPmc::from_bits(val)
            }
        }
        impl From<P108pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P108pfsAPmc) -> u8 {
                P108pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsAPodr {
                P108pfsAPodr::from_bits(val)
            }
        }
        impl From<P108pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsAPodr) -> u8 {
                P108pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P109pfsAIsel {
                P109pfsAIsel::from_bits(val)
            }
        }
        impl From<P109pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P109pfsAIsel) -> u8 {
                P109pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsANcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsANcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsANcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsANcodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsANcodr {
                P109pfsANcodr::from_bits(val)
            }
        }
        impl From<P109pfsANcodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsANcodr) -> u8 {
                P109pfsANcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsAPcr {
                P109pfsAPcr::from_bits(val)
            }
        }
        impl From<P109pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsAPcr) -> u8 {
                P109pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsAPdr {
                P109pfsAPdr::from_bits(val)
            }
        }
        impl From<P109pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsAPdr) -> u8 {
                P109pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsAPidr {
                P109pfsAPidr::from_bits(val)
            }
        }
        impl From<P109pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsAPidr) -> u8 {
                P109pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsAPim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsAPim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsAPim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsAPim {
            #[inline(always)]
            fn from(val: u8) -> P109pfsAPim {
                P109pfsAPim::from_bits(val)
            }
        }
        impl From<P109pfsAPim> for u8 {
            #[inline(always)]
            fn from(val: P109pfsAPim) -> u8 {
                P109pfsAPim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P109pfsAPmc {
                P109pfsAPmc::from_bits(val)
            }
        }
        impl From<P109pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P109pfsAPmc) -> u8 {
                P109pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsAPodr {
                P109pfsAPodr::from_bits(val)
            }
        }
        impl From<P109pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsAPodr) -> u8 {
                P109pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsA1Isel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsA1Isel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsA1Isel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsA1Isel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsA1Isel {
                P10pfsA1Isel::from_bits(val)
            }
        }
        impl From<P10pfsA1Isel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsA1Isel) -> u8 {
                P10pfsA1Isel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsA1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsA1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsA1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsA1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsA1Ncodr {
                P10pfsA1Ncodr::from_bits(val)
            }
        }
        impl From<P10pfsA1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsA1Ncodr) -> u8 {
                P10pfsA1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsA1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsA1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsA1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsA1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsA1Pcr {
                P10pfsA1Pcr::from_bits(val)
            }
        }
        impl From<P10pfsA1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsA1Pcr) -> u8 {
                P10pfsA1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsA1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsA1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsA1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsA1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsA1Pdr {
                P10pfsA1Pdr::from_bits(val)
            }
        }
        impl From<P10pfsA1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsA1Pdr) -> u8 {
                P10pfsA1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsA1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsA1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsA1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsA1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsA1Pidr {
                P10pfsA1Pidr::from_bits(val)
            }
        }
        impl From<P10pfsA1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsA1Pidr) -> u8 {
                P10pfsA1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsA1Pim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsA1Pim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsA1Pim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsA1Pim {
            #[inline(always)]
            fn from(val: u8) -> P10pfsA1Pim {
                P10pfsA1Pim::from_bits(val)
            }
        }
        impl From<P10pfsA1Pim> for u8 {
            #[inline(always)]
            fn from(val: P10pfsA1Pim) -> u8 {
                P10pfsA1Pim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsA1Pmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsA1Pmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsA1Pmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsA1Pmc {
            #[inline(always)]
            fn from(val: u8) -> P10pfsA1Pmc {
                P10pfsA1Pmc::from_bits(val)
            }
        }
        impl From<P10pfsA1Pmc> for u8 {
            #[inline(always)]
            fn from(val: P10pfsA1Pmc) -> u8 {
                P10pfsA1Pmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsA1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsA1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsA1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsA1Podr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsA1Podr {
                P10pfsA1Podr::from_bits(val)
            }
        }
        impl From<P10pfsA1Podr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsA1Podr) -> u8 {
                P10pfsA1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsAIsel {
                P10pfsAIsel::from_bits(val)
            }
        }
        impl From<P10pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsAIsel) -> u8 {
                P10pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsANcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsANcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsANcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsANcodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsANcodr {
                P10pfsANcodr::from_bits(val)
            }
        }
        impl From<P10pfsANcodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsANcodr) -> u8 {
                P10pfsANcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsAPcr {
                P10pfsAPcr::from_bits(val)
            }
        }
        impl From<P10pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsAPcr) -> u8 {
                P10pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsAPdr {
                P10pfsAPdr::from_bits(val)
            }
        }
        impl From<P10pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsAPdr) -> u8 {
                P10pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsAPidr {
                P10pfsAPidr::from_bits(val)
            }
        }
        impl From<P10pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsAPidr) -> u8 {
                P10pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsAPim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsAPim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsAPim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsAPim {
            #[inline(always)]
            fn from(val: u8) -> P10pfsAPim {
                P10pfsAPim::from_bits(val)
            }
        }
        impl From<P10pfsAPim> for u8 {
            #[inline(always)]
            fn from(val: P10pfsAPim) -> u8 {
                P10pfsAPim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P10pfsAPmc {
                P10pfsAPmc::from_bits(val)
            }
        }
        impl From<P10pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P10pfsAPmc) -> u8 {
                P10pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsAPodr {
                P10pfsAPodr::from_bits(val)
            }
        }
        impl From<P10pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsAPodr) -> u8 {
                P10pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P110pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P110pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P110pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P110pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P110pfsAIsel {
                P110pfsAIsel::from_bits(val)
            }
        }
        impl From<P110pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P110pfsAIsel) -> u8 {
                P110pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P110pfsANcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P110pfsANcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P110pfsANcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P110pfsANcodr {
            #[inline(always)]
            fn from(val: u8) -> P110pfsANcodr {
                P110pfsANcodr::from_bits(val)
            }
        }
        impl From<P110pfsANcodr> for u8 {
            #[inline(always)]
            fn from(val: P110pfsANcodr) -> u8 {
                P110pfsANcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P110pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P110pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P110pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P110pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P110pfsAPcr {
                P110pfsAPcr::from_bits(val)
            }
        }
        impl From<P110pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P110pfsAPcr) -> u8 {
                P110pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P110pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P110pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P110pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P110pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P110pfsAPdr {
                P110pfsAPdr::from_bits(val)
            }
        }
        impl From<P110pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P110pfsAPdr) -> u8 {
                P110pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P110pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P110pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P110pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P110pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P110pfsAPidr {
                P110pfsAPidr::from_bits(val)
            }
        }
        impl From<P110pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P110pfsAPidr) -> u8 {
                P110pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P110pfsAPim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P110pfsAPim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P110pfsAPim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P110pfsAPim {
            #[inline(always)]
            fn from(val: u8) -> P110pfsAPim {
                P110pfsAPim::from_bits(val)
            }
        }
        impl From<P110pfsAPim> for u8 {
            #[inline(always)]
            fn from(val: P110pfsAPim) -> u8 {
                P110pfsAPim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P110pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P110pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P110pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P110pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P110pfsAPmc {
                P110pfsAPmc::from_bits(val)
            }
        }
        impl From<P110pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P110pfsAPmc) -> u8 {
                P110pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P110pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P110pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P110pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P110pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P110pfsAPodr {
                P110pfsAPodr::from_bits(val)
            }
        }
        impl From<P110pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P110pfsAPodr) -> u8 {
                P110pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P112pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P112pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P112pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P112pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P112pfsAIsel {
                P112pfsAIsel::from_bits(val)
            }
        }
        impl From<P112pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P112pfsAIsel) -> u8 {
                P112pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P112pfsANcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P112pfsANcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P112pfsANcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P112pfsANcodr {
            #[inline(always)]
            fn from(val: u8) -> P112pfsANcodr {
                P112pfsANcodr::from_bits(val)
            }
        }
        impl From<P112pfsANcodr> for u8 {
            #[inline(always)]
            fn from(val: P112pfsANcodr) -> u8 {
                P112pfsANcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P112pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P112pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P112pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P112pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P112pfsAPcr {
                P112pfsAPcr::from_bits(val)
            }
        }
        impl From<P112pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P112pfsAPcr) -> u8 {
                P112pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P112pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P112pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P112pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P112pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P112pfsAPdr {
                P112pfsAPdr::from_bits(val)
            }
        }
        impl From<P112pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P112pfsAPdr) -> u8 {
                P112pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P112pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P112pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P112pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P112pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P112pfsAPidr {
                P112pfsAPidr::from_bits(val)
            }
        }
        impl From<P112pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P112pfsAPidr) -> u8 {
                P112pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P112pfsAPim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P112pfsAPim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P112pfsAPim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P112pfsAPim {
            #[inline(always)]
            fn from(val: u8) -> P112pfsAPim {
                P112pfsAPim::from_bits(val)
            }
        }
        impl From<P112pfsAPim> for u8 {
            #[inline(always)]
            fn from(val: P112pfsAPim) -> u8 {
                P112pfsAPim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P112pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P112pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P112pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P112pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P112pfsAPmc {
                P112pfsAPmc::from_bits(val)
            }
        }
        impl From<P112pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P112pfsAPmc) -> u8 {
                P112pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P112pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P112pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P112pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P112pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P112pfsAPodr {
                P112pfsAPodr::from_bits(val)
            }
        }
        impl From<P112pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P112pfsAPodr) -> u8 {
                P112pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P200pfsAIsel {
                P200pfsAIsel::from_bits(val)
            }
        }
        impl From<P200pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P200pfsAIsel) -> u8 {
                P200pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsAPidr {
                P200pfsAPidr::from_bits(val)
            }
        }
        impl From<P200pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsAPidr) -> u8 {
                P200pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P200pfsAPmc {
                P200pfsAPmc::from_bits(val)
            }
        }
        impl From<P200pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P200pfsAPmc) -> u8 {
                P200pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P201pfsAIsel {
                P201pfsAIsel::from_bits(val)
            }
        }
        impl From<P201pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P201pfsAIsel) -> u8 {
                P201pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsANcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsANcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsANcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsANcodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsANcodr {
                P201pfsANcodr::from_bits(val)
            }
        }
        impl From<P201pfsANcodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsANcodr) -> u8 {
                P201pfsANcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsAPcr {
                P201pfsAPcr::from_bits(val)
            }
        }
        impl From<P201pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsAPcr) -> u8 {
                P201pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsAPdr {
                P201pfsAPdr::from_bits(val)
            }
        }
        impl From<P201pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsAPdr) -> u8 {
                P201pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsAPidr {
                P201pfsAPidr::from_bits(val)
            }
        }
        impl From<P201pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsAPidr) -> u8 {
                P201pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsAPim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsAPim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsAPim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsAPim {
            #[inline(always)]
            fn from(val: u8) -> P201pfsAPim {
                P201pfsAPim::from_bits(val)
            }
        }
        impl From<P201pfsAPim> for u8 {
            #[inline(always)]
            fn from(val: P201pfsAPim) -> u8 {
                P201pfsAPim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P201pfsAPmc {
                P201pfsAPmc::from_bits(val)
            }
        }
        impl From<P201pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P201pfsAPmc) -> u8 {
                P201pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsAPodr {
                P201pfsAPodr::from_bits(val)
            }
        }
        impl From<P201pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsAPodr) -> u8 {
                P201pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P206pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P206pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P206pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P206pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P206pfsAPcr {
                P206pfsAPcr::from_bits(val)
            }
        }
        impl From<P206pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P206pfsAPcr) -> u8 {
                P206pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P206pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P206pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P206pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P206pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P206pfsAPdr {
                P206pfsAPdr::from_bits(val)
            }
        }
        impl From<P206pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P206pfsAPdr) -> u8 {
                P206pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P206pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P206pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P206pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P206pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P206pfsAPidr {
                P206pfsAPidr::from_bits(val)
            }
        }
        impl From<P206pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P206pfsAPidr) -> u8 {
                P206pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P206pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P206pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P206pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P206pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P206pfsAPodr {
                P206pfsAPodr::from_bits(val)
            }
        }
        impl From<P206pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P206pfsAPodr) -> u8 {
                P206pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P20pfsAIsel {
                P20pfsAIsel::from_bits(val)
            }
        }
        impl From<P20pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P20pfsAIsel) -> u8 {
                P20pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsANcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsANcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsANcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsANcodr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsANcodr {
                P20pfsANcodr::from_bits(val)
            }
        }
        impl From<P20pfsANcodr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsANcodr) -> u8 {
                P20pfsANcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsAPcr {
                P20pfsAPcr::from_bits(val)
            }
        }
        impl From<P20pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsAPcr) -> u8 {
                P20pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsAPdr {
                P20pfsAPdr::from_bits(val)
            }
        }
        impl From<P20pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsAPdr) -> u8 {
                P20pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsAPidr {
                P20pfsAPidr::from_bits(val)
            }
        }
        impl From<P20pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsAPidr) -> u8 {
                P20pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsAPim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsAPim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsAPim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsAPim {
            #[inline(always)]
            fn from(val: u8) -> P20pfsAPim {
                P20pfsAPim::from_bits(val)
            }
        }
        impl From<P20pfsAPim> for u8 {
            #[inline(always)]
            fn from(val: P20pfsAPim) -> u8 {
                P20pfsAPim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P20pfsAPmc {
                P20pfsAPmc::from_bits(val)
            }
        }
        impl From<P20pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P20pfsAPmc) -> u8 {
                P20pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsAPodr {
                P20pfsAPodr::from_bits(val)
            }
        }
        impl From<P20pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsAPodr) -> u8 {
                P20pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsA1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsA1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsA1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsA1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsA1Pidr {
                P2pfsA1Pidr::from_bits(val)
            }
        }
        impl From<P2pfsA1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsA1Pidr) -> u8 {
                P2pfsA1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P2pfsAIsel {
                P2pfsAIsel::from_bits(val)
            }
        }
        impl From<P2pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P2pfsAIsel) -> u8 {
                P2pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsANcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsANcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsANcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsANcodr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsANcodr {
                P2pfsANcodr::from_bits(val)
            }
        }
        impl From<P2pfsANcodr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsANcodr) -> u8 {
                P2pfsANcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsAPcr {
                P2pfsAPcr::from_bits(val)
            }
        }
        impl From<P2pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsAPcr) -> u8 {
                P2pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsAPdr {
                P2pfsAPdr::from_bits(val)
            }
        }
        impl From<P2pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsAPdr) -> u8 {
                P2pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsAPidr {
                P2pfsAPidr::from_bits(val)
            }
        }
        impl From<P2pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsAPidr) -> u8 {
                P2pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P2pfsAPmc {
                P2pfsAPmc::from_bits(val)
            }
        }
        impl From<P2pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P2pfsAPmc) -> u8 {
                P2pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsAPodr {
                P2pfsAPodr::from_bits(val)
            }
        }
        impl From<P2pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsAPodr) -> u8 {
                P2pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsAPcr {
                P300pfsAPcr::from_bits(val)
            }
        }
        impl From<P300pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsAPcr) -> u8 {
                P300pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsAPdr {
                P300pfsAPdr::from_bits(val)
            }
        }
        impl From<P300pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsAPdr) -> u8 {
                P300pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsAPidr {
                P300pfsAPidr::from_bits(val)
            }
        }
        impl From<P300pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsAPidr) -> u8 {
                P300pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsAPim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsAPim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsAPim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsAPim {
            #[inline(always)]
            fn from(val: u8) -> P300pfsAPim {
                P300pfsAPim::from_bits(val)
            }
        }
        impl From<P300pfsAPim> for u8 {
            #[inline(always)]
            fn from(val: P300pfsAPim) -> u8 {
                P300pfsAPim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P300pfsAPmc {
                P300pfsAPmc::from_bits(val)
            }
        }
        impl From<P300pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P300pfsAPmc) -> u8 {
                P300pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsAPodr {
                P300pfsAPodr::from_bits(val)
            }
        }
        impl From<P300pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsAPodr) -> u8 {
                P300pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsAIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsAIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsAIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsAIsel {
            #[inline(always)]
            fn from(val: u8) -> P407pfsAIsel {
                P407pfsAIsel::from_bits(val)
            }
        }
        impl From<P407pfsAIsel> for u8 {
            #[inline(always)]
            fn from(val: P407pfsAIsel) -> u8 {
                P407pfsAIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsANcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsANcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsANcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsANcodr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsANcodr {
                P407pfsANcodr::from_bits(val)
            }
        }
        impl From<P407pfsANcodr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsANcodr) -> u8 {
                P407pfsANcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsAPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsAPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsAPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsAPcr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsAPcr {
                P407pfsAPcr::from_bits(val)
            }
        }
        impl From<P407pfsAPcr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsAPcr) -> u8 {
                P407pfsAPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsAPdr {
                P407pfsAPdr::from_bits(val)
            }
        }
        impl From<P407pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsAPdr) -> u8 {
                P407pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsAPidr {
                P407pfsAPidr::from_bits(val)
            }
        }
        impl From<P407pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsAPidr) -> u8 {
                P407pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsAPim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsAPim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsAPim {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsAPim {
            #[inline(always)]
            fn from(val: u8) -> P407pfsAPim {
                P407pfsAPim::from_bits(val)
            }
        }
        impl From<P407pfsAPim> for u8 {
            #[inline(always)]
            fn from(val: P407pfsAPim) -> u8 {
                P407pfsAPim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P407pfsAPmc {
                P407pfsAPmc::from_bits(val)
            }
        }
        impl From<P407pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P407pfsAPmc) -> u8 {
                P407pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsAPodr {
                P407pfsAPodr::from_bits(val)
            }
        }
        impl From<P407pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsAPodr) -> u8 {
                P407pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P9pfsAPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P9pfsAPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P9pfsAPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P9pfsAPdr {
            #[inline(always)]
            fn from(val: u8) -> P9pfsAPdr {
                P9pfsAPdr::from_bits(val)
            }
        }
        impl From<P9pfsAPdr> for u8 {
            #[inline(always)]
            fn from(val: P9pfsAPdr) -> u8 {
                P9pfsAPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P9pfsAPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P9pfsAPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P9pfsAPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P9pfsAPidr {
            #[inline(always)]
            fn from(val: u8) -> P9pfsAPidr {
                P9pfsAPidr::from_bits(val)
            }
        }
        impl From<P9pfsAPidr> for u8 {
            #[inline(always)]
            fn from(val: P9pfsAPidr) -> u8 {
                P9pfsAPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P9pfsAPmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P9pfsAPmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P9pfsAPmc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P9pfsAPmc {
            #[inline(always)]
            fn from(val: u8) -> P9pfsAPmc {
                P9pfsAPmc::from_bits(val)
            }
        }
        impl From<P9pfsAPmc> for u8 {
            #[inline(always)]
            fn from(val: P9pfsAPmc) -> u8 {
                P9pfsAPmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P9pfsAPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P9pfsAPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P9pfsAPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P9pfsAPodr {
            #[inline(always)]
            fn from(val: u8) -> P9pfsAPodr {
                P9pfsAPodr::from_bits(val)
            }
        }
        impl From<P9pfsAPodr> for u8 {
            #[inline(always)]
            fn from(val: P9pfsAPodr) -> u8 {
                P9pfsAPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pfswe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pfswe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pfswe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pfswe {
            #[inline(always)]
            fn from(val: u8) -> Pfswe {
                Pfswe::from_bits(val)
            }
        }
        impl From<Pfswe> for u8 {
            #[inline(always)]
            fn from(val: Pfswe) -> u8 {
                Pfswe::to_bits(val)
            }
        }
    }
}
pub mod porga {
    #[doc = "Product Organize"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Porga {
        ptr: *mut u8,
    }
    unsafe impl Send for Porga {}
    unsafe impl Sync for Porga {}
    impl Porga {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SAU Noise Filter Enable Register"]
        #[inline(always)]
        pub const fn snfen(self) -> crate::common::Reg<regs::Snfen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "TAU Noise Filter Enable Register"]
        #[inline(always)]
        pub const fn tnfen(self) -> crate::common::Reg<regs::Tnfen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Input Switch Control Register"]
        #[inline(always)]
        pub const fn isc(self) -> crate::common::Reg<regs::Isc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Timer Input Select Register 0"]
        #[inline(always)]
        pub const fn tis0(self) -> crate::common::Reg<regs::Tis0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Timer Input Select Register 1"]
        #[inline(always)]
        pub const fn tis1(self) -> crate::common::Reg<regs::Tis1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "UART Loopback Select Register"]
        #[inline(always)]
        pub const fn ulbs(self) -> crate::common::Reg<regs::Ulbs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Input Switch Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Isc(pub u8);
        impl Isc {
            #[doc = "Switching External Interrupt (IRQ0) Input"]
            #[inline(always)]
            pub const fn isc0(&self) -> super::vals::Isc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Isc0::from_bits(val as u8)
            }
            #[doc = "Switching External Interrupt (IRQ0) Input"]
            #[inline(always)]
            pub fn set_isc0(&mut self, val: super::vals::Isc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Switching Channel 7 Input of Timer Array Unit"]
            #[inline(always)]
            pub const fn isc1(&self) -> super::vals::Isc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Isc1::from_bits(val as u8)
            }
            #[doc = "Switching Channel 7 Input of Timer Array Unit"]
            #[inline(always)]
            pub fn set_isc1(&mut self, val: super::vals::Isc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Setting of the SSI00 Input of Channel 0 in the Communications Through SPI00 in the Slave Mode"]
            #[inline(always)]
            pub const fn ssie00(&self) -> super::vals::Ssie00 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ssie00::from_bits(val as u8)
            }
            #[doc = "Setting of the SSI00 Input of Channel 0 in the Communications Through SPI00 in the Slave Mode"]
            #[inline(always)]
            pub fn set_ssie00(&mut self, val: super::vals::Ssie00) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Isc {
            #[inline(always)]
            fn default() -> Isc {
                Isc(0)
            }
        }
        impl core::fmt::Debug for Isc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Isc")
                    .field("isc0", &self.isc0())
                    .field("isc1", &self.isc1())
                    .field("ssie00", &self.ssie00())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Isc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Isc {{ isc0: {:?}, isc1: {:?}, ssie00: {:?} }}",
                    self.isc0(),
                    self.isc1(),
                    self.ssie00()
                )
            }
        }
        #[doc = "SAU Noise Filter Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snfen(pub u8);
        impl Snfen {
            #[doc = "Use of Noise Filter of RXD0 Pin"]
            #[inline(always)]
            pub const fn snfen00(&self) -> super::vals::Snfen00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Snfen00::from_bits(val as u8)
            }
            #[doc = "Use of Noise Filter of RXD0 Pin"]
            #[inline(always)]
            pub fn set_snfen00(&mut self, val: super::vals::Snfen00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Use of Noise Filter of RXD1 Pin"]
            #[inline(always)]
            pub const fn snfen10(&self) -> super::vals::Snfen10 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Snfen10::from_bits(val as u8)
            }
            #[doc = "Use of Noise Filter of RXD1 Pin"]
            #[inline(always)]
            pub fn set_snfen10(&mut self, val: super::vals::Snfen10) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Use of Noise Filter of RXD2 Pin"]
            #[inline(always)]
            pub const fn snfen20(&self) -> super::vals::Snfen20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Snfen20::from_bits(val as u8)
            }
            #[doc = "Use of Noise Filter of RXD2 Pin"]
            #[inline(always)]
            pub fn set_snfen20(&mut self, val: super::vals::Snfen20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Snfen {
            #[inline(always)]
            fn default() -> Snfen {
                Snfen(0)
            }
        }
        impl core::fmt::Debug for Snfen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snfen")
                    .field("snfen00", &self.snfen00())
                    .field("snfen10", &self.snfen10())
                    .field("snfen20", &self.snfen20())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snfen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Snfen {{ snfen00: {:?}, snfen10: {:?}, snfen20: {:?} }}",
                    self.snfen00(),
                    self.snfen10(),
                    self.snfen20()
                )
            }
        }
        #[doc = "Timer Input Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tis0(pub u8);
        impl Tis0 {
            #[doc = "Selection of Timer Input Used with Channel 5"]
            #[inline(always)]
            pub const fn tis(&self) -> super::vals::Tis {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Tis::from_bits(val as u8)
            }
            #[doc = "Selection of Timer Input Used with Channel 5"]
            #[inline(always)]
            pub fn set_tis(&mut self, val: super::vals::Tis) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Tis0 {
            #[inline(always)]
            fn default() -> Tis0 {
                Tis0(0)
            }
        }
        impl core::fmt::Debug for Tis0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tis0").field("tis", &self.tis()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tis0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tis0 {{ tis: {:?} }}", self.tis())
            }
        }
        #[doc = "Timer Input Select Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tis1(pub u8);
        impl Tis1 {
            #[doc = "Selection of Timer Input Used with Channel 0"]
            #[inline(always)]
            pub const fn tis0(&self) -> super::vals::Tis0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tis0::from_bits(val as u8)
            }
            #[doc = "Selection of Timer Input Used with Channel 0"]
            #[inline(always)]
            pub fn set_tis0(&mut self, val: super::vals::Tis0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Selection of Timer Input Used with Channel 1"]
            #[inline(always)]
            pub const fn tis1(&self) -> super::vals::Tis1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tis1::from_bits(val as u8)
            }
            #[doc = "Selection of Timer Input Used with Channel 1"]
            #[inline(always)]
            pub fn set_tis1(&mut self, val: super::vals::Tis1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Tis1 {
            #[inline(always)]
            fn default() -> Tis1 {
                Tis1(0)
            }
        }
        impl core::fmt::Debug for Tis1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tis1")
                    .field("tis0", &self.tis0())
                    .field("tis1", &self.tis1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tis1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tis1 {{ tis0: {:?}, tis1: {:?} }}",
                    self.tis0(),
                    self.tis1()
                )
            }
        }
        #[doc = "TAU Noise Filter Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tnfen(pub u8);
        impl Tnfen {
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI00 Pin"]
            #[inline(always)]
            pub const fn tnfen00(&self) -> super::vals::Tnfen00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tnfen00::from_bits(val as u8)
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI00 Pin"]
            #[inline(always)]
            pub fn set_tnfen00(&mut self, val: super::vals::Tnfen00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI01 Pin"]
            #[inline(always)]
            pub const fn tnfen01(&self) -> super::vals::Tnfen01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tnfen01::from_bits(val as u8)
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI01 Pin"]
            #[inline(always)]
            pub fn set_tnfen01(&mut self, val: super::vals::Tnfen01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI02 Pin"]
            #[inline(always)]
            pub const fn tnfen02(&self) -> super::vals::Tnfen02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tnfen02::from_bits(val as u8)
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI02 Pin"]
            #[inline(always)]
            pub fn set_tnfen02(&mut self, val: super::vals::Tnfen02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI03 Pin"]
            #[inline(always)]
            pub const fn tnfen03(&self) -> super::vals::Tnfen03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tnfen03::from_bits(val as u8)
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI03 Pin"]
            #[inline(always)]
            pub fn set_tnfen03(&mut self, val: super::vals::Tnfen03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI04 Pin"]
            #[inline(always)]
            pub const fn tnfen04(&self) -> super::vals::Tnfen04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tnfen04::from_bits(val as u8)
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI04 Pin"]
            #[inline(always)]
            pub fn set_tnfen04(&mut self, val: super::vals::Tnfen04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI05 Pin"]
            #[inline(always)]
            pub const fn tnfen05(&self) -> super::vals::Tnfen05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tnfen05::from_bits(val as u8)
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI05 Pin"]
            #[inline(always)]
            pub fn set_tnfen05(&mut self, val: super::vals::Tnfen05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI06 Pin"]
            #[inline(always)]
            pub const fn tnfen06(&self) -> super::vals::Tnfen06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tnfen06::from_bits(val as u8)
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI06 Pin"]
            #[inline(always)]
            pub fn set_tnfen06(&mut self, val: super::vals::Tnfen06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI07 Pin"]
            #[inline(always)]
            pub const fn tnfen07(&self) -> super::vals::Tnfen07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tnfen07::from_bits(val as u8)
            }
            #[doc = "Enabling or Disabling Use of the Noise Filter for the TI07 Pin"]
            #[inline(always)]
            pub fn set_tnfen07(&mut self, val: super::vals::Tnfen07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Tnfen {
            #[inline(always)]
            fn default() -> Tnfen {
                Tnfen(0)
            }
        }
        impl core::fmt::Debug for Tnfen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tnfen")
                    .field("tnfen00", &self.tnfen00())
                    .field("tnfen01", &self.tnfen01())
                    .field("tnfen02", &self.tnfen02())
                    .field("tnfen03", &self.tnfen03())
                    .field("tnfen04", &self.tnfen04())
                    .field("tnfen05", &self.tnfen05())
                    .field("tnfen06", &self.tnfen06())
                    .field("tnfen07", &self.tnfen07())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tnfen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tnfen {{ tnfen00: {:?}, tnfen01: {:?}, tnfen02: {:?}, tnfen03: {:?}, tnfen04: {:?}, tnfen05: {:?}, tnfen06: {:?}, tnfen07: {:?} }}" , self . tnfen00 () , self . tnfen01 () , self . tnfen02 () , self . tnfen03 () , self . tnfen04 () , self . tnfen05 () , self . tnfen06 () , self . tnfen07 ())
            }
        }
        #[doc = "UART Loopback Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ulbs(pub u8);
        impl Ulbs {
            #[doc = "Selection of the UART0 Loopback Function"]
            #[inline(always)]
            pub const fn ulbs0(&self) -> super::vals::Ulbs0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ulbs0::from_bits(val as u8)
            }
            #[doc = "Selection of the UART0 Loopback Function"]
            #[inline(always)]
            pub fn set_ulbs0(&mut self, val: super::vals::Ulbs0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Selection of the UART1 Loopback Function"]
            #[inline(always)]
            pub const fn ulbs1(&self) -> super::vals::Ulbs1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ulbs1::from_bits(val as u8)
            }
            #[doc = "Selection of the UART1 Loopback Function"]
            #[inline(always)]
            pub fn set_ulbs1(&mut self, val: super::vals::Ulbs1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Selection of the UART2 Loopback Function"]
            #[inline(always)]
            pub const fn ulbs2(&self) -> super::vals::Ulbs2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ulbs2::from_bits(val as u8)
            }
            #[doc = "Selection of the UART2 Loopback Function"]
            #[inline(always)]
            pub fn set_ulbs2(&mut self, val: super::vals::Ulbs2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Selection of the UARTA Loopback Function"]
            #[inline(always)]
            pub const fn ulbs4(&self) -> super::vals::Ulbs4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ulbs4::from_bits(val as u8)
            }
            #[doc = "Selection of the UARTA Loopback Function"]
            #[inline(always)]
            pub fn set_ulbs4(&mut self, val: super::vals::Ulbs4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Ulbs {
            #[inline(always)]
            fn default() -> Ulbs {
                Ulbs(0)
            }
        }
        impl core::fmt::Debug for Ulbs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ulbs")
                    .field("ulbs0", &self.ulbs0())
                    .field("ulbs1", &self.ulbs1())
                    .field("ulbs2", &self.ulbs2())
                    .field("ulbs4", &self.ulbs4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ulbs {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ulbs {{ ulbs0: {:?}, ulbs1: {:?}, ulbs2: {:?}, ulbs4: {:?} }}",
                    self.ulbs0(),
                    self.ulbs1(),
                    self.ulbs2(),
                    self.ulbs4()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Isc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Isc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Isc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Isc0 {
            #[inline(always)]
            fn from(val: u8) -> Isc0 {
                Isc0::from_bits(val)
            }
        }
        impl From<Isc0> for u8 {
            #[inline(always)]
            fn from(val: Isc0) -> u8 {
                Isc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Isc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Isc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Isc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Isc1 {
            #[inline(always)]
            fn from(val: u8) -> Isc1 {
                Isc1::from_bits(val)
            }
        }
        impl From<Isc1> for u8 {
            #[inline(always)]
            fn from(val: Isc1) -> u8 {
                Isc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snfen00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snfen00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snfen00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snfen00 {
            #[inline(always)]
            fn from(val: u8) -> Snfen00 {
                Snfen00::from_bits(val)
            }
        }
        impl From<Snfen00> for u8 {
            #[inline(always)]
            fn from(val: Snfen00) -> u8 {
                Snfen00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snfen10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snfen10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snfen10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snfen10 {
            #[inline(always)]
            fn from(val: u8) -> Snfen10 {
                Snfen10::from_bits(val)
            }
        }
        impl From<Snfen10> for u8 {
            #[inline(always)]
            fn from(val: Snfen10) -> u8 {
                Snfen10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snfen20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snfen20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snfen20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snfen20 {
            #[inline(always)]
            fn from(val: u8) -> Snfen20 {
                Snfen20::from_bits(val)
            }
        }
        impl From<Snfen20> for u8 {
            #[inline(always)]
            fn from(val: Snfen20) -> u8 {
                Snfen20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssie00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssie00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssie00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssie00 {
            #[inline(always)]
            fn from(val: u8) -> Ssie00 {
                Ssie00::from_bits(val)
            }
        }
        impl From<Ssie00> for u8 {
            #[inline(always)]
            fn from(val: Ssie00) -> u8 {
                Ssie00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tis {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tis {
            #[inline(always)]
            fn from(val: u8) -> Tis {
                Tis::from_bits(val)
            }
        }
        impl From<Tis> for u8 {
            #[inline(always)]
            fn from(val: Tis) -> u8 {
                Tis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tis0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tis0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tis0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tis0 {
            #[inline(always)]
            fn from(val: u8) -> Tis0 {
                Tis0::from_bits(val)
            }
        }
        impl From<Tis0> for u8 {
            #[inline(always)]
            fn from(val: Tis0) -> u8 {
                Tis0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tis1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tis1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tis1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tis1 {
            #[inline(always)]
            fn from(val: u8) -> Tis1 {
                Tis1::from_bits(val)
            }
        }
        impl From<Tis1> for u8 {
            #[inline(always)]
            fn from(val: Tis1) -> u8 {
                Tis1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tnfen00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tnfen00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tnfen00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tnfen00 {
            #[inline(always)]
            fn from(val: u8) -> Tnfen00 {
                Tnfen00::from_bits(val)
            }
        }
        impl From<Tnfen00> for u8 {
            #[inline(always)]
            fn from(val: Tnfen00) -> u8 {
                Tnfen00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tnfen01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tnfen01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tnfen01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tnfen01 {
            #[inline(always)]
            fn from(val: u8) -> Tnfen01 {
                Tnfen01::from_bits(val)
            }
        }
        impl From<Tnfen01> for u8 {
            #[inline(always)]
            fn from(val: Tnfen01) -> u8 {
                Tnfen01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tnfen02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tnfen02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tnfen02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tnfen02 {
            #[inline(always)]
            fn from(val: u8) -> Tnfen02 {
                Tnfen02::from_bits(val)
            }
        }
        impl From<Tnfen02> for u8 {
            #[inline(always)]
            fn from(val: Tnfen02) -> u8 {
                Tnfen02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tnfen03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tnfen03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tnfen03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tnfen03 {
            #[inline(always)]
            fn from(val: u8) -> Tnfen03 {
                Tnfen03::from_bits(val)
            }
        }
        impl From<Tnfen03> for u8 {
            #[inline(always)]
            fn from(val: Tnfen03) -> u8 {
                Tnfen03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tnfen04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tnfen04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tnfen04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tnfen04 {
            #[inline(always)]
            fn from(val: u8) -> Tnfen04 {
                Tnfen04::from_bits(val)
            }
        }
        impl From<Tnfen04> for u8 {
            #[inline(always)]
            fn from(val: Tnfen04) -> u8 {
                Tnfen04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tnfen05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tnfen05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tnfen05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tnfen05 {
            #[inline(always)]
            fn from(val: u8) -> Tnfen05 {
                Tnfen05::from_bits(val)
            }
        }
        impl From<Tnfen05> for u8 {
            #[inline(always)]
            fn from(val: Tnfen05) -> u8 {
                Tnfen05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tnfen06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tnfen06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tnfen06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tnfen06 {
            #[inline(always)]
            fn from(val: u8) -> Tnfen06 {
                Tnfen06::from_bits(val)
            }
        }
        impl From<Tnfen06> for u8 {
            #[inline(always)]
            fn from(val: Tnfen06) -> u8 {
                Tnfen06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tnfen07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tnfen07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tnfen07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tnfen07 {
            #[inline(always)]
            fn from(val: u8) -> Tnfen07 {
                Tnfen07::from_bits(val)
            }
        }
        impl From<Tnfen07> for u8 {
            #[inline(always)]
            fn from(val: Tnfen07) -> u8 {
                Tnfen07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ulbs0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ulbs0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ulbs0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ulbs0 {
            #[inline(always)]
            fn from(val: u8) -> Ulbs0 {
                Ulbs0::from_bits(val)
            }
        }
        impl From<Ulbs0> for u8 {
            #[inline(always)]
            fn from(val: Ulbs0) -> u8 {
                Ulbs0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ulbs1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ulbs1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ulbs1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ulbs1 {
            #[inline(always)]
            fn from(val: u8) -> Ulbs1 {
                Ulbs1::from_bits(val)
            }
        }
        impl From<Ulbs1> for u8 {
            #[inline(always)]
            fn from(val: Ulbs1) -> u8 {
                Ulbs1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ulbs2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ulbs2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ulbs2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ulbs2 {
            #[inline(always)]
            fn from(val: u8) -> Ulbs2 {
                Ulbs2::from_bits(val)
            }
        }
        impl From<Ulbs2> for u8 {
            #[inline(always)]
            fn from(val: Ulbs2) -> u8 {
                Ulbs2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ulbs4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ulbs4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ulbs4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ulbs4 {
            #[inline(always)]
            fn from(val: u8) -> Ulbs4 {
                Ulbs4::from_bits(val)
            }
        }
        impl From<Ulbs4> for u8 {
            #[inline(always)]
            fn from(val: Ulbs4) -> u8 {
                Ulbs4::to_bits(val)
            }
        }
    }
}
pub mod port0 {
    #[doc = "Port 0 Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port0 {}
    unsafe impl Sync for Port0 {}
    impl Port0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port 0 Output Data Register"]
        #[inline(always)]
        pub const fn podr0(self) -> crate::common::Reg<regs::Podr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port 0 Direction Register"]
        #[inline(always)]
        pub const fn pdr0(self) -> crate::common::Reg<regs::Pdr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port 0 State Register"]
        #[inline(always)]
        pub const fn pidr0(self) -> crate::common::Reg<regs::Pidr0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port 0 Output Reset Register"]
        #[inline(always)]
        pub const fn porr0(self) -> crate::common::Reg<regs::Porr0, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port 0 Output Set Register"]
        #[inline(always)]
        pub const fn posr0(self) -> crate::common::Reg<regs::Posr0, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port 0 Direction Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr0(pub u16);
        impl Pdr0 {
            #[doc = "P008 Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::Pdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pdr08::from_bits(val as u8)
            }
            #[doc = "P008 Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::Pdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P009 Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::Pdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pdr09::from_bits(val as u8)
            }
            #[doc = "P009 Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::Pdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P010 Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::Pdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pdr10::from_bits(val as u8)
            }
            #[doc = "P010 Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::Pdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P011 Direction"]
            #[inline(always)]
            pub const fn pdr11(&self) -> super::vals::Pdr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pdr11::from_bits(val as u8)
            }
            #[doc = "P011 Direction"]
            #[inline(always)]
            pub fn set_pdr11(&mut self, val: super::vals::Pdr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "P012 Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::Pdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pdr12::from_bits(val as u8)
            }
            #[doc = "P012 Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::Pdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P013 Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::Pdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pdr13::from_bits(val as u8)
            }
            #[doc = "P013 Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::Pdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P014 Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::Pdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pdr14::from_bits(val as u8)
            }
            #[doc = "P014 Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::Pdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "P015 Direction"]
            #[inline(always)]
            pub const fn pdr15(&self) -> super::vals::Pdr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pdr15::from_bits(val as u8)
            }
            #[doc = "P015 Direction"]
            #[inline(always)]
            pub fn set_pdr15(&mut self, val: super::vals::Pdr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pdr0 {
            #[inline(always)]
            fn default() -> Pdr0 {
                Pdr0(0)
            }
        }
        impl core::fmt::Debug for Pdr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr0")
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr11", &self.pdr11())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .field("pdr15", &self.pdr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pdr0 {{ pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr11: {:?}, pdr12: {:?}, pdr13: {:?}, pdr14: {:?}, pdr15: {:?} }}" , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr11 () , self . pdr12 () , self . pdr13 () , self . pdr14 () , self . pdr15 ())
            }
        }
        #[doc = "Port 0 State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr0(pub u16);
        impl Pidr0 {
            #[doc = "P008 State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::Pidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pidr08::from_bits(val as u8)
            }
            #[doc = "P008 State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::Pidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P009 State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::Pidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pidr09::from_bits(val as u8)
            }
            #[doc = "P009 State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::Pidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P010 State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::Pidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pidr10::from_bits(val as u8)
            }
            #[doc = "P010 State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::Pidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P011 State"]
            #[inline(always)]
            pub const fn pidr11(&self) -> super::vals::Pidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pidr11::from_bits(val as u8)
            }
            #[doc = "P011 State"]
            #[inline(always)]
            pub fn set_pidr11(&mut self, val: super::vals::Pidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "P012 State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::Pidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pidr12::from_bits(val as u8)
            }
            #[doc = "P012 State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::Pidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P013 State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::Pidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pidr13::from_bits(val as u8)
            }
            #[doc = "P013 State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::Pidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P014 State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::Pidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pidr14::from_bits(val as u8)
            }
            #[doc = "P014 State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::Pidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "P015 State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::Pidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pidr15::from_bits(val as u8)
            }
            #[doc = "P015 State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::Pidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pidr0 {
            #[inline(always)]
            fn default() -> Pidr0 {
                Pidr0(0)
            }
        }
        impl core::fmt::Debug for Pidr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr0")
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr11", &self.pidr11())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pidr0 {{ pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr11: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?} }}" , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr11 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 ())
            }
        }
        #[doc = "Port 0 Output Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr0(pub u16);
        impl Podr0 {
            #[doc = "P008 Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::Podr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Podr08::from_bits(val as u8)
            }
            #[doc = "P008 Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::Podr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P009 Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::Podr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Podr09::from_bits(val as u8)
            }
            #[doc = "P009 Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::Podr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P010 Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::Podr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Podr10::from_bits(val as u8)
            }
            #[doc = "P010 Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::Podr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P011 Output Data"]
            #[inline(always)]
            pub const fn podr11(&self) -> super::vals::Podr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Podr11::from_bits(val as u8)
            }
            #[doc = "P011 Output Data"]
            #[inline(always)]
            pub fn set_podr11(&mut self, val: super::vals::Podr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "P012 Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::Podr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Podr12::from_bits(val as u8)
            }
            #[doc = "P012 Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::Podr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P013 Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::Podr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Podr13::from_bits(val as u8)
            }
            #[doc = "P013 Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::Podr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P014 Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::Podr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Podr14::from_bits(val as u8)
            }
            #[doc = "P014 Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::Podr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "P015 Output Data"]
            #[inline(always)]
            pub const fn podr15(&self) -> super::vals::Podr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Podr15::from_bits(val as u8)
            }
            #[doc = "P015 Output Data"]
            #[inline(always)]
            pub fn set_podr15(&mut self, val: super::vals::Podr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Podr0 {
            #[inline(always)]
            fn default() -> Podr0 {
                Podr0(0)
            }
        }
        impl core::fmt::Debug for Podr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr0")
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr11", &self.podr11())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .field("podr15", &self.podr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Podr0 {{ podr08: {:?}, podr09: {:?}, podr10: {:?}, podr11: {:?}, podr12: {:?}, podr13: {:?}, podr14: {:?}, podr15: {:?} }}" , self . podr08 () , self . podr09 () , self . podr10 () , self . podr11 () , self . podr12 () , self . podr13 () , self . podr14 () , self . podr15 ())
            }
        }
        #[doc = "Port 0 Output Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr0(pub u16);
        impl Porr0 {
            #[doc = "P008 Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::Porr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Porr08::from_bits(val as u8)
            }
            #[doc = "P008 Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::Porr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P009 Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::Porr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Porr09::from_bits(val as u8)
            }
            #[doc = "P009 Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::Porr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P010 Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::Porr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Porr10::from_bits(val as u8)
            }
            #[doc = "P010 Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::Porr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P011 Output Reset"]
            #[inline(always)]
            pub const fn porr11(&self) -> super::vals::Porr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Porr11::from_bits(val as u8)
            }
            #[doc = "P011 Output Reset"]
            #[inline(always)]
            pub fn set_porr11(&mut self, val: super::vals::Porr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "P012 Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::Porr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Porr12::from_bits(val as u8)
            }
            #[doc = "P012 Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::Porr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P013 Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::Porr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Porr13::from_bits(val as u8)
            }
            #[doc = "P013 Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::Porr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P014 Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::Porr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Porr14::from_bits(val as u8)
            }
            #[doc = "P014 Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::Porr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "P015 Output Reset"]
            #[inline(always)]
            pub const fn porr15(&self) -> super::vals::Porr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Porr15::from_bits(val as u8)
            }
            #[doc = "P015 Output Reset"]
            #[inline(always)]
            pub fn set_porr15(&mut self, val: super::vals::Porr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Porr0 {
            #[inline(always)]
            fn default() -> Porr0 {
                Porr0(0)
            }
        }
        impl core::fmt::Debug for Porr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr0")
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr11", &self.porr11())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .field("porr15", &self.porr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Porr0 {{ porr08: {:?}, porr09: {:?}, porr10: {:?}, porr11: {:?}, porr12: {:?}, porr13: {:?}, porr14: {:?}, porr15: {:?} }}" , self . porr08 () , self . porr09 () , self . porr10 () , self . porr11 () , self . porr12 () , self . porr13 () , self . porr14 () , self . porr15 ())
            }
        }
        #[doc = "Port 0 Output Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr0(pub u16);
        impl Posr0 {
            #[doc = "P008 Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::Posr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Posr08::from_bits(val as u8)
            }
            #[doc = "P008 Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::Posr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P009 Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::Posr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Posr09::from_bits(val as u8)
            }
            #[doc = "P009 Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::Posr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P010 Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::Posr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Posr10::from_bits(val as u8)
            }
            #[doc = "P010 Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::Posr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P011 Output Set"]
            #[inline(always)]
            pub const fn posr11(&self) -> super::vals::Posr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Posr11::from_bits(val as u8)
            }
            #[doc = "P011 Output Set"]
            #[inline(always)]
            pub fn set_posr11(&mut self, val: super::vals::Posr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "P012 Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::Posr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Posr12::from_bits(val as u8)
            }
            #[doc = "P012 Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::Posr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P013 Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::Posr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Posr13::from_bits(val as u8)
            }
            #[doc = "P013 Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::Posr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P014 Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::Posr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Posr14::from_bits(val as u8)
            }
            #[doc = "P014 Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::Posr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "P015 Output Set"]
            #[inline(always)]
            pub const fn posr15(&self) -> super::vals::Posr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Posr15::from_bits(val as u8)
            }
            #[doc = "P015 Output Set"]
            #[inline(always)]
            pub fn set_posr15(&mut self, val: super::vals::Posr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Posr0 {
            #[inline(always)]
            fn default() -> Posr0 {
                Posr0(0)
            }
        }
        impl core::fmt::Debug for Posr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr0")
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr11", &self.posr11())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .field("posr15", &self.posr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Posr0 {{ posr08: {:?}, posr09: {:?}, posr10: {:?}, posr11: {:?}, posr12: {:?}, posr13: {:?}, posr14: {:?}, posr15: {:?} }}" , self . posr08 () , self . posr09 () , self . posr10 () , self . posr11 () , self . posr12 () , self . posr13 () , self . posr14 () , self . posr15 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr08 {
            #[inline(always)]
            fn from(val: u8) -> Pdr08 {
                Pdr08::from_bits(val)
            }
        }
        impl From<Pdr08> for u8 {
            #[inline(always)]
            fn from(val: Pdr08) -> u8 {
                Pdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr09 {
            #[inline(always)]
            fn from(val: u8) -> Pdr09 {
                Pdr09::from_bits(val)
            }
        }
        impl From<Pdr09> for u8 {
            #[inline(always)]
            fn from(val: Pdr09) -> u8 {
                Pdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr10 {
            #[inline(always)]
            fn from(val: u8) -> Pdr10 {
                Pdr10::from_bits(val)
            }
        }
        impl From<Pdr10> for u8 {
            #[inline(always)]
            fn from(val: Pdr10) -> u8 {
                Pdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr11 {
            #[inline(always)]
            fn from(val: u8) -> Pdr11 {
                Pdr11::from_bits(val)
            }
        }
        impl From<Pdr11> for u8 {
            #[inline(always)]
            fn from(val: Pdr11) -> u8 {
                Pdr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr12 {
            #[inline(always)]
            fn from(val: u8) -> Pdr12 {
                Pdr12::from_bits(val)
            }
        }
        impl From<Pdr12> for u8 {
            #[inline(always)]
            fn from(val: Pdr12) -> u8 {
                Pdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr13 {
            #[inline(always)]
            fn from(val: u8) -> Pdr13 {
                Pdr13::from_bits(val)
            }
        }
        impl From<Pdr13> for u8 {
            #[inline(always)]
            fn from(val: Pdr13) -> u8 {
                Pdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr14 {
            #[inline(always)]
            fn from(val: u8) -> Pdr14 {
                Pdr14::from_bits(val)
            }
        }
        impl From<Pdr14> for u8 {
            #[inline(always)]
            fn from(val: Pdr14) -> u8 {
                Pdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr15 {
            #[inline(always)]
            fn from(val: u8) -> Pdr15 {
                Pdr15::from_bits(val)
            }
        }
        impl From<Pdr15> for u8 {
            #[inline(always)]
            fn from(val: Pdr15) -> u8 {
                Pdr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pidr08 {
                Pidr08::from_bits(val)
            }
        }
        impl From<Pidr08> for u8 {
            #[inline(always)]
            fn from(val: Pidr08) -> u8 {
                Pidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr09 {
            #[inline(always)]
            fn from(val: u8) -> Pidr09 {
                Pidr09::from_bits(val)
            }
        }
        impl From<Pidr09> for u8 {
            #[inline(always)]
            fn from(val: Pidr09) -> u8 {
                Pidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr10 {
            #[inline(always)]
            fn from(val: u8) -> Pidr10 {
                Pidr10::from_bits(val)
            }
        }
        impl From<Pidr10> for u8 {
            #[inline(always)]
            fn from(val: Pidr10) -> u8 {
                Pidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr11 {
            #[inline(always)]
            fn from(val: u8) -> Pidr11 {
                Pidr11::from_bits(val)
            }
        }
        impl From<Pidr11> for u8 {
            #[inline(always)]
            fn from(val: Pidr11) -> u8 {
                Pidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pidr12 {
                Pidr12::from_bits(val)
            }
        }
        impl From<Pidr12> for u8 {
            #[inline(always)]
            fn from(val: Pidr12) -> u8 {
                Pidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pidr13 {
                Pidr13::from_bits(val)
            }
        }
        impl From<Pidr13> for u8 {
            #[inline(always)]
            fn from(val: Pidr13) -> u8 {
                Pidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pidr14 {
                Pidr14::from_bits(val)
            }
        }
        impl From<Pidr14> for u8 {
            #[inline(always)]
            fn from(val: Pidr14) -> u8 {
                Pidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr15 {
            #[inline(always)]
            fn from(val: u8) -> Pidr15 {
                Pidr15::from_bits(val)
            }
        }
        impl From<Pidr15> for u8 {
            #[inline(always)]
            fn from(val: Pidr15) -> u8 {
                Pidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr08 {
            #[inline(always)]
            fn from(val: u8) -> Podr08 {
                Podr08::from_bits(val)
            }
        }
        impl From<Podr08> for u8 {
            #[inline(always)]
            fn from(val: Podr08) -> u8 {
                Podr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr09 {
            #[inline(always)]
            fn from(val: u8) -> Podr09 {
                Podr09::from_bits(val)
            }
        }
        impl From<Podr09> for u8 {
            #[inline(always)]
            fn from(val: Podr09) -> u8 {
                Podr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr10 {
            #[inline(always)]
            fn from(val: u8) -> Podr10 {
                Podr10::from_bits(val)
            }
        }
        impl From<Podr10> for u8 {
            #[inline(always)]
            fn from(val: Podr10) -> u8 {
                Podr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr11 {
            #[inline(always)]
            fn from(val: u8) -> Podr11 {
                Podr11::from_bits(val)
            }
        }
        impl From<Podr11> for u8 {
            #[inline(always)]
            fn from(val: Podr11) -> u8 {
                Podr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr12 {
            #[inline(always)]
            fn from(val: u8) -> Podr12 {
                Podr12::from_bits(val)
            }
        }
        impl From<Podr12> for u8 {
            #[inline(always)]
            fn from(val: Podr12) -> u8 {
                Podr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr13 {
            #[inline(always)]
            fn from(val: u8) -> Podr13 {
                Podr13::from_bits(val)
            }
        }
        impl From<Podr13> for u8 {
            #[inline(always)]
            fn from(val: Podr13) -> u8 {
                Podr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr14 {
            #[inline(always)]
            fn from(val: u8) -> Podr14 {
                Podr14::from_bits(val)
            }
        }
        impl From<Podr14> for u8 {
            #[inline(always)]
            fn from(val: Podr14) -> u8 {
                Podr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr15 {
            #[inline(always)]
            fn from(val: u8) -> Podr15 {
                Podr15::from_bits(val)
            }
        }
        impl From<Podr15> for u8 {
            #[inline(always)]
            fn from(val: Podr15) -> u8 {
                Podr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr08 {
            #[inline(always)]
            fn from(val: u8) -> Porr08 {
                Porr08::from_bits(val)
            }
        }
        impl From<Porr08> for u8 {
            #[inline(always)]
            fn from(val: Porr08) -> u8 {
                Porr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr09 {
            #[inline(always)]
            fn from(val: u8) -> Porr09 {
                Porr09::from_bits(val)
            }
        }
        impl From<Porr09> for u8 {
            #[inline(always)]
            fn from(val: Porr09) -> u8 {
                Porr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr10 {
            #[inline(always)]
            fn from(val: u8) -> Porr10 {
                Porr10::from_bits(val)
            }
        }
        impl From<Porr10> for u8 {
            #[inline(always)]
            fn from(val: Porr10) -> u8 {
                Porr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr11 {
            #[inline(always)]
            fn from(val: u8) -> Porr11 {
                Porr11::from_bits(val)
            }
        }
        impl From<Porr11> for u8 {
            #[inline(always)]
            fn from(val: Porr11) -> u8 {
                Porr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr12 {
            #[inline(always)]
            fn from(val: u8) -> Porr12 {
                Porr12::from_bits(val)
            }
        }
        impl From<Porr12> for u8 {
            #[inline(always)]
            fn from(val: Porr12) -> u8 {
                Porr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr13 {
            #[inline(always)]
            fn from(val: u8) -> Porr13 {
                Porr13::from_bits(val)
            }
        }
        impl From<Porr13> for u8 {
            #[inline(always)]
            fn from(val: Porr13) -> u8 {
                Porr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr14 {
            #[inline(always)]
            fn from(val: u8) -> Porr14 {
                Porr14::from_bits(val)
            }
        }
        impl From<Porr14> for u8 {
            #[inline(always)]
            fn from(val: Porr14) -> u8 {
                Porr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr15 {
            #[inline(always)]
            fn from(val: u8) -> Porr15 {
                Porr15::from_bits(val)
            }
        }
        impl From<Porr15> for u8 {
            #[inline(always)]
            fn from(val: Porr15) -> u8 {
                Porr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr08 {
            #[inline(always)]
            fn from(val: u8) -> Posr08 {
                Posr08::from_bits(val)
            }
        }
        impl From<Posr08> for u8 {
            #[inline(always)]
            fn from(val: Posr08) -> u8 {
                Posr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr09 {
            #[inline(always)]
            fn from(val: u8) -> Posr09 {
                Posr09::from_bits(val)
            }
        }
        impl From<Posr09> for u8 {
            #[inline(always)]
            fn from(val: Posr09) -> u8 {
                Posr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr10 {
            #[inline(always)]
            fn from(val: u8) -> Posr10 {
                Posr10::from_bits(val)
            }
        }
        impl From<Posr10> for u8 {
            #[inline(always)]
            fn from(val: Posr10) -> u8 {
                Posr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr11 {
            #[inline(always)]
            fn from(val: u8) -> Posr11 {
                Posr11::from_bits(val)
            }
        }
        impl From<Posr11> for u8 {
            #[inline(always)]
            fn from(val: Posr11) -> u8 {
                Posr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr12 {
            #[inline(always)]
            fn from(val: u8) -> Posr12 {
                Posr12::from_bits(val)
            }
        }
        impl From<Posr12> for u8 {
            #[inline(always)]
            fn from(val: Posr12) -> u8 {
                Posr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr13 {
            #[inline(always)]
            fn from(val: u8) -> Posr13 {
                Posr13::from_bits(val)
            }
        }
        impl From<Posr13> for u8 {
            #[inline(always)]
            fn from(val: Posr13) -> u8 {
                Posr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr14 {
            #[inline(always)]
            fn from(val: u8) -> Posr14 {
                Posr14::from_bits(val)
            }
        }
        impl From<Posr14> for u8 {
            #[inline(always)]
            fn from(val: Posr14) -> u8 {
                Posr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr15 {
            #[inline(always)]
            fn from(val: u8) -> Posr15 {
                Posr15::from_bits(val)
            }
        }
        impl From<Posr15> for u8 {
            #[inline(always)]
            fn from(val: Posr15) -> u8 {
                Posr15::to_bits(val)
            }
        }
    }
}
pub mod port1 {
    #[doc = "Port 1 Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port1 {}
    unsafe impl Sync for Port1 {}
    impl Port1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port 1 Output Data Register"]
        #[inline(always)]
        pub const fn podr1(self) -> crate::common::Reg<regs::Podr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port 1 Direction Register"]
        #[inline(always)]
        pub const fn pdr1(self) -> crate::common::Reg<regs::Pdr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port 1 State Register"]
        #[inline(always)]
        pub const fn pidr1(self) -> crate::common::Reg<regs::Pidr1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port 1 Output Reset Register"]
        #[inline(always)]
        pub const fn porr1(self) -> crate::common::Reg<regs::Porr1, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port 1 Output Set Register"]
        #[inline(always)]
        pub const fn posr1(self) -> crate::common::Reg<regs::Posr1, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Port 1 Event Output Reset Register"]
        #[inline(always)]
        pub const fn eorr1(self) -> crate::common::Reg<regs::Eorr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Port 1 Event Output Set Register"]
        #[inline(always)]
        pub const fn eosr1(self) -> crate::common::Reg<regs::Eosr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port 1 Event Output Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eorr1(pub u16);
        impl Eorr1 {
            #[doc = "P100 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr00(&self) -> super::vals::Eorr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Eorr00::from_bits(val as u8)
            }
            #[doc = "P100 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr00(&mut self, val: super::vals::Eorr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "P101 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr01(&self) -> super::vals::Eorr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Eorr01::from_bits(val as u8)
            }
            #[doc = "P101 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr01(&mut self, val: super::vals::Eorr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P102 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr02(&self) -> super::vals::Eorr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Eorr02::from_bits(val as u8)
            }
            #[doc = "P102 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr02(&mut self, val: super::vals::Eorr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "P103 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr03(&self) -> super::vals::Eorr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Eorr03::from_bits(val as u8)
            }
            #[doc = "P103 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr03(&mut self, val: super::vals::Eorr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "P108 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr08(&self) -> super::vals::Eorr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Eorr08::from_bits(val as u8)
            }
            #[doc = "P108 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr08(&mut self, val: super::vals::Eorr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P109 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr09(&self) -> super::vals::Eorr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Eorr09::from_bits(val as u8)
            }
            #[doc = "P109 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr09(&mut self, val: super::vals::Eorr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P110 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr10(&self) -> super::vals::Eorr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Eorr10::from_bits(val as u8)
            }
            #[doc = "P110 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr10(&mut self, val: super::vals::Eorr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P112 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr12(&self) -> super::vals::Eorr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Eorr12::from_bits(val as u8)
            }
            #[doc = "P112 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr12(&mut self, val: super::vals::Eorr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Eorr1 {
            #[inline(always)]
            fn default() -> Eorr1 {
                Eorr1(0)
            }
        }
        impl core::fmt::Debug for Eorr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eorr1")
                    .field("eorr00", &self.eorr00())
                    .field("eorr01", &self.eorr01())
                    .field("eorr02", &self.eorr02())
                    .field("eorr03", &self.eorr03())
                    .field("eorr08", &self.eorr08())
                    .field("eorr09", &self.eorr09())
                    .field("eorr10", &self.eorr10())
                    .field("eorr12", &self.eorr12())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eorr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eorr1 {{ eorr00: {:?}, eorr01: {:?}, eorr02: {:?}, eorr03: {:?}, eorr08: {:?}, eorr09: {:?}, eorr10: {:?}, eorr12: {:?} }}" , self . eorr00 () , self . eorr01 () , self . eorr02 () , self . eorr03 () , self . eorr08 () , self . eorr09 () , self . eorr10 () , self . eorr12 ())
            }
        }
        #[doc = "Port 1 Event Output Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eosr1(pub u16);
        impl Eosr1 {
            #[doc = "P100 Event Output Set"]
            #[inline(always)]
            pub const fn eosr00(&self) -> super::vals::Eosr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Eosr00::from_bits(val as u8)
            }
            #[doc = "P100 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr00(&mut self, val: super::vals::Eosr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "P101 Event Output Set"]
            #[inline(always)]
            pub const fn eosr01(&self) -> super::vals::Eosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Eosr01::from_bits(val as u8)
            }
            #[doc = "P101 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr01(&mut self, val: super::vals::Eosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P102 Event Output Set"]
            #[inline(always)]
            pub const fn eosr02(&self) -> super::vals::Eosr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Eosr02::from_bits(val as u8)
            }
            #[doc = "P102 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr02(&mut self, val: super::vals::Eosr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "P103 Event Output Set"]
            #[inline(always)]
            pub const fn eosr03(&self) -> super::vals::Eosr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Eosr03::from_bits(val as u8)
            }
            #[doc = "P103 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr03(&mut self, val: super::vals::Eosr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "P108 Event Output Set"]
            #[inline(always)]
            pub const fn eosr08(&self) -> super::vals::Eosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Eosr08::from_bits(val as u8)
            }
            #[doc = "P108 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr08(&mut self, val: super::vals::Eosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P109 Event Output Set"]
            #[inline(always)]
            pub const fn eosr09(&self) -> super::vals::Eosr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Eosr09::from_bits(val as u8)
            }
            #[doc = "P109 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr09(&mut self, val: super::vals::Eosr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P110 Event Output Set"]
            #[inline(always)]
            pub const fn eosr10(&self) -> super::vals::Eosr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Eosr10::from_bits(val as u8)
            }
            #[doc = "P110 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr10(&mut self, val: super::vals::Eosr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P112 Event Output Set"]
            #[inline(always)]
            pub const fn eosr12(&self) -> super::vals::Eosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Eosr12::from_bits(val as u8)
            }
            #[doc = "P112 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr12(&mut self, val: super::vals::Eosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Eosr1 {
            #[inline(always)]
            fn default() -> Eosr1 {
                Eosr1(0)
            }
        }
        impl core::fmt::Debug for Eosr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eosr1")
                    .field("eosr00", &self.eosr00())
                    .field("eosr01", &self.eosr01())
                    .field("eosr02", &self.eosr02())
                    .field("eosr03", &self.eosr03())
                    .field("eosr08", &self.eosr08())
                    .field("eosr09", &self.eosr09())
                    .field("eosr10", &self.eosr10())
                    .field("eosr12", &self.eosr12())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eosr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eosr1 {{ eosr00: {:?}, eosr01: {:?}, eosr02: {:?}, eosr03: {:?}, eosr08: {:?}, eosr09: {:?}, eosr10: {:?}, eosr12: {:?} }}" , self . eosr00 () , self . eosr01 () , self . eosr02 () , self . eosr03 () , self . eosr08 () , self . eosr09 () , self . eosr10 () , self . eosr12 ())
            }
        }
        #[doc = "Port 1 Direction Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr1(pub u16);
        impl Pdr1 {
            #[doc = "P100 Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::Pdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pdr00::from_bits(val as u8)
            }
            #[doc = "P100 Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::Pdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "P101 Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::Pdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pdr01::from_bits(val as u8)
            }
            #[doc = "P101 Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::Pdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P102 Direction"]
            #[inline(always)]
            pub const fn pdr02(&self) -> super::vals::Pdr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pdr02::from_bits(val as u8)
            }
            #[doc = "P102 Direction"]
            #[inline(always)]
            pub fn set_pdr02(&mut self, val: super::vals::Pdr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "P103 Direction"]
            #[inline(always)]
            pub const fn pdr03(&self) -> super::vals::Pdr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pdr03::from_bits(val as u8)
            }
            #[doc = "P103 Direction"]
            #[inline(always)]
            pub fn set_pdr03(&mut self, val: super::vals::Pdr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "P108 Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::Pdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pdr08::from_bits(val as u8)
            }
            #[doc = "P108 Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::Pdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P109 Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::Pdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pdr09::from_bits(val as u8)
            }
            #[doc = "P109 Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::Pdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P110 Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::Pdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pdr10::from_bits(val as u8)
            }
            #[doc = "P110 Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::Pdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P112 Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::Pdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pdr12::from_bits(val as u8)
            }
            #[doc = "P112 Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::Pdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Pdr1 {
            #[inline(always)]
            fn default() -> Pdr1 {
                Pdr1(0)
            }
        }
        impl core::fmt::Debug for Pdr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr1")
                    .field("pdr00", &self.pdr00())
                    .field("pdr01", &self.pdr01())
                    .field("pdr02", &self.pdr02())
                    .field("pdr03", &self.pdr03())
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr12", &self.pdr12())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pdr1 {{ pdr00: {:?}, pdr01: {:?}, pdr02: {:?}, pdr03: {:?}, pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr12: {:?} }}" , self . pdr00 () , self . pdr01 () , self . pdr02 () , self . pdr03 () , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr12 ())
            }
        }
        #[doc = "Port 1 State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr1(pub u16);
        impl Pidr1 {
            #[doc = "P100 State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::Pidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pidr00::from_bits(val as u8)
            }
            #[doc = "P100 State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::Pidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "P101 State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::Pidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pidr01::from_bits(val as u8)
            }
            #[doc = "P101 State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::Pidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P102 State"]
            #[inline(always)]
            pub const fn pidr02(&self) -> super::vals::Pidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pidr02::from_bits(val as u8)
            }
            #[doc = "P102 State"]
            #[inline(always)]
            pub fn set_pidr02(&mut self, val: super::vals::Pidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "P103 State"]
            #[inline(always)]
            pub const fn pidr03(&self) -> super::vals::Pidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pidr03::from_bits(val as u8)
            }
            #[doc = "P103 State"]
            #[inline(always)]
            pub fn set_pidr03(&mut self, val: super::vals::Pidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "P108 State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::Pidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pidr08::from_bits(val as u8)
            }
            #[doc = "P108 State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::Pidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P109 State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::Pidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pidr09::from_bits(val as u8)
            }
            #[doc = "P109 State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::Pidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P110 State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::Pidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pidr10::from_bits(val as u8)
            }
            #[doc = "P110 State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::Pidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P112 State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::Pidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pidr12::from_bits(val as u8)
            }
            #[doc = "P112 State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::Pidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Pidr1 {
            #[inline(always)]
            fn default() -> Pidr1 {
                Pidr1(0)
            }
        }
        impl core::fmt::Debug for Pidr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr1")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr02", &self.pidr02())
                    .field("pidr03", &self.pidr03())
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr12", &self.pidr12())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pidr1 {{ pidr00: {:?}, pidr01: {:?}, pidr02: {:?}, pidr03: {:?}, pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr12: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr02 () , self . pidr03 () , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr12 ())
            }
        }
        #[doc = "Port 1 Output Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr1(pub u16);
        impl Podr1 {
            #[doc = "P100 Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::Podr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Podr00::from_bits(val as u8)
            }
            #[doc = "P100 Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::Podr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "P101 Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::Podr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Podr01::from_bits(val as u8)
            }
            #[doc = "P101 Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::Podr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P102 Output Data"]
            #[inline(always)]
            pub const fn podr02(&self) -> super::vals::Podr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Podr02::from_bits(val as u8)
            }
            #[doc = "P102 Output Data"]
            #[inline(always)]
            pub fn set_podr02(&mut self, val: super::vals::Podr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "P103 Output Data"]
            #[inline(always)]
            pub const fn podr03(&self) -> super::vals::Podr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Podr03::from_bits(val as u8)
            }
            #[doc = "P103 Output Data"]
            #[inline(always)]
            pub fn set_podr03(&mut self, val: super::vals::Podr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "P108 Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::Podr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Podr08::from_bits(val as u8)
            }
            #[doc = "P108 Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::Podr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P109 Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::Podr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Podr09::from_bits(val as u8)
            }
            #[doc = "P109 Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::Podr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P110 Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::Podr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Podr10::from_bits(val as u8)
            }
            #[doc = "P110 Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::Podr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P112 Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::Podr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Podr12::from_bits(val as u8)
            }
            #[doc = "P112 Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::Podr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Podr1 {
            #[inline(always)]
            fn default() -> Podr1 {
                Podr1(0)
            }
        }
        impl core::fmt::Debug for Podr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr1")
                    .field("podr00", &self.podr00())
                    .field("podr01", &self.podr01())
                    .field("podr02", &self.podr02())
                    .field("podr03", &self.podr03())
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr12", &self.podr12())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Podr1 {{ podr00: {:?}, podr01: {:?}, podr02: {:?}, podr03: {:?}, podr08: {:?}, podr09: {:?}, podr10: {:?}, podr12: {:?} }}" , self . podr00 () , self . podr01 () , self . podr02 () , self . podr03 () , self . podr08 () , self . podr09 () , self . podr10 () , self . podr12 ())
            }
        }
        #[doc = "Port 1 Output Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr1(pub u16);
        impl Porr1 {
            #[doc = "P100 Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::Porr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Porr00::from_bits(val as u8)
            }
            #[doc = "P100 Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::Porr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "P101 Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::Porr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Porr01::from_bits(val as u8)
            }
            #[doc = "P101 Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::Porr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P102 Output Reset"]
            #[inline(always)]
            pub const fn porr02(&self) -> super::vals::Porr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Porr02::from_bits(val as u8)
            }
            #[doc = "P102 Output Reset"]
            #[inline(always)]
            pub fn set_porr02(&mut self, val: super::vals::Porr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "P103 Output Reset"]
            #[inline(always)]
            pub const fn porr03(&self) -> super::vals::Porr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Porr03::from_bits(val as u8)
            }
            #[doc = "P103 Output Reset"]
            #[inline(always)]
            pub fn set_porr03(&mut self, val: super::vals::Porr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "P108 Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::Porr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Porr08::from_bits(val as u8)
            }
            #[doc = "P108 Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::Porr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P109 Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::Porr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Porr09::from_bits(val as u8)
            }
            #[doc = "P109 Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::Porr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P110 Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::Porr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Porr10::from_bits(val as u8)
            }
            #[doc = "P110 Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::Porr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P112 Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::Porr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Porr12::from_bits(val as u8)
            }
            #[doc = "P112 Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::Porr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Porr1 {
            #[inline(always)]
            fn default() -> Porr1 {
                Porr1(0)
            }
        }
        impl core::fmt::Debug for Porr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr1")
                    .field("porr00", &self.porr00())
                    .field("porr01", &self.porr01())
                    .field("porr02", &self.porr02())
                    .field("porr03", &self.porr03())
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr12", &self.porr12())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Porr1 {{ porr00: {:?}, porr01: {:?}, porr02: {:?}, porr03: {:?}, porr08: {:?}, porr09: {:?}, porr10: {:?}, porr12: {:?} }}" , self . porr00 () , self . porr01 () , self . porr02 () , self . porr03 () , self . porr08 () , self . porr09 () , self . porr10 () , self . porr12 ())
            }
        }
        #[doc = "Port 1 Output Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr1(pub u16);
        impl Posr1 {
            #[doc = "P100 Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::Posr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Posr00::from_bits(val as u8)
            }
            #[doc = "P100 Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::Posr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "P101 Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::Posr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Posr01::from_bits(val as u8)
            }
            #[doc = "P101 Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::Posr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P102 Output Set"]
            #[inline(always)]
            pub const fn posr02(&self) -> super::vals::Posr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Posr02::from_bits(val as u8)
            }
            #[doc = "P102 Output Set"]
            #[inline(always)]
            pub fn set_posr02(&mut self, val: super::vals::Posr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "P103 Output Set"]
            #[inline(always)]
            pub const fn posr03(&self) -> super::vals::Posr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Posr03::from_bits(val as u8)
            }
            #[doc = "P103 Output Set"]
            #[inline(always)]
            pub fn set_posr03(&mut self, val: super::vals::Posr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "P108 Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::Posr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Posr08::from_bits(val as u8)
            }
            #[doc = "P108 Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::Posr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P109 Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::Posr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Posr09::from_bits(val as u8)
            }
            #[doc = "P109 Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::Posr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "P110 Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::Posr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Posr10::from_bits(val as u8)
            }
            #[doc = "P110 Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::Posr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "P112 Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::Posr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Posr12::from_bits(val as u8)
            }
            #[doc = "P112 Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::Posr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Posr1 {
            #[inline(always)]
            fn default() -> Posr1 {
                Posr1(0)
            }
        }
        impl core::fmt::Debug for Posr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr1")
                    .field("posr00", &self.posr00())
                    .field("posr01", &self.posr01())
                    .field("posr02", &self.posr02())
                    .field("posr03", &self.posr03())
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr12", &self.posr12())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Posr1 {{ posr00: {:?}, posr01: {:?}, posr02: {:?}, posr03: {:?}, posr08: {:?}, posr09: {:?}, posr10: {:?}, posr12: {:?} }}" , self . posr00 () , self . posr01 () , self . posr02 () , self . posr03 () , self . posr08 () , self . posr09 () , self . posr10 () , self . posr12 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr00 {
            #[inline(always)]
            fn from(val: u8) -> Eorr00 {
                Eorr00::from_bits(val)
            }
        }
        impl From<Eorr00> for u8 {
            #[inline(always)]
            fn from(val: Eorr00) -> u8 {
                Eorr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr01 {
            #[inline(always)]
            fn from(val: u8) -> Eorr01 {
                Eorr01::from_bits(val)
            }
        }
        impl From<Eorr01> for u8 {
            #[inline(always)]
            fn from(val: Eorr01) -> u8 {
                Eorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr02 {
            #[inline(always)]
            fn from(val: u8) -> Eorr02 {
                Eorr02::from_bits(val)
            }
        }
        impl From<Eorr02> for u8 {
            #[inline(always)]
            fn from(val: Eorr02) -> u8 {
                Eorr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr03 {
            #[inline(always)]
            fn from(val: u8) -> Eorr03 {
                Eorr03::from_bits(val)
            }
        }
        impl From<Eorr03> for u8 {
            #[inline(always)]
            fn from(val: Eorr03) -> u8 {
                Eorr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr08 {
            #[inline(always)]
            fn from(val: u8) -> Eorr08 {
                Eorr08::from_bits(val)
            }
        }
        impl From<Eorr08> for u8 {
            #[inline(always)]
            fn from(val: Eorr08) -> u8 {
                Eorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr09 {
            #[inline(always)]
            fn from(val: u8) -> Eorr09 {
                Eorr09::from_bits(val)
            }
        }
        impl From<Eorr09> for u8 {
            #[inline(always)]
            fn from(val: Eorr09) -> u8 {
                Eorr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr10 {
            #[inline(always)]
            fn from(val: u8) -> Eorr10 {
                Eorr10::from_bits(val)
            }
        }
        impl From<Eorr10> for u8 {
            #[inline(always)]
            fn from(val: Eorr10) -> u8 {
                Eorr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr12 {
            #[inline(always)]
            fn from(val: u8) -> Eorr12 {
                Eorr12::from_bits(val)
            }
        }
        impl From<Eorr12> for u8 {
            #[inline(always)]
            fn from(val: Eorr12) -> u8 {
                Eorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr00 {
            #[inline(always)]
            fn from(val: u8) -> Eosr00 {
                Eosr00::from_bits(val)
            }
        }
        impl From<Eosr00> for u8 {
            #[inline(always)]
            fn from(val: Eosr00) -> u8 {
                Eosr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr01 {
            #[inline(always)]
            fn from(val: u8) -> Eosr01 {
                Eosr01::from_bits(val)
            }
        }
        impl From<Eosr01> for u8 {
            #[inline(always)]
            fn from(val: Eosr01) -> u8 {
                Eosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr02 {
            #[inline(always)]
            fn from(val: u8) -> Eosr02 {
                Eosr02::from_bits(val)
            }
        }
        impl From<Eosr02> for u8 {
            #[inline(always)]
            fn from(val: Eosr02) -> u8 {
                Eosr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr03 {
            #[inline(always)]
            fn from(val: u8) -> Eosr03 {
                Eosr03::from_bits(val)
            }
        }
        impl From<Eosr03> for u8 {
            #[inline(always)]
            fn from(val: Eosr03) -> u8 {
                Eosr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr08 {
            #[inline(always)]
            fn from(val: u8) -> Eosr08 {
                Eosr08::from_bits(val)
            }
        }
        impl From<Eosr08> for u8 {
            #[inline(always)]
            fn from(val: Eosr08) -> u8 {
                Eosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr09 {
            #[inline(always)]
            fn from(val: u8) -> Eosr09 {
                Eosr09::from_bits(val)
            }
        }
        impl From<Eosr09> for u8 {
            #[inline(always)]
            fn from(val: Eosr09) -> u8 {
                Eosr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr10 {
            #[inline(always)]
            fn from(val: u8) -> Eosr10 {
                Eosr10::from_bits(val)
            }
        }
        impl From<Eosr10> for u8 {
            #[inline(always)]
            fn from(val: Eosr10) -> u8 {
                Eosr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr12 {
            #[inline(always)]
            fn from(val: u8) -> Eosr12 {
                Eosr12::from_bits(val)
            }
        }
        impl From<Eosr12> for u8 {
            #[inline(always)]
            fn from(val: Eosr12) -> u8 {
                Eosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr00 {
            #[inline(always)]
            fn from(val: u8) -> Pdr00 {
                Pdr00::from_bits(val)
            }
        }
        impl From<Pdr00> for u8 {
            #[inline(always)]
            fn from(val: Pdr00) -> u8 {
                Pdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr01 {
            #[inline(always)]
            fn from(val: u8) -> Pdr01 {
                Pdr01::from_bits(val)
            }
        }
        impl From<Pdr01> for u8 {
            #[inline(always)]
            fn from(val: Pdr01) -> u8 {
                Pdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr02 {
            #[inline(always)]
            fn from(val: u8) -> Pdr02 {
                Pdr02::from_bits(val)
            }
        }
        impl From<Pdr02> for u8 {
            #[inline(always)]
            fn from(val: Pdr02) -> u8 {
                Pdr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr03 {
            #[inline(always)]
            fn from(val: u8) -> Pdr03 {
                Pdr03::from_bits(val)
            }
        }
        impl From<Pdr03> for u8 {
            #[inline(always)]
            fn from(val: Pdr03) -> u8 {
                Pdr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr08 {
            #[inline(always)]
            fn from(val: u8) -> Pdr08 {
                Pdr08::from_bits(val)
            }
        }
        impl From<Pdr08> for u8 {
            #[inline(always)]
            fn from(val: Pdr08) -> u8 {
                Pdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr09 {
            #[inline(always)]
            fn from(val: u8) -> Pdr09 {
                Pdr09::from_bits(val)
            }
        }
        impl From<Pdr09> for u8 {
            #[inline(always)]
            fn from(val: Pdr09) -> u8 {
                Pdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr10 {
            #[inline(always)]
            fn from(val: u8) -> Pdr10 {
                Pdr10::from_bits(val)
            }
        }
        impl From<Pdr10> for u8 {
            #[inline(always)]
            fn from(val: Pdr10) -> u8 {
                Pdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr12 {
            #[inline(always)]
            fn from(val: u8) -> Pdr12 {
                Pdr12::from_bits(val)
            }
        }
        impl From<Pdr12> for u8 {
            #[inline(always)]
            fn from(val: Pdr12) -> u8 {
                Pdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pidr00 {
                Pidr00::from_bits(val)
            }
        }
        impl From<Pidr00> for u8 {
            #[inline(always)]
            fn from(val: Pidr00) -> u8 {
                Pidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr01 {
            #[inline(always)]
            fn from(val: u8) -> Pidr01 {
                Pidr01::from_bits(val)
            }
        }
        impl From<Pidr01> for u8 {
            #[inline(always)]
            fn from(val: Pidr01) -> u8 {
                Pidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr02 {
            #[inline(always)]
            fn from(val: u8) -> Pidr02 {
                Pidr02::from_bits(val)
            }
        }
        impl From<Pidr02> for u8 {
            #[inline(always)]
            fn from(val: Pidr02) -> u8 {
                Pidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr03 {
            #[inline(always)]
            fn from(val: u8) -> Pidr03 {
                Pidr03::from_bits(val)
            }
        }
        impl From<Pidr03> for u8 {
            #[inline(always)]
            fn from(val: Pidr03) -> u8 {
                Pidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pidr08 {
                Pidr08::from_bits(val)
            }
        }
        impl From<Pidr08> for u8 {
            #[inline(always)]
            fn from(val: Pidr08) -> u8 {
                Pidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr09 {
            #[inline(always)]
            fn from(val: u8) -> Pidr09 {
                Pidr09::from_bits(val)
            }
        }
        impl From<Pidr09> for u8 {
            #[inline(always)]
            fn from(val: Pidr09) -> u8 {
                Pidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr10 {
            #[inline(always)]
            fn from(val: u8) -> Pidr10 {
                Pidr10::from_bits(val)
            }
        }
        impl From<Pidr10> for u8 {
            #[inline(always)]
            fn from(val: Pidr10) -> u8 {
                Pidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pidr12 {
                Pidr12::from_bits(val)
            }
        }
        impl From<Pidr12> for u8 {
            #[inline(always)]
            fn from(val: Pidr12) -> u8 {
                Pidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr00 {
            #[inline(always)]
            fn from(val: u8) -> Podr00 {
                Podr00::from_bits(val)
            }
        }
        impl From<Podr00> for u8 {
            #[inline(always)]
            fn from(val: Podr00) -> u8 {
                Podr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr01 {
            #[inline(always)]
            fn from(val: u8) -> Podr01 {
                Podr01::from_bits(val)
            }
        }
        impl From<Podr01> for u8 {
            #[inline(always)]
            fn from(val: Podr01) -> u8 {
                Podr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr02 {
            #[inline(always)]
            fn from(val: u8) -> Podr02 {
                Podr02::from_bits(val)
            }
        }
        impl From<Podr02> for u8 {
            #[inline(always)]
            fn from(val: Podr02) -> u8 {
                Podr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr03 {
            #[inline(always)]
            fn from(val: u8) -> Podr03 {
                Podr03::from_bits(val)
            }
        }
        impl From<Podr03> for u8 {
            #[inline(always)]
            fn from(val: Podr03) -> u8 {
                Podr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr08 {
            #[inline(always)]
            fn from(val: u8) -> Podr08 {
                Podr08::from_bits(val)
            }
        }
        impl From<Podr08> for u8 {
            #[inline(always)]
            fn from(val: Podr08) -> u8 {
                Podr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr09 {
            #[inline(always)]
            fn from(val: u8) -> Podr09 {
                Podr09::from_bits(val)
            }
        }
        impl From<Podr09> for u8 {
            #[inline(always)]
            fn from(val: Podr09) -> u8 {
                Podr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr10 {
            #[inline(always)]
            fn from(val: u8) -> Podr10 {
                Podr10::from_bits(val)
            }
        }
        impl From<Podr10> for u8 {
            #[inline(always)]
            fn from(val: Podr10) -> u8 {
                Podr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr12 {
            #[inline(always)]
            fn from(val: u8) -> Podr12 {
                Podr12::from_bits(val)
            }
        }
        impl From<Podr12> for u8 {
            #[inline(always)]
            fn from(val: Podr12) -> u8 {
                Podr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr00 {
            #[inline(always)]
            fn from(val: u8) -> Porr00 {
                Porr00::from_bits(val)
            }
        }
        impl From<Porr00> for u8 {
            #[inline(always)]
            fn from(val: Porr00) -> u8 {
                Porr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr01 {
            #[inline(always)]
            fn from(val: u8) -> Porr01 {
                Porr01::from_bits(val)
            }
        }
        impl From<Porr01> for u8 {
            #[inline(always)]
            fn from(val: Porr01) -> u8 {
                Porr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr02 {
            #[inline(always)]
            fn from(val: u8) -> Porr02 {
                Porr02::from_bits(val)
            }
        }
        impl From<Porr02> for u8 {
            #[inline(always)]
            fn from(val: Porr02) -> u8 {
                Porr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr03 {
            #[inline(always)]
            fn from(val: u8) -> Porr03 {
                Porr03::from_bits(val)
            }
        }
        impl From<Porr03> for u8 {
            #[inline(always)]
            fn from(val: Porr03) -> u8 {
                Porr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr08 {
            #[inline(always)]
            fn from(val: u8) -> Porr08 {
                Porr08::from_bits(val)
            }
        }
        impl From<Porr08> for u8 {
            #[inline(always)]
            fn from(val: Porr08) -> u8 {
                Porr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr09 {
            #[inline(always)]
            fn from(val: u8) -> Porr09 {
                Porr09::from_bits(val)
            }
        }
        impl From<Porr09> for u8 {
            #[inline(always)]
            fn from(val: Porr09) -> u8 {
                Porr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr10 {
            #[inline(always)]
            fn from(val: u8) -> Porr10 {
                Porr10::from_bits(val)
            }
        }
        impl From<Porr10> for u8 {
            #[inline(always)]
            fn from(val: Porr10) -> u8 {
                Porr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr12 {
            #[inline(always)]
            fn from(val: u8) -> Porr12 {
                Porr12::from_bits(val)
            }
        }
        impl From<Porr12> for u8 {
            #[inline(always)]
            fn from(val: Porr12) -> u8 {
                Porr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr00 {
            #[inline(always)]
            fn from(val: u8) -> Posr00 {
                Posr00::from_bits(val)
            }
        }
        impl From<Posr00> for u8 {
            #[inline(always)]
            fn from(val: Posr00) -> u8 {
                Posr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr01 {
            #[inline(always)]
            fn from(val: u8) -> Posr01 {
                Posr01::from_bits(val)
            }
        }
        impl From<Posr01> for u8 {
            #[inline(always)]
            fn from(val: Posr01) -> u8 {
                Posr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr02 {
            #[inline(always)]
            fn from(val: u8) -> Posr02 {
                Posr02::from_bits(val)
            }
        }
        impl From<Posr02> for u8 {
            #[inline(always)]
            fn from(val: Posr02) -> u8 {
                Posr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr03 {
            #[inline(always)]
            fn from(val: u8) -> Posr03 {
                Posr03::from_bits(val)
            }
        }
        impl From<Posr03> for u8 {
            #[inline(always)]
            fn from(val: Posr03) -> u8 {
                Posr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr08 {
            #[inline(always)]
            fn from(val: u8) -> Posr08 {
                Posr08::from_bits(val)
            }
        }
        impl From<Posr08> for u8 {
            #[inline(always)]
            fn from(val: Posr08) -> u8 {
                Posr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr09 {
            #[inline(always)]
            fn from(val: u8) -> Posr09 {
                Posr09::from_bits(val)
            }
        }
        impl From<Posr09> for u8 {
            #[inline(always)]
            fn from(val: Posr09) -> u8 {
                Posr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr10 {
            #[inline(always)]
            fn from(val: u8) -> Posr10 {
                Posr10::from_bits(val)
            }
        }
        impl From<Posr10> for u8 {
            #[inline(always)]
            fn from(val: Posr10) -> u8 {
                Posr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr12 {
            #[inline(always)]
            fn from(val: u8) -> Posr12 {
                Posr12::from_bits(val)
            }
        }
        impl From<Posr12> for u8 {
            #[inline(always)]
            fn from(val: Posr12) -> u8 {
                Posr12::to_bits(val)
            }
        }
    }
}
pub mod port2 {
    #[doc = "Port 2 Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port2 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port2 {}
    unsafe impl Sync for Port2 {}
    impl Port2 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port 2 Output Data Register"]
        #[inline(always)]
        pub const fn podr2(self) -> crate::common::Reg<regs::Podr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port 2 Direction Register"]
        #[inline(always)]
        pub const fn pdr2(self) -> crate::common::Reg<regs::Pdr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port 2 State Register"]
        #[inline(always)]
        pub const fn pidr2(self) -> crate::common::Reg<regs::Pidr2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port 2 Output Reset Register"]
        #[inline(always)]
        pub const fn porr2(self) -> crate::common::Reg<regs::Porr2, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port 2 Output Set Register"]
        #[inline(always)]
        pub const fn posr2(self) -> crate::common::Reg<regs::Posr2, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Port 2 Event Output Reset Register"]
        #[inline(always)]
        pub const fn eorr2(self) -> crate::common::Reg<regs::Eorr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Port 2 Event Output Set Register"]
        #[inline(always)]
        pub const fn eosr2(self) -> crate::common::Reg<regs::Eosr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port 2 Event Output Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eorr2(pub u16);
        impl Eorr2 {
            #[doc = "P201 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr01(&self) -> super::vals::Eorr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Eorr01::from_bits(val as u8)
            }
            #[doc = "P201 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr01(&mut self, val: super::vals::Eorr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P206 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr06(&self) -> super::vals::Eorr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Eorr06::from_bits(val as u8)
            }
            #[doc = "P206 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr06(&mut self, val: super::vals::Eorr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "P207 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr07(&self) -> super::vals::Eorr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Eorr07::from_bits(val as u8)
            }
            #[doc = "P207 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr07(&mut self, val: super::vals::Eorr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "P208 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr08(&self) -> super::vals::Eorr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Eorr08::from_bits(val as u8)
            }
            #[doc = "P208 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr08(&mut self, val: super::vals::Eorr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P212 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr12(&self) -> super::vals::Eorr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Eorr12::from_bits(val as u8)
            }
            #[doc = "P212 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr12(&mut self, val: super::vals::Eorr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P213 Event Output Reset"]
            #[inline(always)]
            pub const fn eorr13(&self) -> super::vals::Eorr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Eorr13::from_bits(val as u8)
            }
            #[doc = "P213 Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr13(&mut self, val: super::vals::Eorr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
        }
        impl Default for Eorr2 {
            #[inline(always)]
            fn default() -> Eorr2 {
                Eorr2(0)
            }
        }
        impl core::fmt::Debug for Eorr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eorr2")
                    .field("eorr01", &self.eorr01())
                    .field("eorr06", &self.eorr06())
                    .field("eorr07", &self.eorr07())
                    .field("eorr08", &self.eorr08())
                    .field("eorr12", &self.eorr12())
                    .field("eorr13", &self.eorr13())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eorr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eorr2 {{ eorr01: {:?}, eorr06: {:?}, eorr07: {:?}, eorr08: {:?}, eorr12: {:?}, eorr13: {:?} }}" , self . eorr01 () , self . eorr06 () , self . eorr07 () , self . eorr08 () , self . eorr12 () , self . eorr13 ())
            }
        }
        #[doc = "Port 2 Event Output Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eosr2(pub u16);
        impl Eosr2 {
            #[doc = "P201 Event Output Set"]
            #[inline(always)]
            pub const fn eosr01(&self) -> super::vals::Eosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Eosr01::from_bits(val as u8)
            }
            #[doc = "P201 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr01(&mut self, val: super::vals::Eosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P206 Event Output Set"]
            #[inline(always)]
            pub const fn eosr06(&self) -> super::vals::Eosr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Eosr06::from_bits(val as u8)
            }
            #[doc = "P206 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr06(&mut self, val: super::vals::Eosr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "P207 Event Output Set"]
            #[inline(always)]
            pub const fn eosr07(&self) -> super::vals::Eosr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Eosr07::from_bits(val as u8)
            }
            #[doc = "P207 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr07(&mut self, val: super::vals::Eosr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "P208 Event Output Set"]
            #[inline(always)]
            pub const fn eosr08(&self) -> super::vals::Eosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Eosr08::from_bits(val as u8)
            }
            #[doc = "P208 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr08(&mut self, val: super::vals::Eosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P212 Event Output Set"]
            #[inline(always)]
            pub const fn eosr12(&self) -> super::vals::Eosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Eosr12::from_bits(val as u8)
            }
            #[doc = "P212 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr12(&mut self, val: super::vals::Eosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P213 Event Output Set"]
            #[inline(always)]
            pub const fn eosr13(&self) -> super::vals::Eosr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Eosr13::from_bits(val as u8)
            }
            #[doc = "P213 Event Output Set"]
            #[inline(always)]
            pub fn set_eosr13(&mut self, val: super::vals::Eosr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
        }
        impl Default for Eosr2 {
            #[inline(always)]
            fn default() -> Eosr2 {
                Eosr2(0)
            }
        }
        impl core::fmt::Debug for Eosr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eosr2")
                    .field("eosr01", &self.eosr01())
                    .field("eosr06", &self.eosr06())
                    .field("eosr07", &self.eosr07())
                    .field("eosr08", &self.eosr08())
                    .field("eosr12", &self.eosr12())
                    .field("eosr13", &self.eosr13())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eosr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eosr2 {{ eosr01: {:?}, eosr06: {:?}, eosr07: {:?}, eosr08: {:?}, eosr12: {:?}, eosr13: {:?} }}" , self . eosr01 () , self . eosr06 () , self . eosr07 () , self . eosr08 () , self . eosr12 () , self . eosr13 ())
            }
        }
        #[doc = "Port 2 Direction Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr2(pub u16);
        impl Pdr2 {
            #[doc = "P201 Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::Pdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pdr01::from_bits(val as u8)
            }
            #[doc = "P201 Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::Pdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P206 Direction"]
            #[inline(always)]
            pub const fn pdr06(&self) -> super::vals::Pdr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pdr06::from_bits(val as u8)
            }
            #[doc = "P206 Direction"]
            #[inline(always)]
            pub fn set_pdr06(&mut self, val: super::vals::Pdr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "P207 Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::Pdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pdr07::from_bits(val as u8)
            }
            #[doc = "P207 Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::Pdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "P208 Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::Pdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pdr08::from_bits(val as u8)
            }
            #[doc = "P208 Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::Pdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P212 Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::Pdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pdr12::from_bits(val as u8)
            }
            #[doc = "P212 Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::Pdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P213 Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::Pdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pdr13::from_bits(val as u8)
            }
            #[doc = "P213 Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::Pdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
        }
        impl Default for Pdr2 {
            #[inline(always)]
            fn default() -> Pdr2 {
                Pdr2(0)
            }
        }
        impl core::fmt::Debug for Pdr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr2")
                    .field("pdr01", &self.pdr01())
                    .field("pdr06", &self.pdr06())
                    .field("pdr07", &self.pdr07())
                    .field("pdr08", &self.pdr08())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pdr2 {{ pdr01: {:?}, pdr06: {:?}, pdr07: {:?}, pdr08: {:?}, pdr12: {:?}, pdr13: {:?} }}" , self . pdr01 () , self . pdr06 () , self . pdr07 () , self . pdr08 () , self . pdr12 () , self . pdr13 ())
            }
        }
        #[doc = "Port 2 State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr2(pub u16);
        impl Pidr2 {
            #[doc = "P200 State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::Pidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pidr00::from_bits(val as u8)
            }
            #[doc = "P200 State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::Pidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "P201 State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::Pidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pidr01::from_bits(val as u8)
            }
            #[doc = "P201 State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::Pidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P206 State"]
            #[inline(always)]
            pub const fn pidr06(&self) -> super::vals::Pidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pidr06::from_bits(val as u8)
            }
            #[doc = "P206 State"]
            #[inline(always)]
            pub fn set_pidr06(&mut self, val: super::vals::Pidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "P207 State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::Pidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pidr07::from_bits(val as u8)
            }
            #[doc = "P207 State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::Pidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "P208 State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::Pidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pidr08::from_bits(val as u8)
            }
            #[doc = "P208 State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::Pidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P212 State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::Pidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pidr12::from_bits(val as u8)
            }
            #[doc = "P212 State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::Pidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P213 State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::Pidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pidr13::from_bits(val as u8)
            }
            #[doc = "P213 State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::Pidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P214 State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::Pidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pidr14::from_bits(val as u8)
            }
            #[doc = "P214 State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::Pidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "P215 State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::Pidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pidr15::from_bits(val as u8)
            }
            #[doc = "P215 State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::Pidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pidr2 {
            #[inline(always)]
            fn default() -> Pidr2 {
                Pidr2(0)
            }
        }
        impl core::fmt::Debug for Pidr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr2")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr06", &self.pidr06())
                    .field("pidr07", &self.pidr07())
                    .field("pidr08", &self.pidr08())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pidr2 {{ pidr00: {:?}, pidr01: {:?}, pidr06: {:?}, pidr07: {:?}, pidr08: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr06 () , self . pidr07 () , self . pidr08 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 ())
            }
        }
        #[doc = "Port 2 Output Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr2(pub u16);
        impl Podr2 {
            #[doc = "P201 Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::Podr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Podr01::from_bits(val as u8)
            }
            #[doc = "P201 Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::Podr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P206 Output Data"]
            #[inline(always)]
            pub const fn podr06(&self) -> super::vals::Podr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Podr06::from_bits(val as u8)
            }
            #[doc = "P206 Output Data"]
            #[inline(always)]
            pub fn set_podr06(&mut self, val: super::vals::Podr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "P207 Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::Podr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Podr07::from_bits(val as u8)
            }
            #[doc = "P207 Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::Podr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "P208 Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::Podr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Podr08::from_bits(val as u8)
            }
            #[doc = "P208 Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::Podr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P212 Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::Podr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Podr12::from_bits(val as u8)
            }
            #[doc = "P212 Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::Podr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P213 Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::Podr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Podr13::from_bits(val as u8)
            }
            #[doc = "P213 Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::Podr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
        }
        impl Default for Podr2 {
            #[inline(always)]
            fn default() -> Podr2 {
                Podr2(0)
            }
        }
        impl core::fmt::Debug for Podr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr2")
                    .field("podr01", &self.podr01())
                    .field("podr06", &self.podr06())
                    .field("podr07", &self.podr07())
                    .field("podr08", &self.podr08())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Podr2 {{ podr01: {:?}, podr06: {:?}, podr07: {:?}, podr08: {:?}, podr12: {:?}, podr13: {:?} }}" , self . podr01 () , self . podr06 () , self . podr07 () , self . podr08 () , self . podr12 () , self . podr13 ())
            }
        }
        #[doc = "Port 2 Output Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr2(pub u16);
        impl Porr2 {
            #[doc = "P201 Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::Porr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Porr01::from_bits(val as u8)
            }
            #[doc = "P201 Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::Porr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P206 Output Reset"]
            #[inline(always)]
            pub const fn porr06(&self) -> super::vals::Porr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Porr06::from_bits(val as u8)
            }
            #[doc = "P206 Output Reset"]
            #[inline(always)]
            pub fn set_porr06(&mut self, val: super::vals::Porr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "P207 Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::Porr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Porr07::from_bits(val as u8)
            }
            #[doc = "P207 Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::Porr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "P208 Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::Porr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Porr08::from_bits(val as u8)
            }
            #[doc = "P208 Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::Porr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P212 Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::Porr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Porr12::from_bits(val as u8)
            }
            #[doc = "P212 Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::Porr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P213 Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::Porr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Porr13::from_bits(val as u8)
            }
            #[doc = "P213 Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::Porr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
        }
        impl Default for Porr2 {
            #[inline(always)]
            fn default() -> Porr2 {
                Porr2(0)
            }
        }
        impl core::fmt::Debug for Porr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr2")
                    .field("porr01", &self.porr01())
                    .field("porr06", &self.porr06())
                    .field("porr07", &self.porr07())
                    .field("porr08", &self.porr08())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Porr2 {{ porr01: {:?}, porr06: {:?}, porr07: {:?}, porr08: {:?}, porr12: {:?}, porr13: {:?} }}" , self . porr01 () , self . porr06 () , self . porr07 () , self . porr08 () , self . porr12 () , self . porr13 ())
            }
        }
        #[doc = "Port 2 Output Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr2(pub u16);
        impl Posr2 {
            #[doc = "P201 Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::Posr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Posr01::from_bits(val as u8)
            }
            #[doc = "P201 Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::Posr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "P206 Output Set"]
            #[inline(always)]
            pub const fn posr06(&self) -> super::vals::Posr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Posr06::from_bits(val as u8)
            }
            #[doc = "P206 Output Set"]
            #[inline(always)]
            pub fn set_posr06(&mut self, val: super::vals::Posr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "P207 Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::Posr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Posr07::from_bits(val as u8)
            }
            #[doc = "P207 Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::Posr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "P208 Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::Posr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Posr08::from_bits(val as u8)
            }
            #[doc = "P208 Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::Posr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "P212 Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::Posr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Posr12::from_bits(val as u8)
            }
            #[doc = "P212 Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::Posr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "P213 Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::Posr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Posr13::from_bits(val as u8)
            }
            #[doc = "P213 Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::Posr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
        }
        impl Default for Posr2 {
            #[inline(always)]
            fn default() -> Posr2 {
                Posr2(0)
            }
        }
        impl core::fmt::Debug for Posr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr2")
                    .field("posr01", &self.posr01())
                    .field("posr06", &self.posr06())
                    .field("posr07", &self.posr07())
                    .field("posr08", &self.posr08())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Posr2 {{ posr01: {:?}, posr06: {:?}, posr07: {:?}, posr08: {:?}, posr12: {:?}, posr13: {:?} }}" , self . posr01 () , self . posr06 () , self . posr07 () , self . posr08 () , self . posr12 () , self . posr13 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr01 {
            #[inline(always)]
            fn from(val: u8) -> Eorr01 {
                Eorr01::from_bits(val)
            }
        }
        impl From<Eorr01> for u8 {
            #[inline(always)]
            fn from(val: Eorr01) -> u8 {
                Eorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr06 {
            #[inline(always)]
            fn from(val: u8) -> Eorr06 {
                Eorr06::from_bits(val)
            }
        }
        impl From<Eorr06> for u8 {
            #[inline(always)]
            fn from(val: Eorr06) -> u8 {
                Eorr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr07 {
            #[inline(always)]
            fn from(val: u8) -> Eorr07 {
                Eorr07::from_bits(val)
            }
        }
        impl From<Eorr07> for u8 {
            #[inline(always)]
            fn from(val: Eorr07) -> u8 {
                Eorr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr08 {
            #[inline(always)]
            fn from(val: u8) -> Eorr08 {
                Eorr08::from_bits(val)
            }
        }
        impl From<Eorr08> for u8 {
            #[inline(always)]
            fn from(val: Eorr08) -> u8 {
                Eorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr12 {
            #[inline(always)]
            fn from(val: u8) -> Eorr12 {
                Eorr12::from_bits(val)
            }
        }
        impl From<Eorr12> for u8 {
            #[inline(always)]
            fn from(val: Eorr12) -> u8 {
                Eorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eorr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eorr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eorr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eorr13 {
            #[inline(always)]
            fn from(val: u8) -> Eorr13 {
                Eorr13::from_bits(val)
            }
        }
        impl From<Eorr13> for u8 {
            #[inline(always)]
            fn from(val: Eorr13) -> u8 {
                Eorr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr01 {
            #[inline(always)]
            fn from(val: u8) -> Eosr01 {
                Eosr01::from_bits(val)
            }
        }
        impl From<Eosr01> for u8 {
            #[inline(always)]
            fn from(val: Eosr01) -> u8 {
                Eosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr06 {
            #[inline(always)]
            fn from(val: u8) -> Eosr06 {
                Eosr06::from_bits(val)
            }
        }
        impl From<Eosr06> for u8 {
            #[inline(always)]
            fn from(val: Eosr06) -> u8 {
                Eosr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr07 {
            #[inline(always)]
            fn from(val: u8) -> Eosr07 {
                Eosr07::from_bits(val)
            }
        }
        impl From<Eosr07> for u8 {
            #[inline(always)]
            fn from(val: Eosr07) -> u8 {
                Eosr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr08 {
            #[inline(always)]
            fn from(val: u8) -> Eosr08 {
                Eosr08::from_bits(val)
            }
        }
        impl From<Eosr08> for u8 {
            #[inline(always)]
            fn from(val: Eosr08) -> u8 {
                Eosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr12 {
            #[inline(always)]
            fn from(val: u8) -> Eosr12 {
                Eosr12::from_bits(val)
            }
        }
        impl From<Eosr12> for u8 {
            #[inline(always)]
            fn from(val: Eosr12) -> u8 {
                Eosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eosr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eosr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eosr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eosr13 {
            #[inline(always)]
            fn from(val: u8) -> Eosr13 {
                Eosr13::from_bits(val)
            }
        }
        impl From<Eosr13> for u8 {
            #[inline(always)]
            fn from(val: Eosr13) -> u8 {
                Eosr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr01 {
            #[inline(always)]
            fn from(val: u8) -> Pdr01 {
                Pdr01::from_bits(val)
            }
        }
        impl From<Pdr01> for u8 {
            #[inline(always)]
            fn from(val: Pdr01) -> u8 {
                Pdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr06 {
            #[inline(always)]
            fn from(val: u8) -> Pdr06 {
                Pdr06::from_bits(val)
            }
        }
        impl From<Pdr06> for u8 {
            #[inline(always)]
            fn from(val: Pdr06) -> u8 {
                Pdr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr07 {
            #[inline(always)]
            fn from(val: u8) -> Pdr07 {
                Pdr07::from_bits(val)
            }
        }
        impl From<Pdr07> for u8 {
            #[inline(always)]
            fn from(val: Pdr07) -> u8 {
                Pdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr08 {
            #[inline(always)]
            fn from(val: u8) -> Pdr08 {
                Pdr08::from_bits(val)
            }
        }
        impl From<Pdr08> for u8 {
            #[inline(always)]
            fn from(val: Pdr08) -> u8 {
                Pdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr12 {
            #[inline(always)]
            fn from(val: u8) -> Pdr12 {
                Pdr12::from_bits(val)
            }
        }
        impl From<Pdr12> for u8 {
            #[inline(always)]
            fn from(val: Pdr12) -> u8 {
                Pdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr13 {
            #[inline(always)]
            fn from(val: u8) -> Pdr13 {
                Pdr13::from_bits(val)
            }
        }
        impl From<Pdr13> for u8 {
            #[inline(always)]
            fn from(val: Pdr13) -> u8 {
                Pdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pidr00 {
                Pidr00::from_bits(val)
            }
        }
        impl From<Pidr00> for u8 {
            #[inline(always)]
            fn from(val: Pidr00) -> u8 {
                Pidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr01 {
            #[inline(always)]
            fn from(val: u8) -> Pidr01 {
                Pidr01::from_bits(val)
            }
        }
        impl From<Pidr01> for u8 {
            #[inline(always)]
            fn from(val: Pidr01) -> u8 {
                Pidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr06 {
            #[inline(always)]
            fn from(val: u8) -> Pidr06 {
                Pidr06::from_bits(val)
            }
        }
        impl From<Pidr06> for u8 {
            #[inline(always)]
            fn from(val: Pidr06) -> u8 {
                Pidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr07 {
            #[inline(always)]
            fn from(val: u8) -> Pidr07 {
                Pidr07::from_bits(val)
            }
        }
        impl From<Pidr07> for u8 {
            #[inline(always)]
            fn from(val: Pidr07) -> u8 {
                Pidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pidr08 {
                Pidr08::from_bits(val)
            }
        }
        impl From<Pidr08> for u8 {
            #[inline(always)]
            fn from(val: Pidr08) -> u8 {
                Pidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pidr12 {
                Pidr12::from_bits(val)
            }
        }
        impl From<Pidr12> for u8 {
            #[inline(always)]
            fn from(val: Pidr12) -> u8 {
                Pidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pidr13 {
                Pidr13::from_bits(val)
            }
        }
        impl From<Pidr13> for u8 {
            #[inline(always)]
            fn from(val: Pidr13) -> u8 {
                Pidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pidr14 {
                Pidr14::from_bits(val)
            }
        }
        impl From<Pidr14> for u8 {
            #[inline(always)]
            fn from(val: Pidr14) -> u8 {
                Pidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr15 {
            #[inline(always)]
            fn from(val: u8) -> Pidr15 {
                Pidr15::from_bits(val)
            }
        }
        impl From<Pidr15> for u8 {
            #[inline(always)]
            fn from(val: Pidr15) -> u8 {
                Pidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr01 {
            #[inline(always)]
            fn from(val: u8) -> Podr01 {
                Podr01::from_bits(val)
            }
        }
        impl From<Podr01> for u8 {
            #[inline(always)]
            fn from(val: Podr01) -> u8 {
                Podr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr06 {
            #[inline(always)]
            fn from(val: u8) -> Podr06 {
                Podr06::from_bits(val)
            }
        }
        impl From<Podr06> for u8 {
            #[inline(always)]
            fn from(val: Podr06) -> u8 {
                Podr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr07 {
            #[inline(always)]
            fn from(val: u8) -> Podr07 {
                Podr07::from_bits(val)
            }
        }
        impl From<Podr07> for u8 {
            #[inline(always)]
            fn from(val: Podr07) -> u8 {
                Podr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr08 {
            #[inline(always)]
            fn from(val: u8) -> Podr08 {
                Podr08::from_bits(val)
            }
        }
        impl From<Podr08> for u8 {
            #[inline(always)]
            fn from(val: Podr08) -> u8 {
                Podr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr12 {
            #[inline(always)]
            fn from(val: u8) -> Podr12 {
                Podr12::from_bits(val)
            }
        }
        impl From<Podr12> for u8 {
            #[inline(always)]
            fn from(val: Podr12) -> u8 {
                Podr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr13 {
            #[inline(always)]
            fn from(val: u8) -> Podr13 {
                Podr13::from_bits(val)
            }
        }
        impl From<Podr13> for u8 {
            #[inline(always)]
            fn from(val: Podr13) -> u8 {
                Podr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr01 {
            #[inline(always)]
            fn from(val: u8) -> Porr01 {
                Porr01::from_bits(val)
            }
        }
        impl From<Porr01> for u8 {
            #[inline(always)]
            fn from(val: Porr01) -> u8 {
                Porr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr06 {
            #[inline(always)]
            fn from(val: u8) -> Porr06 {
                Porr06::from_bits(val)
            }
        }
        impl From<Porr06> for u8 {
            #[inline(always)]
            fn from(val: Porr06) -> u8 {
                Porr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr07 {
            #[inline(always)]
            fn from(val: u8) -> Porr07 {
                Porr07::from_bits(val)
            }
        }
        impl From<Porr07> for u8 {
            #[inline(always)]
            fn from(val: Porr07) -> u8 {
                Porr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr08 {
            #[inline(always)]
            fn from(val: u8) -> Porr08 {
                Porr08::from_bits(val)
            }
        }
        impl From<Porr08> for u8 {
            #[inline(always)]
            fn from(val: Porr08) -> u8 {
                Porr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr12 {
            #[inline(always)]
            fn from(val: u8) -> Porr12 {
                Porr12::from_bits(val)
            }
        }
        impl From<Porr12> for u8 {
            #[inline(always)]
            fn from(val: Porr12) -> u8 {
                Porr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr13 {
            #[inline(always)]
            fn from(val: u8) -> Porr13 {
                Porr13::from_bits(val)
            }
        }
        impl From<Porr13> for u8 {
            #[inline(always)]
            fn from(val: Porr13) -> u8 {
                Porr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr01 {
            #[inline(always)]
            fn from(val: u8) -> Posr01 {
                Posr01::from_bits(val)
            }
        }
        impl From<Posr01> for u8 {
            #[inline(always)]
            fn from(val: Posr01) -> u8 {
                Posr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr06 {
            #[inline(always)]
            fn from(val: u8) -> Posr06 {
                Posr06::from_bits(val)
            }
        }
        impl From<Posr06> for u8 {
            #[inline(always)]
            fn from(val: Posr06) -> u8 {
                Posr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr07 {
            #[inline(always)]
            fn from(val: u8) -> Posr07 {
                Posr07::from_bits(val)
            }
        }
        impl From<Posr07> for u8 {
            #[inline(always)]
            fn from(val: Posr07) -> u8 {
                Posr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr08 {
            #[inline(always)]
            fn from(val: u8) -> Posr08 {
                Posr08::from_bits(val)
            }
        }
        impl From<Posr08> for u8 {
            #[inline(always)]
            fn from(val: Posr08) -> u8 {
                Posr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr12 {
            #[inline(always)]
            fn from(val: u8) -> Posr12 {
                Posr12::from_bits(val)
            }
        }
        impl From<Posr12> for u8 {
            #[inline(always)]
            fn from(val: Posr12) -> u8 {
                Posr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr13 {
            #[inline(always)]
            fn from(val: u8) -> Posr13 {
                Posr13::from_bits(val)
            }
        }
        impl From<Posr13> for u8 {
            #[inline(always)]
            fn from(val: Posr13) -> u8 {
                Posr13::to_bits(val)
            }
        }
    }
}
pub mod port3 {
    #[doc = "Port 3 Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port3 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port3 {}
    unsafe impl Sync for Port3 {}
    impl Port3 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port 3 Output Data Register"]
        #[inline(always)]
        pub const fn podr3(self) -> crate::common::Reg<regs::Podr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port 3 Direction Register"]
        #[inline(always)]
        pub const fn pdr3(self) -> crate::common::Reg<regs::Pdr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port 3 State Register"]
        #[inline(always)]
        pub const fn pidr3(self) -> crate::common::Reg<regs::Pidr3, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port 3 Output Reset Register"]
        #[inline(always)]
        pub const fn porr3(self) -> crate::common::Reg<regs::Porr3, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port 3 Output Set Register"]
        #[inline(always)]
        pub const fn posr3(self) -> crate::common::Reg<regs::Posr3, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port 3 Direction Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr3(pub u16);
        impl Pdr3 {
            #[doc = "P300 Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::Pdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pdr00::from_bits(val as u8)
            }
            #[doc = "P300 Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::Pdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Pdr3 {
            #[inline(always)]
            fn default() -> Pdr3 {
                Pdr3(0)
            }
        }
        impl core::fmt::Debug for Pdr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr3")
                    .field("pdr00", &self.pdr00())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pdr3 {{ pdr00: {:?} }}", self.pdr00())
            }
        }
        #[doc = "Port 3 State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr3(pub u16);
        impl Pidr3 {
            #[doc = "P300 State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::Pidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pidr00::from_bits(val as u8)
            }
            #[doc = "P300 State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::Pidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Pidr3 {
            #[inline(always)]
            fn default() -> Pidr3 {
                Pidr3(0)
            }
        }
        impl core::fmt::Debug for Pidr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr3")
                    .field("pidr00", &self.pidr00())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pidr3 {{ pidr00: {:?} }}", self.pidr00())
            }
        }
        #[doc = "Port 3 Output Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr3(pub u16);
        impl Podr3 {
            #[doc = "P300 Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::Podr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Podr00::from_bits(val as u8)
            }
            #[doc = "P300 Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::Podr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Podr3 {
            #[inline(always)]
            fn default() -> Podr3 {
                Podr3(0)
            }
        }
        impl core::fmt::Debug for Podr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr3")
                    .field("podr00", &self.podr00())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Podr3 {{ podr00: {:?} }}", self.podr00())
            }
        }
        #[doc = "Port 3 Output Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr3(pub u16);
        impl Porr3 {
            #[doc = "P300 Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::Porr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Porr00::from_bits(val as u8)
            }
            #[doc = "P300 Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::Porr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Porr3 {
            #[inline(always)]
            fn default() -> Porr3 {
                Porr3(0)
            }
        }
        impl core::fmt::Debug for Porr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr3")
                    .field("porr00", &self.porr00())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Porr3 {{ porr00: {:?} }}", self.porr00())
            }
        }
        #[doc = "Port 3 Output Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr3(pub u16);
        impl Posr3 {
            #[doc = "P300 Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::Posr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Posr00::from_bits(val as u8)
            }
            #[doc = "P300 Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::Posr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Posr3 {
            #[inline(always)]
            fn default() -> Posr3 {
                Posr3(0)
            }
        }
        impl core::fmt::Debug for Posr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr3")
                    .field("posr00", &self.posr00())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Posr3 {{ posr00: {:?} }}", self.posr00())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr00 {
            #[inline(always)]
            fn from(val: u8) -> Pdr00 {
                Pdr00::from_bits(val)
            }
        }
        impl From<Pdr00> for u8 {
            #[inline(always)]
            fn from(val: Pdr00) -> u8 {
                Pdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pidr00 {
                Pidr00::from_bits(val)
            }
        }
        impl From<Pidr00> for u8 {
            #[inline(always)]
            fn from(val: Pidr00) -> u8 {
                Pidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr00 {
            #[inline(always)]
            fn from(val: u8) -> Podr00 {
                Podr00::from_bits(val)
            }
        }
        impl From<Podr00> for u8 {
            #[inline(always)]
            fn from(val: Podr00) -> u8 {
                Podr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr00 {
            #[inline(always)]
            fn from(val: u8) -> Porr00 {
                Porr00::from_bits(val)
            }
        }
        impl From<Porr00> for u8 {
            #[inline(always)]
            fn from(val: Porr00) -> u8 {
                Porr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr00 {
            #[inline(always)]
            fn from(val: u8) -> Posr00 {
                Posr00::from_bits(val)
            }
        }
        impl From<Posr00> for u8 {
            #[inline(always)]
            fn from(val: Posr00) -> u8 {
                Posr00::to_bits(val)
            }
        }
    }
}
pub mod port4 {
    #[doc = "Port 4 Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port4 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port4 {}
    unsafe impl Sync for Port4 {}
    impl Port4 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port 4 Output Data Register"]
        #[inline(always)]
        pub const fn podr4(self) -> crate::common::Reg<regs::Podr4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port 4 Direction Register"]
        #[inline(always)]
        pub const fn pdr4(self) -> crate::common::Reg<regs::Pdr4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port 4 State Register"]
        #[inline(always)]
        pub const fn pidr4(self) -> crate::common::Reg<regs::Pidr4, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port 4 Output Reset Register"]
        #[inline(always)]
        pub const fn porr4(self) -> crate::common::Reg<regs::Porr4, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port 4 Output Set Register"]
        #[inline(always)]
        pub const fn posr4(self) -> crate::common::Reg<regs::Posr4, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port 4 Direction Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr4(pub u16);
        impl Pdr4 {
            #[doc = "P407 Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::Pdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pdr07::from_bits(val as u8)
            }
            #[doc = "P407 Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::Pdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
        }
        impl Default for Pdr4 {
            #[inline(always)]
            fn default() -> Pdr4 {
                Pdr4(0)
            }
        }
        impl core::fmt::Debug for Pdr4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr4")
                    .field("pdr07", &self.pdr07())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pdr4 {{ pdr07: {:?} }}", self.pdr07())
            }
        }
        #[doc = "Port 4 State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr4(pub u16);
        impl Pidr4 {
            #[doc = "P407 State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::Pidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pidr07::from_bits(val as u8)
            }
            #[doc = "P407 State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::Pidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
        }
        impl Default for Pidr4 {
            #[inline(always)]
            fn default() -> Pidr4 {
                Pidr4(0)
            }
        }
        impl core::fmt::Debug for Pidr4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr4")
                    .field("pidr07", &self.pidr07())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pidr4 {{ pidr07: {:?} }}", self.pidr07())
            }
        }
        #[doc = "Port 4 Output Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr4(pub u16);
        impl Podr4 {
            #[doc = "P407 Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::Podr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Podr07::from_bits(val as u8)
            }
            #[doc = "P407 Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::Podr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
        }
        impl Default for Podr4 {
            #[inline(always)]
            fn default() -> Podr4 {
                Podr4(0)
            }
        }
        impl core::fmt::Debug for Podr4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr4")
                    .field("podr07", &self.podr07())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Podr4 {{ podr07: {:?} }}", self.podr07())
            }
        }
        #[doc = "Port 4 Output Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr4(pub u16);
        impl Porr4 {
            #[doc = "P407 Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::Porr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Porr07::from_bits(val as u8)
            }
            #[doc = "P407 Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::Porr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
        }
        impl Default for Porr4 {
            #[inline(always)]
            fn default() -> Porr4 {
                Porr4(0)
            }
        }
        impl core::fmt::Debug for Porr4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr4")
                    .field("porr07", &self.porr07())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Porr4 {{ porr07: {:?} }}", self.porr07())
            }
        }
        #[doc = "Port 4 Output Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr4(pub u16);
        impl Posr4 {
            #[doc = "P407 Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::Posr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Posr07::from_bits(val as u8)
            }
            #[doc = "P407 Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::Posr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
        }
        impl Default for Posr4 {
            #[inline(always)]
            fn default() -> Posr4 {
                Posr4(0)
            }
        }
        impl core::fmt::Debug for Posr4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr4")
                    .field("posr07", &self.posr07())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Posr4 {{ posr07: {:?} }}", self.posr07())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr07 {
            #[inline(always)]
            fn from(val: u8) -> Pdr07 {
                Pdr07::from_bits(val)
            }
        }
        impl From<Pdr07> for u8 {
            #[inline(always)]
            fn from(val: Pdr07) -> u8 {
                Pdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr07 {
            #[inline(always)]
            fn from(val: u8) -> Pidr07 {
                Pidr07::from_bits(val)
            }
        }
        impl From<Pidr07> for u8 {
            #[inline(always)]
            fn from(val: Pidr07) -> u8 {
                Pidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr07 {
            #[inline(always)]
            fn from(val: u8) -> Podr07 {
                Podr07::from_bits(val)
            }
        }
        impl From<Podr07> for u8 {
            #[inline(always)]
            fn from(val: Podr07) -> u8 {
                Podr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr07 {
            #[inline(always)]
            fn from(val: u8) -> Porr07 {
                Porr07::from_bits(val)
            }
        }
        impl From<Porr07> for u8 {
            #[inline(always)]
            fn from(val: Porr07) -> u8 {
                Porr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr07 {
            #[inline(always)]
            fn from(val: u8) -> Posr07 {
                Posr07::from_bits(val)
            }
        }
        impl From<Posr07> for u8 {
            #[inline(always)]
            fn from(val: Posr07) -> u8 {
                Posr07::to_bits(val)
            }
        }
    }
}
pub mod port9 {
    #[doc = "Port 9 Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port9 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port9 {}
    unsafe impl Sync for Port9 {}
    impl Port9 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port 9 Output Data Register"]
        #[inline(always)]
        pub const fn podr9(self) -> crate::common::Reg<regs::Podr9, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port 9 Direction Register"]
        #[inline(always)]
        pub const fn pdr9(self) -> crate::common::Reg<regs::Pdr9, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port 9 State Register"]
        #[inline(always)]
        pub const fn pidr9(self) -> crate::common::Reg<regs::Pidr9, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port 9 Output Reset Register"]
        #[inline(always)]
        pub const fn porr9(self) -> crate::common::Reg<regs::Porr9, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port 9 Output Set Register"]
        #[inline(always)]
        pub const fn posr9(self) -> crate::common::Reg<regs::Posr9, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port 9 Direction Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr9(pub u16);
        impl Pdr9 {
            #[doc = "P913 Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::Pdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pdr13::from_bits(val as u8)
            }
            #[doc = "P913 Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::Pdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P914 Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::Pdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pdr14::from_bits(val as u8)
            }
            #[doc = "P914 Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::Pdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
        }
        impl Default for Pdr9 {
            #[inline(always)]
            fn default() -> Pdr9 {
                Pdr9(0)
            }
        }
        impl core::fmt::Debug for Pdr9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr9")
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr9 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pdr9 {{ pdr13: {:?}, pdr14: {:?} }}",
                    self.pdr13(),
                    self.pdr14()
                )
            }
        }
        #[doc = "Port 9 State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr9(pub u16);
        impl Pidr9 {
            #[doc = "P913 State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::Pidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pidr13::from_bits(val as u8)
            }
            #[doc = "P913 State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::Pidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P914 State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::Pidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pidr14::from_bits(val as u8)
            }
            #[doc = "P914 State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::Pidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
        }
        impl Default for Pidr9 {
            #[inline(always)]
            fn default() -> Pidr9 {
                Pidr9(0)
            }
        }
        impl core::fmt::Debug for Pidr9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr9")
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr9 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pidr9 {{ pidr13: {:?}, pidr14: {:?} }}",
                    self.pidr13(),
                    self.pidr14()
                )
            }
        }
        #[doc = "Port 9 Output Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr9(pub u16);
        impl Podr9 {
            #[doc = "P913 Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::Podr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Podr13::from_bits(val as u8)
            }
            #[doc = "P913 Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::Podr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P914 Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::Podr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Podr14::from_bits(val as u8)
            }
            #[doc = "P914 Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::Podr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
        }
        impl Default for Podr9 {
            #[inline(always)]
            fn default() -> Podr9 {
                Podr9(0)
            }
        }
        impl core::fmt::Debug for Podr9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr9")
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr9 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Podr9 {{ podr13: {:?}, podr14: {:?} }}",
                    self.podr13(),
                    self.podr14()
                )
            }
        }
        #[doc = "Port 9 Output Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr9(pub u16);
        impl Porr9 {
            #[doc = "P913 Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::Porr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Porr13::from_bits(val as u8)
            }
            #[doc = "P913 Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::Porr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P914 Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::Porr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Porr14::from_bits(val as u8)
            }
            #[doc = "P914 Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::Porr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
        }
        impl Default for Porr9 {
            #[inline(always)]
            fn default() -> Porr9 {
                Porr9(0)
            }
        }
        impl core::fmt::Debug for Porr9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr9")
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr9 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Porr9 {{ porr13: {:?}, porr14: {:?} }}",
                    self.porr13(),
                    self.porr14()
                )
            }
        }
        #[doc = "Port 9 Output Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr9(pub u16);
        impl Posr9 {
            #[doc = "P913 Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::Posr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Posr13::from_bits(val as u8)
            }
            #[doc = "P913 Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::Posr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "P914 Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::Posr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Posr14::from_bits(val as u8)
            }
            #[doc = "P914 Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::Posr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
        }
        impl Default for Posr9 {
            #[inline(always)]
            fn default() -> Posr9 {
                Posr9(0)
            }
        }
        impl core::fmt::Debug for Posr9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr9")
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr9 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Posr9 {{ posr13: {:?}, posr14: {:?} }}",
                    self.posr13(),
                    self.posr14()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr13 {
            #[inline(always)]
            fn from(val: u8) -> Pdr13 {
                Pdr13::from_bits(val)
            }
        }
        impl From<Pdr13> for u8 {
            #[inline(always)]
            fn from(val: Pdr13) -> u8 {
                Pdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdr14 {
            #[inline(always)]
            fn from(val: u8) -> Pdr14 {
                Pdr14::from_bits(val)
            }
        }
        impl From<Pdr14> for u8 {
            #[inline(always)]
            fn from(val: Pdr14) -> u8 {
                Pdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pidr13 {
                Pidr13::from_bits(val)
            }
        }
        impl From<Pidr13> for u8 {
            #[inline(always)]
            fn from(val: Pidr13) -> u8 {
                Pidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pidr14 {
                Pidr14::from_bits(val)
            }
        }
        impl From<Pidr14> for u8 {
            #[inline(always)]
            fn from(val: Pidr14) -> u8 {
                Pidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr13 {
            #[inline(always)]
            fn from(val: u8) -> Podr13 {
                Podr13::from_bits(val)
            }
        }
        impl From<Podr13> for u8 {
            #[inline(always)]
            fn from(val: Podr13) -> u8 {
                Podr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Podr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Podr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Podr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Podr14 {
            #[inline(always)]
            fn from(val: u8) -> Podr14 {
                Podr14::from_bits(val)
            }
        }
        impl From<Podr14> for u8 {
            #[inline(always)]
            fn from(val: Podr14) -> u8 {
                Podr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr13 {
            #[inline(always)]
            fn from(val: u8) -> Porr13 {
                Porr13::from_bits(val)
            }
        }
        impl From<Porr13> for u8 {
            #[inline(always)]
            fn from(val: Porr13) -> u8 {
                Porr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porr14 {
            #[inline(always)]
            fn from(val: u8) -> Porr14 {
                Porr14::from_bits(val)
            }
        }
        impl From<Porr14> for u8 {
            #[inline(always)]
            fn from(val: Porr14) -> u8 {
                Porr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr13 {
            #[inline(always)]
            fn from(val: u8) -> Posr13 {
                Posr13::from_bits(val)
            }
        }
        impl From<Posr13> for u8 {
            #[inline(always)]
            fn from(val: Posr13) -> u8 {
                Posr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Posr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Posr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Posr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Posr14 {
            #[inline(always)]
            fn from(val: u8) -> Posr14 {
                Posr14::from_bits(val)
            }
        }
        impl From<Posr14> for u8 {
            #[inline(always)]
            fn from(val: Posr14) -> u8 {
                Posr14::to_bits(val)
            }
        }
    }
}
pub mod rtc_c {
    #[doc = "Realtime Clock"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct RtcC {
        ptr: *mut u8,
    }
    unsafe impl Send for RtcC {}
    unsafe impl Sync for RtcC {}
    impl RtcC {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Second Count Register"]
        #[inline(always)]
        pub const fn sec(self) -> crate::common::Reg<regs::Sec, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Minute Count Register"]
        #[inline(always)]
        pub const fn min(self) -> crate::common::Reg<regs::Min, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Hour Count Register"]
        #[inline(always)]
        pub const fn hour(self) -> crate::common::Reg<regs::Hour, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Day,of,Week Count Register"]
        #[inline(always)]
        pub const fn week(self) -> crate::common::Reg<regs::Week, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Day Count Register"]
        #[inline(always)]
        pub const fn day(self) -> crate::common::Reg<regs::Day, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Month Count Register"]
        #[inline(always)]
        pub const fn month(self) -> crate::common::Reg<regs::Month, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "Year Count Register"]
        #[inline(always)]
        pub const fn year(self) -> crate::common::Reg<regs::Year, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Time Error Correction Register"]
        #[inline(always)]
        pub const fn subcud(self) -> crate::common::Reg<regs::Subcud, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Alarm Minute Register"]
        #[inline(always)]
        pub const fn alarmwm(self) -> crate::common::Reg<regs::Alarmwm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Alarm Hour Register"]
        #[inline(always)]
        pub const fn alarmwh(self) -> crate::common::Reg<regs::Alarmwh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "Alarm Day,of,Week Register"]
        #[inline(always)]
        pub const fn alarmww(self) -> crate::common::Reg<regs::Alarmww, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Realtime Clock Control Register 0"]
        #[inline(always)]
        pub const fn rtcc0(self) -> crate::common::Reg<regs::Rtcc0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "Realtime Clock Control Register 1"]
        #[inline(always)]
        pub const fn rtcc1(self) -> crate::common::Reg<regs::Rtcc1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Alarm Hour Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Alarmwh(pub u8);
        impl Alarmwh {
            #[doc = "1-digit hour setting"]
            #[inline(always)]
            pub const fn wh1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-digit hour setting"]
            #[inline(always)]
            pub fn set_wh1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-digit hour setting"]
            #[inline(always)]
            pub const fn wh10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-digit hour setting"]
            #[inline(always)]
            pub fn set_wh10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Alarmwh {
            #[inline(always)]
            fn default() -> Alarmwh {
                Alarmwh(0)
            }
        }
        impl core::fmt::Debug for Alarmwh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Alarmwh")
                    .field("wh1", &self.wh1())
                    .field("wh10", &self.wh10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Alarmwh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Alarmwh {{ wh1: {=u8:?}, wh10: {=u8:?} }}",
                    self.wh1(),
                    self.wh10()
                )
            }
        }
        #[doc = "Alarm Minute Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Alarmwm(pub u8);
        impl Alarmwm {
            #[doc = "1-digit minute setting"]
            #[inline(always)]
            pub const fn wm1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-digit minute setting"]
            #[inline(always)]
            pub fn set_wm1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-digit minute setting"]
            #[inline(always)]
            pub const fn wm10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-digit minute setting"]
            #[inline(always)]
            pub fn set_wm10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Alarmwm {
            #[inline(always)]
            fn default() -> Alarmwm {
                Alarmwm(0)
            }
        }
        impl core::fmt::Debug for Alarmwm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Alarmwm")
                    .field("wm1", &self.wm1())
                    .field("wm10", &self.wm10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Alarmwm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Alarmwm {{ wm1: {=u8:?}, wm10: {=u8:?} }}",
                    self.wm1(),
                    self.wm10()
                )
            }
        }
        #[doc = "Alarm Day,of,Week Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Alarmww(pub u8);
        impl Alarmww {
            #[doc = "Alarm enabled setting \"Sunday\""]
            #[inline(always)]
            pub const fn ww0(&self) -> super::vals::Ww0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ww0::from_bits(val as u8)
            }
            #[doc = "Alarm enabled setting \"Sunday\""]
            #[inline(always)]
            pub fn set_ww0(&mut self, val: super::vals::Ww0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Alarm enabled setting \"Monday\""]
            #[inline(always)]
            pub const fn ww1(&self) -> super::vals::Ww1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ww1::from_bits(val as u8)
            }
            #[doc = "Alarm enabled setting \"Monday\""]
            #[inline(always)]
            pub fn set_ww1(&mut self, val: super::vals::Ww1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Alarm enabled setting \"Tuesday\""]
            #[inline(always)]
            pub const fn ww2(&self) -> super::vals::Ww2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ww2::from_bits(val as u8)
            }
            #[doc = "Alarm enabled setting \"Tuesday\""]
            #[inline(always)]
            pub fn set_ww2(&mut self, val: super::vals::Ww2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Alarm enabled setting \"Wednesday\""]
            #[inline(always)]
            pub const fn ww3(&self) -> super::vals::Ww3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ww3::from_bits(val as u8)
            }
            #[doc = "Alarm enabled setting \"Wednesday\""]
            #[inline(always)]
            pub fn set_ww3(&mut self, val: super::vals::Ww3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Alarm enabled setting \"Thursday\""]
            #[inline(always)]
            pub const fn ww4(&self) -> super::vals::Ww4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ww4::from_bits(val as u8)
            }
            #[doc = "Alarm enabled setting \"Thursday\""]
            #[inline(always)]
            pub fn set_ww4(&mut self, val: super::vals::Ww4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Alarm enabled setting \"Friday\""]
            #[inline(always)]
            pub const fn ww5(&self) -> super::vals::Ww5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ww5::from_bits(val as u8)
            }
            #[doc = "Alarm enabled setting \"Friday\""]
            #[inline(always)]
            pub fn set_ww5(&mut self, val: super::vals::Ww5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Alarm enabled setting \"Saturday\""]
            #[inline(always)]
            pub const fn ww6(&self) -> super::vals::Ww6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ww6::from_bits(val as u8)
            }
            #[doc = "Alarm enabled setting \"Saturday\""]
            #[inline(always)]
            pub fn set_ww6(&mut self, val: super::vals::Ww6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Alarmww {
            #[inline(always)]
            fn default() -> Alarmww {
                Alarmww(0)
            }
        }
        impl core::fmt::Debug for Alarmww {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Alarmww")
                    .field("ww0", &self.ww0())
                    .field("ww1", &self.ww1())
                    .field("ww2", &self.ww2())
                    .field("ww3", &self.ww3())
                    .field("ww4", &self.ww4())
                    .field("ww5", &self.ww5())
                    .field("ww6", &self.ww6())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Alarmww {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Alarmww {{ ww0: {:?}, ww1: {:?}, ww2: {:?}, ww3: {:?}, ww4: {:?}, ww5: {:?}, ww6: {:?} }}" , self . ww0 () , self . ww1 () , self . ww2 () , self . ww3 () , self . ww4 () , self . ww5 () , self . ww6 ())
            }
        }
        #[doc = "Day Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Day(pub u8);
        impl Day {
            #[doc = "1-day count"]
            #[inline(always)]
            pub const fn day1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-day count"]
            #[inline(always)]
            pub fn set_day1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-day count"]
            #[inline(always)]
            pub const fn day10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-day count"]
            #[inline(always)]
            pub fn set_day10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Day {
            #[inline(always)]
            fn default() -> Day {
                Day(0)
            }
        }
        impl core::fmt::Debug for Day {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Day")
                    .field("day1", &self.day1())
                    .field("day10", &self.day10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Day {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Day {{ day1: {=u8:?}, day10: {=u8:?} }}",
                    self.day1(),
                    self.day10()
                )
            }
        }
        #[doc = "Hour Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hour(pub u8);
        impl Hour {
            #[doc = "1-hour count"]
            #[inline(always)]
            pub const fn hour1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-hour count"]
            #[inline(always)]
            pub fn set_hour1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-hour count"]
            #[inline(always)]
            pub const fn hour10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-hour count"]
            #[inline(always)]
            pub fn set_hour10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Hour {
            #[inline(always)]
            fn default() -> Hour {
                Hour(0)
            }
        }
        impl core::fmt::Debug for Hour {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hour")
                    .field("hour1", &self.hour1())
                    .field("hour10", &self.hour10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hour {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hour {{ hour1: {=u8:?}, hour10: {=u8:?} }}",
                    self.hour1(),
                    self.hour10()
                )
            }
        }
        #[doc = "Minute Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Min(pub u8);
        impl Min {
            #[doc = "1-minute count"]
            #[inline(always)]
            pub const fn min1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-minute count"]
            #[inline(always)]
            pub fn set_min1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10- minute count"]
            #[inline(always)]
            pub const fn min10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10- minute count"]
            #[inline(always)]
            pub fn set_min10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Min {
            #[inline(always)]
            fn default() -> Min {
                Min(0)
            }
        }
        impl core::fmt::Debug for Min {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Min")
                    .field("min1", &self.min1())
                    .field("min10", &self.min10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Min {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Min {{ min1: {=u8:?}, min10: {=u8:?} }}",
                    self.min1(),
                    self.min10()
                )
            }
        }
        #[doc = "Month Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Month(pub u8);
        impl Month {
            #[doc = "1-month count"]
            #[inline(always)]
            pub const fn month1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-month count"]
            #[inline(always)]
            pub fn set_month1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-month count"]
            #[inline(always)]
            pub const fn month10(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "10-month count"]
            #[inline(always)]
            pub fn set_month10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Month {
            #[inline(always)]
            fn default() -> Month {
                Month(0)
            }
        }
        impl core::fmt::Debug for Month {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Month")
                    .field("month1", &self.month1())
                    .field("month10", &self.month10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Month {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Month {{ month1: {=u8:?}, month10: {=bool:?} }}",
                    self.month1(),
                    self.month10()
                )
            }
        }
        #[doc = "Realtime Clock Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rtcc0(pub u8);
        impl Rtcc0 {
            #[doc = "Fixed,cycle interrupt (RTC_ALM_OR_PRD) selection"]
            #[inline(always)]
            pub const fn ct(&self) -> super::vals::Ct {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ct::from_bits(val as u8)
            }
            #[doc = "Fixed,cycle interrupt (RTC_ALM_OR_PRD) selection"]
            #[inline(always)]
            pub fn set_ct(&mut self, val: super::vals::Ct) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Selection of 12- or 24-hour system"]
            #[inline(always)]
            pub const fn ampm(&self) -> super::vals::Ampm {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ampm::from_bits(val as u8)
            }
            #[doc = "Selection of 12- or 24-hour system"]
            #[inline(always)]
            pub fn set_ampm(&mut self, val: super::vals::Ampm) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Selection of the operating clock for the realtime clock (RTCCLK)"]
            #[inline(always)]
            pub const fn rtc128en(&self) -> super::vals::Rtc128en {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rtc128en::from_bits(val as u8)
            }
            #[doc = "Selection of the operating clock for the realtime clock (RTCCLK)"]
            #[inline(always)]
            pub fn set_rtc128en(&mut self, val: super::vals::Rtc128en) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "RTCOUT pin output control"]
            #[inline(always)]
            pub const fn rcloe1(&self) -> super::vals::Rcloe1 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rcloe1::from_bits(val as u8)
            }
            #[doc = "RTCOUT pin output control"]
            #[inline(always)]
            pub fn set_rcloe1(&mut self, val: super::vals::Rcloe1) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Realtime clock operation control"]
            #[inline(always)]
            pub const fn rtce(&self) -> super::vals::Rtce {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rtce::from_bits(val as u8)
            }
            #[doc = "Realtime clock operation control"]
            #[inline(always)]
            pub fn set_rtce(&mut self, val: super::vals::Rtce) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rtcc0 {
            #[inline(always)]
            fn default() -> Rtcc0 {
                Rtcc0(0)
            }
        }
        impl core::fmt::Debug for Rtcc0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rtcc0")
                    .field("ct", &self.ct())
                    .field("ampm", &self.ampm())
                    .field("rtc128en", &self.rtc128en())
                    .field("rcloe1", &self.rcloe1())
                    .field("rtce", &self.rtce())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rtcc0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rtcc0 {{ ct: {:?}, ampm: {:?}, rtc128en: {:?}, rcloe1: {:?}, rtce: {:?} }}",
                    self.ct(),
                    self.ampm(),
                    self.rtc128en(),
                    self.rcloe1(),
                    self.rtce()
                )
            }
        }
        #[doc = "Realtime Clock Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rtcc1(pub u8);
        impl Rtcc1 {
            #[doc = "Wait control of realtime clock"]
            #[inline(always)]
            pub const fn rwait(&self) -> super::vals::Rwait {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rwait::from_bits(val as u8)
            }
            #[doc = "Wait control of realtime clock"]
            #[inline(always)]
            pub fn set_rwait(&mut self, val: super::vals::Rwait) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Wait status flag of realtime clock"]
            #[inline(always)]
            pub const fn rwst(&self) -> super::vals::Rwst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rwst::from_bits(val as u8)
            }
            #[doc = "Wait status flag of realtime clock"]
            #[inline(always)]
            pub fn set_rwst(&mut self, val: super::vals::Rwst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Fixed,cycle interrupt status flag"]
            #[inline(always)]
            pub const fn rifg(&self) -> super::vals::Rifg {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rifg::from_bits(val as u8)
            }
            #[doc = "Fixed,cycle interrupt status flag"]
            #[inline(always)]
            pub fn set_rifg(&mut self, val: super::vals::Rifg) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Alarm detection status flag"]
            #[inline(always)]
            pub const fn wafg(&self) -> super::vals::Wafg {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Wafg::from_bits(val as u8)
            }
            #[doc = "Alarm detection status flag"]
            #[inline(always)]
            pub fn set_wafg(&mut self, val: super::vals::Wafg) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Control of alarm interrupt (RTC_ALM_OR_PRD)"]
            #[inline(always)]
            pub const fn walie(&self) -> super::vals::Walie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Walie::from_bits(val as u8)
            }
            #[doc = "Control of alarm interrupt (RTC_ALM_OR_PRD)"]
            #[inline(always)]
            pub fn set_walie(&mut self, val: super::vals::Walie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Alarm operation control"]
            #[inline(always)]
            pub const fn wale(&self) -> super::vals::Wale {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wale::from_bits(val as u8)
            }
            #[doc = "Alarm operation control"]
            #[inline(always)]
            pub fn set_wale(&mut self, val: super::vals::Wale) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rtcc1 {
            #[inline(always)]
            fn default() -> Rtcc1 {
                Rtcc1(0)
            }
        }
        impl core::fmt::Debug for Rtcc1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rtcc1")
                    .field("rwait", &self.rwait())
                    .field("rwst", &self.rwst())
                    .field("rifg", &self.rifg())
                    .field("wafg", &self.wafg())
                    .field("walie", &self.walie())
                    .field("wale", &self.wale())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rtcc1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rtcc1 {{ rwait: {:?}, rwst: {:?}, rifg: {:?}, wafg: {:?}, walie: {:?}, wale: {:?} }}" , self . rwait () , self . rwst () , self . rifg () , self . wafg () , self . walie () , self . wale ())
            }
        }
        #[doc = "Second Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sec(pub u8);
        impl Sec {
            #[doc = "1-second count"]
            #[inline(always)]
            pub const fn sec1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-second count"]
            #[inline(always)]
            pub fn set_sec1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-second count"]
            #[inline(always)]
            pub const fn sec10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-second count"]
            #[inline(always)]
            pub fn set_sec10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Sec {
            #[inline(always)]
            fn default() -> Sec {
                Sec(0)
            }
        }
        impl core::fmt::Debug for Sec {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sec")
                    .field("sec1", &self.sec1())
                    .field("sec10", &self.sec10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sec {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sec {{ sec1: {=u8:?}, sec10: {=u8:?} }}",
                    self.sec1(),
                    self.sec10()
                )
            }
        }
        #[doc = "Time Error Correction Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Subcud(pub u8);
        impl Subcud {
            #[doc = "Adjustment Value"]
            #[inline(always)]
            pub const fn f(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Adjustment Value"]
            #[inline(always)]
            pub fn set_f(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "Setting of time error correction value"]
            #[inline(always)]
            pub const fn f6(&self) -> super::vals::F6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::F6::from_bits(val as u8)
            }
            #[doc = "Setting of time error correction value"]
            #[inline(always)]
            pub fn set_f6(&mut self, val: super::vals::F6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Setting of time error correction timing"]
            #[inline(always)]
            pub const fn dev(&self) -> super::vals::Dev {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dev::from_bits(val as u8)
            }
            #[doc = "Setting of time error correction timing"]
            #[inline(always)]
            pub fn set_dev(&mut self, val: super::vals::Dev) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Subcud {
            #[inline(always)]
            fn default() -> Subcud {
                Subcud(0)
            }
        }
        impl core::fmt::Debug for Subcud {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Subcud")
                    .field("f", &self.f())
                    .field("f6", &self.f6())
                    .field("dev", &self.dev())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Subcud {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Subcud {{ f: {=u8:?}, f6: {:?}, dev: {:?} }}",
                    self.f(),
                    self.f6(),
                    self.dev()
                )
            }
        }
        #[doc = "Day,of,Week Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Week(pub u8);
        impl Week {
            #[doc = "Day,of,Week Counting"]
            #[inline(always)]
            pub const fn week(&self) -> super::vals::Week {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Week::from_bits(val as u8)
            }
            #[doc = "Day,of,Week Counting"]
            #[inline(always)]
            pub fn set_week(&mut self, val: super::vals::Week) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Week {
            #[inline(always)]
            fn default() -> Week {
                Week(0)
            }
        }
        impl core::fmt::Debug for Week {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Week").field("week", &self.week()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Week {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Week {{ week: {:?} }}", self.week())
            }
        }
        #[doc = "Year Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Year(pub u8);
        impl Year {
            #[doc = "1-year count"]
            #[inline(always)]
            pub const fn year1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-year count"]
            #[inline(always)]
            pub fn set_year1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-year count"]
            #[inline(always)]
            pub const fn year10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "10-year count"]
            #[inline(always)]
            pub fn set_year10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u8) & 0x0f) << 4usize);
            }
        }
        impl Default for Year {
            #[inline(always)]
            fn default() -> Year {
                Year(0)
            }
        }
        impl core::fmt::Debug for Year {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Year")
                    .field("year1", &self.year1())
                    .field("year10", &self.year10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Year {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Year {{ year1: {=u8:?}, year10: {=u8:?} }}",
                    self.year1(),
                    self.year10()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampm {
            #[inline(always)]
            fn from(val: u8) -> Ampm {
                Ampm::from_bits(val)
            }
        }
        impl From<Ampm> for u8 {
            #[inline(always)]
            fn from(val: Ampm) -> u8 {
                Ampm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ct {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ct {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ct {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ct {
            #[inline(always)]
            fn from(val: u8) -> Ct {
                Ct::from_bits(val)
            }
        }
        impl From<Ct> for u8 {
            #[inline(always)]
            fn from(val: Ct) -> u8 {
                Ct::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dev {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dev {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dev {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dev {
            #[inline(always)]
            fn from(val: u8) -> Dev {
                Dev::from_bits(val)
            }
        }
        impl From<Dev> for u8 {
            #[inline(always)]
            fn from(val: Dev) -> u8 {
                Dev::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum F6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl F6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> F6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for F6 {
            #[inline(always)]
            fn from(val: u8) -> F6 {
                F6::from_bits(val)
            }
        }
        impl From<F6> for u8 {
            #[inline(always)]
            fn from(val: F6) -> u8 {
                F6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcloe1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcloe1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcloe1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcloe1 {
            #[inline(always)]
            fn from(val: u8) -> Rcloe1 {
                Rcloe1::from_bits(val)
            }
        }
        impl From<Rcloe1> for u8 {
            #[inline(always)]
            fn from(val: Rcloe1) -> u8 {
                Rcloe1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rifg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rifg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rifg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rifg {
            #[inline(always)]
            fn from(val: u8) -> Rifg {
                Rifg::from_bits(val)
            }
        }
        impl From<Rifg> for u8 {
            #[inline(always)]
            fn from(val: Rifg) -> u8 {
                Rifg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtc128en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtc128en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtc128en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtc128en {
            #[inline(always)]
            fn from(val: u8) -> Rtc128en {
                Rtc128en::from_bits(val)
            }
        }
        impl From<Rtc128en> for u8 {
            #[inline(always)]
            fn from(val: Rtc128en) -> u8 {
                Rtc128en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtce {
            #[inline(always)]
            fn from(val: u8) -> Rtce {
                Rtce::from_bits(val)
            }
        }
        impl From<Rtce> for u8 {
            #[inline(always)]
            fn from(val: Rtce) -> u8 {
                Rtce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rwait {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rwait {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rwait {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rwait {
            #[inline(always)]
            fn from(val: u8) -> Rwait {
                Rwait::from_bits(val)
            }
        }
        impl From<Rwait> for u8 {
            #[inline(always)]
            fn from(val: Rwait) -> u8 {
                Rwait::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rwst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rwst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rwst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rwst {
            #[inline(always)]
            fn from(val: u8) -> Rwst {
                Rwst::from_bits(val)
            }
        }
        impl From<Rwst> for u8 {
            #[inline(always)]
            fn from(val: Rwst) -> u8 {
                Rwst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wafg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wafg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wafg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wafg {
            #[inline(always)]
            fn from(val: u8) -> Wafg {
                Wafg::from_bits(val)
            }
        }
        impl From<Wafg> for u8 {
            #[inline(always)]
            fn from(val: Wafg) -> u8 {
                Wafg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wale {
            #[inline(always)]
            fn from(val: u8) -> Wale {
                Wale::from_bits(val)
            }
        }
        impl From<Wale> for u8 {
            #[inline(always)]
            fn from(val: Wale) -> u8 {
                Wale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Walie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Walie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Walie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Walie {
            #[inline(always)]
            fn from(val: u8) -> Walie {
                Walie::from_bits(val)
            }
        }
        impl From<Walie> for u8 {
            #[inline(always)]
            fn from(val: Walie) -> u8 {
                Walie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Week {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Week {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Week {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Week {
            #[inline(always)]
            fn from(val: u8) -> Week {
                Week::from_bits(val)
            }
        }
        impl From<Week> for u8 {
            #[inline(always)]
            fn from(val: Week) -> u8 {
                Week::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ww0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ww0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ww0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ww0 {
            #[inline(always)]
            fn from(val: u8) -> Ww0 {
                Ww0::from_bits(val)
            }
        }
        impl From<Ww0> for u8 {
            #[inline(always)]
            fn from(val: Ww0) -> u8 {
                Ww0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ww1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ww1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ww1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ww1 {
            #[inline(always)]
            fn from(val: u8) -> Ww1 {
                Ww1::from_bits(val)
            }
        }
        impl From<Ww1> for u8 {
            #[inline(always)]
            fn from(val: Ww1) -> u8 {
                Ww1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ww2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ww2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ww2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ww2 {
            #[inline(always)]
            fn from(val: u8) -> Ww2 {
                Ww2::from_bits(val)
            }
        }
        impl From<Ww2> for u8 {
            #[inline(always)]
            fn from(val: Ww2) -> u8 {
                Ww2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ww3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ww3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ww3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ww3 {
            #[inline(always)]
            fn from(val: u8) -> Ww3 {
                Ww3::from_bits(val)
            }
        }
        impl From<Ww3> for u8 {
            #[inline(always)]
            fn from(val: Ww3) -> u8 {
                Ww3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ww4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ww4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ww4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ww4 {
            #[inline(always)]
            fn from(val: u8) -> Ww4 {
                Ww4::from_bits(val)
            }
        }
        impl From<Ww4> for u8 {
            #[inline(always)]
            fn from(val: Ww4) -> u8 {
                Ww4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ww5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ww5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ww5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ww5 {
            #[inline(always)]
            fn from(val: u8) -> Ww5 {
                Ww5::from_bits(val)
            }
        }
        impl From<Ww5> for u8 {
            #[inline(always)]
            fn from(val: Ww5) -> u8 {
                Ww5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ww6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ww6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ww6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ww6 {
            #[inline(always)]
            fn from(val: u8) -> Ww6 {
                Ww6::from_bits(val)
            }
        }
        impl From<Ww6> for u8 {
            #[inline(always)]
            fn from(val: Ww6) -> u8 {
                Ww6::to_bits(val)
            }
        }
    }
}
pub mod sau0 {
    #[doc = "Serial Array Unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sau0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Sau0 {}
    unsafe impl Sync for Sau0 {}
    impl Sau0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Serial Data Register 0%s"]
        #[inline(always)]
        pub const fn sdr0(self, n: usize) -> crate::common::Reg<regs::Sdr0, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 2usize) as _) }
        }
        #[doc = "Serial Status Register 00"]
        #[inline(always)]
        pub const fn ssr00(self) -> crate::common::Reg<regs::Ssr00, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Serial Status Register 01"]
        #[inline(always)]
        pub const fn ssr01(self) -> crate::common::Reg<regs::Ssr01, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize) as _) }
        }
        #[doc = "Serial Status Register 02"]
        #[inline(always)]
        pub const fn ssr02(self) -> crate::common::Reg<regs::Ssr02, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Serial Status Register 03"]
        #[inline(always)]
        pub const fn ssr03(self) -> crate::common::Reg<regs::Ssr03, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0106usize) as _) }
        }
        #[doc = "Serial Flag Clear Trigger Register 00"]
        #[inline(always)]
        pub const fn sir00(self) -> crate::common::Reg<regs::Sir00, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Serial Flag Clear Trigger Register 01"]
        #[inline(always)]
        pub const fn sir01(self) -> crate::common::Reg<regs::Sir01, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010ausize) as _) }
        }
        #[doc = "Serial Flag Clear Trigger Register 02"]
        #[inline(always)]
        pub const fn sir02(self) -> crate::common::Reg<regs::Sir02, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Serial Flag Clear Trigger Register 03"]
        #[inline(always)]
        pub const fn sir03(self) -> crate::common::Reg<regs::Sir03, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010eusize) as _) }
        }
        #[doc = "Serial Mode Register 00"]
        #[inline(always)]
        pub const fn smr00(self) -> crate::common::Reg<regs::Smr00, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Serial Mode Register 01"]
        #[inline(always)]
        pub const fn smr01(self) -> crate::common::Reg<regs::Smr01, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0112usize) as _) }
        }
        #[doc = "Serial Mode Register 02"]
        #[inline(always)]
        pub const fn smr02(self) -> crate::common::Reg<regs::Smr02, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Serial Mode Register 03"]
        #[inline(always)]
        pub const fn smr03(self) -> crate::common::Reg<regs::Smr03, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0116usize) as _) }
        }
        #[doc = "Serial Communication Operation Setting Register 00"]
        #[inline(always)]
        pub const fn scr00(self) -> crate::common::Reg<regs::Scr00, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Serial Communication Operation Setting Register 01"]
        #[inline(always)]
        pub const fn scr01(self) -> crate::common::Reg<regs::Scr01, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011ausize) as _) }
        }
        #[doc = "Serial Communication Operation Setting Register 02"]
        #[inline(always)]
        pub const fn scr02(self) -> crate::common::Reg<regs::Scr02, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Serial Communication Operation Setting Register 03"]
        #[inline(always)]
        pub const fn scr03(self) -> crate::common::Reg<regs::Scr03, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011eusize) as _) }
        }
        #[doc = "Serial Channel Enable Status Register 0"]
        #[inline(always)]
        pub const fn se0(self) -> crate::common::Reg<regs::Se0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Serial Channel Start Register 0"]
        #[inline(always)]
        pub const fn ss0(self) -> crate::common::Reg<regs::Ss0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0122usize) as _) }
        }
        #[doc = "Serial Channel Stop Register 0"]
        #[inline(always)]
        pub const fn st0(self) -> crate::common::Reg<regs::St0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Serial Clock Select Register 0"]
        #[inline(always)]
        pub const fn sps0(self) -> crate::common::Reg<regs::Sps0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0126usize) as _) }
        }
        #[doc = "Serial Output Register 0"]
        #[inline(always)]
        pub const fn so0(self) -> crate::common::Reg<regs::So0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "Serial Output Enable Register 0"]
        #[inline(always)]
        pub const fn soe0(self) -> crate::common::Reg<regs::Soe0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012ausize) as _) }
        }
        #[doc = "Serial Output Level Register 0"]
        #[inline(always)]
        pub const fn sol0(self) -> crate::common::Reg<regs::Sol0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "Serial Standby Control Register 0"]
        #[inline(always)]
        pub const fn ssc0(self) -> crate::common::Reg<regs::Ssc0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Serial Communication Operation Setting Register 00"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr00(pub u16);
        impl Scr00 {
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dls(&self) -> super::vals::Scr00Dls {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Scr00Dls::from_bits(val as u8)
            }
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dls(&mut self, val: super::vals::Scr00Dls) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub const fn slc(&self) -> super::vals::Scr00Slc {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Scr00Slc::from_bits(val as u8)
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub fn set_slc(&mut self, val: super::vals::Scr00Slc) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u16) & 0x03) << 4usize);
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Scr00Dir {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Scr00Dir::from_bits(val as u8)
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::Scr00Dir) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub const fn ptc(&self) -> super::vals::Scr00Ptc {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Scr00Ptc::from_bits(val as u8)
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub fn set_ptc(&mut self, val: super::vals::Scr00Ptc) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub const fn dcp(&self) -> super::vals::Scr00Dcp {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Scr00Dcp::from_bits(val as u8)
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub fn set_dcp(&mut self, val: super::vals::Scr00Dcp) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "Setting of Channel 0 Operation Mode"]
            #[inline(always)]
            pub const fn trxe(&self) -> super::vals::Scr00Trxe {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Scr00Trxe::from_bits(val as u8)
            }
            #[doc = "Setting of Channel 0 Operation Mode"]
            #[inline(always)]
            pub fn set_trxe(&mut self, val: super::vals::Scr00Trxe) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Scr00 {
            #[inline(always)]
            fn default() -> Scr00 {
                Scr00(0)
            }
        }
        impl core::fmt::Debug for Scr00 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr00")
                    .field("dls", &self.dls())
                    .field("slc", &self.slc())
                    .field("dir", &self.dir())
                    .field("ptc", &self.ptc())
                    .field("dcp", &self.dcp())
                    .field("trxe", &self.trxe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr00 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Scr00 {{ dls: {:?}, slc: {:?}, dir: {:?}, ptc: {:?}, dcp: {:?}, trxe: {:?} }}",
                    self.dls(),
                    self.slc(),
                    self.dir(),
                    self.ptc(),
                    self.dcp(),
                    self.trxe()
                )
            }
        }
        #[doc = "Serial Communication Operation Setting Register 01"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr01(pub u16);
        impl Scr01 {
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dls(&self) -> super::vals::Scr01Dls {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Scr01Dls::from_bits(val as u8)
            }
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dls(&mut self, val: super::vals::Scr01Dls) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub const fn slc(&self) -> super::vals::Scr01Slc {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Scr01Slc::from_bits(val as u8)
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub fn set_slc(&mut self, val: super::vals::Scr01Slc) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Scr01Dir {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Scr01Dir::from_bits(val as u8)
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::Scr01Dir) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub const fn ptc(&self) -> super::vals::Scr01Ptc {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Scr01Ptc::from_bits(val as u8)
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub fn set_ptc(&mut self, val: super::vals::Scr01Ptc) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Mask Control of Error Interrupt Signal SAU0_UART_ERRI0 (m = 0), SAU1_UART_ERRI2 (m = 1)"]
            #[inline(always)]
            pub const fn eoc(&self) -> super::vals::Scr01Eoc {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Scr01Eoc::from_bits(val as u8)
            }
            #[doc = "Mask Control of Error Interrupt Signal SAU0_UART_ERRI0 (m = 0), SAU1_UART_ERRI2 (m = 1)"]
            #[inline(always)]
            pub fn set_eoc(&mut self, val: super::vals::Scr01Eoc) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub const fn dcp(&self) -> super::vals::Scr01Dcp {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Scr01Dcp::from_bits(val as u8)
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub fn set_dcp(&mut self, val: super::vals::Scr01Dcp) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "Setting of Channel 1 Operation Mode"]
            #[inline(always)]
            pub const fn trxe(&self) -> super::vals::Scr01Trxe {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Scr01Trxe::from_bits(val as u8)
            }
            #[doc = "Setting of Channel 1 Operation Mode"]
            #[inline(always)]
            pub fn set_trxe(&mut self, val: super::vals::Scr01Trxe) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Scr01 {
            #[inline(always)]
            fn default() -> Scr01 {
                Scr01(0)
            }
        }
        impl core::fmt::Debug for Scr01 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr01")
                    .field("dls", &self.dls())
                    .field("slc", &self.slc())
                    .field("dir", &self.dir())
                    .field("ptc", &self.ptc())
                    .field("eoc", &self.eoc())
                    .field("dcp", &self.dcp())
                    .field("trxe", &self.trxe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr01 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scr01 {{ dls: {:?}, slc: {:?}, dir: {:?}, ptc: {:?}, eoc: {:?}, dcp: {:?}, trxe: {:?} }}" , self . dls () , self . slc () , self . dir () , self . ptc () , self . eoc () , self . dcp () , self . trxe ())
            }
        }
        #[doc = "Serial Communication Operation Setting Register 02"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr02(pub u16);
        impl Scr02 {
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dls(&self) -> super::vals::Scr02Dls {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Scr02Dls::from_bits(val as u8)
            }
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dls(&mut self, val: super::vals::Scr02Dls) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub const fn slc(&self) -> super::vals::Scr02Slc {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Scr02Slc::from_bits(val as u8)
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub fn set_slc(&mut self, val: super::vals::Scr02Slc) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u16) & 0x03) << 4usize);
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Scr02Dir {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Scr02Dir::from_bits(val as u8)
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::Scr02Dir) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub const fn ptc(&self) -> super::vals::Scr02Ptc {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Scr02Ptc::from_bits(val as u8)
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub fn set_ptc(&mut self, val: super::vals::Scr02Ptc) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub const fn dcp(&self) -> super::vals::Scr02Dcp {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Scr02Dcp::from_bits(val as u8)
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub fn set_dcp(&mut self, val: super::vals::Scr02Dcp) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "Setting of Channel 2 Operation Mode"]
            #[inline(always)]
            pub const fn trxe(&self) -> super::vals::Scr02Trxe {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Scr02Trxe::from_bits(val as u8)
            }
            #[doc = "Setting of Channel 2 Operation Mode"]
            #[inline(always)]
            pub fn set_trxe(&mut self, val: super::vals::Scr02Trxe) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Scr02 {
            #[inline(always)]
            fn default() -> Scr02 {
                Scr02(0)
            }
        }
        impl core::fmt::Debug for Scr02 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr02")
                    .field("dls", &self.dls())
                    .field("slc", &self.slc())
                    .field("dir", &self.dir())
                    .field("ptc", &self.ptc())
                    .field("dcp", &self.dcp())
                    .field("trxe", &self.trxe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr02 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Scr02 {{ dls: {:?}, slc: {:?}, dir: {:?}, ptc: {:?}, dcp: {:?}, trxe: {:?} }}",
                    self.dls(),
                    self.slc(),
                    self.dir(),
                    self.ptc(),
                    self.dcp(),
                    self.trxe()
                )
            }
        }
        #[doc = "Serial Communication Operation Setting Register 03"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr03(pub u16);
        impl Scr03 {
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dls(&self) -> super::vals::Scr03Dls {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Scr03Dls::from_bits(val as u8)
            }
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dls(&mut self, val: super::vals::Scr03Dls) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub const fn slc(&self) -> super::vals::Scr03Slc {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Scr03Slc::from_bits(val as u8)
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub fn set_slc(&mut self, val: super::vals::Scr03Slc) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Scr03Dir {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Scr03Dir::from_bits(val as u8)
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::Scr03Dir) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub const fn ptc(&self) -> super::vals::Scr03Ptc {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Scr03Ptc::from_bits(val as u8)
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub fn set_ptc(&mut self, val: super::vals::Scr03Ptc) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Mask Control of Error Interrupt Signal SAU0_UART_ERRI1"]
            #[inline(always)]
            pub const fn eoc(&self) -> super::vals::Scr03Eoc {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Scr03Eoc::from_bits(val as u8)
            }
            #[doc = "Mask Control of Error Interrupt Signal SAU0_UART_ERRI1"]
            #[inline(always)]
            pub fn set_eoc(&mut self, val: super::vals::Scr03Eoc) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub const fn dcp(&self) -> super::vals::Scr03Dcp {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Scr03Dcp::from_bits(val as u8)
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub fn set_dcp(&mut self, val: super::vals::Scr03Dcp) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "Setting of Operation Mode of Channel 3"]
            #[inline(always)]
            pub const fn trxe(&self) -> super::vals::Scr03Trxe {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Scr03Trxe::from_bits(val as u8)
            }
            #[doc = "Setting of Operation Mode of Channel 3"]
            #[inline(always)]
            pub fn set_trxe(&mut self, val: super::vals::Scr03Trxe) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Scr03 {
            #[inline(always)]
            fn default() -> Scr03 {
                Scr03(0)
            }
        }
        impl core::fmt::Debug for Scr03 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr03")
                    .field("dls", &self.dls())
                    .field("slc", &self.slc())
                    .field("dir", &self.dir())
                    .field("ptc", &self.ptc())
                    .field("eoc", &self.eoc())
                    .field("dcp", &self.dcp())
                    .field("trxe", &self.trxe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr03 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scr03 {{ dls: {:?}, slc: {:?}, dir: {:?}, ptc: {:?}, eoc: {:?}, dcp: {:?}, trxe: {:?} }}" , self . dls () , self . slc () , self . dir () , self . ptc () , self . eoc () , self . dcp () , self . trxe ())
            }
        }
        #[doc = "Serial Data Register 0%s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdr0(pub u16);
        impl Sdr0 {
            #[doc = "Data Buffer for Transmit and Receive"]
            #[inline(always)]
            pub const fn dat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Data Buffer for Transmit and Receive"]
            #[inline(always)]
            pub fn set_dat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "Transfer Clock Setting by Dividing the Operation Clock"]
            #[inline(always)]
            pub const fn stclk(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "Transfer Clock Setting by Dividing the Operation Clock"]
            #[inline(always)]
            pub fn set_stclk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Sdr0 {
            #[inline(always)]
            fn default() -> Sdr0 {
                Sdr0(0)
            }
        }
        impl core::fmt::Debug for Sdr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdr0")
                    .field("dat", &self.dat())
                    .field("stclk", &self.stclk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sdr0 {{ dat: {=u16:?}, stclk: {=u8:?} }}",
                    self.dat(),
                    self.stclk()
                )
            }
        }
        #[doc = "Serial Channel Enable Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Se0(pub u16);
        impl Se0 {
            #[doc = "Indication of whether Operation of Channel n is Enabled or Stopped."]
            #[inline(always)]
            pub const fn se(&self) -> super::vals::Se {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Se::from_bits(val as u8)
            }
            #[doc = "Indication of whether Operation of Channel n is Enabled or Stopped."]
            #[inline(always)]
            pub fn set_se(&mut self, val: super::vals::Se) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
        }
        impl Default for Se0 {
            #[inline(always)]
            fn default() -> Se0 {
                Se0(0)
            }
        }
        impl core::fmt::Debug for Se0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Se0").field("se", &self.se()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Se0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Se0 {{ se: {:?} }}", self.se())
            }
        }
        #[doc = "Serial Flag Clear Trigger Register 00"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sir00(pub u16);
        impl Sir00 {
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub const fn ovct(&self) -> super::vals::Sir00Ovct {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sir00Ovct::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovct(&mut self, val: super::vals::Sir00Ovct) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub const fn pect(&self) -> super::vals::Sir00Pect {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sir00Pect::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_pect(&mut self, val: super::vals::Sir00Pect) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
        }
        impl Default for Sir00 {
            #[inline(always)]
            fn default() -> Sir00 {
                Sir00(0)
            }
        }
        impl core::fmt::Debug for Sir00 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sir00")
                    .field("ovct", &self.ovct())
                    .field("pect", &self.pect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sir00 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sir00 {{ ovct: {:?}, pect: {:?} }}",
                    self.ovct(),
                    self.pect()
                )
            }
        }
        #[doc = "Serial Flag Clear Trigger Register 01"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sir01(pub u16);
        impl Sir01 {
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub const fn ovct(&self) -> super::vals::Sir01Ovct {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sir01Ovct::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovct(&mut self, val: super::vals::Sir01Ovct) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub const fn pect(&self) -> super::vals::Sir01Pect {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sir01Pect::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_pect(&mut self, val: super::vals::Sir01Pect) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Clear Trigger of Framing Error Flag of Channel n"]
            #[inline(always)]
            pub const fn fect(&self) -> super::vals::Sir01Fect {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sir01Fect::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Framing Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_fect(&mut self, val: super::vals::Sir01Fect) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
        }
        impl Default for Sir01 {
            #[inline(always)]
            fn default() -> Sir01 {
                Sir01(0)
            }
        }
        impl core::fmt::Debug for Sir01 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sir01")
                    .field("ovct", &self.ovct())
                    .field("pect", &self.pect())
                    .field("fect", &self.fect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sir01 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sir01 {{ ovct: {:?}, pect: {:?}, fect: {:?} }}",
                    self.ovct(),
                    self.pect(),
                    self.fect()
                )
            }
        }
        #[doc = "Serial Flag Clear Trigger Register 02"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sir02(pub u16);
        impl Sir02 {
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub const fn ovct(&self) -> super::vals::Sir02Ovct {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sir02Ovct::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovct(&mut self, val: super::vals::Sir02Ovct) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub const fn pect(&self) -> super::vals::Sir02Pect {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sir02Pect::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_pect(&mut self, val: super::vals::Sir02Pect) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
        }
        impl Default for Sir02 {
            #[inline(always)]
            fn default() -> Sir02 {
                Sir02(0)
            }
        }
        impl core::fmt::Debug for Sir02 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sir02")
                    .field("ovct", &self.ovct())
                    .field("pect", &self.pect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sir02 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sir02 {{ ovct: {:?}, pect: {:?} }}",
                    self.ovct(),
                    self.pect()
                )
            }
        }
        #[doc = "Serial Flag Clear Trigger Register 03"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sir03(pub u16);
        impl Sir03 {
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub const fn ovct(&self) -> super::vals::Sir03Ovct {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sir03Ovct::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovct(&mut self, val: super::vals::Sir03Ovct) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub const fn pect(&self) -> super::vals::Sir03Pect {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sir03Pect::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_pect(&mut self, val: super::vals::Sir03Pect) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Clear Trigger of Framing Error Flag of Channel n"]
            #[inline(always)]
            pub const fn fect(&self) -> super::vals::Sir03Fect {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sir03Fect::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Framing Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_fect(&mut self, val: super::vals::Sir03Fect) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
        }
        impl Default for Sir03 {
            #[inline(always)]
            fn default() -> Sir03 {
                Sir03(0)
            }
        }
        impl core::fmt::Debug for Sir03 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sir03")
                    .field("ovct", &self.ovct())
                    .field("pect", &self.pect())
                    .field("fect", &self.fect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sir03 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sir03 {{ ovct: {:?}, pect: {:?}, fect: {:?} }}",
                    self.ovct(),
                    self.pect(),
                    self.fect()
                )
            }
        }
        #[doc = "Serial Mode Register 00"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr00(pub u16);
        impl Smr00 {
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub const fn md0(&self) -> super::vals::Smr00Md0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smr00Md0::from_bits(val as u8)
            }
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub fn set_md0(&mut self, val: super::vals::Smr00Md0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub const fn md1(&self) -> super::vals::Smr00Md1 {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Smr00Md1::from_bits(val as u8)
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub fn set_md1(&mut self, val: super::vals::Smr00Md1) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u16) & 0x03) << 1usize);
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Smr00Ccs {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Smr00Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Smr00Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Smr00Cks {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Smr00Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Smr00Cks) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Smr00 {
            #[inline(always)]
            fn default() -> Smr00 {
                Smr00(0)
            }
        }
        impl core::fmt::Debug for Smr00 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr00")
                    .field("md0", &self.md0())
                    .field("md1", &self.md1())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr00 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smr00 {{ md0: {:?}, md1: {:?}, ccs: {:?}, cks: {:?} }}",
                    self.md0(),
                    self.md1(),
                    self.ccs(),
                    self.cks()
                )
            }
        }
        #[doc = "Serial Mode Register 01"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr01(pub u16);
        impl Smr01 {
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub const fn md0(&self) -> super::vals::Smr01Md0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smr01Md0::from_bits(val as u8)
            }
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub fn set_md0(&mut self, val: super::vals::Smr01Md0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub const fn md1(&self) -> super::vals::Smr01Md1 {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Smr01Md1::from_bits(val as u8)
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub fn set_md1(&mut self, val: super::vals::Smr01Md1) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u16) & 0x03) << 1usize);
            }
            #[doc = "Controls Inversion of Level of Channel n Receive Data in UART Mode"]
            #[inline(always)]
            pub const fn sis0(&self) -> super::vals::Smr01Sis0 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Smr01Sis0::from_bits(val as u8)
            }
            #[doc = "Controls Inversion of Level of Channel n Receive Data in UART Mode"]
            #[inline(always)]
            pub fn set_sis0(&mut self, val: super::vals::Smr01Sis0) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Selection of Start Trigger Source"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Smr01Sts {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Smr01Sts::from_bits(val as u8)
            }
            #[doc = "Selection of Start Trigger Source"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Smr01Sts) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Smr01Ccs {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Smr01Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Smr01Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Smr01Cks {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Smr01Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Smr01Cks) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Smr01 {
            #[inline(always)]
            fn default() -> Smr01 {
                Smr01(0)
            }
        }
        impl core::fmt::Debug for Smr01 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr01")
                    .field("md0", &self.md0())
                    .field("md1", &self.md1())
                    .field("sis0", &self.sis0())
                    .field("sts", &self.sts())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr01 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smr01 {{ md0: {:?}, md1: {:?}, sis0: {:?}, sts: {:?}, ccs: {:?}, cks: {:?} }}",
                    self.md0(),
                    self.md1(),
                    self.sis0(),
                    self.sts(),
                    self.ccs(),
                    self.cks()
                )
            }
        }
        #[doc = "Serial Mode Register 02"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr02(pub u16);
        impl Smr02 {
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub const fn md0(&self) -> super::vals::Smr02Md0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smr02Md0::from_bits(val as u8)
            }
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub fn set_md0(&mut self, val: super::vals::Smr02Md0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub const fn md1(&self) -> super::vals::Smr02Md1 {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Smr02Md1::from_bits(val as u8)
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub fn set_md1(&mut self, val: super::vals::Smr02Md1) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u16) & 0x03) << 1usize);
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Smr02Ccs {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Smr02Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Smr02Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Smr02Cks {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Smr02Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Smr02Cks) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Smr02 {
            #[inline(always)]
            fn default() -> Smr02 {
                Smr02(0)
            }
        }
        impl core::fmt::Debug for Smr02 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr02")
                    .field("md0", &self.md0())
                    .field("md1", &self.md1())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr02 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smr02 {{ md0: {:?}, md1: {:?}, ccs: {:?}, cks: {:?} }}",
                    self.md0(),
                    self.md1(),
                    self.ccs(),
                    self.cks()
                )
            }
        }
        #[doc = "Serial Mode Register 03"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr03(pub u16);
        impl Smr03 {
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub const fn md0(&self) -> super::vals::Smr03Md0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smr03Md0::from_bits(val as u8)
            }
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub fn set_md0(&mut self, val: super::vals::Smr03Md0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub const fn md1(&self) -> super::vals::Smr03Md1 {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Smr03Md1::from_bits(val as u8)
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub fn set_md1(&mut self, val: super::vals::Smr03Md1) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u16) & 0x03) << 1usize);
            }
            #[doc = "Controls Inversion of Level of Channel n Receive Data in UART Mode"]
            #[inline(always)]
            pub const fn sis0(&self) -> super::vals::Smr03Sis0 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Smr03Sis0::from_bits(val as u8)
            }
            #[doc = "Controls Inversion of Level of Channel n Receive Data in UART Mode"]
            #[inline(always)]
            pub fn set_sis0(&mut self, val: super::vals::Smr03Sis0) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Selection of Start Trigger Source"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Smr03Sts {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Smr03Sts::from_bits(val as u8)
            }
            #[doc = "Selection of Start Trigger Source"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Smr03Sts) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Smr03Ccs {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Smr03Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Smr03Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Smr03Cks {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Smr03Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Smr03Cks) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Smr03 {
            #[inline(always)]
            fn default() -> Smr03 {
                Smr03(0)
            }
        }
        impl core::fmt::Debug for Smr03 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr03")
                    .field("md0", &self.md0())
                    .field("md1", &self.md1())
                    .field("sis0", &self.sis0())
                    .field("sts", &self.sts())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr03 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smr03 {{ md0: {:?}, md1: {:?}, sis0: {:?}, sts: {:?}, ccs: {:?}, cks: {:?} }}",
                    self.md0(),
                    self.md1(),
                    self.sis0(),
                    self.sts(),
                    self.ccs(),
                    self.cks()
                )
            }
        }
        #[doc = "Serial Output Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct So0(pub u16);
        impl So0 {
            #[doc = "Serial Data Output of Channel n"]
            #[inline(always)]
            pub const fn so(&self) -> super::vals::So {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::So::from_bits(val as u8)
            }
            #[doc = "Serial Data Output of Channel n"]
            #[inline(always)]
            pub fn set_so(&mut self, val: super::vals::So) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
            #[doc = "Serial Clock Output of Channel n"]
            #[inline(always)]
            pub const fn cko(&self) -> super::vals::Cko {
                let val = (self.0 >> 8usize) & 0x0f;
                super::vals::Cko::from_bits(val as u8)
            }
            #[doc = "Serial Clock Output of Channel n"]
            #[inline(always)]
            pub fn set_cko(&mut self, val: super::vals::Cko) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u16) & 0x0f) << 8usize);
            }
        }
        impl Default for So0 {
            #[inline(always)]
            fn default() -> So0 {
                So0(0)
            }
        }
        impl core::fmt::Debug for So0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("So0")
                    .field("so", &self.so())
                    .field("cko", &self.cko())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for So0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "So0 {{ so: {:?}, cko: {:?} }}", self.so(), self.cko())
            }
        }
        #[doc = "Serial Output Enable Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Soe0(pub u16);
        impl Soe0 {
            #[doc = "Serial Output Enable or Stop of Channel n"]
            #[inline(always)]
            pub const fn soe(&self) -> super::vals::Soe {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Soe::from_bits(val as u8)
            }
            #[doc = "Serial Output Enable or Stop of Channel n"]
            #[inline(always)]
            pub fn set_soe(&mut self, val: super::vals::Soe) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
        }
        impl Default for Soe0 {
            #[inline(always)]
            fn default() -> Soe0 {
                Soe0(0)
            }
        }
        impl core::fmt::Debug for Soe0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Soe0").field("soe", &self.soe()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Soe0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Soe0 {{ soe: {:?} }}", self.soe())
            }
        }
        #[doc = "Serial Output Level Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sol0(pub u16);
        impl Sol0 {
            #[doc = "Selects Inversion of the Level of the Transmit Data of Channel 0 in UART Mode"]
            #[inline(always)]
            pub const fn sol0(&self) -> super::vals::Sol0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sol0::from_bits(val as u8)
            }
            #[doc = "Selects Inversion of the Level of the Transmit Data of Channel 0 in UART Mode"]
            #[inline(always)]
            pub fn set_sol0(&mut self, val: super::vals::Sol0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Selects Inversion of the Level of the Transmit Data of Channel 2 in UART Mode"]
            #[inline(always)]
            pub const fn sol2(&self) -> super::vals::Sol2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sol2::from_bits(val as u8)
            }
            #[doc = "Selects Inversion of the Level of the Transmit Data of Channel 2 in UART Mode"]
            #[inline(always)]
            pub fn set_sol2(&mut self, val: super::vals::Sol2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
        }
        impl Default for Sol0 {
            #[inline(always)]
            fn default() -> Sol0 {
                Sol0(0)
            }
        }
        impl core::fmt::Debug for Sol0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sol0")
                    .field("sol0", &self.sol0())
                    .field("sol2", &self.sol2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sol0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sol0 {{ sol0: {:?}, sol2: {:?} }}",
                    self.sol0(),
                    self.sol2()
                )
            }
        }
        #[doc = "Serial Clock Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sps0(pub u16);
        impl Sps0 {
            #[doc = "Selection of Operation Clock (CKm0)"]
            #[inline(always)]
            pub const fn prs0(&self) -> super::vals::Prs0 {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Prs0::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (CKm0)"]
            #[inline(always)]
            pub fn set_prs0(&mut self, val: super::vals::Prs0) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
            #[doc = "Selection of Operation Clock (CKm1)"]
            #[inline(always)]
            pub const fn prs1(&self) -> super::vals::Prs1 {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Prs1::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (CKm1)"]
            #[inline(always)]
            pub fn set_prs1(&mut self, val: super::vals::Prs1) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u16) & 0x0f) << 4usize);
            }
        }
        impl Default for Sps0 {
            #[inline(always)]
            fn default() -> Sps0 {
                Sps0(0)
            }
        }
        impl core::fmt::Debug for Sps0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sps0")
                    .field("prs0", &self.prs0())
                    .field("prs1", &self.prs1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sps0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sps0 {{ prs0: {:?}, prs1: {:?} }}",
                    self.prs0(),
                    self.prs1()
                )
            }
        }
        #[doc = "Serial Channel Start Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ss0(pub u16);
        impl Ss0 {
            #[doc = "Operation Start Trigger of Channel n"]
            #[inline(always)]
            pub const fn ss(&self) -> super::vals::Ss {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Ss::from_bits(val as u8)
            }
            #[doc = "Operation Start Trigger of Channel n"]
            #[inline(always)]
            pub fn set_ss(&mut self, val: super::vals::Ss) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
        }
        impl Default for Ss0 {
            #[inline(always)]
            fn default() -> Ss0 {
                Ss0(0)
            }
        }
        impl core::fmt::Debug for Ss0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ss0").field("ss", &self.ss()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ss0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ss0 {{ ss: {:?} }}", self.ss())
            }
        }
        #[doc = "Serial Standby Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssc0(pub u16);
        impl Ssc0 {
            #[doc = "Setting of the Snooze Mode"]
            #[inline(always)]
            pub const fn swc(&self) -> super::vals::Swc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Swc::from_bits(val as u8)
            }
            #[doc = "Setting of the Snooze Mode"]
            #[inline(always)]
            pub fn set_swc(&mut self, val: super::vals::Swc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Selection of whether to Enable or Disable the Generation of Communication Error Interrupts in the Snooze Mode"]
            #[inline(always)]
            pub const fn ssec(&self) -> super::vals::Ssec {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssec::from_bits(val as u8)
            }
            #[doc = "Selection of whether to Enable or Disable the Generation of Communication Error Interrupts in the Snooze Mode"]
            #[inline(always)]
            pub fn set_ssec(&mut self, val: super::vals::Ssec) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
        }
        impl Default for Ssc0 {
            #[inline(always)]
            fn default() -> Ssc0 {
                Ssc0(0)
            }
        }
        impl core::fmt::Debug for Ssc0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssc0")
                    .field("swc", &self.swc())
                    .field("ssec", &self.ssec())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssc0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ssc0 {{ swc: {:?}, ssec: {:?} }}",
                    self.swc(),
                    self.ssec()
                )
            }
        }
        #[doc = "Serial Status Register 00"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr00(pub u16);
        impl Ssr00 {
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn ovf(&self) -> super::vals::Ssr00Ovf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssr00Ovf::from_bits(val as u8)
            }
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovf(&mut self, val: super::vals::Ssr00Ovf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn pef(&self) -> super::vals::Ssr00Pef {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssr00Pef::from_bits(val as u8)
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_pef(&mut self, val: super::vals::Ssr00Pef) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub const fn bff(&self) -> super::vals::Ssr00Bff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ssr00Bff::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub fn set_bff(&mut self, val: super::vals::Ssr00Bff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub const fn tsf(&self) -> super::vals::Ssr00Tsf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ssr00Tsf::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub fn set_tsf(&mut self, val: super::vals::Ssr00Tsf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
        }
        impl Default for Ssr00 {
            #[inline(always)]
            fn default() -> Ssr00 {
                Ssr00(0)
            }
        }
        impl core::fmt::Debug for Ssr00 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr00")
                    .field("ovf", &self.ovf())
                    .field("pef", &self.pef())
                    .field("bff", &self.bff())
                    .field("tsf", &self.tsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr00 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ssr00 {{ ovf: {:?}, pef: {:?}, bff: {:?}, tsf: {:?} }}",
                    self.ovf(),
                    self.pef(),
                    self.bff(),
                    self.tsf()
                )
            }
        }
        #[doc = "Serial Status Register 01"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr01(pub u16);
        impl Ssr01 {
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn ovf(&self) -> super::vals::Ssr01Ovf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssr01Ovf::from_bits(val as u8)
            }
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovf(&mut self, val: super::vals::Ssr01Ovf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn pef(&self) -> super::vals::Ssr01Pef {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssr01Pef::from_bits(val as u8)
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_pef(&mut self, val: super::vals::Ssr01Pef) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Framing Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn fef(&self) -> super::vals::Ssr01Fef {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ssr01Fef::from_bits(val as u8)
            }
            #[doc = "Framing Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_fef(&mut self, val: super::vals::Ssr01Fef) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub const fn bff(&self) -> super::vals::Ssr01Bff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ssr01Bff::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub fn set_bff(&mut self, val: super::vals::Ssr01Bff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub const fn tsf(&self) -> super::vals::Ssr01Tsf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ssr01Tsf::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub fn set_tsf(&mut self, val: super::vals::Ssr01Tsf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
        }
        impl Default for Ssr01 {
            #[inline(always)]
            fn default() -> Ssr01 {
                Ssr01(0)
            }
        }
        impl core::fmt::Debug for Ssr01 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr01")
                    .field("ovf", &self.ovf())
                    .field("pef", &self.pef())
                    .field("fef", &self.fef())
                    .field("bff", &self.bff())
                    .field("tsf", &self.tsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr01 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ssr01 {{ ovf: {:?}, pef: {:?}, fef: {:?}, bff: {:?}, tsf: {:?} }}",
                    self.ovf(),
                    self.pef(),
                    self.fef(),
                    self.bff(),
                    self.tsf()
                )
            }
        }
        #[doc = "Serial Status Register 02"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr02(pub u16);
        impl Ssr02 {
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn ovf(&self) -> super::vals::Ssr02Ovf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssr02Ovf::from_bits(val as u8)
            }
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovf(&mut self, val: super::vals::Ssr02Ovf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn pef(&self) -> super::vals::Ssr02Pef {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssr02Pef::from_bits(val as u8)
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_pef(&mut self, val: super::vals::Ssr02Pef) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub const fn bff(&self) -> super::vals::Ssr02Bff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ssr02Bff::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub fn set_bff(&mut self, val: super::vals::Ssr02Bff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub const fn tsf(&self) -> super::vals::Ssr02Tsf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ssr02Tsf::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub fn set_tsf(&mut self, val: super::vals::Ssr02Tsf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
        }
        impl Default for Ssr02 {
            #[inline(always)]
            fn default() -> Ssr02 {
                Ssr02(0)
            }
        }
        impl core::fmt::Debug for Ssr02 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr02")
                    .field("ovf", &self.ovf())
                    .field("pef", &self.pef())
                    .field("bff", &self.bff())
                    .field("tsf", &self.tsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr02 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ssr02 {{ ovf: {:?}, pef: {:?}, bff: {:?}, tsf: {:?} }}",
                    self.ovf(),
                    self.pef(),
                    self.bff(),
                    self.tsf()
                )
            }
        }
        #[doc = "Serial Status Register 03"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr03(pub u16);
        impl Ssr03 {
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn ovf(&self) -> super::vals::Ssr03Ovf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssr03Ovf::from_bits(val as u8)
            }
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovf(&mut self, val: super::vals::Ssr03Ovf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn pef(&self) -> super::vals::Ssr03Pef {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssr03Pef::from_bits(val as u8)
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_pef(&mut self, val: super::vals::Ssr03Pef) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Framing Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn fef(&self) -> super::vals::Ssr03Fef {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ssr03Fef::from_bits(val as u8)
            }
            #[doc = "Framing Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_fef(&mut self, val: super::vals::Ssr03Fef) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub const fn bff(&self) -> super::vals::Ssr03Bff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ssr03Bff::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub fn set_bff(&mut self, val: super::vals::Ssr03Bff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub const fn tsf(&self) -> super::vals::Ssr03Tsf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ssr03Tsf::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub fn set_tsf(&mut self, val: super::vals::Ssr03Tsf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
        }
        impl Default for Ssr03 {
            #[inline(always)]
            fn default() -> Ssr03 {
                Ssr03(0)
            }
        }
        impl core::fmt::Debug for Ssr03 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr03")
                    .field("ovf", &self.ovf())
                    .field("pef", &self.pef())
                    .field("fef", &self.fef())
                    .field("bff", &self.bff())
                    .field("tsf", &self.tsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr03 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ssr03 {{ ovf: {:?}, pef: {:?}, fef: {:?}, bff: {:?}, tsf: {:?} }}",
                    self.ovf(),
                    self.pef(),
                    self.fef(),
                    self.bff(),
                    self.tsf()
                )
            }
        }
        #[doc = "Serial Channel Stop Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct St0(pub u16);
        impl St0 {
            #[doc = "Operation Stop Trigger of Channel n"]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::St {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::St::from_bits(val as u8)
            }
            #[doc = "Operation Stop Trigger of Channel n"]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::St) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
        }
        impl Default for St0 {
            #[inline(always)]
            fn default() -> St0 {
                St0(0)
            }
        }
        impl core::fmt::Debug for St0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("St0").field("st", &self.st()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for St0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "St0 {{ st: {:?} }}", self.st())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cko {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Cko {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cko {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cko {
            #[inline(always)]
            fn from(val: u8) -> Cko {
                Cko::from_bits(val)
            }
        }
        impl From<Cko> for u8 {
            #[inline(always)]
            fn from(val: Cko) -> u8 {
                Cko::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prs0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Prs0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prs0 {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prs0 {
            #[inline(always)]
            fn from(val: u8) -> Prs0 {
                Prs0::from_bits(val)
            }
        }
        impl From<Prs0> for u8 {
            #[inline(always)]
            fn from(val: Prs0) -> u8 {
                Prs0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prs1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Prs1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prs1 {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prs1 {
            #[inline(always)]
            fn from(val: u8) -> Prs1 {
                Prs1::from_bits(val)
            }
        }
        impl From<Prs1> for u8 {
            #[inline(always)]
            fn from(val: Prs1) -> u8 {
                Prs1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr00Dcp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr00Dcp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr00Dcp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr00Dcp {
            #[inline(always)]
            fn from(val: u8) -> Scr00Dcp {
                Scr00Dcp::from_bits(val)
            }
        }
        impl From<Scr00Dcp> for u8 {
            #[inline(always)]
            fn from(val: Scr00Dcp) -> u8 {
                Scr00Dcp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr00Dir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr00Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr00Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr00Dir {
            #[inline(always)]
            fn from(val: u8) -> Scr00Dir {
                Scr00Dir::from_bits(val)
            }
        }
        impl From<Scr00Dir> for u8 {
            #[inline(always)]
            fn from(val: Scr00Dir) -> u8 {
                Scr00Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr00Dls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr00Dls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr00Dls {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr00Dls {
            #[inline(always)]
            fn from(val: u8) -> Scr00Dls {
                Scr00Dls::from_bits(val)
            }
        }
        impl From<Scr00Dls> for u8 {
            #[inline(always)]
            fn from(val: Scr00Dls) -> u8 {
                Scr00Dls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr00Ptc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr00Ptc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr00Ptc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr00Ptc {
            #[inline(always)]
            fn from(val: u8) -> Scr00Ptc {
                Scr00Ptc::from_bits(val)
            }
        }
        impl From<Scr00Ptc> for u8 {
            #[inline(always)]
            fn from(val: Scr00Ptc) -> u8 {
                Scr00Ptc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr00Slc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr00Slc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr00Slc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr00Slc {
            #[inline(always)]
            fn from(val: u8) -> Scr00Slc {
                Scr00Slc::from_bits(val)
            }
        }
        impl From<Scr00Slc> for u8 {
            #[inline(always)]
            fn from(val: Scr00Slc) -> u8 {
                Scr00Slc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr00Trxe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr00Trxe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr00Trxe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr00Trxe {
            #[inline(always)]
            fn from(val: u8) -> Scr00Trxe {
                Scr00Trxe::from_bits(val)
            }
        }
        impl From<Scr00Trxe> for u8 {
            #[inline(always)]
            fn from(val: Scr00Trxe) -> u8 {
                Scr00Trxe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr01Dcp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr01Dcp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr01Dcp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr01Dcp {
            #[inline(always)]
            fn from(val: u8) -> Scr01Dcp {
                Scr01Dcp::from_bits(val)
            }
        }
        impl From<Scr01Dcp> for u8 {
            #[inline(always)]
            fn from(val: Scr01Dcp) -> u8 {
                Scr01Dcp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr01Dir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr01Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr01Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr01Dir {
            #[inline(always)]
            fn from(val: u8) -> Scr01Dir {
                Scr01Dir::from_bits(val)
            }
        }
        impl From<Scr01Dir> for u8 {
            #[inline(always)]
            fn from(val: Scr01Dir) -> u8 {
                Scr01Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr01Dls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr01Dls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr01Dls {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr01Dls {
            #[inline(always)]
            fn from(val: u8) -> Scr01Dls {
                Scr01Dls::from_bits(val)
            }
        }
        impl From<Scr01Dls> for u8 {
            #[inline(always)]
            fn from(val: Scr01Dls) -> u8 {
                Scr01Dls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr01Eoc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr01Eoc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr01Eoc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr01Eoc {
            #[inline(always)]
            fn from(val: u8) -> Scr01Eoc {
                Scr01Eoc::from_bits(val)
            }
        }
        impl From<Scr01Eoc> for u8 {
            #[inline(always)]
            fn from(val: Scr01Eoc) -> u8 {
                Scr01Eoc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr01Ptc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr01Ptc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr01Ptc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr01Ptc {
            #[inline(always)]
            fn from(val: u8) -> Scr01Ptc {
                Scr01Ptc::from_bits(val)
            }
        }
        impl From<Scr01Ptc> for u8 {
            #[inline(always)]
            fn from(val: Scr01Ptc) -> u8 {
                Scr01Ptc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr01Slc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr01Slc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr01Slc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr01Slc {
            #[inline(always)]
            fn from(val: u8) -> Scr01Slc {
                Scr01Slc::from_bits(val)
            }
        }
        impl From<Scr01Slc> for u8 {
            #[inline(always)]
            fn from(val: Scr01Slc) -> u8 {
                Scr01Slc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr01Trxe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr01Trxe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr01Trxe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr01Trxe {
            #[inline(always)]
            fn from(val: u8) -> Scr01Trxe {
                Scr01Trxe::from_bits(val)
            }
        }
        impl From<Scr01Trxe> for u8 {
            #[inline(always)]
            fn from(val: Scr01Trxe) -> u8 {
                Scr01Trxe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr02Dcp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr02Dcp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr02Dcp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr02Dcp {
            #[inline(always)]
            fn from(val: u8) -> Scr02Dcp {
                Scr02Dcp::from_bits(val)
            }
        }
        impl From<Scr02Dcp> for u8 {
            #[inline(always)]
            fn from(val: Scr02Dcp) -> u8 {
                Scr02Dcp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr02Dir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr02Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr02Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr02Dir {
            #[inline(always)]
            fn from(val: u8) -> Scr02Dir {
                Scr02Dir::from_bits(val)
            }
        }
        impl From<Scr02Dir> for u8 {
            #[inline(always)]
            fn from(val: Scr02Dir) -> u8 {
                Scr02Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr02Dls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr02Dls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr02Dls {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr02Dls {
            #[inline(always)]
            fn from(val: u8) -> Scr02Dls {
                Scr02Dls::from_bits(val)
            }
        }
        impl From<Scr02Dls> for u8 {
            #[inline(always)]
            fn from(val: Scr02Dls) -> u8 {
                Scr02Dls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr02Ptc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr02Ptc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr02Ptc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr02Ptc {
            #[inline(always)]
            fn from(val: u8) -> Scr02Ptc {
                Scr02Ptc::from_bits(val)
            }
        }
        impl From<Scr02Ptc> for u8 {
            #[inline(always)]
            fn from(val: Scr02Ptc) -> u8 {
                Scr02Ptc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr02Slc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr02Slc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr02Slc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr02Slc {
            #[inline(always)]
            fn from(val: u8) -> Scr02Slc {
                Scr02Slc::from_bits(val)
            }
        }
        impl From<Scr02Slc> for u8 {
            #[inline(always)]
            fn from(val: Scr02Slc) -> u8 {
                Scr02Slc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr02Trxe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr02Trxe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr02Trxe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr02Trxe {
            #[inline(always)]
            fn from(val: u8) -> Scr02Trxe {
                Scr02Trxe::from_bits(val)
            }
        }
        impl From<Scr02Trxe> for u8 {
            #[inline(always)]
            fn from(val: Scr02Trxe) -> u8 {
                Scr02Trxe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr03Dcp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr03Dcp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr03Dcp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr03Dcp {
            #[inline(always)]
            fn from(val: u8) -> Scr03Dcp {
                Scr03Dcp::from_bits(val)
            }
        }
        impl From<Scr03Dcp> for u8 {
            #[inline(always)]
            fn from(val: Scr03Dcp) -> u8 {
                Scr03Dcp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr03Dir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr03Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr03Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr03Dir {
            #[inline(always)]
            fn from(val: u8) -> Scr03Dir {
                Scr03Dir::from_bits(val)
            }
        }
        impl From<Scr03Dir> for u8 {
            #[inline(always)]
            fn from(val: Scr03Dir) -> u8 {
                Scr03Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr03Dls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr03Dls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr03Dls {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr03Dls {
            #[inline(always)]
            fn from(val: u8) -> Scr03Dls {
                Scr03Dls::from_bits(val)
            }
        }
        impl From<Scr03Dls> for u8 {
            #[inline(always)]
            fn from(val: Scr03Dls) -> u8 {
                Scr03Dls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr03Eoc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr03Eoc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr03Eoc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr03Eoc {
            #[inline(always)]
            fn from(val: u8) -> Scr03Eoc {
                Scr03Eoc::from_bits(val)
            }
        }
        impl From<Scr03Eoc> for u8 {
            #[inline(always)]
            fn from(val: Scr03Eoc) -> u8 {
                Scr03Eoc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr03Ptc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr03Ptc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr03Ptc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr03Ptc {
            #[inline(always)]
            fn from(val: u8) -> Scr03Ptc {
                Scr03Ptc::from_bits(val)
            }
        }
        impl From<Scr03Ptc> for u8 {
            #[inline(always)]
            fn from(val: Scr03Ptc) -> u8 {
                Scr03Ptc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr03Slc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr03Slc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr03Slc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr03Slc {
            #[inline(always)]
            fn from(val: u8) -> Scr03Slc {
                Scr03Slc::from_bits(val)
            }
        }
        impl From<Scr03Slc> for u8 {
            #[inline(always)]
            fn from(val: Scr03Slc) -> u8 {
                Scr03Slc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr03Trxe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr03Trxe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr03Trxe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr03Trxe {
            #[inline(always)]
            fn from(val: u8) -> Scr03Trxe {
                Scr03Trxe::from_bits(val)
            }
        }
        impl From<Scr03Trxe> for u8 {
            #[inline(always)]
            fn from(val: Scr03Trxe) -> u8 {
                Scr03Trxe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Se {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Se {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Se {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Se {
            #[inline(always)]
            fn from(val: u8) -> Se {
                Se::from_bits(val)
            }
        }
        impl From<Se> for u8 {
            #[inline(always)]
            fn from(val: Se) -> u8 {
                Se::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir00Ovct {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir00Ovct {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir00Ovct {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir00Ovct {
            #[inline(always)]
            fn from(val: u8) -> Sir00Ovct {
                Sir00Ovct::from_bits(val)
            }
        }
        impl From<Sir00Ovct> for u8 {
            #[inline(always)]
            fn from(val: Sir00Ovct) -> u8 {
                Sir00Ovct::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir00Pect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir00Pect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir00Pect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir00Pect {
            #[inline(always)]
            fn from(val: u8) -> Sir00Pect {
                Sir00Pect::from_bits(val)
            }
        }
        impl From<Sir00Pect> for u8 {
            #[inline(always)]
            fn from(val: Sir00Pect) -> u8 {
                Sir00Pect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir01Fect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir01Fect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir01Fect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir01Fect {
            #[inline(always)]
            fn from(val: u8) -> Sir01Fect {
                Sir01Fect::from_bits(val)
            }
        }
        impl From<Sir01Fect> for u8 {
            #[inline(always)]
            fn from(val: Sir01Fect) -> u8 {
                Sir01Fect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir01Ovct {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir01Ovct {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir01Ovct {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir01Ovct {
            #[inline(always)]
            fn from(val: u8) -> Sir01Ovct {
                Sir01Ovct::from_bits(val)
            }
        }
        impl From<Sir01Ovct> for u8 {
            #[inline(always)]
            fn from(val: Sir01Ovct) -> u8 {
                Sir01Ovct::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir01Pect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir01Pect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir01Pect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir01Pect {
            #[inline(always)]
            fn from(val: u8) -> Sir01Pect {
                Sir01Pect::from_bits(val)
            }
        }
        impl From<Sir01Pect> for u8 {
            #[inline(always)]
            fn from(val: Sir01Pect) -> u8 {
                Sir01Pect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir02Ovct {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir02Ovct {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir02Ovct {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir02Ovct {
            #[inline(always)]
            fn from(val: u8) -> Sir02Ovct {
                Sir02Ovct::from_bits(val)
            }
        }
        impl From<Sir02Ovct> for u8 {
            #[inline(always)]
            fn from(val: Sir02Ovct) -> u8 {
                Sir02Ovct::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir02Pect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir02Pect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir02Pect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir02Pect {
            #[inline(always)]
            fn from(val: u8) -> Sir02Pect {
                Sir02Pect::from_bits(val)
            }
        }
        impl From<Sir02Pect> for u8 {
            #[inline(always)]
            fn from(val: Sir02Pect) -> u8 {
                Sir02Pect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir03Fect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir03Fect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir03Fect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir03Fect {
            #[inline(always)]
            fn from(val: u8) -> Sir03Fect {
                Sir03Fect::from_bits(val)
            }
        }
        impl From<Sir03Fect> for u8 {
            #[inline(always)]
            fn from(val: Sir03Fect) -> u8 {
                Sir03Fect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir03Ovct {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir03Ovct {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir03Ovct {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir03Ovct {
            #[inline(always)]
            fn from(val: u8) -> Sir03Ovct {
                Sir03Ovct::from_bits(val)
            }
        }
        impl From<Sir03Ovct> for u8 {
            #[inline(always)]
            fn from(val: Sir03Ovct) -> u8 {
                Sir03Ovct::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir03Pect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir03Pect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir03Pect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir03Pect {
            #[inline(always)]
            fn from(val: u8) -> Sir03Pect {
                Sir03Pect::from_bits(val)
            }
        }
        impl From<Sir03Pect> for u8 {
            #[inline(always)]
            fn from(val: Sir03Pect) -> u8 {
                Sir03Pect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr00Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr00Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr00Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr00Ccs {
            #[inline(always)]
            fn from(val: u8) -> Smr00Ccs {
                Smr00Ccs::from_bits(val)
            }
        }
        impl From<Smr00Ccs> for u8 {
            #[inline(always)]
            fn from(val: Smr00Ccs) -> u8 {
                Smr00Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr00Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr00Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr00Cks {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr00Cks {
            #[inline(always)]
            fn from(val: u8) -> Smr00Cks {
                Smr00Cks::from_bits(val)
            }
        }
        impl From<Smr00Cks> for u8 {
            #[inline(always)]
            fn from(val: Smr00Cks) -> u8 {
                Smr00Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr00Md0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr00Md0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr00Md0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr00Md0 {
            #[inline(always)]
            fn from(val: u8) -> Smr00Md0 {
                Smr00Md0::from_bits(val)
            }
        }
        impl From<Smr00Md0> for u8 {
            #[inline(always)]
            fn from(val: Smr00Md0) -> u8 {
                Smr00Md0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr00Md1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Smr00Md1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr00Md1 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr00Md1 {
            #[inline(always)]
            fn from(val: u8) -> Smr00Md1 {
                Smr00Md1::from_bits(val)
            }
        }
        impl From<Smr00Md1> for u8 {
            #[inline(always)]
            fn from(val: Smr00Md1) -> u8 {
                Smr00Md1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr01Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr01Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr01Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr01Ccs {
            #[inline(always)]
            fn from(val: u8) -> Smr01Ccs {
                Smr01Ccs::from_bits(val)
            }
        }
        impl From<Smr01Ccs> for u8 {
            #[inline(always)]
            fn from(val: Smr01Ccs) -> u8 {
                Smr01Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr01Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr01Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr01Cks {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr01Cks {
            #[inline(always)]
            fn from(val: u8) -> Smr01Cks {
                Smr01Cks::from_bits(val)
            }
        }
        impl From<Smr01Cks> for u8 {
            #[inline(always)]
            fn from(val: Smr01Cks) -> u8 {
                Smr01Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr01Md0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr01Md0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr01Md0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr01Md0 {
            #[inline(always)]
            fn from(val: u8) -> Smr01Md0 {
                Smr01Md0::from_bits(val)
            }
        }
        impl From<Smr01Md0> for u8 {
            #[inline(always)]
            fn from(val: Smr01Md0) -> u8 {
                Smr01Md0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr01Md1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Smr01Md1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr01Md1 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr01Md1 {
            #[inline(always)]
            fn from(val: u8) -> Smr01Md1 {
                Smr01Md1::from_bits(val)
            }
        }
        impl From<Smr01Md1> for u8 {
            #[inline(always)]
            fn from(val: Smr01Md1) -> u8 {
                Smr01Md1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr01Sis0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr01Sis0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr01Sis0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr01Sis0 {
            #[inline(always)]
            fn from(val: u8) -> Smr01Sis0 {
                Smr01Sis0::from_bits(val)
            }
        }
        impl From<Smr01Sis0> for u8 {
            #[inline(always)]
            fn from(val: Smr01Sis0) -> u8 {
                Smr01Sis0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr01Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr01Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr01Sts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr01Sts {
            #[inline(always)]
            fn from(val: u8) -> Smr01Sts {
                Smr01Sts::from_bits(val)
            }
        }
        impl From<Smr01Sts> for u8 {
            #[inline(always)]
            fn from(val: Smr01Sts) -> u8 {
                Smr01Sts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr02Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr02Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr02Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr02Ccs {
            #[inline(always)]
            fn from(val: u8) -> Smr02Ccs {
                Smr02Ccs::from_bits(val)
            }
        }
        impl From<Smr02Ccs> for u8 {
            #[inline(always)]
            fn from(val: Smr02Ccs) -> u8 {
                Smr02Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr02Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr02Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr02Cks {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr02Cks {
            #[inline(always)]
            fn from(val: u8) -> Smr02Cks {
                Smr02Cks::from_bits(val)
            }
        }
        impl From<Smr02Cks> for u8 {
            #[inline(always)]
            fn from(val: Smr02Cks) -> u8 {
                Smr02Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr02Md0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr02Md0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr02Md0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr02Md0 {
            #[inline(always)]
            fn from(val: u8) -> Smr02Md0 {
                Smr02Md0::from_bits(val)
            }
        }
        impl From<Smr02Md0> for u8 {
            #[inline(always)]
            fn from(val: Smr02Md0) -> u8 {
                Smr02Md0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr02Md1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Smr02Md1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr02Md1 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr02Md1 {
            #[inline(always)]
            fn from(val: u8) -> Smr02Md1 {
                Smr02Md1::from_bits(val)
            }
        }
        impl From<Smr02Md1> for u8 {
            #[inline(always)]
            fn from(val: Smr02Md1) -> u8 {
                Smr02Md1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr03Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr03Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr03Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr03Ccs {
            #[inline(always)]
            fn from(val: u8) -> Smr03Ccs {
                Smr03Ccs::from_bits(val)
            }
        }
        impl From<Smr03Ccs> for u8 {
            #[inline(always)]
            fn from(val: Smr03Ccs) -> u8 {
                Smr03Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr03Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr03Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr03Cks {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr03Cks {
            #[inline(always)]
            fn from(val: u8) -> Smr03Cks {
                Smr03Cks::from_bits(val)
            }
        }
        impl From<Smr03Cks> for u8 {
            #[inline(always)]
            fn from(val: Smr03Cks) -> u8 {
                Smr03Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr03Md0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr03Md0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr03Md0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr03Md0 {
            #[inline(always)]
            fn from(val: u8) -> Smr03Md0 {
                Smr03Md0::from_bits(val)
            }
        }
        impl From<Smr03Md0> for u8 {
            #[inline(always)]
            fn from(val: Smr03Md0) -> u8 {
                Smr03Md0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr03Md1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Smr03Md1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr03Md1 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr03Md1 {
            #[inline(always)]
            fn from(val: u8) -> Smr03Md1 {
                Smr03Md1::from_bits(val)
            }
        }
        impl From<Smr03Md1> for u8 {
            #[inline(always)]
            fn from(val: Smr03Md1) -> u8 {
                Smr03Md1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr03Sis0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr03Sis0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr03Sis0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr03Sis0 {
            #[inline(always)]
            fn from(val: u8) -> Smr03Sis0 {
                Smr03Sis0::from_bits(val)
            }
        }
        impl From<Smr03Sis0> for u8 {
            #[inline(always)]
            fn from(val: Smr03Sis0) -> u8 {
                Smr03Sis0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr03Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr03Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr03Sts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr03Sts {
            #[inline(always)]
            fn from(val: u8) -> Smr03Sts {
                Smr03Sts::from_bits(val)
            }
        }
        impl From<Smr03Sts> for u8 {
            #[inline(always)]
            fn from(val: Smr03Sts) -> u8 {
                Smr03Sts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum So {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl So {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> So {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for So {
            #[inline(always)]
            fn from(val: u8) -> So {
                So::from_bits(val)
            }
        }
        impl From<So> for u8 {
            #[inline(always)]
            fn from(val: So) -> u8 {
                So::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Soe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Soe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Soe {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Soe {
            #[inline(always)]
            fn from(val: u8) -> Soe {
                Soe::from_bits(val)
            }
        }
        impl From<Soe> for u8 {
            #[inline(always)]
            fn from(val: Soe) -> u8 {
                Soe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sol0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sol0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sol0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sol0 {
            #[inline(always)]
            fn from(val: u8) -> Sol0 {
                Sol0::from_bits(val)
            }
        }
        impl From<Sol0> for u8 {
            #[inline(always)]
            fn from(val: Sol0) -> u8 {
                Sol0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sol2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sol2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sol2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sol2 {
            #[inline(always)]
            fn from(val: u8) -> Sol2 {
                Sol2::from_bits(val)
            }
        }
        impl From<Sol2> for u8 {
            #[inline(always)]
            fn from(val: Sol2) -> u8 {
                Sol2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Ss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ss {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ss {
            #[inline(always)]
            fn from(val: u8) -> Ss {
                Ss::from_bits(val)
            }
        }
        impl From<Ss> for u8 {
            #[inline(always)]
            fn from(val: Ss) -> u8 {
                Ss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssec {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssec {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssec {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssec {
            #[inline(always)]
            fn from(val: u8) -> Ssec {
                Ssec::from_bits(val)
            }
        }
        impl From<Ssec> for u8 {
            #[inline(always)]
            fn from(val: Ssec) -> u8 {
                Ssec::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr00Bff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr00Bff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr00Bff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr00Bff {
            #[inline(always)]
            fn from(val: u8) -> Ssr00Bff {
                Ssr00Bff::from_bits(val)
            }
        }
        impl From<Ssr00Bff> for u8 {
            #[inline(always)]
            fn from(val: Ssr00Bff) -> u8 {
                Ssr00Bff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr00Ovf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr00Ovf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr00Ovf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr00Ovf {
            #[inline(always)]
            fn from(val: u8) -> Ssr00Ovf {
                Ssr00Ovf::from_bits(val)
            }
        }
        impl From<Ssr00Ovf> for u8 {
            #[inline(always)]
            fn from(val: Ssr00Ovf) -> u8 {
                Ssr00Ovf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr00Pef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr00Pef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr00Pef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr00Pef {
            #[inline(always)]
            fn from(val: u8) -> Ssr00Pef {
                Ssr00Pef::from_bits(val)
            }
        }
        impl From<Ssr00Pef> for u8 {
            #[inline(always)]
            fn from(val: Ssr00Pef) -> u8 {
                Ssr00Pef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr00Tsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr00Tsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr00Tsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr00Tsf {
            #[inline(always)]
            fn from(val: u8) -> Ssr00Tsf {
                Ssr00Tsf::from_bits(val)
            }
        }
        impl From<Ssr00Tsf> for u8 {
            #[inline(always)]
            fn from(val: Ssr00Tsf) -> u8 {
                Ssr00Tsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr01Bff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr01Bff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr01Bff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr01Bff {
            #[inline(always)]
            fn from(val: u8) -> Ssr01Bff {
                Ssr01Bff::from_bits(val)
            }
        }
        impl From<Ssr01Bff> for u8 {
            #[inline(always)]
            fn from(val: Ssr01Bff) -> u8 {
                Ssr01Bff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr01Fef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr01Fef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr01Fef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr01Fef {
            #[inline(always)]
            fn from(val: u8) -> Ssr01Fef {
                Ssr01Fef::from_bits(val)
            }
        }
        impl From<Ssr01Fef> for u8 {
            #[inline(always)]
            fn from(val: Ssr01Fef) -> u8 {
                Ssr01Fef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr01Ovf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr01Ovf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr01Ovf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr01Ovf {
            #[inline(always)]
            fn from(val: u8) -> Ssr01Ovf {
                Ssr01Ovf::from_bits(val)
            }
        }
        impl From<Ssr01Ovf> for u8 {
            #[inline(always)]
            fn from(val: Ssr01Ovf) -> u8 {
                Ssr01Ovf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr01Pef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr01Pef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr01Pef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr01Pef {
            #[inline(always)]
            fn from(val: u8) -> Ssr01Pef {
                Ssr01Pef::from_bits(val)
            }
        }
        impl From<Ssr01Pef> for u8 {
            #[inline(always)]
            fn from(val: Ssr01Pef) -> u8 {
                Ssr01Pef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr01Tsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr01Tsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr01Tsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr01Tsf {
            #[inline(always)]
            fn from(val: u8) -> Ssr01Tsf {
                Ssr01Tsf::from_bits(val)
            }
        }
        impl From<Ssr01Tsf> for u8 {
            #[inline(always)]
            fn from(val: Ssr01Tsf) -> u8 {
                Ssr01Tsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr02Bff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr02Bff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr02Bff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr02Bff {
            #[inline(always)]
            fn from(val: u8) -> Ssr02Bff {
                Ssr02Bff::from_bits(val)
            }
        }
        impl From<Ssr02Bff> for u8 {
            #[inline(always)]
            fn from(val: Ssr02Bff) -> u8 {
                Ssr02Bff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr02Ovf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr02Ovf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr02Ovf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr02Ovf {
            #[inline(always)]
            fn from(val: u8) -> Ssr02Ovf {
                Ssr02Ovf::from_bits(val)
            }
        }
        impl From<Ssr02Ovf> for u8 {
            #[inline(always)]
            fn from(val: Ssr02Ovf) -> u8 {
                Ssr02Ovf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr02Pef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr02Pef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr02Pef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr02Pef {
            #[inline(always)]
            fn from(val: u8) -> Ssr02Pef {
                Ssr02Pef::from_bits(val)
            }
        }
        impl From<Ssr02Pef> for u8 {
            #[inline(always)]
            fn from(val: Ssr02Pef) -> u8 {
                Ssr02Pef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr02Tsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr02Tsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr02Tsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr02Tsf {
            #[inline(always)]
            fn from(val: u8) -> Ssr02Tsf {
                Ssr02Tsf::from_bits(val)
            }
        }
        impl From<Ssr02Tsf> for u8 {
            #[inline(always)]
            fn from(val: Ssr02Tsf) -> u8 {
                Ssr02Tsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr03Bff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr03Bff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr03Bff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr03Bff {
            #[inline(always)]
            fn from(val: u8) -> Ssr03Bff {
                Ssr03Bff::from_bits(val)
            }
        }
        impl From<Ssr03Bff> for u8 {
            #[inline(always)]
            fn from(val: Ssr03Bff) -> u8 {
                Ssr03Bff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr03Fef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr03Fef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr03Fef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr03Fef {
            #[inline(always)]
            fn from(val: u8) -> Ssr03Fef {
                Ssr03Fef::from_bits(val)
            }
        }
        impl From<Ssr03Fef> for u8 {
            #[inline(always)]
            fn from(val: Ssr03Fef) -> u8 {
                Ssr03Fef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr03Ovf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr03Ovf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr03Ovf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr03Ovf {
            #[inline(always)]
            fn from(val: u8) -> Ssr03Ovf {
                Ssr03Ovf::from_bits(val)
            }
        }
        impl From<Ssr03Ovf> for u8 {
            #[inline(always)]
            fn from(val: Ssr03Ovf) -> u8 {
                Ssr03Ovf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr03Pef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr03Pef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr03Pef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr03Pef {
            #[inline(always)]
            fn from(val: u8) -> Ssr03Pef {
                Ssr03Pef::from_bits(val)
            }
        }
        impl From<Ssr03Pef> for u8 {
            #[inline(always)]
            fn from(val: Ssr03Pef) -> u8 {
                Ssr03Pef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr03Tsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr03Tsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr03Tsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr03Tsf {
            #[inline(always)]
            fn from(val: u8) -> Ssr03Tsf {
                Ssr03Tsf::from_bits(val)
            }
        }
        impl From<Ssr03Tsf> for u8 {
            #[inline(always)]
            fn from(val: Ssr03Tsf) -> u8 {
                Ssr03Tsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl St {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St {
            #[inline(always)]
            fn from(val: u8) -> St {
                St::from_bits(val)
            }
        }
        impl From<St> for u8 {
            #[inline(always)]
            fn from(val: St) -> u8 {
                St::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Swc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swc {
            #[inline(always)]
            fn from(val: u8) -> Swc {
                Swc::from_bits(val)
            }
        }
        impl From<Swc> for u8 {
            #[inline(always)]
            fn from(val: Swc) -> u8 {
                Swc::to_bits(val)
            }
        }
    }
}
pub mod sau1 {
    #[doc = "Serial Array Unit 1"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sau1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Sau1 {}
    unsafe impl Sync for Sau1 {}
    impl Sau1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Serial Data Register 1%s"]
        #[inline(always)]
        pub const fn sdr1(self, n: usize) -> crate::common::Reg<regs::Sdr1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 2usize) as _) }
        }
        #[doc = "Serial Status Register 10"]
        #[inline(always)]
        pub const fn ssr10(self) -> crate::common::Reg<regs::Ssr10, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Serial Status Register 11"]
        #[inline(always)]
        pub const fn ssr11(self) -> crate::common::Reg<regs::Ssr11, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize) as _) }
        }
        #[doc = "Serial Flag Clear Trigger Register 10"]
        #[inline(always)]
        pub const fn sir10(self) -> crate::common::Reg<regs::Sir10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Serial Flag Clear Trigger Register 11"]
        #[inline(always)]
        pub const fn sir11(self) -> crate::common::Reg<regs::Sir11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010ausize) as _) }
        }
        #[doc = "Serial Mode Register 10"]
        #[inline(always)]
        pub const fn smr10(self) -> crate::common::Reg<regs::Smr10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Serial Mode Register 11"]
        #[inline(always)]
        pub const fn smr11(self) -> crate::common::Reg<regs::Smr11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0112usize) as _) }
        }
        #[doc = "Serial Communication Operation Setting Register 10"]
        #[inline(always)]
        pub const fn scr10(self) -> crate::common::Reg<regs::Scr10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Serial Communication Operation Setting Register 11"]
        #[inline(always)]
        pub const fn scr11(self) -> crate::common::Reg<regs::Scr11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011ausize) as _) }
        }
        #[doc = "Serial Channel Enable Status Register 1"]
        #[inline(always)]
        pub const fn se1(self) -> crate::common::Reg<regs::Se1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Serial Channel Start Register 1"]
        #[inline(always)]
        pub const fn ss1(self) -> crate::common::Reg<regs::Ss1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0122usize) as _) }
        }
        #[doc = "Serial Channel Stop Register 1"]
        #[inline(always)]
        pub const fn st1(self) -> crate::common::Reg<regs::St1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Serial Clock Select Register 1"]
        #[inline(always)]
        pub const fn sps1(self) -> crate::common::Reg<regs::Sps1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0126usize) as _) }
        }
        #[doc = "Serial Output Register 1"]
        #[inline(always)]
        pub const fn so1(self) -> crate::common::Reg<regs::So1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "Serial Output Enable Register 1"]
        #[inline(always)]
        pub const fn soe1(self) -> crate::common::Reg<regs::Soe1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012ausize) as _) }
        }
        #[doc = "Serial Output Level Register 1"]
        #[inline(always)]
        pub const fn sol1(self) -> crate::common::Reg<regs::Sol1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Serial Communication Operation Setting Register 10"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr10(pub u16);
        impl Scr10 {
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dls(&self) -> super::vals::Scr10Dls {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Scr10Dls::from_bits(val as u8)
            }
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dls(&mut self, val: super::vals::Scr10Dls) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub const fn slc(&self) -> super::vals::Scr10Slc {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Scr10Slc::from_bits(val as u8)
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub fn set_slc(&mut self, val: super::vals::Scr10Slc) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u16) & 0x03) << 4usize);
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Scr10Dir {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Scr10Dir::from_bits(val as u8)
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::Scr10Dir) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub const fn ptc(&self) -> super::vals::Scr10Ptc {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Scr10Ptc::from_bits(val as u8)
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub fn set_ptc(&mut self, val: super::vals::Scr10Ptc) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub const fn dcp(&self) -> super::vals::Scr10Dcp {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Scr10Dcp::from_bits(val as u8)
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub fn set_dcp(&mut self, val: super::vals::Scr10Dcp) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "Setting of Channel 0 Operation Mode"]
            #[inline(always)]
            pub const fn trxe(&self) -> super::vals::Scr10Trxe {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Scr10Trxe::from_bits(val as u8)
            }
            #[doc = "Setting of Channel 0 Operation Mode"]
            #[inline(always)]
            pub fn set_trxe(&mut self, val: super::vals::Scr10Trxe) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Scr10 {
            #[inline(always)]
            fn default() -> Scr10 {
                Scr10(0)
            }
        }
        impl core::fmt::Debug for Scr10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr10")
                    .field("dls", &self.dls())
                    .field("slc", &self.slc())
                    .field("dir", &self.dir())
                    .field("ptc", &self.ptc())
                    .field("dcp", &self.dcp())
                    .field("trxe", &self.trxe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr10 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Scr10 {{ dls: {:?}, slc: {:?}, dir: {:?}, ptc: {:?}, dcp: {:?}, trxe: {:?} }}",
                    self.dls(),
                    self.slc(),
                    self.dir(),
                    self.ptc(),
                    self.dcp(),
                    self.trxe()
                )
            }
        }
        #[doc = "Serial Communication Operation Setting Register 11"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr11(pub u16);
        impl Scr11 {
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dls(&self) -> super::vals::Scr11Dls {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Scr11Dls::from_bits(val as u8)
            }
            #[doc = "Setting of Data Length in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dls(&mut self, val: super::vals::Scr11Dls) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub const fn slc(&self) -> super::vals::Scr11Slc {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Scr11Slc::from_bits(val as u8)
            }
            #[doc = "Setting of Stop Bit in UART Mode"]
            #[inline(always)]
            pub fn set_slc(&mut self, val: super::vals::Scr11Slc) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Scr11Dir {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Scr11Dir::from_bits(val as u8)
            }
            #[doc = "Selection of Data Transfer Sequence in Simplified SPI and UART Modes"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::Scr11Dir) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub const fn ptc(&self) -> super::vals::Scr11Ptc {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Scr11Ptc::from_bits(val as u8)
            }
            #[doc = "Setting of Parity Bit in UART Mode"]
            #[inline(always)]
            pub fn set_ptc(&mut self, val: super::vals::Scr11Ptc) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Mask Control of Error Interrupt Signal SAU0_UART_ERRI0 (m = 0), SAU1_UART_ERRI2 (m = 1)"]
            #[inline(always)]
            pub const fn eoc(&self) -> super::vals::Eoc {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Eoc::from_bits(val as u8)
            }
            #[doc = "Mask Control of Error Interrupt Signal SAU0_UART_ERRI0 (m = 0), SAU1_UART_ERRI2 (m = 1)"]
            #[inline(always)]
            pub fn set_eoc(&mut self, val: super::vals::Eoc) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub const fn dcp(&self) -> super::vals::Scr11Dcp {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Scr11Dcp::from_bits(val as u8)
            }
            #[doc = "Selection of Data and Clock Phase in Simplified SPI Mode"]
            #[inline(always)]
            pub fn set_dcp(&mut self, val: super::vals::Scr11Dcp) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "Setting of Channel 1 Operation Mode"]
            #[inline(always)]
            pub const fn trxe(&self) -> super::vals::Scr11Trxe {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Scr11Trxe::from_bits(val as u8)
            }
            #[doc = "Setting of Channel 1 Operation Mode"]
            #[inline(always)]
            pub fn set_trxe(&mut self, val: super::vals::Scr11Trxe) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Scr11 {
            #[inline(always)]
            fn default() -> Scr11 {
                Scr11(0)
            }
        }
        impl core::fmt::Debug for Scr11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr11")
                    .field("dls", &self.dls())
                    .field("slc", &self.slc())
                    .field("dir", &self.dir())
                    .field("ptc", &self.ptc())
                    .field("eoc", &self.eoc())
                    .field("dcp", &self.dcp())
                    .field("trxe", &self.trxe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr11 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scr11 {{ dls: {:?}, slc: {:?}, dir: {:?}, ptc: {:?}, eoc: {:?}, dcp: {:?}, trxe: {:?} }}" , self . dls () , self . slc () , self . dir () , self . ptc () , self . eoc () , self . dcp () , self . trxe ())
            }
        }
        #[doc = "Serial Data Register 1%s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdr1(pub u16);
        impl Sdr1 {
            #[doc = "Data Buffer for Transmit and Receive"]
            #[inline(always)]
            pub const fn dat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Data Buffer for Transmit and Receive"]
            #[inline(always)]
            pub fn set_dat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "Transfer Clock Setting by Dividing the Operation Clock"]
            #[inline(always)]
            pub const fn stclk(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "Transfer Clock Setting by Dividing the Operation Clock"]
            #[inline(always)]
            pub fn set_stclk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Sdr1 {
            #[inline(always)]
            fn default() -> Sdr1 {
                Sdr1(0)
            }
        }
        impl core::fmt::Debug for Sdr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdr1")
                    .field("dat", &self.dat())
                    .field("stclk", &self.stclk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sdr1 {{ dat: {=u16:?}, stclk: {=u8:?} }}",
                    self.dat(),
                    self.stclk()
                )
            }
        }
        #[doc = "Serial Channel Enable Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Se1(pub u16);
        impl Se1 {
            #[doc = "Indication of whether Operation of Channel n is Enabled or Stopped."]
            #[inline(always)]
            pub const fn se(&self) -> super::vals::Se {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Se::from_bits(val as u8)
            }
            #[doc = "Indication of whether Operation of Channel n is Enabled or Stopped."]
            #[inline(always)]
            pub fn set_se(&mut self, val: super::vals::Se) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
        }
        impl Default for Se1 {
            #[inline(always)]
            fn default() -> Se1 {
                Se1(0)
            }
        }
        impl core::fmt::Debug for Se1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Se1").field("se", &self.se()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Se1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Se1 {{ se: {:?} }}", self.se())
            }
        }
        #[doc = "Serial Flag Clear Trigger Register 10"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sir10(pub u16);
        impl Sir10 {
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub const fn ovct(&self) -> super::vals::Sir10Ovct {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sir10Ovct::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovct(&mut self, val: super::vals::Sir10Ovct) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub const fn pect(&self) -> super::vals::Sir10Pect {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sir10Pect::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_pect(&mut self, val: super::vals::Sir10Pect) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
        }
        impl Default for Sir10 {
            #[inline(always)]
            fn default() -> Sir10 {
                Sir10(0)
            }
        }
        impl core::fmt::Debug for Sir10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sir10")
                    .field("ovct", &self.ovct())
                    .field("pect", &self.pect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sir10 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sir10 {{ ovct: {:?}, pect: {:?} }}",
                    self.ovct(),
                    self.pect()
                )
            }
        }
        #[doc = "Serial Flag Clear Trigger Register 11"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sir11(pub u16);
        impl Sir11 {
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub const fn ovct(&self) -> super::vals::Sir11Ovct {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sir11Ovct::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Overrun Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovct(&mut self, val: super::vals::Sir11Ovct) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub const fn pect(&self) -> super::vals::Sir11Pect {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sir11Pect::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Parity Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_pect(&mut self, val: super::vals::Sir11Pect) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Clear Trigger of Framing Error Flag of Channel n"]
            #[inline(always)]
            pub const fn fect(&self) -> super::vals::Fect {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Fect::from_bits(val as u8)
            }
            #[doc = "Clear Trigger of Framing Error Flag of Channel n"]
            #[inline(always)]
            pub fn set_fect(&mut self, val: super::vals::Fect) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
        }
        impl Default for Sir11 {
            #[inline(always)]
            fn default() -> Sir11 {
                Sir11(0)
            }
        }
        impl core::fmt::Debug for Sir11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sir11")
                    .field("ovct", &self.ovct())
                    .field("pect", &self.pect())
                    .field("fect", &self.fect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sir11 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sir11 {{ ovct: {:?}, pect: {:?}, fect: {:?} }}",
                    self.ovct(),
                    self.pect(),
                    self.fect()
                )
            }
        }
        #[doc = "Serial Mode Register 10"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr10(pub u16);
        impl Smr10 {
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub const fn md0(&self) -> super::vals::Smr10Md0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smr10Md0::from_bits(val as u8)
            }
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub fn set_md0(&mut self, val: super::vals::Smr10Md0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub const fn md1(&self) -> super::vals::Smr10Md1 {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Smr10Md1::from_bits(val as u8)
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub fn set_md1(&mut self, val: super::vals::Smr10Md1) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u16) & 0x03) << 1usize);
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Smr10Ccs {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Smr10Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Smr10Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Smr10Cks {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Smr10Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Smr10Cks) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Smr10 {
            #[inline(always)]
            fn default() -> Smr10 {
                Smr10(0)
            }
        }
        impl core::fmt::Debug for Smr10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr10")
                    .field("md0", &self.md0())
                    .field("md1", &self.md1())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr10 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smr10 {{ md0: {:?}, md1: {:?}, ccs: {:?}, cks: {:?} }}",
                    self.md0(),
                    self.md1(),
                    self.ccs(),
                    self.cks()
                )
            }
        }
        #[doc = "Serial Mode Register 11"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr11(pub u16);
        impl Smr11 {
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub const fn md0(&self) -> super::vals::Smr11Md0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smr11Md0::from_bits(val as u8)
            }
            #[doc = "Selection of Channel n Interrupt Source"]
            #[inline(always)]
            pub fn set_md0(&mut self, val: super::vals::Smr11Md0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub const fn md1(&self) -> super::vals::Smr11Md1 {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Smr11Md1::from_bits(val as u8)
            }
            #[doc = "Setting of Channel n Operation Mode"]
            #[inline(always)]
            pub fn set_md1(&mut self, val: super::vals::Smr11Md1) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u16) & 0x03) << 1usize);
            }
            #[doc = "Controls Inversion of Level of Channel n Receive Data in UART Mode"]
            #[inline(always)]
            pub const fn sis0(&self) -> super::vals::Sis0 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Sis0::from_bits(val as u8)
            }
            #[doc = "Controls Inversion of Level of Channel n Receive Data in UART Mode"]
            #[inline(always)]
            pub fn set_sis0(&mut self, val: super::vals::Sis0) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Selection of Start Trigger Source"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "Selection of Start Trigger Source"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Smr11Ccs {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Smr11Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Transfer Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Smr11Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Smr11Cks {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Smr11Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Smr11Cks) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Smr11 {
            #[inline(always)]
            fn default() -> Smr11 {
                Smr11(0)
            }
        }
        impl core::fmt::Debug for Smr11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr11")
                    .field("md0", &self.md0())
                    .field("md1", &self.md1())
                    .field("sis0", &self.sis0())
                    .field("sts", &self.sts())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr11 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smr11 {{ md0: {:?}, md1: {:?}, sis0: {:?}, sts: {:?}, ccs: {:?}, cks: {:?} }}",
                    self.md0(),
                    self.md1(),
                    self.sis0(),
                    self.sts(),
                    self.ccs(),
                    self.cks()
                )
            }
        }
        #[doc = "Serial Output Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct So1(pub u16);
        impl So1 {
            #[doc = "Serial Data Output of Channel n"]
            #[inline(always)]
            pub const fn so(&self) -> super::vals::So {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::So::from_bits(val as u8)
            }
            #[doc = "Serial Data Output of Channel n"]
            #[inline(always)]
            pub fn set_so(&mut self, val: super::vals::So) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Serial Clock Output of Channel n"]
            #[inline(always)]
            pub const fn cko(&self) -> super::vals::Cko {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Cko::from_bits(val as u8)
            }
            #[doc = "Serial Clock Output of Channel n"]
            #[inline(always)]
            pub fn set_cko(&mut self, val: super::vals::Cko) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
        }
        impl Default for So1 {
            #[inline(always)]
            fn default() -> So1 {
                So1(0)
            }
        }
        impl core::fmt::Debug for So1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("So1")
                    .field("so", &self.so())
                    .field("cko", &self.cko())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for So1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "So1 {{ so: {:?}, cko: {:?} }}", self.so(), self.cko())
            }
        }
        #[doc = "Serial Output Enable Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Soe1(pub u16);
        impl Soe1 {
            #[doc = "Serial Output Enable or Stop of Channel n"]
            #[inline(always)]
            pub const fn soe(&self) -> super::vals::Soe {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Soe::from_bits(val as u8)
            }
            #[doc = "Serial Output Enable or Stop of Channel n"]
            #[inline(always)]
            pub fn set_soe(&mut self, val: super::vals::Soe) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
        }
        impl Default for Soe1 {
            #[inline(always)]
            fn default() -> Soe1 {
                Soe1(0)
            }
        }
        impl core::fmt::Debug for Soe1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Soe1").field("soe", &self.soe()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Soe1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Soe1 {{ soe: {:?} }}", self.soe())
            }
        }
        #[doc = "Serial Output Level Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sol1(pub u16);
        impl Sol1 {
            #[doc = "Selects Inversion of the Level of the Transmit Data of Channel 0 in UART Mode"]
            #[inline(always)]
            pub const fn sol0(&self) -> super::vals::Sol0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sol0::from_bits(val as u8)
            }
            #[doc = "Selects Inversion of the Level of the Transmit Data of Channel 0 in UART Mode"]
            #[inline(always)]
            pub fn set_sol0(&mut self, val: super::vals::Sol0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Sol1 {
            #[inline(always)]
            fn default() -> Sol1 {
                Sol1(0)
            }
        }
        impl core::fmt::Debug for Sol1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sol1").field("sol0", &self.sol0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sol1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sol1 {{ sol0: {:?} }}", self.sol0())
            }
        }
        #[doc = "Serial Clock Select Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sps1(pub u16);
        impl Sps1 {
            #[doc = "Selection of Operation Clock (CKm0)"]
            #[inline(always)]
            pub const fn prs0(&self) -> super::vals::Prs0 {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Prs0::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (CKm0)"]
            #[inline(always)]
            pub fn set_prs0(&mut self, val: super::vals::Prs0) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
            #[doc = "Selection of Operation Clock (CKm1)"]
            #[inline(always)]
            pub const fn prs1(&self) -> super::vals::Prs1 {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Prs1::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (CKm1)"]
            #[inline(always)]
            pub fn set_prs1(&mut self, val: super::vals::Prs1) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u16) & 0x0f) << 4usize);
            }
        }
        impl Default for Sps1 {
            #[inline(always)]
            fn default() -> Sps1 {
                Sps1(0)
            }
        }
        impl core::fmt::Debug for Sps1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sps1")
                    .field("prs0", &self.prs0())
                    .field("prs1", &self.prs1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sps1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sps1 {{ prs0: {:?}, prs1: {:?} }}",
                    self.prs0(),
                    self.prs1()
                )
            }
        }
        #[doc = "Serial Channel Start Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ss1(pub u16);
        impl Ss1 {
            #[doc = "Operation Start Trigger of Channel n"]
            #[inline(always)]
            pub const fn ss(&self) -> super::vals::Ss {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Ss::from_bits(val as u8)
            }
            #[doc = "Operation Start Trigger of Channel n"]
            #[inline(always)]
            pub fn set_ss(&mut self, val: super::vals::Ss) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
        }
        impl Default for Ss1 {
            #[inline(always)]
            fn default() -> Ss1 {
                Ss1(0)
            }
        }
        impl core::fmt::Debug for Ss1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ss1").field("ss", &self.ss()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ss1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ss1 {{ ss: {:?} }}", self.ss())
            }
        }
        #[doc = "Serial Status Register 10"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr10(pub u16);
        impl Ssr10 {
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn ovf(&self) -> super::vals::Ssr10Ovf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssr10Ovf::from_bits(val as u8)
            }
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovf(&mut self, val: super::vals::Ssr10Ovf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn pef(&self) -> super::vals::Ssr10Pef {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssr10Pef::from_bits(val as u8)
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_pef(&mut self, val: super::vals::Ssr10Pef) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub const fn bff(&self) -> super::vals::Ssr10Bff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ssr10Bff::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub fn set_bff(&mut self, val: super::vals::Ssr10Bff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub const fn tsf(&self) -> super::vals::Ssr10Tsf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ssr10Tsf::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub fn set_tsf(&mut self, val: super::vals::Ssr10Tsf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
        }
        impl Default for Ssr10 {
            #[inline(always)]
            fn default() -> Ssr10 {
                Ssr10(0)
            }
        }
        impl core::fmt::Debug for Ssr10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr10")
                    .field("ovf", &self.ovf())
                    .field("pef", &self.pef())
                    .field("bff", &self.bff())
                    .field("tsf", &self.tsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr10 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ssr10 {{ ovf: {:?}, pef: {:?}, bff: {:?}, tsf: {:?} }}",
                    self.ovf(),
                    self.pef(),
                    self.bff(),
                    self.tsf()
                )
            }
        }
        #[doc = "Serial Status Register 11"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr11(pub u16);
        impl Ssr11 {
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn ovf(&self) -> super::vals::Ssr11Ovf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssr11Ovf::from_bits(val as u8)
            }
            #[doc = "Overrun Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_ovf(&mut self, val: super::vals::Ssr11Ovf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn pef(&self) -> super::vals::Ssr11Pef {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssr11Pef::from_bits(val as u8)
            }
            #[doc = "Parity or ACK Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_pef(&mut self, val: super::vals::Ssr11Pef) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Framing Error Detection Flag of Channel n"]
            #[inline(always)]
            pub const fn fef(&self) -> super::vals::Fef {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Fef::from_bits(val as u8)
            }
            #[doc = "Framing Error Detection Flag of Channel n"]
            #[inline(always)]
            pub fn set_fef(&mut self, val: super::vals::Fef) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub const fn bff(&self) -> super::vals::Ssr11Bff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ssr11Bff::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of the Buffer Register for Channel n"]
            #[inline(always)]
            pub fn set_bff(&mut self, val: super::vals::Ssr11Bff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub const fn tsf(&self) -> super::vals::Ssr11Tsf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ssr11Tsf::from_bits(val as u8)
            }
            #[doc = "Flag Indicating the State of Communications for Channel n"]
            #[inline(always)]
            pub fn set_tsf(&mut self, val: super::vals::Ssr11Tsf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
        }
        impl Default for Ssr11 {
            #[inline(always)]
            fn default() -> Ssr11 {
                Ssr11(0)
            }
        }
        impl core::fmt::Debug for Ssr11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr11")
                    .field("ovf", &self.ovf())
                    .field("pef", &self.pef())
                    .field("fef", &self.fef())
                    .field("bff", &self.bff())
                    .field("tsf", &self.tsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr11 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ssr11 {{ ovf: {:?}, pef: {:?}, fef: {:?}, bff: {:?}, tsf: {:?} }}",
                    self.ovf(),
                    self.pef(),
                    self.fef(),
                    self.bff(),
                    self.tsf()
                )
            }
        }
        #[doc = "Serial Channel Stop Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct St1(pub u16);
        impl St1 {
            #[doc = "Operation Stop Trigger of Channel n"]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::St {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::St::from_bits(val as u8)
            }
            #[doc = "Operation Stop Trigger of Channel n"]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::St) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
        }
        impl Default for St1 {
            #[inline(always)]
            fn default() -> St1 {
                St1(0)
            }
        }
        impl core::fmt::Debug for St1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("St1").field("st", &self.st()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for St1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "St1 {{ st: {:?} }}", self.st())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cko {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cko {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cko {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cko {
            #[inline(always)]
            fn from(val: u8) -> Cko {
                Cko::from_bits(val)
            }
        }
        impl From<Cko> for u8 {
            #[inline(always)]
            fn from(val: Cko) -> u8 {
                Cko::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eoc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eoc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eoc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eoc {
            #[inline(always)]
            fn from(val: u8) -> Eoc {
                Eoc::from_bits(val)
            }
        }
        impl From<Eoc> for u8 {
            #[inline(always)]
            fn from(val: Eoc) -> u8 {
                Eoc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fect {
            #[inline(always)]
            fn from(val: u8) -> Fect {
                Fect::from_bits(val)
            }
        }
        impl From<Fect> for u8 {
            #[inline(always)]
            fn from(val: Fect) -> u8 {
                Fect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fef {
            #[inline(always)]
            fn from(val: u8) -> Fef {
                Fef::from_bits(val)
            }
        }
        impl From<Fef> for u8 {
            #[inline(always)]
            fn from(val: Fef) -> u8 {
                Fef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prs0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Prs0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prs0 {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prs0 {
            #[inline(always)]
            fn from(val: u8) -> Prs0 {
                Prs0::from_bits(val)
            }
        }
        impl From<Prs0> for u8 {
            #[inline(always)]
            fn from(val: Prs0) -> u8 {
                Prs0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prs1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Prs1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prs1 {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prs1 {
            #[inline(always)]
            fn from(val: u8) -> Prs1 {
                Prs1::from_bits(val)
            }
        }
        impl From<Prs1> for u8 {
            #[inline(always)]
            fn from(val: Prs1) -> u8 {
                Prs1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr10Dcp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr10Dcp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr10Dcp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr10Dcp {
            #[inline(always)]
            fn from(val: u8) -> Scr10Dcp {
                Scr10Dcp::from_bits(val)
            }
        }
        impl From<Scr10Dcp> for u8 {
            #[inline(always)]
            fn from(val: Scr10Dcp) -> u8 {
                Scr10Dcp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr10Dir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr10Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr10Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr10Dir {
            #[inline(always)]
            fn from(val: u8) -> Scr10Dir {
                Scr10Dir::from_bits(val)
            }
        }
        impl From<Scr10Dir> for u8 {
            #[inline(always)]
            fn from(val: Scr10Dir) -> u8 {
                Scr10Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr10Dls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr10Dls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr10Dls {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr10Dls {
            #[inline(always)]
            fn from(val: u8) -> Scr10Dls {
                Scr10Dls::from_bits(val)
            }
        }
        impl From<Scr10Dls> for u8 {
            #[inline(always)]
            fn from(val: Scr10Dls) -> u8 {
                Scr10Dls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr10Ptc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr10Ptc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr10Ptc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr10Ptc {
            #[inline(always)]
            fn from(val: u8) -> Scr10Ptc {
                Scr10Ptc::from_bits(val)
            }
        }
        impl From<Scr10Ptc> for u8 {
            #[inline(always)]
            fn from(val: Scr10Ptc) -> u8 {
                Scr10Ptc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr10Slc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr10Slc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr10Slc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr10Slc {
            #[inline(always)]
            fn from(val: u8) -> Scr10Slc {
                Scr10Slc::from_bits(val)
            }
        }
        impl From<Scr10Slc> for u8 {
            #[inline(always)]
            fn from(val: Scr10Slc) -> u8 {
                Scr10Slc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr10Trxe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr10Trxe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr10Trxe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr10Trxe {
            #[inline(always)]
            fn from(val: u8) -> Scr10Trxe {
                Scr10Trxe::from_bits(val)
            }
        }
        impl From<Scr10Trxe> for u8 {
            #[inline(always)]
            fn from(val: Scr10Trxe) -> u8 {
                Scr10Trxe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr11Dcp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr11Dcp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr11Dcp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr11Dcp {
            #[inline(always)]
            fn from(val: u8) -> Scr11Dcp {
                Scr11Dcp::from_bits(val)
            }
        }
        impl From<Scr11Dcp> for u8 {
            #[inline(always)]
            fn from(val: Scr11Dcp) -> u8 {
                Scr11Dcp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr11Dir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr11Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr11Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr11Dir {
            #[inline(always)]
            fn from(val: u8) -> Scr11Dir {
                Scr11Dir::from_bits(val)
            }
        }
        impl From<Scr11Dir> for u8 {
            #[inline(always)]
            fn from(val: Scr11Dir) -> u8 {
                Scr11Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr11Dls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr11Dls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr11Dls {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr11Dls {
            #[inline(always)]
            fn from(val: u8) -> Scr11Dls {
                Scr11Dls::from_bits(val)
            }
        }
        impl From<Scr11Dls> for u8 {
            #[inline(always)]
            fn from(val: Scr11Dls) -> u8 {
                Scr11Dls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr11Ptc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr11Ptc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr11Ptc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr11Ptc {
            #[inline(always)]
            fn from(val: u8) -> Scr11Ptc {
                Scr11Ptc::from_bits(val)
            }
        }
        impl From<Scr11Ptc> for u8 {
            #[inline(always)]
            fn from(val: Scr11Ptc) -> u8 {
                Scr11Ptc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr11Slc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scr11Slc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr11Slc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr11Slc {
            #[inline(always)]
            fn from(val: u8) -> Scr11Slc {
                Scr11Slc::from_bits(val)
            }
        }
        impl From<Scr11Slc> for u8 {
            #[inline(always)]
            fn from(val: Scr11Slc) -> u8 {
                Scr11Slc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scr11Trxe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Scr11Trxe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scr11Trxe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scr11Trxe {
            #[inline(always)]
            fn from(val: u8) -> Scr11Trxe {
                Scr11Trxe::from_bits(val)
            }
        }
        impl From<Scr11Trxe> for u8 {
            #[inline(always)]
            fn from(val: Scr11Trxe) -> u8 {
                Scr11Trxe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Se {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Se {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Se {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Se {
            #[inline(always)]
            fn from(val: u8) -> Se {
                Se::from_bits(val)
            }
        }
        impl From<Se> for u8 {
            #[inline(always)]
            fn from(val: Se) -> u8 {
                Se::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir10Ovct {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir10Ovct {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir10Ovct {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir10Ovct {
            #[inline(always)]
            fn from(val: u8) -> Sir10Ovct {
                Sir10Ovct::from_bits(val)
            }
        }
        impl From<Sir10Ovct> for u8 {
            #[inline(always)]
            fn from(val: Sir10Ovct) -> u8 {
                Sir10Ovct::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir10Pect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir10Pect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir10Pect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir10Pect {
            #[inline(always)]
            fn from(val: u8) -> Sir10Pect {
                Sir10Pect::from_bits(val)
            }
        }
        impl From<Sir10Pect> for u8 {
            #[inline(always)]
            fn from(val: Sir10Pect) -> u8 {
                Sir10Pect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir11Ovct {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir11Ovct {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir11Ovct {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir11Ovct {
            #[inline(always)]
            fn from(val: u8) -> Sir11Ovct {
                Sir11Ovct::from_bits(val)
            }
        }
        impl From<Sir11Ovct> for u8 {
            #[inline(always)]
            fn from(val: Sir11Ovct) -> u8 {
                Sir11Ovct::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sir11Pect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sir11Pect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sir11Pect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sir11Pect {
            #[inline(always)]
            fn from(val: u8) -> Sir11Pect {
                Sir11Pect::from_bits(val)
            }
        }
        impl From<Sir11Pect> for u8 {
            #[inline(always)]
            fn from(val: Sir11Pect) -> u8 {
                Sir11Pect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sis0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sis0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sis0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sis0 {
            #[inline(always)]
            fn from(val: u8) -> Sis0 {
                Sis0::from_bits(val)
            }
        }
        impl From<Sis0> for u8 {
            #[inline(always)]
            fn from(val: Sis0) -> u8 {
                Sis0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr10Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr10Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr10Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr10Ccs {
            #[inline(always)]
            fn from(val: u8) -> Smr10Ccs {
                Smr10Ccs::from_bits(val)
            }
        }
        impl From<Smr10Ccs> for u8 {
            #[inline(always)]
            fn from(val: Smr10Ccs) -> u8 {
                Smr10Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr10Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr10Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr10Cks {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr10Cks {
            #[inline(always)]
            fn from(val: u8) -> Smr10Cks {
                Smr10Cks::from_bits(val)
            }
        }
        impl From<Smr10Cks> for u8 {
            #[inline(always)]
            fn from(val: Smr10Cks) -> u8 {
                Smr10Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr10Md0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr10Md0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr10Md0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr10Md0 {
            #[inline(always)]
            fn from(val: u8) -> Smr10Md0 {
                Smr10Md0::from_bits(val)
            }
        }
        impl From<Smr10Md0> for u8 {
            #[inline(always)]
            fn from(val: Smr10Md0) -> u8 {
                Smr10Md0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr10Md1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Smr10Md1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr10Md1 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr10Md1 {
            #[inline(always)]
            fn from(val: u8) -> Smr10Md1 {
                Smr10Md1::from_bits(val)
            }
        }
        impl From<Smr10Md1> for u8 {
            #[inline(always)]
            fn from(val: Smr10Md1) -> u8 {
                Smr10Md1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr11Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr11Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr11Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr11Ccs {
            #[inline(always)]
            fn from(val: u8) -> Smr11Ccs {
                Smr11Ccs::from_bits(val)
            }
        }
        impl From<Smr11Ccs> for u8 {
            #[inline(always)]
            fn from(val: Smr11Ccs) -> u8 {
                Smr11Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr11Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr11Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr11Cks {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr11Cks {
            #[inline(always)]
            fn from(val: u8) -> Smr11Cks {
                Smr11Cks::from_bits(val)
            }
        }
        impl From<Smr11Cks> for u8 {
            #[inline(always)]
            fn from(val: Smr11Cks) -> u8 {
                Smr11Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr11Md0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smr11Md0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr11Md0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr11Md0 {
            #[inline(always)]
            fn from(val: u8) -> Smr11Md0 {
                Smr11Md0::from_bits(val)
            }
        }
        impl From<Smr11Md0> for u8 {
            #[inline(always)]
            fn from(val: Smr11Md0) -> u8 {
                Smr11Md0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smr11Md1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Smr11Md1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smr11Md1 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smr11Md1 {
            #[inline(always)]
            fn from(val: u8) -> Smr11Md1 {
                Smr11Md1::from_bits(val)
            }
        }
        impl From<Smr11Md1> for u8 {
            #[inline(always)]
            fn from(val: Smr11Md1) -> u8 {
                Smr11Md1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum So {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl So {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> So {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for So {
            #[inline(always)]
            fn from(val: u8) -> So {
                So::from_bits(val)
            }
        }
        impl From<So> for u8 {
            #[inline(always)]
            fn from(val: So) -> u8 {
                So::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Soe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Soe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Soe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Soe {
            #[inline(always)]
            fn from(val: u8) -> Soe {
                Soe::from_bits(val)
            }
        }
        impl From<Soe> for u8 {
            #[inline(always)]
            fn from(val: Soe) -> u8 {
                Soe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sol0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sol0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sol0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sol0 {
            #[inline(always)]
            fn from(val: u8) -> Sol0 {
                Sol0::from_bits(val)
            }
        }
        impl From<Sol0> for u8 {
            #[inline(always)]
            fn from(val: Sol0) -> u8 {
                Sol0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ss {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ss {
            #[inline(always)]
            fn from(val: u8) -> Ss {
                Ss::from_bits(val)
            }
        }
        impl From<Ss> for u8 {
            #[inline(always)]
            fn from(val: Ss) -> u8 {
                Ss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr10Bff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr10Bff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr10Bff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr10Bff {
            #[inline(always)]
            fn from(val: u8) -> Ssr10Bff {
                Ssr10Bff::from_bits(val)
            }
        }
        impl From<Ssr10Bff> for u8 {
            #[inline(always)]
            fn from(val: Ssr10Bff) -> u8 {
                Ssr10Bff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr10Ovf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr10Ovf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr10Ovf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr10Ovf {
            #[inline(always)]
            fn from(val: u8) -> Ssr10Ovf {
                Ssr10Ovf::from_bits(val)
            }
        }
        impl From<Ssr10Ovf> for u8 {
            #[inline(always)]
            fn from(val: Ssr10Ovf) -> u8 {
                Ssr10Ovf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr10Pef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr10Pef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr10Pef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr10Pef {
            #[inline(always)]
            fn from(val: u8) -> Ssr10Pef {
                Ssr10Pef::from_bits(val)
            }
        }
        impl From<Ssr10Pef> for u8 {
            #[inline(always)]
            fn from(val: Ssr10Pef) -> u8 {
                Ssr10Pef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr10Tsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr10Tsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr10Tsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr10Tsf {
            #[inline(always)]
            fn from(val: u8) -> Ssr10Tsf {
                Ssr10Tsf::from_bits(val)
            }
        }
        impl From<Ssr10Tsf> for u8 {
            #[inline(always)]
            fn from(val: Ssr10Tsf) -> u8 {
                Ssr10Tsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr11Bff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr11Bff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr11Bff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr11Bff {
            #[inline(always)]
            fn from(val: u8) -> Ssr11Bff {
                Ssr11Bff::from_bits(val)
            }
        }
        impl From<Ssr11Bff> for u8 {
            #[inline(always)]
            fn from(val: Ssr11Bff) -> u8 {
                Ssr11Bff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr11Ovf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr11Ovf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr11Ovf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr11Ovf {
            #[inline(always)]
            fn from(val: u8) -> Ssr11Ovf {
                Ssr11Ovf::from_bits(val)
            }
        }
        impl From<Ssr11Ovf> for u8 {
            #[inline(always)]
            fn from(val: Ssr11Ovf) -> u8 {
                Ssr11Ovf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr11Pef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr11Pef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr11Pef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr11Pef {
            #[inline(always)]
            fn from(val: u8) -> Ssr11Pef {
                Ssr11Pef::from_bits(val)
            }
        }
        impl From<Ssr11Pef> for u8 {
            #[inline(always)]
            fn from(val: Ssr11Pef) -> u8 {
                Ssr11Pef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssr11Tsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssr11Tsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssr11Tsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssr11Tsf {
            #[inline(always)]
            fn from(val: u8) -> Ssr11Tsf {
                Ssr11Tsf::from_bits(val)
            }
        }
        impl From<Ssr11Tsf> for u8 {
            #[inline(always)]
            fn from(val: Ssr11Tsf) -> u8 {
                Ssr11Tsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl St {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St {
            #[inline(always)]
            fn from(val: u8) -> St {
                St::from_bits(val)
            }
        }
        impl From<St> for u8 {
            #[inline(always)]
            fn from(val: St) -> u8 {
                St::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod sram {
    #[doc = "SRAM Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sram {
        ptr: *mut u8,
    }
    unsafe impl Send for Sram {}
    unsafe impl Sync for Sram {}
    impl Sram {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SRAM Parity Error Operation After Detection Register"]
        #[inline(always)]
        pub const fn parioad(self) -> crate::common::Reg<regs::Parioad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SRAM Protection Register"]
        #[inline(always)]
        pub const fn sramprcr(self) -> crate::common::Reg<regs::Sramprcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SRAM Parity Error Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Parioad(pub u8);
        impl Parioad {
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::Oad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Oad::from_bits(val as u8)
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::Oad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Parioad {
            #[inline(always)]
            fn default() -> Parioad {
                Parioad(0)
            }
        }
        impl core::fmt::Debug for Parioad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Parioad").field("oad", &self.oad()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Parioad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Parioad {{ oad: {:?} }}", self.oad())
            }
        }
        #[doc = "SRAM Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sramprcr(pub u8);
        impl Sramprcr {
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub const fn sramprcr(&self) -> super::vals::Sramprcr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sramprcr::from_bits(val as u8)
            }
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub fn set_sramprcr(&mut self, val: super::vals::Sramprcr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub const fn kw(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub fn set_kw(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Sramprcr {
            #[inline(always)]
            fn default() -> Sramprcr {
                Sramprcr(0)
            }
        }
        impl core::fmt::Debug for Sramprcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sramprcr")
                    .field("sramprcr", &self.sramprcr())
                    .field("kw", &self.kw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sramprcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sramprcr {{ sramprcr: {:?}, kw: {=u8:?} }}",
                    self.sramprcr(),
                    self.kw()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oad {
            #[inline(always)]
            fn from(val: u8) -> Oad {
                Oad::from_bits(val)
            }
        }
        impl From<Oad> for u8 {
            #[inline(always)]
            fn from(val: Oad) -> u8 {
                Oad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sramprcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sramprcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sramprcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sramprcr {
            #[inline(always)]
            fn from(val: u8) -> Sramprcr {
                Sramprcr::from_bits(val)
            }
        }
        impl From<Sramprcr> for u8 {
            #[inline(always)]
            fn from(val: Sramprcr) -> u8 {
                Sramprcr::to_bits(val)
            }
        }
    }
}
pub mod sysc {
    #[doc = "System Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysc {
        ptr: *mut u8,
    }
    unsafe impl Send for Sysc {}
    unsafe impl Sync for Sysc {}
    impl Sysc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Clock Operation Mode Control Register"]
        #[inline(always)]
        pub const fn cmc(self) -> crate::common::Reg<regs::Cmc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0800usize) as _) }
        }
        #[doc = "Sub,clock Oscillator Margin Check Register"]
        #[inline(always)]
        pub const fn somrg(self) -> crate::common::Reg<regs::Somrg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0803usize) as _) }
        }
        #[doc = "Middle,speed On,chip Oscillator Trimming Register"]
        #[inline(always)]
        pub const fn miotrm(self) -> crate::common::Reg<regs::Miotrm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0804usize) as _) }
        }
        #[doc = "Low,speed On,chip Oscillator Trimming Register"]
        #[inline(always)]
        pub const fn liotrm(self) -> crate::common::Reg<regs::Liotrm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0805usize) as _) }
        }
        #[doc = "High,speed On,chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn hococr(self) -> crate::common::Reg<regs::Hococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0808usize) as _) }
        }
        #[doc = "Middle,speed On,chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn mococr(self) -> crate::common::Reg<regs::Mococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0809usize) as _) }
        }
        #[doc = "Low,speed On,chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn lococr(self) -> crate::common::Reg<regs::Lococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x080ausize) as _) }
        }
        #[doc = "Main Clock Oscillator Control Register"]
        #[inline(always)]
        pub const fn mosccr(self) -> crate::common::Reg<regs::Mosccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x080busize) as _) }
        }
        #[doc = "Sub,clock Oscillator Control Register"]
        #[inline(always)]
        pub const fn sosccr(self) -> crate::common::Reg<regs::Sosccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x080cusize) as _) }
        }
        #[doc = "Oscillation Stabilization Time Counter Status Register"]
        #[inline(always)]
        pub const fn ostc(self) -> crate::common::Reg<regs::Ostc, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0810usize) as _) }
        }
        #[doc = "Oscillation Stabilization Time Select Register"]
        #[inline(always)]
        pub const fn osts(self) -> crate::common::Reg<regs::Osts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0811usize) as _) }
        }
        #[doc = "Oscillation Stabilization Flag Register"]
        #[inline(always)]
        pub const fn oscsf(self) -> crate::common::Reg<regs::Oscsf, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0812usize) as _) }
        }
        #[doc = "High,speed On,chip Oscillator Frequency Select Register"]
        #[inline(always)]
        pub const fn hocodiv(self) -> crate::common::Reg<regs::Hocodiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0818usize) as _) }
        }
        #[doc = "Middle,speed On,chip Oscillator Frequency Select Register"]
        #[inline(always)]
        pub const fn mocodiv(self) -> crate::common::Reg<regs::Mocodiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0819usize) as _) }
        }
        #[doc = "MOSC Clock Division Register"]
        #[inline(always)]
        pub const fn moscdiv(self) -> crate::common::Reg<regs::Moscdiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x081ausize) as _) }
        }
        #[doc = "FOCO Clock Source Control Register"]
        #[inline(always)]
        pub const fn focoscr(self) -> crate::common::Reg<regs::Focoscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0820usize) as _) }
        }
        #[doc = "FMAIN Clock Source Control Register"]
        #[inline(always)]
        pub const fn fmainscr(self) -> crate::common::Reg<regs::Fmainscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0821usize) as _) }
        }
        #[doc = "FSUB Clock Source Control Register"]
        #[inline(always)]
        pub const fn fsubscr(self) -> crate::common::Reg<regs::Fsubscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0822usize) as _) }
        }
        #[doc = "ICLK Clock Source Control Register"]
        #[inline(always)]
        pub const fn iclkscr(self) -> crate::common::Reg<regs::Iclkscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0823usize) as _) }
        }
        #[doc = "Subsystem Clock Supply Mode Control Register"]
        #[inline(always)]
        pub const fn osmc(self) -> crate::common::Reg<regs::Osmc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0824usize) as _) }
        }
        #[doc = "Reset Status Flag Register"]
        #[inline(always)]
        pub const fn resf(self) -> crate::common::Reg<regs::Resf, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0830usize) as _) }
        }
        #[doc = "Power,On Reset Status Register"]
        #[inline(always)]
        pub const fn porsr(self) -> crate::common::Reg<regs::Porsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0831usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register"]
        #[inline(always)]
        pub const fn lvd1cr(self) -> crate::common::Reg<regs::Lvd1cr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0840usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Mask Register"]
        #[inline(always)]
        pub const fn lvd1mkr(self) -> crate::common::Reg<regs::Lvd1mkr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0841usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Status Register"]
        #[inline(always)]
        pub const fn lvd1sr(self) -> crate::common::Reg<regs::Lvd1sr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0843usize) as _) }
        }
        #[doc = "Standby Control Register"]
        #[inline(always)]
        pub const fn sbycr(self) -> crate::common::Reg<regs::Sbycr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0860usize) as _) }
        }
        #[doc = "Power Save Memory Control Register"]
        #[inline(always)]
        pub const fn psmcr(self) -> crate::common::Reg<regs::Psmcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0862usize) as _) }
        }
        #[doc = "System Control OCD Control Register"]
        #[inline(always)]
        pub const fn syocdcr(self) -> crate::common::Reg<regs::Syocdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0863usize) as _) }
        }
        #[doc = "Protect Register"]
        #[inline(always)]
        pub const fn prcr(self) -> crate::common::Reg<regs::Prcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08feusize) as _) }
        }
        #[doc = "Module Stop Control Register A"]
        #[inline(always)]
        pub const fn mstpcra(self) -> crate::common::Reg<regs::Mstpcra, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c02usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Clock Operation Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmc(pub u8);
        impl Cmc {
            #[doc = "Main Clock Oscillator Drive Capability Switching"]
            #[inline(always)]
            pub const fn modrv(&self) -> super::vals::Modrv {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Modrv::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Drive Capability Switching"]
            #[inline(always)]
            pub fn set_modrv(&mut self, val: super::vals::Modrv) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Sub,Clock Oscillator Drive Capability Switching"]
            #[inline(always)]
            pub const fn sodrv(&self) -> super::vals::Sodrv {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Sodrv::from_bits(val as u8)
            }
            #[doc = "Sub,Clock Oscillator Drive Capability Switching"]
            #[inline(always)]
            pub fn set_sodrv(&mut self, val: super::vals::Sodrv) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u8) & 0x03) << 1usize);
            }
            #[doc = "Selecting Clock Oscillator"]
            #[inline(always)]
            pub const fn xtsel(&self) -> super::vals::Xtsel {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Xtsel::from_bits(val as u8)
            }
            #[doc = "Selecting Clock Oscillator"]
            #[inline(always)]
            pub fn set_xtsel(&mut self, val: super::vals::Xtsel) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Sub Clock Oscillator Switching"]
            #[inline(always)]
            pub const fn sosel(&self) -> super::vals::Sosel {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sosel::from_bits(val as u8)
            }
            #[doc = "Sub Clock Oscillator Switching"]
            #[inline(always)]
            pub fn set_sosel(&mut self, val: super::vals::Sosel) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Main Clock Oscillator Switching"]
            #[inline(always)]
            pub const fn mosel(&self) -> super::vals::Mosel {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Mosel::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Switching"]
            #[inline(always)]
            pub fn set_mosel(&mut self, val: super::vals::Mosel) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Cmc {
            #[inline(always)]
            fn default() -> Cmc {
                Cmc(0)
            }
        }
        impl core::fmt::Debug for Cmc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmc")
                    .field("modrv", &self.modrv())
                    .field("sodrv", &self.sodrv())
                    .field("xtsel", &self.xtsel())
                    .field("sosel", &self.sosel())
                    .field("mosel", &self.mosel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cmc {{ modrv: {:?}, sodrv: {:?}, xtsel: {:?}, sosel: {:?}, mosel: {:?} }}",
                    self.modrv(),
                    self.sodrv(),
                    self.xtsel(),
                    self.sosel(),
                    self.mosel()
                )
            }
        }
        #[doc = "FMAIN Clock Source Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fmainscr(pub u8);
        impl Fmainscr {
            #[doc = "FMAIN Clock Source Select"]
            #[inline(always)]
            pub const fn cksel(&self) -> super::vals::FmainscrCksel {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::FmainscrCksel::from_bits(val as u8)
            }
            #[doc = "FMAIN Clock Source Select"]
            #[inline(always)]
            pub fn set_cksel(&mut self, val: super::vals::FmainscrCksel) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "FMAIN Clock Source Status"]
            #[inline(always)]
            pub const fn ckst(&self) -> super::vals::FmainscrCkst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::FmainscrCkst::from_bits(val as u8)
            }
            #[doc = "FMAIN Clock Source Status"]
            #[inline(always)]
            pub fn set_ckst(&mut self, val: super::vals::FmainscrCkst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Fmainscr {
            #[inline(always)]
            fn default() -> Fmainscr {
                Fmainscr(0)
            }
        }
        impl core::fmt::Debug for Fmainscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fmainscr")
                    .field("cksel", &self.cksel())
                    .field("ckst", &self.ckst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fmainscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fmainscr {{ cksel: {:?}, ckst: {:?} }}",
                    self.cksel(),
                    self.ckst()
                )
            }
        }
        #[doc = "FOCO Clock Source Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Focoscr(pub u8);
        impl Focoscr {
            #[doc = "FOCO Clock Source Select"]
            #[inline(always)]
            pub const fn cksel(&self) -> super::vals::FocoscrCksel {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::FocoscrCksel::from_bits(val as u8)
            }
            #[doc = "FOCO Clock Source Select"]
            #[inline(always)]
            pub fn set_cksel(&mut self, val: super::vals::FocoscrCksel) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "FOCO Clock Source Status"]
            #[inline(always)]
            pub const fn ckst(&self) -> super::vals::FocoscrCkst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::FocoscrCkst::from_bits(val as u8)
            }
            #[doc = "FOCO Clock Source Status"]
            #[inline(always)]
            pub fn set_ckst(&mut self, val: super::vals::FocoscrCkst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Focoscr {
            #[inline(always)]
            fn default() -> Focoscr {
                Focoscr(0)
            }
        }
        impl core::fmt::Debug for Focoscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Focoscr")
                    .field("cksel", &self.cksel())
                    .field("ckst", &self.ckst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Focoscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Focoscr {{ cksel: {:?}, ckst: {:?} }}",
                    self.cksel(),
                    self.ckst()
                )
            }
        }
        #[doc = "FSUB Clock Source Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fsubscr(pub u8);
        impl Fsubscr {
            #[doc = "FSUB Clock Source Select"]
            #[inline(always)]
            pub const fn cksel(&self) -> super::vals::FsubscrCksel {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::FsubscrCksel::from_bits(val as u8)
            }
            #[doc = "FSUB Clock Source Select"]
            #[inline(always)]
            pub fn set_cksel(&mut self, val: super::vals::FsubscrCksel) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fsubscr {
            #[inline(always)]
            fn default() -> Fsubscr {
                Fsubscr(0)
            }
        }
        impl core::fmt::Debug for Fsubscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fsubscr")
                    .field("cksel", &self.cksel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fsubscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fsubscr {{ cksel: {:?} }}", self.cksel())
            }
        }
        #[doc = "High,speed On,chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hococr(pub u8);
        impl Hococr {
            #[doc = "HOCO Stop"]
            #[inline(always)]
            pub const fn hcstp(&self) -> super::vals::Hcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hcstp::from_bits(val as u8)
            }
            #[doc = "HOCO Stop"]
            #[inline(always)]
            pub fn set_hcstp(&mut self, val: super::vals::Hcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Hococr {
            #[inline(always)]
            fn default() -> Hococr {
                Hococr(0)
            }
        }
        impl core::fmt::Debug for Hococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hococr")
                    .field("hcstp", &self.hcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hococr {{ hcstp: {:?} }}", self.hcstp())
            }
        }
        #[doc = "High,speed On,chip Oscillator Frequency Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hocodiv(pub u8);
        impl Hocodiv {
            #[doc = "High,speed On,chip Oscillator Clock Division Ratio"]
            #[inline(always)]
            pub const fn div(&self) -> super::vals::HocodivDiv {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::HocodivDiv::from_bits(val as u8)
            }
            #[doc = "High,speed On,chip Oscillator Clock Division Ratio"]
            #[inline(always)]
            pub fn set_div(&mut self, val: super::vals::HocodivDiv) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Hocodiv {
            #[inline(always)]
            fn default() -> Hocodiv {
                Hocodiv(0)
            }
        }
        impl core::fmt::Debug for Hocodiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hocodiv").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hocodiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hocodiv {{ div: {:?} }}", self.div())
            }
        }
        #[doc = "ICLK Clock Source Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iclkscr(pub u8);
        impl Iclkscr {
            #[doc = "ICLK Clock Source Select"]
            #[inline(always)]
            pub const fn cksel(&self) -> super::vals::IclkscrCksel {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::IclkscrCksel::from_bits(val as u8)
            }
            #[doc = "ICLK Clock Source Select"]
            #[inline(always)]
            pub fn set_cksel(&mut self, val: super::vals::IclkscrCksel) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "ICLK Clock Source Status"]
            #[inline(always)]
            pub const fn ckst(&self) -> super::vals::IclkscrCkst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::IclkscrCkst::from_bits(val as u8)
            }
            #[doc = "ICLK Clock Source Status"]
            #[inline(always)]
            pub fn set_ckst(&mut self, val: super::vals::IclkscrCkst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Iclkscr {
            #[inline(always)]
            fn default() -> Iclkscr {
                Iclkscr(0)
            }
        }
        impl core::fmt::Debug for Iclkscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iclkscr")
                    .field("cksel", &self.cksel())
                    .field("ckst", &self.ckst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iclkscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Iclkscr {{ cksel: {:?}, ckst: {:?} }}",
                    self.cksel(),
                    self.ckst()
                )
            }
        }
        #[doc = "Low,speed On,chip Oscillator Trimming Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Liotrm(pub u8);
        impl Liotrm {
            #[doc = "LOCO User Trimming"]
            #[inline(always)]
            pub const fn liotrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "LOCO User Trimming"]
            #[inline(always)]
            pub fn set_liotrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Liotrm {
            #[inline(always)]
            fn default() -> Liotrm {
                Liotrm(0)
            }
        }
        impl core::fmt::Debug for Liotrm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Liotrm")
                    .field("liotrm", &self.liotrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Liotrm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Liotrm {{ liotrm: {=u8:?} }}", self.liotrm())
            }
        }
        #[doc = "Low,speed On,chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lococr(pub u8);
        impl Lococr {
            #[doc = "LOCO Stop"]
            #[inline(always)]
            pub const fn lcstp(&self) -> super::vals::Lcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lcstp::from_bits(val as u8)
            }
            #[doc = "LOCO Stop"]
            #[inline(always)]
            pub fn set_lcstp(&mut self, val: super::vals::Lcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Lococr {
            #[inline(always)]
            fn default() -> Lococr {
                Lococr(0)
            }
        }
        impl core::fmt::Debug for Lococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lococr")
                    .field("lcstp", &self.lcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lococr {{ lcstp: {:?} }}", self.lcstp())
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1cr(pub u8);
        impl Lvd1cr {
            #[doc = "Voltage Detection 1 Level Select"]
            #[inline(always)]
            pub const fn lvd1v(&self) -> super::vals::Lvd1v {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Lvd1v::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 1 Level Select"]
            #[inline(always)]
            pub fn set_lvd1v(&mut self, val: super::vals::Lvd1v) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u8) & 0x1f) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Type Select"]
            #[inline(always)]
            pub const fn irqsel(&self) -> super::vals::Irqsel {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Irqsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Type Select"]
            #[inline(always)]
            pub fn set_irqsel(&mut self, val: super::vals::Irqsel) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Operation mode of LVD1"]
            #[inline(always)]
            pub const fn lvd1sel(&self) -> super::vals::Lvd1sel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd1sel::from_bits(val as u8)
            }
            #[doc = "Operation mode of LVD1"]
            #[inline(always)]
            pub fn set_lvd1sel(&mut self, val: super::vals::Lvd1sel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Enabling Operation of LVD1"]
            #[inline(always)]
            pub const fn lvd1en(&self) -> super::vals::Lvd1en {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lvd1en::from_bits(val as u8)
            }
            #[doc = "Enabling Operation of LVD1"]
            #[inline(always)]
            pub fn set_lvd1en(&mut self, val: super::vals::Lvd1en) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lvd1cr {
            #[inline(always)]
            fn default() -> Lvd1cr {
                Lvd1cr(0)
            }
        }
        impl core::fmt::Debug for Lvd1cr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1cr")
                    .field("lvd1v", &self.lvd1v())
                    .field("irqsel", &self.irqsel())
                    .field("lvd1sel", &self.lvd1sel())
                    .field("lvd1en", &self.lvd1en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1cr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1cr {{ lvd1v: {:?}, irqsel: {:?}, lvd1sel: {:?}, lvd1en: {:?} }}",
                    self.lvd1v(),
                    self.irqsel(),
                    self.lvd1sel(),
                    self.lvd1en()
                )
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1mkr(pub u8);
        impl Lvd1mkr {
            #[doc = "Specification of Whether to Enable or Disable Rewriting th LVD1CR Register"]
            #[inline(always)]
            pub const fn mk(&self) -> super::vals::Mk {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mk::from_bits(val as u8)
            }
            #[doc = "Specification of Whether to Enable or Disable Rewriting th LVD1CR Register"]
            #[inline(always)]
            pub fn set_mk(&mut self, val: super::vals::Mk) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Lvd1mkr {
            #[inline(always)]
            fn default() -> Lvd1mkr {
                Lvd1mkr(0)
            }
        }
        impl core::fmt::Debug for Lvd1mkr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1mkr").field("mk", &self.mk()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1mkr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lvd1mkr {{ mk: {:?} }}", self.mk())
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1sr(pub u8);
        impl Lvd1sr {
            #[doc = "Voltage Monitor 1 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::Det {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Det::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::Det) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Signal Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::Mon {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mon::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Signal Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::Mon) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Lvd1sr {
            #[inline(always)]
            fn default() -> Lvd1sr {
                Lvd1sr(0)
            }
        }
        impl core::fmt::Debug for Lvd1sr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1sr")
                    .field("det", &self.det())
                    .field("mon", &self.mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1sr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1sr {{ det: {:?}, mon: {:?} }}",
                    self.det(),
                    self.mon()
                )
            }
        }
        #[doc = "Middle,speed On,chip Oscillator Trimming Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Miotrm(pub u8);
        impl Miotrm {
            #[doc = "MOCO User Trimming"]
            #[inline(always)]
            pub const fn miotrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MOCO User Trimming"]
            #[inline(always)]
            pub fn set_miotrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Miotrm {
            #[inline(always)]
            fn default() -> Miotrm {
                Miotrm(0)
            }
        }
        impl core::fmt::Debug for Miotrm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Miotrm")
                    .field("miotrm", &self.miotrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Miotrm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Miotrm {{ miotrm: {=u8:?} }}", self.miotrm())
            }
        }
        #[doc = "Middle,speed On,chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mococr(pub u8);
        impl Mococr {
            #[doc = "MOCO Stop"]
            #[inline(always)]
            pub const fn mcstp(&self) -> super::vals::Mcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mcstp::from_bits(val as u8)
            }
            #[doc = "MOCO Stop"]
            #[inline(always)]
            pub fn set_mcstp(&mut self, val: super::vals::Mcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Mococr {
            #[inline(always)]
            fn default() -> Mococr {
                Mococr(0)
            }
        }
        impl core::fmt::Debug for Mococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mococr")
                    .field("mcstp", &self.mcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mococr {{ mcstp: {:?} }}", self.mcstp())
            }
        }
        #[doc = "Middle,speed On,chip Oscillator Frequency Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mocodiv(pub u8);
        impl Mocodiv {
            #[doc = "Selection of the Middle,speed On,chip Oscillator Clock Frequency"]
            #[inline(always)]
            pub const fn div(&self) -> super::vals::MocodivDiv {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::MocodivDiv::from_bits(val as u8)
            }
            #[doc = "Selection of the Middle,speed On,chip Oscillator Clock Frequency"]
            #[inline(always)]
            pub fn set_div(&mut self, val: super::vals::MocodivDiv) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Mocodiv {
            #[inline(always)]
            fn default() -> Mocodiv {
                Mocodiv(0)
            }
        }
        impl core::fmt::Debug for Mocodiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mocodiv").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mocodiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mocodiv {{ div: {:?} }}", self.div())
            }
        }
        #[doc = "Main Clock Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mosccr(pub u8);
        impl Mosccr {
            #[doc = "Main Clock Oscillator Stop"]
            #[inline(always)]
            pub const fn mostp(&self) -> super::vals::Mostp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mostp::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Stop"]
            #[inline(always)]
            pub fn set_mostp(&mut self, val: super::vals::Mostp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Mosccr {
            #[inline(always)]
            fn default() -> Mosccr {
                Mosccr(0)
            }
        }
        impl core::fmt::Debug for Mosccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mosccr")
                    .field("mostp", &self.mostp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mosccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mosccr {{ mostp: {:?} }}", self.mostp())
            }
        }
        #[doc = "MOSC Clock Division Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Moscdiv(pub u8);
        impl Moscdiv {
            #[doc = "Selection Division Ratio for the MOSC Clock"]
            #[inline(always)]
            pub const fn div(&self) -> super::vals::MoscdivDiv {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::MoscdivDiv::from_bits(val as u8)
            }
            #[doc = "Selection Division Ratio for the MOSC Clock"]
            #[inline(always)]
            pub fn set_div(&mut self, val: super::vals::MoscdivDiv) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Moscdiv {
            #[inline(always)]
            fn default() -> Moscdiv {
                Moscdiv(0)
            }
        }
        impl core::fmt::Debug for Moscdiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Moscdiv").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Moscdiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Moscdiv {{ div: {:?} }}", self.div())
            }
        }
        #[doc = "Module Stop Control Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcra(pub u16);
        impl Mstpcra {
            #[doc = "DTC Module Stop"]
            #[inline(always)]
            pub const fn mstpa22(&self) -> super::vals::Mstpa22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mstpa22::from_bits(val as u8)
            }
            #[doc = "DTC Module Stop"]
            #[inline(always)]
            pub fn set_mstpa22(&mut self, val: super::vals::Mstpa22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
        }
        impl Default for Mstpcra {
            #[inline(always)]
            fn default() -> Mstpcra {
                Mstpcra(0)
            }
        }
        impl core::fmt::Debug for Mstpcra {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcra")
                    .field("mstpa22", &self.mstpa22())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcra {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mstpcra {{ mstpa22: {:?} }}", self.mstpa22())
            }
        }
        #[doc = "Oscillation Stabilization Flag Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oscsf(pub u8);
        impl Oscsf {
            #[doc = "HOCO Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub const fn hocosf(&self) -> super::vals::Hocosf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hocosf::from_bits(val as u8)
            }
            #[doc = "HOCO Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub fn set_hocosf(&mut self, val: super::vals::Hocosf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Oscsf {
            #[inline(always)]
            fn default() -> Oscsf {
                Oscsf(0)
            }
        }
        impl core::fmt::Debug for Oscsf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oscsf")
                    .field("hocosf", &self.hocosf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oscsf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Oscsf {{ hocosf: {:?} }}", self.hocosf())
            }
        }
        #[doc = "Subsystem Clock Supply Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Osmc(pub u8);
        impl Osmc {
            #[doc = "Selection of the Operating clock source for the Realtime Clock, 32-bit Interval Timer, Serial Interface UARTA"]
            #[inline(always)]
            pub const fn wutmmck0(&self) -> super::vals::Wutmmck0 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Wutmmck0::from_bits(val as u8)
            }
            #[doc = "Selection of the Operating clock source for the Realtime Clock, 32-bit Interval Timer, Serial Interface UARTA"]
            #[inline(always)]
            pub fn set_wutmmck0(&mut self, val: super::vals::Wutmmck0) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Osmc {
            #[inline(always)]
            fn default() -> Osmc {
                Osmc(0)
            }
        }
        impl core::fmt::Debug for Osmc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Osmc")
                    .field("wutmmck0", &self.wutmmck0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Osmc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Osmc {{ wutmmck0: {:?} }}", self.wutmmck0())
            }
        }
        #[doc = "Oscillation Stabilization Time Counter Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ostc(pub u8);
        impl Ostc {
            #[doc = "Selection of the Oscillation Stabilization Time"]
            #[inline(always)]
            pub const fn most(&self) -> super::vals::Most {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Most::from_bits(val as u8)
            }
            #[doc = "Selection of the Oscillation Stabilization Time"]
            #[inline(always)]
            pub fn set_most(&mut self, val: super::vals::Most) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ostc {
            #[inline(always)]
            fn default() -> Ostc {
                Ostc(0)
            }
        }
        impl core::fmt::Debug for Ostc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ostc").field("most", &self.most()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ostc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ostc {{ most: {:?} }}", self.most())
            }
        }
        #[doc = "Oscillation Stabilization Time Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Osts(pub u8);
        impl Osts {
            #[doc = "Selection of the Oscillation Stabilization Time"]
            #[inline(always)]
            pub const fn ostsb(&self) -> super::vals::Ostsb {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ostsb::from_bits(val as u8)
            }
            #[doc = "Selection of the Oscillation Stabilization Time"]
            #[inline(always)]
            pub fn set_ostsb(&mut self, val: super::vals::Ostsb) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Osts {
            #[inline(always)]
            fn default() -> Osts {
                Osts(0)
            }
        }
        impl core::fmt::Debug for Osts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Osts")
                    .field("ostsb", &self.ostsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Osts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Osts {{ ostsb: {:?} }}", self.ostsb())
            }
        }
        #[doc = "Power,On Reset Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porsr(pub u8);
        impl Porsr {
            #[doc = "Checking Occurrence of Power,on Reset"]
            #[inline(always)]
            pub const fn porf(&self) -> super::vals::Porf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Porf::from_bits(val as u8)
            }
            #[doc = "Checking Occurrence of Power,on Reset"]
            #[inline(always)]
            pub fn set_porf(&mut self, val: super::vals::Porf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Porsr {
            #[inline(always)]
            fn default() -> Porsr {
                Porsr(0)
            }
        }
        impl core::fmt::Debug for Porsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porsr").field("porf", &self.porf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Porsr {{ porf: {:?} }}", self.porf())
            }
        }
        #[doc = "Protect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prcr(pub u16);
        impl Prcr {
            #[doc = "Enable writing to the registers related to the clock generation circuit"]
            #[inline(always)]
            pub const fn prc0(&self) -> super::vals::Prc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Prc0::from_bits(val as u8)
            }
            #[doc = "Enable writing to the registers related to the clock generation circuit"]
            #[inline(always)]
            pub fn set_prc0(&mut self, val: super::vals::Prc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Enable writing to the registers related to the low power modes"]
            #[inline(always)]
            pub const fn prc1(&self) -> super::vals::Prc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Prc1::from_bits(val as u8)
            }
            #[doc = "Enable writing to the registers related to the low power modes"]
            #[inline(always)]
            pub fn set_prc1(&mut self, val: super::vals::Prc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Enable writing to the registers related to the LVD"]
            #[inline(always)]
            pub const fn prc3(&self) -> super::vals::Prc3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Prc3::from_bits(val as u8)
            }
            #[doc = "Enable writing to the registers related to the LVD"]
            #[inline(always)]
            pub fn set_prc3(&mut self, val: super::vals::Prc3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "PRC Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "PRC Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Prcr {
            #[inline(always)]
            fn default() -> Prcr {
                Prcr(0)
            }
        }
        impl core::fmt::Debug for Prcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prcr")
                    .field("prc0", &self.prc0())
                    .field("prc1", &self.prc1())
                    .field("prc3", &self.prc3())
                    .field("prkey", &self.prkey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prcr {{ prc0: {:?}, prc1: {:?}, prc3: {:?}, prkey: {=u8:?} }}",
                    self.prc0(),
                    self.prc1(),
                    self.prc3(),
                    self.prkey()
                )
            }
        }
        #[doc = "Power Save Memory Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psmcr(pub u8);
        impl Psmcr {
            #[doc = "Operating Mode of the RAM"]
            #[inline(always)]
            pub const fn ramsd(&self) -> super::vals::Ramsd {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Ramsd::from_bits(val as u8)
            }
            #[doc = "Operating Mode of the RAM"]
            #[inline(always)]
            pub fn set_ramsd(&mut self, val: super::vals::Ramsd) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Psmcr {
            #[inline(always)]
            fn default() -> Psmcr {
                Psmcr(0)
            }
        }
        impl core::fmt::Debug for Psmcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psmcr")
                    .field("ramsd", &self.ramsd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psmcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Psmcr {{ ramsd: {:?} }}", self.ramsd())
            }
        }
        #[doc = "Reset Status Flag Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Resf(pub u8);
        impl Resf {
            #[doc = "Internal Reset Request by Voltage Detector (LVD0 or LVD1)"]
            #[inline(always)]
            pub const fn lvirf(&self) -> super::vals::Lvirf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvirf::from_bits(val as u8)
            }
            #[doc = "Internal Reset Request by Voltage Detector (LVD0 or LVD1)"]
            #[inline(always)]
            pub fn set_lvirf(&mut self, val: super::vals::Lvirf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Internal Reset Request by RAM Parity Error"]
            #[inline(always)]
            pub const fn rperf(&self) -> super::vals::Rperf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Rperf::from_bits(val as u8)
            }
            #[doc = "Internal Reset Request by RAM Parity Error"]
            #[inline(always)]
            pub fn set_rperf(&mut self, val: super::vals::Rperf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Internal Reset Request by Independent Watchdog Timer (IWDT)"]
            #[inline(always)]
            pub const fn iwdtrf(&self) -> super::vals::Iwdtrf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Iwdtrf::from_bits(val as u8)
            }
            #[doc = "Internal Reset Request by Independent Watchdog Timer (IWDT)"]
            #[inline(always)]
            pub fn set_iwdtrf(&mut self, val: super::vals::Iwdtrf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Internal Reset Request by Software Reset"]
            #[inline(always)]
            pub const fn swrf(&self) -> super::vals::Swrf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Swrf::from_bits(val as u8)
            }
            #[doc = "Internal Reset Request by Software Reset"]
            #[inline(always)]
            pub fn set_swrf(&mut self, val: super::vals::Swrf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Resf {
            #[inline(always)]
            fn default() -> Resf {
                Resf(0)
            }
        }
        impl core::fmt::Debug for Resf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Resf")
                    .field("lvirf", &self.lvirf())
                    .field("rperf", &self.rperf())
                    .field("iwdtrf", &self.iwdtrf())
                    .field("swrf", &self.swrf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Resf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Resf {{ lvirf: {:?}, rperf: {:?}, iwdtrf: {:?}, swrf: {:?} }}",
                    self.lvirf(),
                    self.rperf(),
                    self.iwdtrf(),
                    self.swrf()
                )
            }
        }
        #[doc = "Standby Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sbycr(pub u16);
        impl Sbycr {
            #[doc = "Flash Mode in Sleep Mode or in Snooze Mode"]
            #[inline(always)]
            pub const fn flstp(&self) -> super::vals::Flstp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Flstp::from_bits(val as u8)
            }
            #[doc = "Flash Mode in Sleep Mode or in Snooze Mode"]
            #[inline(always)]
            pub fn set_flstp(&mut self, val: super::vals::Flstp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Setting for Starting the High,speed On,chip Oscillator at the times of release from Software Standby Mode and of Transitions to Snooze Mode"]
            #[inline(always)]
            pub const fn fwkup(&self) -> super::vals::Fwkup {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Fwkup::from_bits(val as u8)
            }
            #[doc = "Setting for Starting the High,speed On,chip Oscillator at the times of release from Software Standby Mode and of Transitions to Snooze Mode"]
            #[inline(always)]
            pub fn set_fwkup(&mut self, val: super::vals::Fwkup) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "SOSC Setting in Software Standby Mode or in Snooze Mode"]
            #[inline(always)]
            pub const fn rtclpc(&self) -> super::vals::Rtclpc {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Rtclpc::from_bits(val as u8)
            }
            #[doc = "SOSC Setting in Software Standby Mode or in Snooze Mode"]
            #[inline(always)]
            pub fn set_rtclpc(&mut self, val: super::vals::Rtclpc) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Software Standby Mode Select"]
            #[inline(always)]
            pub const fn ssby(&self) -> super::vals::Ssby {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ssby::from_bits(val as u8)
            }
            #[doc = "Software Standby Mode Select"]
            #[inline(always)]
            pub fn set_ssby(&mut self, val: super::vals::Ssby) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Sbycr {
            #[inline(always)]
            fn default() -> Sbycr {
                Sbycr(0)
            }
        }
        impl core::fmt::Debug for Sbycr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sbycr")
                    .field("flstp", &self.flstp())
                    .field("fwkup", &self.fwkup())
                    .field("rtclpc", &self.rtclpc())
                    .field("ssby", &self.ssby())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sbycr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sbycr {{ flstp: {:?}, fwkup: {:?}, rtclpc: {:?}, ssby: {:?} }}",
                    self.flstp(),
                    self.fwkup(),
                    self.rtclpc(),
                    self.ssby()
                )
            }
        }
        #[doc = "Sub,clock Oscillator Margin Check Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Somrg(pub u8);
        impl Somrg {
            #[doc = "Sub Clock Oscillator Margin Check Switching"]
            #[inline(always)]
            pub const fn soscmrg(&self) -> super::vals::Soscmrg {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Soscmrg::from_bits(val as u8)
            }
            #[doc = "Sub Clock Oscillator Margin Check Switching"]
            #[inline(always)]
            pub fn set_soscmrg(&mut self, val: super::vals::Soscmrg) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Somrg {
            #[inline(always)]
            fn default() -> Somrg {
                Somrg(0)
            }
        }
        impl core::fmt::Debug for Somrg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Somrg")
                    .field("soscmrg", &self.soscmrg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Somrg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Somrg {{ soscmrg: {:?} }}", self.soscmrg())
            }
        }
        #[doc = "Sub,clock Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sosccr(pub u8);
        impl Sosccr {
            #[doc = "Sub Clock Oscillator Stop"]
            #[inline(always)]
            pub const fn sostp(&self) -> super::vals::Sostp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sostp::from_bits(val as u8)
            }
            #[doc = "Sub Clock Oscillator Stop"]
            #[inline(always)]
            pub fn set_sostp(&mut self, val: super::vals::Sostp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Sosccr {
            #[inline(always)]
            fn default() -> Sosccr {
                Sosccr(0)
            }
        }
        impl core::fmt::Debug for Sosccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sosccr")
                    .field("sostp", &self.sostp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sosccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sosccr {{ sostp: {:?} }}", self.sostp())
            }
        }
        #[doc = "System Control OCD Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syocdcr(pub u8);
        impl Syocdcr {
            #[doc = "Debugger Enable bit"]
            #[inline(always)]
            pub const fn dbgen(&self) -> super::vals::Dbgen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dbgen::from_bits(val as u8)
            }
            #[doc = "Debugger Enable bit"]
            #[inline(always)]
            pub fn set_dbgen(&mut self, val: super::vals::Dbgen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Syocdcr {
            #[inline(always)]
            fn default() -> Syocdcr {
                Syocdcr(0)
            }
        }
        impl core::fmt::Debug for Syocdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syocdcr")
                    .field("dbgen", &self.dbgen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syocdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Syocdcr {{ dbgen: {:?} }}", self.dbgen())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dbgen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dbgen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dbgen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dbgen {
            #[inline(always)]
            fn from(val: u8) -> Dbgen {
                Dbgen::from_bits(val)
            }
        }
        impl From<Dbgen> for u8 {
            #[inline(always)]
            fn from(val: Dbgen) -> u8 {
                Dbgen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Det {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Det {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Det {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Det {
            #[inline(always)]
            fn from(val: u8) -> Det {
                Det::from_bits(val)
            }
        }
        impl From<Det> for u8 {
            #[inline(always)]
            fn from(val: Det) -> u8 {
                Det::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Flstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flstp {
            #[inline(always)]
            fn from(val: u8) -> Flstp {
                Flstp::from_bits(val)
            }
        }
        impl From<Flstp> for u8 {
            #[inline(always)]
            fn from(val: Flstp) -> u8 {
                Flstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FmainscrCksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FmainscrCksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FmainscrCksel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FmainscrCksel {
            #[inline(always)]
            fn from(val: u8) -> FmainscrCksel {
                FmainscrCksel::from_bits(val)
            }
        }
        impl From<FmainscrCksel> for u8 {
            #[inline(always)]
            fn from(val: FmainscrCksel) -> u8 {
                FmainscrCksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FmainscrCkst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FmainscrCkst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FmainscrCkst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FmainscrCkst {
            #[inline(always)]
            fn from(val: u8) -> FmainscrCkst {
                FmainscrCkst::from_bits(val)
            }
        }
        impl From<FmainscrCkst> for u8 {
            #[inline(always)]
            fn from(val: FmainscrCkst) -> u8 {
                FmainscrCkst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FocoscrCksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FocoscrCksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FocoscrCksel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FocoscrCksel {
            #[inline(always)]
            fn from(val: u8) -> FocoscrCksel {
                FocoscrCksel::from_bits(val)
            }
        }
        impl From<FocoscrCksel> for u8 {
            #[inline(always)]
            fn from(val: FocoscrCksel) -> u8 {
                FocoscrCksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FocoscrCkst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FocoscrCkst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FocoscrCkst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FocoscrCkst {
            #[inline(always)]
            fn from(val: u8) -> FocoscrCkst {
                FocoscrCkst::from_bits(val)
            }
        }
        impl From<FocoscrCkst> for u8 {
            #[inline(always)]
            fn from(val: FocoscrCkst) -> u8 {
                FocoscrCkst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FsubscrCksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FsubscrCksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FsubscrCksel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FsubscrCksel {
            #[inline(always)]
            fn from(val: u8) -> FsubscrCksel {
                FsubscrCksel::from_bits(val)
            }
        }
        impl From<FsubscrCksel> for u8 {
            #[inline(always)]
            fn from(val: FsubscrCksel) -> u8 {
                FsubscrCksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fwkup {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fwkup {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fwkup {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fwkup {
            #[inline(always)]
            fn from(val: u8) -> Fwkup {
                Fwkup::from_bits(val)
            }
        }
        impl From<Fwkup> for u8 {
            #[inline(always)]
            fn from(val: Fwkup) -> u8 {
                Fwkup::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hcstp {
            #[inline(always)]
            fn from(val: u8) -> Hcstp {
                Hcstp::from_bits(val)
            }
        }
        impl From<Hcstp> for u8 {
            #[inline(always)]
            fn from(val: Hcstp) -> u8 {
                Hcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum HocodivDiv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl HocodivDiv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> HocodivDiv {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for HocodivDiv {
            #[inline(always)]
            fn from(val: u8) -> HocodivDiv {
                HocodivDiv::from_bits(val)
            }
        }
        impl From<HocodivDiv> for u8 {
            #[inline(always)]
            fn from(val: HocodivDiv) -> u8 {
                HocodivDiv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hocosf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hocosf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hocosf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hocosf {
            #[inline(always)]
            fn from(val: u8) -> Hocosf {
                Hocosf::from_bits(val)
            }
        }
        impl From<Hocosf> for u8 {
            #[inline(always)]
            fn from(val: Hocosf) -> u8 {
                Hocosf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IclkscrCksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl IclkscrCksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IclkscrCksel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IclkscrCksel {
            #[inline(always)]
            fn from(val: u8) -> IclkscrCksel {
                IclkscrCksel::from_bits(val)
            }
        }
        impl From<IclkscrCksel> for u8 {
            #[inline(always)]
            fn from(val: IclkscrCksel) -> u8 {
                IclkscrCksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IclkscrCkst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl IclkscrCkst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IclkscrCkst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IclkscrCkst {
            #[inline(always)]
            fn from(val: u8) -> IclkscrCkst {
                IclkscrCkst::from_bits(val)
            }
        }
        impl From<IclkscrCkst> for u8 {
            #[inline(always)]
            fn from(val: IclkscrCkst) -> u8 {
                IclkscrCkst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irqsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqsel {
            #[inline(always)]
            fn from(val: u8) -> Irqsel {
                Irqsel::from_bits(val)
            }
        }
        impl From<Irqsel> for u8 {
            #[inline(always)]
            fn from(val: Irqsel) -> u8 {
                Irqsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtrf {
            #[inline(always)]
            fn from(val: u8) -> Iwdtrf {
                Iwdtrf::from_bits(val)
            }
        }
        impl From<Iwdtrf> for u8 {
            #[inline(always)]
            fn from(val: Iwdtrf) -> u8 {
                Iwdtrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcstp {
            #[inline(always)]
            fn from(val: u8) -> Lcstp {
                Lcstp::from_bits(val)
            }
        }
        impl From<Lcstp> for u8 {
            #[inline(always)]
            fn from(val: Lcstp) -> u8 {
                Lcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1en {
            #[inline(always)]
            fn from(val: u8) -> Lvd1en {
                Lvd1en::from_bits(val)
            }
        }
        impl From<Lvd1en> for u8 {
            #[inline(always)]
            fn from(val: Lvd1en) -> u8 {
                Lvd1en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1sel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1sel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1sel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1sel {
            #[inline(always)]
            fn from(val: u8) -> Lvd1sel {
                Lvd1sel::from_bits(val)
            }
        }
        impl From<Lvd1sel> for u8 {
            #[inline(always)]
            fn from(val: Lvd1sel) -> u8 {
                Lvd1sel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1v {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Lvd1v {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1v {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1v {
            #[inline(always)]
            fn from(val: u8) -> Lvd1v {
                Lvd1v::from_bits(val)
            }
        }
        impl From<Lvd1v> for u8 {
            #[inline(always)]
            fn from(val: Lvd1v) -> u8 {
                Lvd1v::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvirf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvirf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvirf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvirf {
            #[inline(always)]
            fn from(val: u8) -> Lvirf {
                Lvirf::from_bits(val)
            }
        }
        impl From<Lvirf> for u8 {
            #[inline(always)]
            fn from(val: Lvirf) -> u8 {
                Lvirf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mcstp {
            #[inline(always)]
            fn from(val: u8) -> Mcstp {
                Mcstp::from_bits(val)
            }
        }
        impl From<Mcstp> for u8 {
            #[inline(always)]
            fn from(val: Mcstp) -> u8 {
                Mcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mk {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mk {
            #[inline(always)]
            fn from(val: u8) -> Mk {
                Mk::from_bits(val)
            }
        }
        impl From<Mk> for u8 {
            #[inline(always)]
            fn from(val: Mk) -> u8 {
                Mk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MocodivDiv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl MocodivDiv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MocodivDiv {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MocodivDiv {
            #[inline(always)]
            fn from(val: u8) -> MocodivDiv {
                MocodivDiv::from_bits(val)
            }
        }
        impl From<MocodivDiv> for u8 {
            #[inline(always)]
            fn from(val: MocodivDiv) -> u8 {
                MocodivDiv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modrv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Modrv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modrv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modrv {
            #[inline(always)]
            fn from(val: u8) -> Modrv {
                Modrv::from_bits(val)
            }
        }
        impl From<Modrv> for u8 {
            #[inline(always)]
            fn from(val: Modrv) -> u8 {
                Modrv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mon {
            #[inline(always)]
            fn from(val: u8) -> Mon {
                Mon::from_bits(val)
            }
        }
        impl From<Mon> for u8 {
            #[inline(always)]
            fn from(val: Mon) -> u8 {
                Mon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MoscdivDiv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl MoscdivDiv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MoscdivDiv {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MoscdivDiv {
            #[inline(always)]
            fn from(val: u8) -> MoscdivDiv {
                MoscdivDiv::from_bits(val)
            }
        }
        impl From<MoscdivDiv> for u8 {
            #[inline(always)]
            fn from(val: MoscdivDiv) -> u8 {
                MoscdivDiv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mosel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mosel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mosel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mosel {
            #[inline(always)]
            fn from(val: u8) -> Mosel {
                Mosel::from_bits(val)
            }
        }
        impl From<Mosel> for u8 {
            #[inline(always)]
            fn from(val: Mosel) -> u8 {
                Mosel::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Most(u8);
        impl Most {}
        impl Most {
            pub const fn from_bits(val: u8) -> Most {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Most {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Most {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Most {
            #[inline(always)]
            fn from(val: u8) -> Most {
                Most::from_bits(val)
            }
        }
        impl From<Most> for u8 {
            #[inline(always)]
            fn from(val: Most) -> u8 {
                Most::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mostp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mostp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mostp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mostp {
            #[inline(always)]
            fn from(val: u8) -> Mostp {
                Mostp::from_bits(val)
            }
        }
        impl From<Mostp> for u8 {
            #[inline(always)]
            fn from(val: Mostp) -> u8 {
                Mostp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpa22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpa22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpa22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpa22 {
            #[inline(always)]
            fn from(val: u8) -> Mstpa22 {
                Mstpa22::from_bits(val)
            }
        }
        impl From<Mstpa22> for u8 {
            #[inline(always)]
            fn from(val: Mstpa22) -> u8 {
                Mstpa22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostsb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ostsb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostsb {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostsb {
            #[inline(always)]
            fn from(val: u8) -> Ostsb {
                Ostsb::from_bits(val)
            }
        }
        impl From<Ostsb> for u8 {
            #[inline(always)]
            fn from(val: Ostsb) -> u8 {
                Ostsb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porf {
            #[inline(always)]
            fn from(val: u8) -> Porf {
                Porf::from_bits(val)
            }
        }
        impl From<Porf> for u8 {
            #[inline(always)]
            fn from(val: Porf) -> u8 {
                Porf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc0 {
            #[inline(always)]
            fn from(val: u8) -> Prc0 {
                Prc0::from_bits(val)
            }
        }
        impl From<Prc0> for u8 {
            #[inline(always)]
            fn from(val: Prc0) -> u8 {
                Prc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc1 {
            #[inline(always)]
            fn from(val: u8) -> Prc1 {
                Prc1::from_bits(val)
            }
        }
        impl From<Prc1> for u8 {
            #[inline(always)]
            fn from(val: Prc1) -> u8 {
                Prc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc3 {
            #[inline(always)]
            fn from(val: u8) -> Prc3 {
                Prc3::from_bits(val)
            }
        }
        impl From<Prc3> for u8 {
            #[inline(always)]
            fn from(val: Prc3) -> u8 {
                Prc3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ramsd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ramsd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ramsd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ramsd {
            #[inline(always)]
            fn from(val: u8) -> Ramsd {
                Ramsd::from_bits(val)
            }
        }
        impl From<Ramsd> for u8 {
            #[inline(always)]
            fn from(val: Ramsd) -> u8 {
                Ramsd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rperf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rperf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rperf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rperf {
            #[inline(always)]
            fn from(val: u8) -> Rperf {
                Rperf::from_bits(val)
            }
        }
        impl From<Rperf> for u8 {
            #[inline(always)]
            fn from(val: Rperf) -> u8 {
                Rperf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtclpc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtclpc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtclpc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtclpc {
            #[inline(always)]
            fn from(val: u8) -> Rtclpc {
                Rtclpc::from_bits(val)
            }
        }
        impl From<Rtclpc> for u8 {
            #[inline(always)]
            fn from(val: Rtclpc) -> u8 {
                Rtclpc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sodrv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sodrv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sodrv {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sodrv {
            #[inline(always)]
            fn from(val: u8) -> Sodrv {
                Sodrv::from_bits(val)
            }
        }
        impl From<Sodrv> for u8 {
            #[inline(always)]
            fn from(val: Sodrv) -> u8 {
                Sodrv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Soscmrg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Soscmrg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Soscmrg {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Soscmrg {
            #[inline(always)]
            fn from(val: u8) -> Soscmrg {
                Soscmrg::from_bits(val)
            }
        }
        impl From<Soscmrg> for u8 {
            #[inline(always)]
            fn from(val: Soscmrg) -> u8 {
                Soscmrg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sosel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sosel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sosel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sosel {
            #[inline(always)]
            fn from(val: u8) -> Sosel {
                Sosel::from_bits(val)
            }
        }
        impl From<Sosel> for u8 {
            #[inline(always)]
            fn from(val: Sosel) -> u8 {
                Sosel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sostp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sostp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sostp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sostp {
            #[inline(always)]
            fn from(val: u8) -> Sostp {
                Sostp::from_bits(val)
            }
        }
        impl From<Sostp> for u8 {
            #[inline(always)]
            fn from(val: Sostp) -> u8 {
                Sostp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssby {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssby {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssby {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssby {
            #[inline(always)]
            fn from(val: u8) -> Ssby {
                Ssby::from_bits(val)
            }
        }
        impl From<Ssby> for u8 {
            #[inline(always)]
            fn from(val: Ssby) -> u8 {
                Ssby::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Swrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swrf {
            #[inline(always)]
            fn from(val: u8) -> Swrf {
                Swrf::from_bits(val)
            }
        }
        impl From<Swrf> for u8 {
            #[inline(always)]
            fn from(val: Swrf) -> u8 {
                Swrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wutmmck0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wutmmck0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wutmmck0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wutmmck0 {
            #[inline(always)]
            fn from(val: u8) -> Wutmmck0 {
                Wutmmck0::from_bits(val)
            }
        }
        impl From<Wutmmck0> for u8 {
            #[inline(always)]
            fn from(val: Wutmmck0) -> u8 {
                Wutmmck0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Xtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Xtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Xtsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Xtsel {
            #[inline(always)]
            fn from(val: u8) -> Xtsel {
                Xtsel::from_bits(val)
            }
        }
        impl From<Xtsel> for u8 {
            #[inline(always)]
            fn from(val: Xtsel) -> u8 {
                Xtsel::to_bits(val)
            }
        }
    }
}
pub mod tau {
    #[doc = "Timer Array Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tau {
        ptr: *mut u8,
    }
    unsafe impl Send for Tau {}
    unsafe impl Sync for Tau {}
    impl Tau {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Timer Data Register 00"]
        #[inline(always)]
        pub const fn tdr00(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Timer Data Register 01"]
        #[inline(always)]
        pub const fn tdr01(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Timer Data Register 01"]
        #[inline(always)]
        pub const fn tdr01l(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Timer Data Register 01"]
        #[inline(always)]
        pub const fn tdr01h(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Timer Data Register 02"]
        #[inline(always)]
        pub const fn tdr02(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Timer Data Register 03"]
        #[inline(always)]
        pub const fn tdr03(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Timer Data Register 03"]
        #[inline(always)]
        pub const fn tdr03l(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Timer Data Register 03"]
        #[inline(always)]
        pub const fn tdr03h(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Timer Data Register 04"]
        #[inline(always)]
        pub const fn tdr04(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Timer Data Register 05"]
        #[inline(always)]
        pub const fn tdr05(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Timer Data Register 06"]
        #[inline(always)]
        pub const fn tdr06(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Timer Data Register 07"]
        #[inline(always)]
        pub const fn tdr07(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Timer Counter Register 0%s"]
        #[inline(always)]
        pub const fn tcr0(self, n: usize) -> crate::common::Reg<u16, crate::common::R> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 2usize) as _) }
        }
        #[doc = "Timer Mode Register 00"]
        #[inline(always)]
        pub const fn tmr00(self) -> crate::common::Reg<regs::Tmr00, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Timer Mode Register 01"]
        #[inline(always)]
        pub const fn tmr01(self) -> crate::common::Reg<regs::Tmr01, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0112usize) as _) }
        }
        #[doc = "Timer Mode Register 02"]
        #[inline(always)]
        pub const fn tmr02(self) -> crate::common::Reg<regs::Tmr02, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Timer Mode Register 03"]
        #[inline(always)]
        pub const fn tmr03(self) -> crate::common::Reg<regs::Tmr03, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0116usize) as _) }
        }
        #[doc = "Timer Mode Register 04"]
        #[inline(always)]
        pub const fn tmr04(self) -> crate::common::Reg<regs::Tmr04, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Timer Mode Register 05"]
        #[inline(always)]
        pub const fn tmr05(self) -> crate::common::Reg<regs::Tmr05, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011ausize) as _) }
        }
        #[doc = "Timer Mode Register 06"]
        #[inline(always)]
        pub const fn tmr06(self) -> crate::common::Reg<regs::Tmr06, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Timer Mode Register 07"]
        #[inline(always)]
        pub const fn tmr07(self) -> crate::common::Reg<regs::Tmr07, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011eusize) as _) }
        }
        #[doc = "Timer Status Register 0%s"]
        #[inline(always)]
        pub const fn tsr0(self, n: usize) -> crate::common::Reg<regs::Tsr0, crate::common::R> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize + n * 2usize) as _) }
        }
        #[doc = "Timer Channel Enable Status Register 0"]
        #[inline(always)]
        pub const fn te0(self) -> crate::common::Reg<regs::Te0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Timer Channel Start Register 0"]
        #[inline(always)]
        pub const fn ts0(self) -> crate::common::Reg<regs::Ts0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0132usize) as _) }
        }
        #[doc = "Timer Channel Stop Register 0"]
        #[inline(always)]
        pub const fn tt0(self) -> crate::common::Reg<regs::Tt0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "Timer Clock Select Register 0"]
        #[inline(always)]
        pub const fn tps0(self) -> crate::common::Reg<regs::Tps0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0136usize) as _) }
        }
        #[doc = "Timer Output Register 0"]
        #[inline(always)]
        pub const fn to0(self) -> crate::common::Reg<regs::To0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Timer Output Enable Register 0"]
        #[inline(always)]
        pub const fn toe0(self) -> crate::common::Reg<regs::Toe0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013ausize) as _) }
        }
        #[doc = "Timer Output Level Register 0"]
        #[inline(always)]
        pub const fn tol0(self) -> crate::common::Reg<regs::Tol0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013cusize) as _) }
        }
        #[doc = "Timer Output Mode Register 0"]
        #[inline(always)]
        pub const fn tom0(self) -> crate::common::Reg<regs::Tom0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Timer Channel Enable Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Te0(pub u16);
        impl Te0 {
            #[doc = "Indication of Operation Enabled or Stopped State of Channel n"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::Te {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Te::from_bits(val as u8)
            }
            #[doc = "Indication of Operation Enabled or Stopped State of Channel n"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::Te) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "Indication of whether Operation of the Higher 8-bit Timer is Enabled or Stopped when Channel 1 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub const fn teh1(&self) -> super::vals::Teh1 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Teh1::from_bits(val as u8)
            }
            #[doc = "Indication of whether Operation of the Higher 8-bit Timer is Enabled or Stopped when Channel 1 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub fn set_teh1(&mut self, val: super::vals::Teh1) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Indication of whether Operation of the Higher 8-bit Timer is Enabled or Stopped when Channel 3 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub const fn teh3(&self) -> super::vals::Teh3 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Teh3::from_bits(val as u8)
            }
            #[doc = "Indication of whether Operation of the Higher 8-bit Timer is Enabled or Stopped when Channel 3 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub fn set_teh3(&mut self, val: super::vals::Teh3) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
        }
        impl Default for Te0 {
            #[inline(always)]
            fn default() -> Te0 {
                Te0(0)
            }
        }
        impl core::fmt::Debug for Te0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Te0")
                    .field("te", &self.te())
                    .field("teh1", &self.teh1())
                    .field("teh3", &self.teh3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Te0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Te0 {{ te: {:?}, teh1: {:?}, teh3: {:?} }}",
                    self.te(),
                    self.teh1(),
                    self.teh3()
                )
            }
        }
        #[doc = "Timer Mode Register 00"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmr00(pub u16);
        impl Tmr00 {
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub const fn opirq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub fn set_opirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Tmr00Md {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Tmr00Md::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Tmr00Md) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u16) & 0x07) << 1usize);
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub const fn cis(&self) -> super::vals::Tmr00Cis {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tmr00Cis::from_bits(val as u8)
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub fn set_cis(&mut self, val: super::vals::Tmr00Cis) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u16) & 0x03) << 6usize);
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Tmr00Sts {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tmr00Sts::from_bits(val as u8)
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Tmr00Sts) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u16) & 0x07) << 8usize);
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Tmr00Ccs {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Tmr00Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Tmr00Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Tmr00Cks {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Tmr00Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Tmr00Cks) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Tmr00 {
            #[inline(always)]
            fn default() -> Tmr00 {
                Tmr00(0)
            }
        }
        impl core::fmt::Debug for Tmr00 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmr00")
                    .field("opirq", &self.opirq())
                    .field("md", &self.md())
                    .field("cis", &self.cis())
                    .field("sts", &self.sts())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmr00 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmr00 {{ opirq: {=bool:?}, md: {:?}, cis: {:?}, sts: {:?}, ccs: {:?}, cks: {:?} }}" , self . opirq () , self . md () , self . cis () , self . sts () , self . ccs () , self . cks ())
            }
        }
        #[doc = "Timer Mode Register 01"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmr01(pub u16);
        impl Tmr01 {
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub const fn opirq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub fn set_opirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Tmr01Md {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Tmr01Md::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Tmr01Md) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u16) & 0x07) << 1usize);
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub const fn cis(&self) -> super::vals::Tmr01Cis {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tmr01Cis::from_bits(val as u8)
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub fn set_cis(&mut self, val: super::vals::Tmr01Cis) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u16) & 0x03) << 6usize);
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Tmr01Sts {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tmr01Sts::from_bits(val as u8)
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Tmr01Sts) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u16) & 0x07) << 8usize);
            }
            #[doc = "Selection of 8 or 16-bit Timer Operation for Channels 1 and 3"]
            #[inline(always)]
            pub const fn split(&self) -> super::vals::Tmr01Split {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tmr01Split::from_bits(val as u8)
            }
            #[doc = "Selection of 8 or 16-bit Timer Operation for Channels 1 and 3"]
            #[inline(always)]
            pub fn set_split(&mut self, val: super::vals::Tmr01Split) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Tmr01Ccs {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Tmr01Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Tmr01Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Tmr01Cks {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Tmr01Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Tmr01Cks) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Tmr01 {
            #[inline(always)]
            fn default() -> Tmr01 {
                Tmr01(0)
            }
        }
        impl core::fmt::Debug for Tmr01 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmr01")
                    .field("opirq", &self.opirq())
                    .field("md", &self.md())
                    .field("cis", &self.cis())
                    .field("sts", &self.sts())
                    .field("split", &self.split())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmr01 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmr01 {{ opirq: {=bool:?}, md: {:?}, cis: {:?}, sts: {:?}, split: {:?}, ccs: {:?}, cks: {:?} }}" , self . opirq () , self . md () , self . cis () , self . sts () , self . split () , self . ccs () , self . cks ())
            }
        }
        #[doc = "Timer Mode Register 02"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmr02(pub u16);
        impl Tmr02 {
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub const fn opirq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub fn set_opirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Tmr02Md {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Tmr02Md::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Tmr02Md) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u16) & 0x07) << 1usize);
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub const fn cis(&self) -> super::vals::Tmr02Cis {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tmr02Cis::from_bits(val as u8)
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub fn set_cis(&mut self, val: super::vals::Tmr02Cis) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u16) & 0x03) << 6usize);
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Tmr02Sts {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tmr02Sts::from_bits(val as u8)
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Tmr02Sts) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u16) & 0x07) << 8usize);
            }
            #[doc = "Selection Between Using Channel n Independently or Simultaneously with Another Channel (as a Slave or Master)"]
            #[inline(always)]
            pub const fn master(&self) -> super::vals::Tmr02Master {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tmr02Master::from_bits(val as u8)
            }
            #[doc = "Selection Between Using Channel n Independently or Simultaneously with Another Channel (as a Slave or Master)"]
            #[inline(always)]
            pub fn set_master(&mut self, val: super::vals::Tmr02Master) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Tmr02Ccs {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Tmr02Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Tmr02Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Tmr02Cks {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Tmr02Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Tmr02Cks) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Tmr02 {
            #[inline(always)]
            fn default() -> Tmr02 {
                Tmr02(0)
            }
        }
        impl core::fmt::Debug for Tmr02 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmr02")
                    .field("opirq", &self.opirq())
                    .field("md", &self.md())
                    .field("cis", &self.cis())
                    .field("sts", &self.sts())
                    .field("master", &self.master())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmr02 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmr02 {{ opirq: {=bool:?}, md: {:?}, cis: {:?}, sts: {:?}, master: {:?}, ccs: {:?}, cks: {:?} }}" , self . opirq () , self . md () , self . cis () , self . sts () , self . master () , self . ccs () , self . cks ())
            }
        }
        #[doc = "Timer Mode Register 03"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmr03(pub u16);
        impl Tmr03 {
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub const fn opirq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub fn set_opirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Tmr03Md {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Tmr03Md::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Tmr03Md) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u16) & 0x07) << 1usize);
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub const fn cis(&self) -> super::vals::Tmr03Cis {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tmr03Cis::from_bits(val as u8)
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub fn set_cis(&mut self, val: super::vals::Tmr03Cis) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u16) & 0x03) << 6usize);
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Tmr03Sts {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tmr03Sts::from_bits(val as u8)
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Tmr03Sts) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u16) & 0x07) << 8usize);
            }
            #[doc = "Selection of 8 or 16-bit Timer Operation for Channels 1 and 3"]
            #[inline(always)]
            pub const fn split(&self) -> super::vals::Tmr03Split {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tmr03Split::from_bits(val as u8)
            }
            #[doc = "Selection of 8 or 16-bit Timer Operation for Channels 1 and 3"]
            #[inline(always)]
            pub fn set_split(&mut self, val: super::vals::Tmr03Split) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Tmr03Ccs {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Tmr03Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Tmr03Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Tmr03Cks {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Tmr03Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Tmr03Cks) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Tmr03 {
            #[inline(always)]
            fn default() -> Tmr03 {
                Tmr03(0)
            }
        }
        impl core::fmt::Debug for Tmr03 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmr03")
                    .field("opirq", &self.opirq())
                    .field("md", &self.md())
                    .field("cis", &self.cis())
                    .field("sts", &self.sts())
                    .field("split", &self.split())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmr03 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmr03 {{ opirq: {=bool:?}, md: {:?}, cis: {:?}, sts: {:?}, split: {:?}, ccs: {:?}, cks: {:?} }}" , self . opirq () , self . md () , self . cis () , self . sts () , self . split () , self . ccs () , self . cks ())
            }
        }
        #[doc = "Timer Mode Register 04"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmr04(pub u16);
        impl Tmr04 {
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub const fn opirq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub fn set_opirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Tmr04Md {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Tmr04Md::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Tmr04Md) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u16) & 0x07) << 1usize);
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub const fn cis(&self) -> super::vals::Tmr04Cis {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tmr04Cis::from_bits(val as u8)
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub fn set_cis(&mut self, val: super::vals::Tmr04Cis) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u16) & 0x03) << 6usize);
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Tmr04Sts {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tmr04Sts::from_bits(val as u8)
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Tmr04Sts) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u16) & 0x07) << 8usize);
            }
            #[doc = "Selection Between Using Channel n Independently or Simultaneously with Another Channel (as a Slave or Master)"]
            #[inline(always)]
            pub const fn master(&self) -> super::vals::Tmr04Master {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tmr04Master::from_bits(val as u8)
            }
            #[doc = "Selection Between Using Channel n Independently or Simultaneously with Another Channel (as a Slave or Master)"]
            #[inline(always)]
            pub fn set_master(&mut self, val: super::vals::Tmr04Master) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Tmr04Ccs {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Tmr04Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Tmr04Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Tmr04Cks {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Tmr04Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Tmr04Cks) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Tmr04 {
            #[inline(always)]
            fn default() -> Tmr04 {
                Tmr04(0)
            }
        }
        impl core::fmt::Debug for Tmr04 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmr04")
                    .field("opirq", &self.opirq())
                    .field("md", &self.md())
                    .field("cis", &self.cis())
                    .field("sts", &self.sts())
                    .field("master", &self.master())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmr04 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmr04 {{ opirq: {=bool:?}, md: {:?}, cis: {:?}, sts: {:?}, master: {:?}, ccs: {:?}, cks: {:?} }}" , self . opirq () , self . md () , self . cis () , self . sts () , self . master () , self . ccs () , self . cks ())
            }
        }
        #[doc = "Timer Mode Register 05"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmr05(pub u16);
        impl Tmr05 {
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub const fn opirq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub fn set_opirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Tmr05Md {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Tmr05Md::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Tmr05Md) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u16) & 0x07) << 1usize);
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub const fn cis(&self) -> super::vals::Tmr05Cis {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tmr05Cis::from_bits(val as u8)
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub fn set_cis(&mut self, val: super::vals::Tmr05Cis) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u16) & 0x03) << 6usize);
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Tmr05Sts {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tmr05Sts::from_bits(val as u8)
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Tmr05Sts) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u16) & 0x07) << 8usize);
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Tmr05Ccs {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Tmr05Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Tmr05Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Tmr05Cks {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Tmr05Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Tmr05Cks) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Tmr05 {
            #[inline(always)]
            fn default() -> Tmr05 {
                Tmr05(0)
            }
        }
        impl core::fmt::Debug for Tmr05 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmr05")
                    .field("opirq", &self.opirq())
                    .field("md", &self.md())
                    .field("cis", &self.cis())
                    .field("sts", &self.sts())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmr05 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmr05 {{ opirq: {=bool:?}, md: {:?}, cis: {:?}, sts: {:?}, ccs: {:?}, cks: {:?} }}" , self . opirq () , self . md () , self . cis () , self . sts () , self . ccs () , self . cks ())
            }
        }
        #[doc = "Timer Mode Register 06"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmr06(pub u16);
        impl Tmr06 {
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub const fn opirq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub fn set_opirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Tmr06Md {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Tmr06Md::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Tmr06Md) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u16) & 0x07) << 1usize);
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub const fn cis(&self) -> super::vals::Tmr06Cis {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tmr06Cis::from_bits(val as u8)
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub fn set_cis(&mut self, val: super::vals::Tmr06Cis) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u16) & 0x03) << 6usize);
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Tmr06Sts {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tmr06Sts::from_bits(val as u8)
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Tmr06Sts) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u16) & 0x07) << 8usize);
            }
            #[doc = "Selection Between Using Channel n Independently or Simultaneously with Another Channel (as a Slave or Master)"]
            #[inline(always)]
            pub const fn master(&self) -> super::vals::Tmr06Master {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tmr06Master::from_bits(val as u8)
            }
            #[doc = "Selection Between Using Channel n Independently or Simultaneously with Another Channel (as a Slave or Master)"]
            #[inline(always)]
            pub fn set_master(&mut self, val: super::vals::Tmr06Master) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Tmr06Ccs {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Tmr06Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Tmr06Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Tmr06Cks {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Tmr06Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Tmr06Cks) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Tmr06 {
            #[inline(always)]
            fn default() -> Tmr06 {
                Tmr06(0)
            }
        }
        impl core::fmt::Debug for Tmr06 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmr06")
                    .field("opirq", &self.opirq())
                    .field("md", &self.md())
                    .field("cis", &self.cis())
                    .field("sts", &self.sts())
                    .field("master", &self.master())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmr06 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmr06 {{ opirq: {=bool:?}, md: {:?}, cis: {:?}, sts: {:?}, master: {:?}, ccs: {:?}, cks: {:?} }}" , self . opirq () , self . md () , self . cis () , self . sts () , self . master () , self . ccs () , self . cks ())
            }
        }
        #[doc = "Timer Mode Register 07"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmr07(pub u16);
        impl Tmr07 {
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub const fn opirq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting of Starting Count and Interrupt"]
            #[inline(always)]
            pub fn set_opirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Tmr07Md {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Tmr07Md::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Mode at Channel n"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Tmr07Md) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u16) & 0x07) << 1usize);
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub const fn cis(&self) -> super::vals::Tmr07Cis {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tmr07Cis::from_bits(val as u8)
            }
            #[doc = "Selection of TI0n Pin Input Valid Edge"]
            #[inline(always)]
            pub fn set_cis(&mut self, val: super::vals::Tmr07Cis) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u16) & 0x03) << 6usize);
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Tmr07Sts {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tmr07Sts::from_bits(val as u8)
            }
            #[doc = "Setting of Start Trigger or Capture Trigger of Channel n"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Tmr07Sts) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u16) & 0x07) << 8usize);
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub const fn ccs(&self) -> super::vals::Tmr07Ccs {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Tmr07Ccs::from_bits(val as u8)
            }
            #[doc = "Selection of Counter Clock (fTCLK) of Channel n"]
            #[inline(always)]
            pub fn set_ccs(&mut self, val: super::vals::Tmr07Ccs) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Tmr07Cks {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Tmr07Cks::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (fMCK) of Channel n"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Tmr07Cks) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Tmr07 {
            #[inline(always)]
            fn default() -> Tmr07 {
                Tmr07(0)
            }
        }
        impl core::fmt::Debug for Tmr07 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmr07")
                    .field("opirq", &self.opirq())
                    .field("md", &self.md())
                    .field("cis", &self.cis())
                    .field("sts", &self.sts())
                    .field("ccs", &self.ccs())
                    .field("cks", &self.cks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmr07 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmr07 {{ opirq: {=bool:?}, md: {:?}, cis: {:?}, sts: {:?}, ccs: {:?}, cks: {:?} }}" , self . opirq () , self . md () , self . cis () , self . sts () , self . ccs () , self . cks ())
            }
        }
        #[doc = "Timer Output Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct To0(pub u16);
        impl To0 {
            #[doc = "Timer Output of Channel n"]
            #[inline(always)]
            pub const fn to(&self) -> super::vals::To {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::To::from_bits(val as u8)
            }
            #[doc = "Timer Output of Channel n"]
            #[inline(always)]
            pub fn set_to(&mut self, val: super::vals::To) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
        }
        impl Default for To0 {
            #[inline(always)]
            fn default() -> To0 {
                To0(0)
            }
        }
        impl core::fmt::Debug for To0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("To0").field("to", &self.to()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for To0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "To0 {{ to: {:?} }}", self.to())
            }
        }
        #[doc = "Timer Output Enable Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Toe0(pub u16);
        impl Toe0 {
            #[doc = "Enabling or Disabling Timer Output for Channel n"]
            #[inline(always)]
            pub const fn toe(&self) -> super::vals::Toe {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Toe::from_bits(val as u8)
            }
            #[doc = "Enabling or Disabling Timer Output for Channel n"]
            #[inline(always)]
            pub fn set_toe(&mut self, val: super::vals::Toe) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
        }
        impl Default for Toe0 {
            #[inline(always)]
            fn default() -> Toe0 {
                Toe0(0)
            }
        }
        impl core::fmt::Debug for Toe0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Toe0").field("toe", &self.toe()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Toe0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Toe0 {{ toe: {:?} }}", self.toe())
            }
        }
        #[doc = "Timer Output Level Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tol0(pub u16);
        impl Tol0 {
            #[doc = "Control of Timer Output of Channel n"]
            #[inline(always)]
            pub const fn tol(&self) -> super::vals::Tol {
                let val = (self.0 >> 1usize) & 0x7f;
                super::vals::Tol::from_bits(val as u8)
            }
            #[doc = "Control of Timer Output of Channel n"]
            #[inline(always)]
            pub fn set_tol(&mut self, val: super::vals::Tol) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val.to_bits() as u16) & 0x7f) << 1usize);
            }
        }
        impl Default for Tol0 {
            #[inline(always)]
            fn default() -> Tol0 {
                Tol0(0)
            }
        }
        impl core::fmt::Debug for Tol0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tol0").field("tol", &self.tol()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tol0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tol0 {{ tol: {:?} }}", self.tol())
            }
        }
        #[doc = "Timer Output Mode Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tom0(pub u16);
        impl Tom0 {
            #[doc = "Control of Timer Output Mode of Channel n"]
            #[inline(always)]
            pub const fn tom(&self) -> super::vals::Tom {
                let val = (self.0 >> 1usize) & 0x7f;
                super::vals::Tom::from_bits(val as u8)
            }
            #[doc = "Control of Timer Output Mode of Channel n"]
            #[inline(always)]
            pub fn set_tom(&mut self, val: super::vals::Tom) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val.to_bits() as u16) & 0x7f) << 1usize);
            }
        }
        impl Default for Tom0 {
            #[inline(always)]
            fn default() -> Tom0 {
                Tom0(0)
            }
        }
        impl core::fmt::Debug for Tom0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tom0").field("tom", &self.tom()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tom0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tom0 {{ tom: {:?} }}", self.tom())
            }
        }
        #[doc = "Timer Clock Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tps0(pub u16);
        impl Tps0 {
            #[doc = "Selection of Operation Clock (CK00)"]
            #[inline(always)]
            pub const fn prs0(&self) -> super::vals::Prs0 {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Prs0::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (CK00)"]
            #[inline(always)]
            pub fn set_prs0(&mut self, val: super::vals::Prs0) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
            #[doc = "Selection of Operation Clock (CK01)"]
            #[inline(always)]
            pub const fn prs1(&self) -> super::vals::Prs1 {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Prs1::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (CK01)"]
            #[inline(always)]
            pub fn set_prs1(&mut self, val: super::vals::Prs1) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u16) & 0x0f) << 4usize);
            }
            #[doc = "Selection of Operation Clock (CK02)"]
            #[inline(always)]
            pub const fn prs2(&self) -> super::vals::Prs2 {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Prs2::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (CK02)"]
            #[inline(always)]
            pub fn set_prs2(&mut self, val: super::vals::Prs2) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Selection of Operation Clock (CK03)"]
            #[inline(always)]
            pub const fn prs3(&self) -> super::vals::Prs3 {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Prs3::from_bits(val as u8)
            }
            #[doc = "Selection of Operation Clock (CK03)"]
            #[inline(always)]
            pub fn set_prs3(&mut self, val: super::vals::Prs3) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
        }
        impl Default for Tps0 {
            #[inline(always)]
            fn default() -> Tps0 {
                Tps0(0)
            }
        }
        impl core::fmt::Debug for Tps0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tps0")
                    .field("prs0", &self.prs0())
                    .field("prs1", &self.prs1())
                    .field("prs2", &self.prs2())
                    .field("prs3", &self.prs3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tps0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tps0 {{ prs0: {:?}, prs1: {:?}, prs2: {:?}, prs3: {:?} }}",
                    self.prs0(),
                    self.prs1(),
                    self.prs2(),
                    self.prs3()
                )
            }
        }
        #[doc = "Timer Channel Start Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ts0(pub u16);
        impl Ts0 {
            #[doc = "Operation Enable (Start) Trigger of Channel n"]
            #[inline(always)]
            pub const fn ts(&self) -> super::vals::Ts {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Ts::from_bits(val as u8)
            }
            #[doc = "Operation Enable (Start) Trigger of Channel n"]
            #[inline(always)]
            pub fn set_ts(&mut self, val: super::vals::Ts) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "Trigger to Enable Operation (Start Operation) of the Higher 8-bit Timer when Channel 1 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub const fn tsh1(&self) -> super::vals::Tsh1 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Tsh1::from_bits(val as u8)
            }
            #[doc = "Trigger to Enable Operation (Start Operation) of the Higher 8-bit Timer when Channel 1 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub fn set_tsh1(&mut self, val: super::vals::Tsh1) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Trigger to Enable Operation (Start Operation) of the Higher 8-bit Timer when Channel 3 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub const fn tsh3(&self) -> super::vals::Tsh3 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tsh3::from_bits(val as u8)
            }
            #[doc = "Trigger to Enable Operation (Start Operation) of the Higher 8-bit Timer when Channel 3 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub fn set_tsh3(&mut self, val: super::vals::Tsh3) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
        }
        impl Default for Ts0 {
            #[inline(always)]
            fn default() -> Ts0 {
                Ts0(0)
            }
        }
        impl core::fmt::Debug for Ts0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ts0")
                    .field("ts", &self.ts())
                    .field("tsh1", &self.tsh1())
                    .field("tsh3", &self.tsh3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ts0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ts0 {{ ts: {:?}, tsh1: {:?}, tsh3: {:?} }}",
                    self.ts(),
                    self.tsh1(),
                    self.tsh3()
                )
            }
        }
        #[doc = "Timer Status Register 0%s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tsr0(pub u16);
        impl Tsr0 {
            #[doc = "Counter Overflow State of Channel n"]
            #[inline(always)]
            pub const fn ovf(&self) -> super::vals::Ovf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ovf::from_bits(val as u8)
            }
            #[doc = "Counter Overflow State of Channel n"]
            #[inline(always)]
            pub fn set_ovf(&mut self, val: super::vals::Ovf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Tsr0 {
            #[inline(always)]
            fn default() -> Tsr0 {
                Tsr0(0)
            }
        }
        impl core::fmt::Debug for Tsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tsr0").field("ovf", &self.ovf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tsr0 {{ ovf: {:?} }}", self.ovf())
            }
        }
        #[doc = "Timer Channel Stop Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tt0(pub u16);
        impl Tt0 {
            #[doc = "Operation Stop Trigger of Channel n"]
            #[inline(always)]
            pub const fn tt(&self) -> super::vals::Tt {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Tt::from_bits(val as u8)
            }
            #[doc = "Operation Stop Trigger of Channel n"]
            #[inline(always)]
            pub fn set_tt(&mut self, val: super::vals::Tt) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "Trigger to Stop Operation of the Higher 8-bit Timer when Channel 1 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub const fn tth1(&self) -> super::vals::Tth1 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Tth1::from_bits(val as u8)
            }
            #[doc = "Trigger to Stop Operation of the Higher 8-bit Timer when Channel 1 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub fn set_tth1(&mut self, val: super::vals::Tth1) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Trigger to Stop Operation of the Higher 8-bit Timer when Channel 3 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub const fn tth3(&self) -> super::vals::Tth3 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tth3::from_bits(val as u8)
            }
            #[doc = "Trigger to Stop Operation of the Higher 8-bit Timer when Channel 3 is in the 8-bit Timer Mode"]
            #[inline(always)]
            pub fn set_tth3(&mut self, val: super::vals::Tth3) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
        }
        impl Default for Tt0 {
            #[inline(always)]
            fn default() -> Tt0 {
                Tt0(0)
            }
        }
        impl core::fmt::Debug for Tt0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tt0")
                    .field("tt", &self.tt())
                    .field("tth1", &self.tth1())
                    .field("tth3", &self.tth3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tt0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tt0 {{ tt: {:?}, tth1: {:?}, tth3: {:?} }}",
                    self.tt(),
                    self.tth1(),
                    self.tth3()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovf {
            #[inline(always)]
            fn from(val: u8) -> Ovf {
                Ovf::from_bits(val)
            }
        }
        impl From<Ovf> for u8 {
            #[inline(always)]
            fn from(val: Ovf) -> u8 {
                Ovf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prs0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Prs0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prs0 {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prs0 {
            #[inline(always)]
            fn from(val: u8) -> Prs0 {
                Prs0::from_bits(val)
            }
        }
        impl From<Prs0> for u8 {
            #[inline(always)]
            fn from(val: Prs0) -> u8 {
                Prs0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prs1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Prs1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prs1 {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prs1 {
            #[inline(always)]
            fn from(val: u8) -> Prs1 {
                Prs1::from_bits(val)
            }
        }
        impl From<Prs1> for u8 {
            #[inline(always)]
            fn from(val: Prs1) -> u8 {
                Prs1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prs2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Prs2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prs2 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prs2 {
            #[inline(always)]
            fn from(val: u8) -> Prs2 {
                Prs2::from_bits(val)
            }
        }
        impl From<Prs2> for u8 {
            #[inline(always)]
            fn from(val: Prs2) -> u8 {
                Prs2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prs3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Prs3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prs3 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prs3 {
            #[inline(always)]
            fn from(val: u8) -> Prs3 {
                Prs3::from_bits(val)
            }
        }
        impl From<Prs3> for u8 {
            #[inline(always)]
            fn from(val: Prs3) -> u8 {
                Prs3::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Te(u8);
        impl Te {}
        impl Te {
            pub const fn from_bits(val: u8) -> Te {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Te {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Te {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Te {
            #[inline(always)]
            fn from(val: u8) -> Te {
                Te::from_bits(val)
            }
        }
        impl From<Te> for u8 {
            #[inline(always)]
            fn from(val: Te) -> u8 {
                Te::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teh1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teh1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teh1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teh1 {
            #[inline(always)]
            fn from(val: u8) -> Teh1 {
                Teh1::from_bits(val)
            }
        }
        impl From<Teh1> for u8 {
            #[inline(always)]
            fn from(val: Teh1) -> u8 {
                Teh1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teh3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teh3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teh3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teh3 {
            #[inline(always)]
            fn from(val: u8) -> Teh3 {
                Teh3::from_bits(val)
            }
        }
        impl From<Teh3> for u8 {
            #[inline(always)]
            fn from(val: Teh3) -> u8 {
                Teh3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr00Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr00Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr00Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr00Ccs {
            #[inline(always)]
            fn from(val: u8) -> Tmr00Ccs {
                Tmr00Ccs::from_bits(val)
            }
        }
        impl From<Tmr00Ccs> for u8 {
            #[inline(always)]
            fn from(val: Tmr00Ccs) -> u8 {
                Tmr00Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr00Cis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr00Cis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr00Cis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr00Cis {
            #[inline(always)]
            fn from(val: u8) -> Tmr00Cis {
                Tmr00Cis::from_bits(val)
            }
        }
        impl From<Tmr00Cis> for u8 {
            #[inline(always)]
            fn from(val: Tmr00Cis) -> u8 {
                Tmr00Cis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr00Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr00Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr00Cks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr00Cks {
            #[inline(always)]
            fn from(val: u8) -> Tmr00Cks {
                Tmr00Cks::from_bits(val)
            }
        }
        impl From<Tmr00Cks> for u8 {
            #[inline(always)]
            fn from(val: Tmr00Cks) -> u8 {
                Tmr00Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr00Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr00Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr00Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr00Md {
            #[inline(always)]
            fn from(val: u8) -> Tmr00Md {
                Tmr00Md::from_bits(val)
            }
        }
        impl From<Tmr00Md> for u8 {
            #[inline(always)]
            fn from(val: Tmr00Md) -> u8 {
                Tmr00Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr00Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr00Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr00Sts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr00Sts {
            #[inline(always)]
            fn from(val: u8) -> Tmr00Sts {
                Tmr00Sts::from_bits(val)
            }
        }
        impl From<Tmr00Sts> for u8 {
            #[inline(always)]
            fn from(val: Tmr00Sts) -> u8 {
                Tmr00Sts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr01Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr01Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr01Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr01Ccs {
            #[inline(always)]
            fn from(val: u8) -> Tmr01Ccs {
                Tmr01Ccs::from_bits(val)
            }
        }
        impl From<Tmr01Ccs> for u8 {
            #[inline(always)]
            fn from(val: Tmr01Ccs) -> u8 {
                Tmr01Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr01Cis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr01Cis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr01Cis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr01Cis {
            #[inline(always)]
            fn from(val: u8) -> Tmr01Cis {
                Tmr01Cis::from_bits(val)
            }
        }
        impl From<Tmr01Cis> for u8 {
            #[inline(always)]
            fn from(val: Tmr01Cis) -> u8 {
                Tmr01Cis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr01Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr01Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr01Cks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr01Cks {
            #[inline(always)]
            fn from(val: u8) -> Tmr01Cks {
                Tmr01Cks::from_bits(val)
            }
        }
        impl From<Tmr01Cks> for u8 {
            #[inline(always)]
            fn from(val: Tmr01Cks) -> u8 {
                Tmr01Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr01Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr01Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr01Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr01Md {
            #[inline(always)]
            fn from(val: u8) -> Tmr01Md {
                Tmr01Md::from_bits(val)
            }
        }
        impl From<Tmr01Md> for u8 {
            #[inline(always)]
            fn from(val: Tmr01Md) -> u8 {
                Tmr01Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr01Split {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr01Split {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr01Split {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr01Split {
            #[inline(always)]
            fn from(val: u8) -> Tmr01Split {
                Tmr01Split::from_bits(val)
            }
        }
        impl From<Tmr01Split> for u8 {
            #[inline(always)]
            fn from(val: Tmr01Split) -> u8 {
                Tmr01Split::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr01Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr01Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr01Sts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr01Sts {
            #[inline(always)]
            fn from(val: u8) -> Tmr01Sts {
                Tmr01Sts::from_bits(val)
            }
        }
        impl From<Tmr01Sts> for u8 {
            #[inline(always)]
            fn from(val: Tmr01Sts) -> u8 {
                Tmr01Sts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr02Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr02Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr02Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr02Ccs {
            #[inline(always)]
            fn from(val: u8) -> Tmr02Ccs {
                Tmr02Ccs::from_bits(val)
            }
        }
        impl From<Tmr02Ccs> for u8 {
            #[inline(always)]
            fn from(val: Tmr02Ccs) -> u8 {
                Tmr02Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr02Cis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr02Cis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr02Cis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr02Cis {
            #[inline(always)]
            fn from(val: u8) -> Tmr02Cis {
                Tmr02Cis::from_bits(val)
            }
        }
        impl From<Tmr02Cis> for u8 {
            #[inline(always)]
            fn from(val: Tmr02Cis) -> u8 {
                Tmr02Cis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr02Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr02Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr02Cks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr02Cks {
            #[inline(always)]
            fn from(val: u8) -> Tmr02Cks {
                Tmr02Cks::from_bits(val)
            }
        }
        impl From<Tmr02Cks> for u8 {
            #[inline(always)]
            fn from(val: Tmr02Cks) -> u8 {
                Tmr02Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr02Master {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr02Master {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr02Master {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr02Master {
            #[inline(always)]
            fn from(val: u8) -> Tmr02Master {
                Tmr02Master::from_bits(val)
            }
        }
        impl From<Tmr02Master> for u8 {
            #[inline(always)]
            fn from(val: Tmr02Master) -> u8 {
                Tmr02Master::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr02Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr02Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr02Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr02Md {
            #[inline(always)]
            fn from(val: u8) -> Tmr02Md {
                Tmr02Md::from_bits(val)
            }
        }
        impl From<Tmr02Md> for u8 {
            #[inline(always)]
            fn from(val: Tmr02Md) -> u8 {
                Tmr02Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr02Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr02Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr02Sts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr02Sts {
            #[inline(always)]
            fn from(val: u8) -> Tmr02Sts {
                Tmr02Sts::from_bits(val)
            }
        }
        impl From<Tmr02Sts> for u8 {
            #[inline(always)]
            fn from(val: Tmr02Sts) -> u8 {
                Tmr02Sts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr03Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr03Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr03Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr03Ccs {
            #[inline(always)]
            fn from(val: u8) -> Tmr03Ccs {
                Tmr03Ccs::from_bits(val)
            }
        }
        impl From<Tmr03Ccs> for u8 {
            #[inline(always)]
            fn from(val: Tmr03Ccs) -> u8 {
                Tmr03Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr03Cis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr03Cis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr03Cis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr03Cis {
            #[inline(always)]
            fn from(val: u8) -> Tmr03Cis {
                Tmr03Cis::from_bits(val)
            }
        }
        impl From<Tmr03Cis> for u8 {
            #[inline(always)]
            fn from(val: Tmr03Cis) -> u8 {
                Tmr03Cis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr03Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr03Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr03Cks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr03Cks {
            #[inline(always)]
            fn from(val: u8) -> Tmr03Cks {
                Tmr03Cks::from_bits(val)
            }
        }
        impl From<Tmr03Cks> for u8 {
            #[inline(always)]
            fn from(val: Tmr03Cks) -> u8 {
                Tmr03Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr03Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr03Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr03Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr03Md {
            #[inline(always)]
            fn from(val: u8) -> Tmr03Md {
                Tmr03Md::from_bits(val)
            }
        }
        impl From<Tmr03Md> for u8 {
            #[inline(always)]
            fn from(val: Tmr03Md) -> u8 {
                Tmr03Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr03Split {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr03Split {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr03Split {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr03Split {
            #[inline(always)]
            fn from(val: u8) -> Tmr03Split {
                Tmr03Split::from_bits(val)
            }
        }
        impl From<Tmr03Split> for u8 {
            #[inline(always)]
            fn from(val: Tmr03Split) -> u8 {
                Tmr03Split::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr03Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr03Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr03Sts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr03Sts {
            #[inline(always)]
            fn from(val: u8) -> Tmr03Sts {
                Tmr03Sts::from_bits(val)
            }
        }
        impl From<Tmr03Sts> for u8 {
            #[inline(always)]
            fn from(val: Tmr03Sts) -> u8 {
                Tmr03Sts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr04Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr04Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr04Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr04Ccs {
            #[inline(always)]
            fn from(val: u8) -> Tmr04Ccs {
                Tmr04Ccs::from_bits(val)
            }
        }
        impl From<Tmr04Ccs> for u8 {
            #[inline(always)]
            fn from(val: Tmr04Ccs) -> u8 {
                Tmr04Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr04Cis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr04Cis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr04Cis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr04Cis {
            #[inline(always)]
            fn from(val: u8) -> Tmr04Cis {
                Tmr04Cis::from_bits(val)
            }
        }
        impl From<Tmr04Cis> for u8 {
            #[inline(always)]
            fn from(val: Tmr04Cis) -> u8 {
                Tmr04Cis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr04Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr04Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr04Cks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr04Cks {
            #[inline(always)]
            fn from(val: u8) -> Tmr04Cks {
                Tmr04Cks::from_bits(val)
            }
        }
        impl From<Tmr04Cks> for u8 {
            #[inline(always)]
            fn from(val: Tmr04Cks) -> u8 {
                Tmr04Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr04Master {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr04Master {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr04Master {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr04Master {
            #[inline(always)]
            fn from(val: u8) -> Tmr04Master {
                Tmr04Master::from_bits(val)
            }
        }
        impl From<Tmr04Master> for u8 {
            #[inline(always)]
            fn from(val: Tmr04Master) -> u8 {
                Tmr04Master::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr04Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr04Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr04Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr04Md {
            #[inline(always)]
            fn from(val: u8) -> Tmr04Md {
                Tmr04Md::from_bits(val)
            }
        }
        impl From<Tmr04Md> for u8 {
            #[inline(always)]
            fn from(val: Tmr04Md) -> u8 {
                Tmr04Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr04Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr04Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr04Sts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr04Sts {
            #[inline(always)]
            fn from(val: u8) -> Tmr04Sts {
                Tmr04Sts::from_bits(val)
            }
        }
        impl From<Tmr04Sts> for u8 {
            #[inline(always)]
            fn from(val: Tmr04Sts) -> u8 {
                Tmr04Sts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr05Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr05Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr05Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr05Ccs {
            #[inline(always)]
            fn from(val: u8) -> Tmr05Ccs {
                Tmr05Ccs::from_bits(val)
            }
        }
        impl From<Tmr05Ccs> for u8 {
            #[inline(always)]
            fn from(val: Tmr05Ccs) -> u8 {
                Tmr05Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr05Cis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr05Cis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr05Cis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr05Cis {
            #[inline(always)]
            fn from(val: u8) -> Tmr05Cis {
                Tmr05Cis::from_bits(val)
            }
        }
        impl From<Tmr05Cis> for u8 {
            #[inline(always)]
            fn from(val: Tmr05Cis) -> u8 {
                Tmr05Cis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr05Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr05Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr05Cks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr05Cks {
            #[inline(always)]
            fn from(val: u8) -> Tmr05Cks {
                Tmr05Cks::from_bits(val)
            }
        }
        impl From<Tmr05Cks> for u8 {
            #[inline(always)]
            fn from(val: Tmr05Cks) -> u8 {
                Tmr05Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr05Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr05Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr05Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr05Md {
            #[inline(always)]
            fn from(val: u8) -> Tmr05Md {
                Tmr05Md::from_bits(val)
            }
        }
        impl From<Tmr05Md> for u8 {
            #[inline(always)]
            fn from(val: Tmr05Md) -> u8 {
                Tmr05Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr05Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr05Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr05Sts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr05Sts {
            #[inline(always)]
            fn from(val: u8) -> Tmr05Sts {
                Tmr05Sts::from_bits(val)
            }
        }
        impl From<Tmr05Sts> for u8 {
            #[inline(always)]
            fn from(val: Tmr05Sts) -> u8 {
                Tmr05Sts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr06Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr06Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr06Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr06Ccs {
            #[inline(always)]
            fn from(val: u8) -> Tmr06Ccs {
                Tmr06Ccs::from_bits(val)
            }
        }
        impl From<Tmr06Ccs> for u8 {
            #[inline(always)]
            fn from(val: Tmr06Ccs) -> u8 {
                Tmr06Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr06Cis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr06Cis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr06Cis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr06Cis {
            #[inline(always)]
            fn from(val: u8) -> Tmr06Cis {
                Tmr06Cis::from_bits(val)
            }
        }
        impl From<Tmr06Cis> for u8 {
            #[inline(always)]
            fn from(val: Tmr06Cis) -> u8 {
                Tmr06Cis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr06Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr06Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr06Cks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr06Cks {
            #[inline(always)]
            fn from(val: u8) -> Tmr06Cks {
                Tmr06Cks::from_bits(val)
            }
        }
        impl From<Tmr06Cks> for u8 {
            #[inline(always)]
            fn from(val: Tmr06Cks) -> u8 {
                Tmr06Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr06Master {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr06Master {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr06Master {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr06Master {
            #[inline(always)]
            fn from(val: u8) -> Tmr06Master {
                Tmr06Master::from_bits(val)
            }
        }
        impl From<Tmr06Master> for u8 {
            #[inline(always)]
            fn from(val: Tmr06Master) -> u8 {
                Tmr06Master::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr06Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr06Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr06Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr06Md {
            #[inline(always)]
            fn from(val: u8) -> Tmr06Md {
                Tmr06Md::from_bits(val)
            }
        }
        impl From<Tmr06Md> for u8 {
            #[inline(always)]
            fn from(val: Tmr06Md) -> u8 {
                Tmr06Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr06Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr06Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr06Sts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr06Sts {
            #[inline(always)]
            fn from(val: u8) -> Tmr06Sts {
                Tmr06Sts::from_bits(val)
            }
        }
        impl From<Tmr06Sts> for u8 {
            #[inline(always)]
            fn from(val: Tmr06Sts) -> u8 {
                Tmr06Sts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr07Ccs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmr07Ccs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr07Ccs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr07Ccs {
            #[inline(always)]
            fn from(val: u8) -> Tmr07Ccs {
                Tmr07Ccs::from_bits(val)
            }
        }
        impl From<Tmr07Ccs> for u8 {
            #[inline(always)]
            fn from(val: Tmr07Ccs) -> u8 {
                Tmr07Ccs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr07Cis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr07Cis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr07Cis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr07Cis {
            #[inline(always)]
            fn from(val: u8) -> Tmr07Cis {
                Tmr07Cis::from_bits(val)
            }
        }
        impl From<Tmr07Cis> for u8 {
            #[inline(always)]
            fn from(val: Tmr07Cis) -> u8 {
                Tmr07Cis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr07Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tmr07Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr07Cks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr07Cks {
            #[inline(always)]
            fn from(val: u8) -> Tmr07Cks {
                Tmr07Cks::from_bits(val)
            }
        }
        impl From<Tmr07Cks> for u8 {
            #[inline(always)]
            fn from(val: Tmr07Cks) -> u8 {
                Tmr07Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr07Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr07Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr07Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr07Md {
            #[inline(always)]
            fn from(val: u8) -> Tmr07Md {
                Tmr07Md::from_bits(val)
            }
        }
        impl From<Tmr07Md> for u8 {
            #[inline(always)]
            fn from(val: Tmr07Md) -> u8 {
                Tmr07Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmr07Sts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmr07Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmr07Sts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmr07Sts {
            #[inline(always)]
            fn from(val: u8) -> Tmr07Sts {
                Tmr07Sts::from_bits(val)
            }
        }
        impl From<Tmr07Sts> for u8 {
            #[inline(always)]
            fn from(val: Tmr07Sts) -> u8 {
                Tmr07Sts::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct To(u8);
        impl To {}
        impl To {
            pub const fn from_bits(val: u8) -> To {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for To {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for To {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for To {
            #[inline(always)]
            fn from(val: u8) -> To {
                To::from_bits(val)
            }
        }
        impl From<To> for u8 {
            #[inline(always)]
            fn from(val: To) -> u8 {
                To::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Toe(u8);
        impl Toe {}
        impl Toe {
            pub const fn from_bits(val: u8) -> Toe {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Toe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Toe {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Toe {
            #[inline(always)]
            fn from(val: u8) -> Toe {
                Toe::from_bits(val)
            }
        }
        impl From<Toe> for u8 {
            #[inline(always)]
            fn from(val: Toe) -> u8 {
                Toe::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Tol(u8);
        impl Tol {}
        impl Tol {
            pub const fn from_bits(val: u8) -> Tol {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Tol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tol {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Tol {
            #[inline(always)]
            fn from(val: u8) -> Tol {
                Tol::from_bits(val)
            }
        }
        impl From<Tol> for u8 {
            #[inline(always)]
            fn from(val: Tol) -> u8 {
                Tol::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Tom(u8);
        impl Tom {}
        impl Tom {
            pub const fn from_bits(val: u8) -> Tom {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Tom {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tom {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Tom {
            #[inline(always)]
            fn from(val: u8) -> Tom {
                Tom::from_bits(val)
            }
        }
        impl From<Tom> for u8 {
            #[inline(always)]
            fn from(val: Tom) -> u8 {
                Tom::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ts(u8);
        impl Ts {}
        impl Ts {
            pub const fn from_bits(val: u8) -> Ts {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ts {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ts {
            #[inline(always)]
            fn from(val: u8) -> Ts {
                Ts::from_bits(val)
            }
        }
        impl From<Ts> for u8 {
            #[inline(always)]
            fn from(val: Ts) -> u8 {
                Ts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsh1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tsh1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsh1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsh1 {
            #[inline(always)]
            fn from(val: u8) -> Tsh1 {
                Tsh1::from_bits(val)
            }
        }
        impl From<Tsh1> for u8 {
            #[inline(always)]
            fn from(val: Tsh1) -> u8 {
                Tsh1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsh3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tsh3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsh3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsh3 {
            #[inline(always)]
            fn from(val: u8) -> Tsh3 {
                Tsh3::from_bits(val)
            }
        }
        impl From<Tsh3> for u8 {
            #[inline(always)]
            fn from(val: Tsh3) -> u8 {
                Tsh3::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Tt(u8);
        impl Tt {}
        impl Tt {
            pub const fn from_bits(val: u8) -> Tt {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Tt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Tt {
            #[inline(always)]
            fn from(val: u8) -> Tt {
                Tt::from_bits(val)
            }
        }
        impl From<Tt> for u8 {
            #[inline(always)]
            fn from(val: Tt) -> u8 {
                Tt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tth1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tth1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tth1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tth1 {
            #[inline(always)]
            fn from(val: u8) -> Tth1 {
                Tth1::from_bits(val)
            }
        }
        impl From<Tth1> for u8 {
            #[inline(always)]
            fn from(val: Tth1) -> u8 {
                Tth1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tth3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tth3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tth3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tth3 {
            #[inline(always)]
            fn from(val: u8) -> Tth3 {
                Tth3::from_bits(val)
            }
        }
        impl From<Tth3> for u8 {
            #[inline(always)]
            fn from(val: Tth3) -> u8 {
                Tth3::to_bits(val)
            }
        }
    }
}
pub mod tml32 {
    #[doc = "32-bit Interval Timer"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tml32 {
        ptr: *mut u8,
    }
    unsafe impl Send for Tml32 {}
    unsafe impl Sync for Tml32 {}
    impl Tml32 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Interval Timer Compare Registers 0%s"]
        #[inline(always)]
        pub const fn itlcmp0(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 2usize) as _) }
        }
        #[doc = "Interval Timer Compare Registers 0%s"]
        #[inline(always)]
        pub const fn itlcmp0_l(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 2usize) as _) }
        }
        #[doc = "Interval Timer Compare Registers 0%s"]
        #[inline(always)]
        pub const fn itlcmp0_h(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize + n * 2usize) as _) }
        }
        #[doc = "Interval Timer Capture Register 00"]
        #[inline(always)]
        pub const fn itlcap00(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Interval Timer Control Register"]
        #[inline(always)]
        pub const fn itlctl0(self) -> crate::common::Reg<regs::Itlctl0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Interval Timer Clock Select Register 0"]
        #[inline(always)]
        pub const fn itlcsel0(self) -> crate::common::Reg<regs::Itlcsel0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Interval Timer Frequency Division Register 0"]
        #[inline(always)]
        pub const fn itlfdiv00(self) -> crate::common::Reg<regs::Itlfdiv00, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Interval Timer Frequency Division Register 1"]
        #[inline(always)]
        pub const fn itlfdiv01(self) -> crate::common::Reg<regs::Itlfdiv01, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "Interval Timer Capture Control Register 0"]
        #[inline(always)]
        pub const fn itlcc0(self) -> crate::common::Reg<regs::Itlcc0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Interval Timer Status Register"]
        #[inline(always)]
        pub const fn itls0(self) -> crate::common::Reg<regs::Itls0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "Interval Timer Match Detection Mask Register"]
        #[inline(always)]
        pub const fn itlmkf0(self) -> crate::common::Reg<regs::Itlmkf0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Interval Timer Capture Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itlcc0(pub u8);
        impl Itlcc0 {
            #[doc = "Selection of Capture Trigger"]
            #[inline(always)]
            pub const fn ctrs(&self) -> super::vals::Ctrs {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Ctrs::from_bits(val as u8)
            }
            #[doc = "Selection of Capture Trigger"]
            #[inline(always)]
            pub fn set_ctrs(&mut self, val: super::vals::Ctrs) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Selection of Capture Counter Clearing After Capturing"]
            #[inline(always)]
            pub const fn capccr(&self) -> super::vals::Capccr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Capccr::from_bits(val as u8)
            }
            #[doc = "Selection of Capture Counter Clearing After Capturing"]
            #[inline(always)]
            pub fn set_capccr(&mut self, val: super::vals::Capccr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Software Capture Trigger"]
            #[inline(always)]
            pub const fn capr(&self) -> super::vals::Capr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Capr::from_bits(val as u8)
            }
            #[doc = "Software Capture Trigger"]
            #[inline(always)]
            pub fn set_capr(&mut self, val: super::vals::Capr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Capture Completion Flag"]
            #[inline(always)]
            pub const fn capf(&self) -> super::vals::Capf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Capf::from_bits(val as u8)
            }
            #[doc = "Capture Completion Flag"]
            #[inline(always)]
            pub fn set_capf(&mut self, val: super::vals::Capf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Capture Completion Flag Clear"]
            #[inline(always)]
            pub const fn capfcr(&self) -> super::vals::Capfcr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Capfcr::from_bits(val as u8)
            }
            #[doc = "Capture Completion Flag Clear"]
            #[inline(always)]
            pub fn set_capfcr(&mut self, val: super::vals::Capfcr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Capture Enable"]
            #[inline(always)]
            pub const fn capen(&self) -> super::vals::Capen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Capen::from_bits(val as u8)
            }
            #[doc = "Capture Enable"]
            #[inline(always)]
            pub fn set_capen(&mut self, val: super::vals::Capen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Itlcc0 {
            #[inline(always)]
            fn default() -> Itlcc0 {
                Itlcc0(0)
            }
        }
        impl core::fmt::Debug for Itlcc0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itlcc0")
                    .field("ctrs", &self.ctrs())
                    .field("capccr", &self.capccr())
                    .field("capr", &self.capr())
                    .field("capf", &self.capf())
                    .field("capfcr", &self.capfcr())
                    .field("capen", &self.capen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itlcc0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Itlcc0 {{ ctrs: {:?}, capccr: {:?}, capr: {:?}, capf: {:?}, capfcr: {:?}, capen: {:?} }}" , self . ctrs () , self . capccr () , self . capr () , self . capf () , self . capfcr () , self . capen ())
            }
        }
        #[doc = "Interval Timer Clock Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itlcsel0(pub u8);
        impl Itlcsel0 {
            #[doc = "Selection of Interval Timer Count Clock (fITL0)"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::Isel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Isel::from_bits(val as u8)
            }
            #[doc = "Selection of Interval Timer Count Clock (fITL0)"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::Isel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Selection of Interval Timer Count Clock for Capturing (fITL1)"]
            #[inline(always)]
            pub const fn csel(&self) -> super::vals::Csel {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Csel::from_bits(val as u8)
            }
            #[doc = "Selection of Interval Timer Count Clock for Capturing (fITL1)"]
            #[inline(always)]
            pub fn set_csel(&mut self, val: super::vals::Csel) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Itlcsel0 {
            #[inline(always)]
            fn default() -> Itlcsel0 {
                Itlcsel0(0)
            }
        }
        impl core::fmt::Debug for Itlcsel0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itlcsel0")
                    .field("isel", &self.isel())
                    .field("csel", &self.csel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itlcsel0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itlcsel0 {{ isel: {:?}, csel: {:?} }}",
                    self.isel(),
                    self.csel()
                )
            }
        }
        #[doc = "Interval Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itlctl0(pub u8);
        impl Itlctl0 {
            #[doc = "8-bit Counter Mode: ITL000 Count Enable"]
            #[inline(always)]
            pub const fn en0(&self) -> super::vals::En0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::En0::from_bits(val as u8)
            }
            #[doc = "8-bit Counter Mode: ITL000 Count Enable"]
            #[inline(always)]
            pub fn set_en0(&mut self, val: super::vals::En0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "8-bit Counter Mode: ITL001 Count Enable"]
            #[inline(always)]
            pub const fn en1(&self) -> super::vals::En1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::En1::from_bits(val as u8)
            }
            #[doc = "8-bit Counter Mode: ITL001 Count Enable"]
            #[inline(always)]
            pub fn set_en1(&mut self, val: super::vals::En1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "8-bit Counter Mode: ITL012 Count Enable"]
            #[inline(always)]
            pub const fn en2(&self) -> super::vals::En2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::En2::from_bits(val as u8)
            }
            #[doc = "8-bit Counter Mode: ITL012 Count Enable"]
            #[inline(always)]
            pub fn set_en2(&mut self, val: super::vals::En2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "8-bit Counter Mode: ITL013 Count Enable"]
            #[inline(always)]
            pub const fn en3(&self) -> super::vals::En3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::En3::from_bits(val as u8)
            }
            #[doc = "8-bit Counter Mode: ITL013 Count Enable"]
            #[inline(always)]
            pub fn set_en3(&mut self, val: super::vals::En3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Selection of 8-bit, 16-bit, or 32-bit Counter Mode"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Md {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Md::from_bits(val as u8)
            }
            #[doc = "Selection of 8-bit, 16-bit, or 32-bit Counter Mode"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Md) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Itlctl0 {
            #[inline(always)]
            fn default() -> Itlctl0 {
                Itlctl0(0)
            }
        }
        impl core::fmt::Debug for Itlctl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itlctl0")
                    .field("en0", &self.en0())
                    .field("en1", &self.en1())
                    .field("en2", &self.en2())
                    .field("en3", &self.en3())
                    .field("md", &self.md())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itlctl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itlctl0 {{ en0: {:?}, en1: {:?}, en2: {:?}, en3: {:?}, md: {:?} }}",
                    self.en0(),
                    self.en1(),
                    self.en2(),
                    self.en3(),
                    self.md()
                )
            }
        }
        #[doc = "Interval Timer Frequency Division Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itlfdiv00(pub u8);
        impl Itlfdiv00 {
            #[doc = "8-bit Counter Mode: Counter Clock for ITL000"]
            #[inline(always)]
            pub const fn fdiv0(&self) -> super::vals::Fdiv0 {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Fdiv0::from_bits(val as u8)
            }
            #[doc = "8-bit Counter Mode: Counter Clock for ITL000"]
            #[inline(always)]
            pub fn set_fdiv0(&mut self, val: super::vals::Fdiv0) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "8-bit Counter Mode: Counter Clock for ITL001"]
            #[inline(always)]
            pub const fn fdiv1(&self) -> super::vals::Fdiv1 {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Fdiv1::from_bits(val as u8)
            }
            #[doc = "8-bit Counter Mode: Counter Clock for ITL001"]
            #[inline(always)]
            pub fn set_fdiv1(&mut self, val: super::vals::Fdiv1) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Itlfdiv00 {
            #[inline(always)]
            fn default() -> Itlfdiv00 {
                Itlfdiv00(0)
            }
        }
        impl core::fmt::Debug for Itlfdiv00 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itlfdiv00")
                    .field("fdiv0", &self.fdiv0())
                    .field("fdiv1", &self.fdiv1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itlfdiv00 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itlfdiv00 {{ fdiv0: {:?}, fdiv1: {:?} }}",
                    self.fdiv0(),
                    self.fdiv1()
                )
            }
        }
        #[doc = "Interval Timer Frequency Division Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itlfdiv01(pub u8);
        impl Itlfdiv01 {
            #[doc = "8-bit Counter Mode: Counter Clock for ITL012"]
            #[inline(always)]
            pub const fn fdiv2(&self) -> super::vals::Fdiv2 {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Fdiv2::from_bits(val as u8)
            }
            #[doc = "8-bit Counter Mode: Counter Clock for ITL012"]
            #[inline(always)]
            pub fn set_fdiv2(&mut self, val: super::vals::Fdiv2) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "8-bit Counter Mode: Counter Clock for ITL013"]
            #[inline(always)]
            pub const fn fdiv3(&self) -> super::vals::Fdiv3 {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Fdiv3::from_bits(val as u8)
            }
            #[doc = "8-bit Counter Mode: Counter Clock for ITL013"]
            #[inline(always)]
            pub fn set_fdiv3(&mut self, val: super::vals::Fdiv3) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Itlfdiv01 {
            #[inline(always)]
            fn default() -> Itlfdiv01 {
                Itlfdiv01(0)
            }
        }
        impl core::fmt::Debug for Itlfdiv01 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itlfdiv01")
                    .field("fdiv2", &self.fdiv2())
                    .field("fdiv3", &self.fdiv3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itlfdiv01 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itlfdiv01 {{ fdiv2: {:?}, fdiv3: {:?} }}",
                    self.fdiv2(),
                    self.fdiv3()
                )
            }
        }
        #[doc = "Interval Timer Match Detection Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itlmkf0(pub u8);
        impl Itlmkf0 {
            #[doc = "Mask for Compare Match Status Flag for Channel 0"]
            #[inline(always)]
            pub const fn mkf00(&self) -> super::vals::Mkf00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mkf00::from_bits(val as u8)
            }
            #[doc = "Mask for Compare Match Status Flag for Channel 0"]
            #[inline(always)]
            pub fn set_mkf00(&mut self, val: super::vals::Mkf00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Mask for Compare Match Status Flag for Channel 1"]
            #[inline(always)]
            pub const fn mkf01(&self) -> super::vals::Mkf01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mkf01::from_bits(val as u8)
            }
            #[doc = "Mask for Compare Match Status Flag for Channel 1"]
            #[inline(always)]
            pub fn set_mkf01(&mut self, val: super::vals::Mkf01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Mask for Compare Match Status Flag for Channel 2"]
            #[inline(always)]
            pub const fn mkf02(&self) -> super::vals::Mkf02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mkf02::from_bits(val as u8)
            }
            #[doc = "Mask for Compare Match Status Flag for Channel 2"]
            #[inline(always)]
            pub fn set_mkf02(&mut self, val: super::vals::Mkf02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Mask for Compare Match Status Flag for Channel 3"]
            #[inline(always)]
            pub const fn mkf03(&self) -> super::vals::Mkf03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mkf03::from_bits(val as u8)
            }
            #[doc = "Mask for Compare Match Status Flag for Channel 3"]
            #[inline(always)]
            pub fn set_mkf03(&mut self, val: super::vals::Mkf03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Mask for Capture Detection Status Flag"]
            #[inline(always)]
            pub const fn mkf0c(&self) -> super::vals::Mkf0c {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mkf0c::from_bits(val as u8)
            }
            #[doc = "Mask for Capture Detection Status Flag"]
            #[inline(always)]
            pub fn set_mkf0c(&mut self, val: super::vals::Mkf0c) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Itlmkf0 {
            #[inline(always)]
            fn default() -> Itlmkf0 {
                Itlmkf0(0)
            }
        }
        impl core::fmt::Debug for Itlmkf0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itlmkf0")
                    .field("mkf00", &self.mkf00())
                    .field("mkf01", &self.mkf01())
                    .field("mkf02", &self.mkf02())
                    .field("mkf03", &self.mkf03())
                    .field("mkf0c", &self.mkf0c())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itlmkf0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itlmkf0 {{ mkf00: {:?}, mkf01: {:?}, mkf02: {:?}, mkf03: {:?}, mkf0c: {:?} }}",
                    self.mkf00(),
                    self.mkf01(),
                    self.mkf02(),
                    self.mkf03(),
                    self.mkf0c()
                )
            }
        }
        #[doc = "Interval Timer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itls0(pub u8);
        impl Itls0 {
            #[doc = "Compare Match Detection Flag for Channel 0"]
            #[inline(always)]
            pub const fn itf00(&self) -> super::vals::Itf00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Itf00::from_bits(val as u8)
            }
            #[doc = "Compare Match Detection Flag for Channel 0"]
            #[inline(always)]
            pub fn set_itf00(&mut self, val: super::vals::Itf00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Compare Match Detection Flag for Channel 1"]
            #[inline(always)]
            pub const fn itf01(&self) -> super::vals::Itf01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Itf01::from_bits(val as u8)
            }
            #[doc = "Compare Match Detection Flag for Channel 1"]
            #[inline(always)]
            pub fn set_itf01(&mut self, val: super::vals::Itf01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Compare Match Detection Flag for Channel 2"]
            #[inline(always)]
            pub const fn itf02(&self) -> super::vals::Itf02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Itf02::from_bits(val as u8)
            }
            #[doc = "Compare Match Detection Flag for Channel 2"]
            #[inline(always)]
            pub fn set_itf02(&mut self, val: super::vals::Itf02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Compare Match Detection Flag for Channel 3"]
            #[inline(always)]
            pub const fn itf03(&self) -> super::vals::Itf03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Itf03::from_bits(val as u8)
            }
            #[doc = "Compare Match Detection Flag for Channel 3"]
            #[inline(always)]
            pub fn set_itf03(&mut self, val: super::vals::Itf03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Capture Detection Flag"]
            #[inline(always)]
            pub const fn itf0c(&self) -> super::vals::Itf0c {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Itf0c::from_bits(val as u8)
            }
            #[doc = "Capture Detection Flag"]
            #[inline(always)]
            pub fn set_itf0c(&mut self, val: super::vals::Itf0c) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Itls0 {
            #[inline(always)]
            fn default() -> Itls0 {
                Itls0(0)
            }
        }
        impl core::fmt::Debug for Itls0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itls0")
                    .field("itf00", &self.itf00())
                    .field("itf01", &self.itf01())
                    .field("itf02", &self.itf02())
                    .field("itf03", &self.itf03())
                    .field("itf0c", &self.itf0c())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itls0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itls0 {{ itf00: {:?}, itf01: {:?}, itf02: {:?}, itf03: {:?}, itf0c: {:?} }}",
                    self.itf00(),
                    self.itf01(),
                    self.itf02(),
                    self.itf03(),
                    self.itf0c()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Capccr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Capccr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Capccr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Capccr {
            #[inline(always)]
            fn from(val: u8) -> Capccr {
                Capccr::from_bits(val)
            }
        }
        impl From<Capccr> for u8 {
            #[inline(always)]
            fn from(val: Capccr) -> u8 {
                Capccr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Capen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Capen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Capen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Capen {
            #[inline(always)]
            fn from(val: u8) -> Capen {
                Capen::from_bits(val)
            }
        }
        impl From<Capen> for u8 {
            #[inline(always)]
            fn from(val: Capen) -> u8 {
                Capen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Capf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Capf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Capf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Capf {
            #[inline(always)]
            fn from(val: u8) -> Capf {
                Capf::from_bits(val)
            }
        }
        impl From<Capf> for u8 {
            #[inline(always)]
            fn from(val: Capf) -> u8 {
                Capf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Capfcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Capfcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Capfcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Capfcr {
            #[inline(always)]
            fn from(val: u8) -> Capfcr {
                Capfcr::from_bits(val)
            }
        }
        impl From<Capfcr> for u8 {
            #[inline(always)]
            fn from(val: Capfcr) -> u8 {
                Capfcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Capr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Capr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Capr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Capr {
            #[inline(always)]
            fn from(val: u8) -> Capr {
                Capr::from_bits(val)
            }
        }
        impl From<Capr> for u8 {
            #[inline(always)]
            fn from(val: Capr) -> u8 {
                Capr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Csel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csel {
            #[inline(always)]
            fn from(val: u8) -> Csel {
                Csel::from_bits(val)
            }
        }
        impl From<Csel> for u8 {
            #[inline(always)]
            fn from(val: Csel) -> u8 {
                Csel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ctrs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrs {
            #[inline(always)]
            fn from(val: u8) -> Ctrs {
                Ctrs::from_bits(val)
            }
        }
        impl From<Ctrs> for u8 {
            #[inline(always)]
            fn from(val: Ctrs) -> u8 {
                Ctrs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En0 {
            #[inline(always)]
            fn from(val: u8) -> En0 {
                En0::from_bits(val)
            }
        }
        impl From<En0> for u8 {
            #[inline(always)]
            fn from(val: En0) -> u8 {
                En0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En1 {
            #[inline(always)]
            fn from(val: u8) -> En1 {
                En1::from_bits(val)
            }
        }
        impl From<En1> for u8 {
            #[inline(always)]
            fn from(val: En1) -> u8 {
                En1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En2 {
            #[inline(always)]
            fn from(val: u8) -> En2 {
                En2::from_bits(val)
            }
        }
        impl From<En2> for u8 {
            #[inline(always)]
            fn from(val: En2) -> u8 {
                En2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En3 {
            #[inline(always)]
            fn from(val: u8) -> En3 {
                En3::from_bits(val)
            }
        }
        impl From<En3> for u8 {
            #[inline(always)]
            fn from(val: En3) -> u8 {
                En3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fdiv0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fdiv0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fdiv0 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fdiv0 {
            #[inline(always)]
            fn from(val: u8) -> Fdiv0 {
                Fdiv0::from_bits(val)
            }
        }
        impl From<Fdiv0> for u8 {
            #[inline(always)]
            fn from(val: Fdiv0) -> u8 {
                Fdiv0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fdiv1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fdiv1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fdiv1 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fdiv1 {
            #[inline(always)]
            fn from(val: u8) -> Fdiv1 {
                Fdiv1::from_bits(val)
            }
        }
        impl From<Fdiv1> for u8 {
            #[inline(always)]
            fn from(val: Fdiv1) -> u8 {
                Fdiv1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fdiv2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fdiv2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fdiv2 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fdiv2 {
            #[inline(always)]
            fn from(val: u8) -> Fdiv2 {
                Fdiv2::from_bits(val)
            }
        }
        impl From<Fdiv2> for u8 {
            #[inline(always)]
            fn from(val: Fdiv2) -> u8 {
                Fdiv2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fdiv3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fdiv3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fdiv3 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fdiv3 {
            #[inline(always)]
            fn from(val: u8) -> Fdiv3 {
                Fdiv3::from_bits(val)
            }
        }
        impl From<Fdiv3> for u8 {
            #[inline(always)]
            fn from(val: Fdiv3) -> u8 {
                Fdiv3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Isel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Isel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Isel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Isel {
            #[inline(always)]
            fn from(val: u8) -> Isel {
                Isel::from_bits(val)
            }
        }
        impl From<Isel> for u8 {
            #[inline(always)]
            fn from(val: Isel) -> u8 {
                Isel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Itf00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Itf00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Itf00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Itf00 {
            #[inline(always)]
            fn from(val: u8) -> Itf00 {
                Itf00::from_bits(val)
            }
        }
        impl From<Itf00> for u8 {
            #[inline(always)]
            fn from(val: Itf00) -> u8 {
                Itf00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Itf01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Itf01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Itf01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Itf01 {
            #[inline(always)]
            fn from(val: u8) -> Itf01 {
                Itf01::from_bits(val)
            }
        }
        impl From<Itf01> for u8 {
            #[inline(always)]
            fn from(val: Itf01) -> u8 {
                Itf01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Itf02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Itf02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Itf02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Itf02 {
            #[inline(always)]
            fn from(val: u8) -> Itf02 {
                Itf02::from_bits(val)
            }
        }
        impl From<Itf02> for u8 {
            #[inline(always)]
            fn from(val: Itf02) -> u8 {
                Itf02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Itf03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Itf03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Itf03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Itf03 {
            #[inline(always)]
            fn from(val: u8) -> Itf03 {
                Itf03::from_bits(val)
            }
        }
        impl From<Itf03> for u8 {
            #[inline(always)]
            fn from(val: Itf03) -> u8 {
                Itf03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Itf0c {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Itf0c {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Itf0c {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Itf0c {
            #[inline(always)]
            fn from(val: u8) -> Itf0c {
                Itf0c::from_bits(val)
            }
        }
        impl From<Itf0c> for u8 {
            #[inline(always)]
            fn from(val: Itf0c) -> u8 {
                Itf0c::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Md {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Md {
            #[inline(always)]
            fn from(val: u8) -> Md {
                Md::from_bits(val)
            }
        }
        impl From<Md> for u8 {
            #[inline(always)]
            fn from(val: Md) -> u8 {
                Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mkf00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mkf00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mkf00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mkf00 {
            #[inline(always)]
            fn from(val: u8) -> Mkf00 {
                Mkf00::from_bits(val)
            }
        }
        impl From<Mkf00> for u8 {
            #[inline(always)]
            fn from(val: Mkf00) -> u8 {
                Mkf00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mkf01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mkf01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mkf01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mkf01 {
            #[inline(always)]
            fn from(val: u8) -> Mkf01 {
                Mkf01::from_bits(val)
            }
        }
        impl From<Mkf01> for u8 {
            #[inline(always)]
            fn from(val: Mkf01) -> u8 {
                Mkf01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mkf02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mkf02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mkf02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mkf02 {
            #[inline(always)]
            fn from(val: u8) -> Mkf02 {
                Mkf02::from_bits(val)
            }
        }
        impl From<Mkf02> for u8 {
            #[inline(always)]
            fn from(val: Mkf02) -> u8 {
                Mkf02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mkf03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mkf03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mkf03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mkf03 {
            #[inline(always)]
            fn from(val: u8) -> Mkf03 {
                Mkf03::from_bits(val)
            }
        }
        impl From<Mkf03> for u8 {
            #[inline(always)]
            fn from(val: Mkf03) -> u8 {
                Mkf03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mkf0c {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mkf0c {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mkf0c {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mkf0c {
            #[inline(always)]
            fn from(val: u8) -> Mkf0c {
                Mkf0c::from_bits(val)
            }
        }
        impl From<Mkf0c> for u8 {
            #[inline(always)]
            fn from(val: Mkf0c) -> u8 {
                Mkf0c::to_bits(val)
            }
        }
    }
}
pub mod trng {
    #[doc = "True Random Number Generator"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trng {
        ptr: *mut u8,
    }
    unsafe impl Send for Trng {}
    unsafe impl Sync for Trng {}
    impl Trng {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "TRNG Seed Data Register"]
        #[inline(always)]
        pub const fn trngsdr(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "TRNG Seed Command Register 0"]
        #[inline(always)]
        pub const fn trngscr0(self) -> crate::common::Reg<regs::Trngscr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "TRNG Seed Command Register 1"]
        #[inline(always)]
        pub const fn trngscr1(self) -> crate::common::Reg<regs::Trngscr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "TRNG Seed Command Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trngscr0(pub u8);
        impl Trngscr0 {
            #[doc = "Seed Generation Start"]
            #[inline(always)]
            pub const fn sgstart(&self) -> super::vals::Sgstart {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sgstart::from_bits(val as u8)
            }
            #[doc = "Seed Generation Start"]
            #[inline(always)]
            pub fn set_sgstart(&mut self, val: super::vals::Sgstart) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Seed Generation Circuit Enable"]
            #[inline(always)]
            pub const fn sgcen(&self) -> super::vals::Sgcen {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sgcen::from_bits(val as u8)
            }
            #[doc = "Seed Generation Circuit Enable"]
            #[inline(always)]
            pub fn set_sgcen(&mut self, val: super::vals::Sgcen) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Read Ready"]
            #[inline(always)]
            pub const fn rdrdy(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Read Ready"]
            #[inline(always)]
            pub fn set_rdrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Trngscr0 {
            #[inline(always)]
            fn default() -> Trngscr0 {
                Trngscr0(0)
            }
        }
        impl core::fmt::Debug for Trngscr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trngscr0")
                    .field("sgstart", &self.sgstart())
                    .field("sgcen", &self.sgcen())
                    .field("rdrdy", &self.rdrdy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trngscr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trngscr0 {{ sgstart: {:?}, sgcen: {:?}, rdrdy: {=bool:?} }}",
                    self.sgstart(),
                    self.sgcen(),
                    self.rdrdy()
                )
            }
        }
        #[doc = "TRNG Seed Command Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trngscr1(pub u8);
        impl Trngscr1 {
            #[doc = "TRNG Interrupt Enable"]
            #[inline(always)]
            pub const fn inten(&self) -> super::vals::Inten {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Inten::from_bits(val as u8)
            }
            #[doc = "TRNG Interrupt Enable"]
            #[inline(always)]
            pub fn set_inten(&mut self, val: super::vals::Inten) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Trngscr1 {
            #[inline(always)]
            fn default() -> Trngscr1 {
                Trngscr1(0)
            }
        }
        impl core::fmt::Debug for Trngscr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trngscr1")
                    .field("inten", &self.inten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trngscr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trngscr1 {{ inten: {:?} }}", self.inten())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Inten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inten {
            #[inline(always)]
            fn from(val: u8) -> Inten {
                Inten::from_bits(val)
            }
        }
        impl From<Inten> for u8 {
            #[inline(always)]
            fn from(val: Inten) -> u8 {
                Inten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sgcen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sgcen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sgcen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sgcen {
            #[inline(always)]
            fn from(val: u8) -> Sgcen {
                Sgcen::from_bits(val)
            }
        }
        impl From<Sgcen> for u8 {
            #[inline(always)]
            fn from(val: Sgcen) -> u8 {
                Sgcen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sgstart {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sgstart {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sgstart {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sgstart {
            #[inline(always)]
            fn from(val: u8) -> Sgstart {
                Sgstart::from_bits(val)
            }
        }
        impl From<Sgstart> for u8 {
            #[inline(always)]
            fn from(val: Sgstart) -> u8 {
                Sgstart::to_bits(val)
            }
        }
    }
}
pub mod uarta {
    #[doc = "Serial Interface UARTA"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uarta {
        ptr: *mut u8,
    }
    unsafe impl Send for Uarta {}
    unsafe impl Sync for Uarta {}
    impl Uarta {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Transmit Buffer Register 0"]
        #[inline(always)]
        pub const fn txba0(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Receive Buffer Register 0"]
        #[inline(always)]
        pub const fn rxba0(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Operation Mode Setting Register 00"]
        #[inline(always)]
        pub const fn asima00(self) -> crate::common::Reg<regs::Asima00, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Operation Mode Setting Register 01"]
        #[inline(always)]
        pub const fn asima01(self) -> crate::common::Reg<regs::Asima01, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Baud Rate Generator Control Register 0"]
        #[inline(always)]
        pub const fn brgca0(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Status Register 0"]
        #[inline(always)]
        pub const fn asisa0(self) -> crate::common::Reg<regs::Asisa0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "Status Clear Trigger Register 0"]
        #[inline(always)]
        pub const fn ascta0(self) -> crate::common::Reg<regs::Ascta0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "UARTA Clock Select Register 0"]
        #[inline(always)]
        pub const fn uta0ck(self) -> crate::common::Reg<regs::Uta0ck, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Status Clear Trigger Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ascta0(pub u8);
        impl Ascta0 {
            #[doc = "Overrun Error Flag Clear Trigger"]
            #[inline(always)]
            pub const fn ovecta(&self) -> super::vals::Ovecta {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ovecta::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag Clear Trigger"]
            #[inline(always)]
            pub fn set_ovecta(&mut self, val: super::vals::Ovecta) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Framing Error Flag Clear Trigger"]
            #[inline(always)]
            pub const fn fecta(&self) -> super::vals::Fecta {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Fecta::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag Clear Trigger"]
            #[inline(always)]
            pub fn set_fecta(&mut self, val: super::vals::Fecta) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Parity Error Flag Clear Trigger"]
            #[inline(always)]
            pub const fn pecta(&self) -> super::vals::Pecta {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pecta::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag Clear Trigger"]
            #[inline(always)]
            pub fn set_pecta(&mut self, val: super::vals::Pecta) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ascta0 {
            #[inline(always)]
            fn default() -> Ascta0 {
                Ascta0(0)
            }
        }
        impl core::fmt::Debug for Ascta0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ascta0")
                    .field("ovecta", &self.ovecta())
                    .field("fecta", &self.fecta())
                    .field("pecta", &self.pecta())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ascta0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ascta0 {{ ovecta: {:?}, fecta: {:?}, pecta: {:?} }}",
                    self.ovecta(),
                    self.fecta(),
                    self.pecta()
                )
            }
        }
        #[doc = "Operation Mode Setting Register 00"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Asima00(pub u8);
        impl Asima00 {
            #[doc = "Receive Interrupt Mode Select"]
            #[inline(always)]
            pub const fn isrma(&self) -> super::vals::Isrma {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Isrma::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Mode Select"]
            #[inline(always)]
            pub fn set_isrma(&mut self, val: super::vals::Isrma) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Transmit Interrupt Mode Select"]
            #[inline(always)]
            pub const fn issma(&self) -> super::vals::Issma {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Issma::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Mode Select"]
            #[inline(always)]
            pub fn set_issma(&mut self, val: super::vals::Issma) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Reception Enable"]
            #[inline(always)]
            pub const fn rxea(&self) -> super::vals::Rxea {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rxea::from_bits(val as u8)
            }
            #[doc = "Reception Enable"]
            #[inline(always)]
            pub fn set_rxea(&mut self, val: super::vals::Rxea) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmission Enable"]
            #[inline(always)]
            pub const fn txea(&self) -> super::vals::Txea {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Txea::from_bits(val as u8)
            }
            #[doc = "Transmission Enable"]
            #[inline(always)]
            pub fn set_txea(&mut self, val: super::vals::Txea) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "UART Operation Enable"]
            #[inline(always)]
            pub const fn en(&self) -> super::vals::En {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::En::from_bits(val as u8)
            }
            #[doc = "UART Operation Enable"]
            #[inline(always)]
            pub fn set_en(&mut self, val: super::vals::En) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Asima00 {
            #[inline(always)]
            fn default() -> Asima00 {
                Asima00(0)
            }
        }
        impl core::fmt::Debug for Asima00 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Asima00")
                    .field("isrma", &self.isrma())
                    .field("issma", &self.issma())
                    .field("rxea", &self.rxea())
                    .field("txea", &self.txea())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Asima00 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Asima00 {{ isrma: {:?}, issma: {:?}, rxea: {:?}, txea: {:?}, en: {:?} }}",
                    self.isrma(),
                    self.issma(),
                    self.rxea(),
                    self.txea(),
                    self.en()
                )
            }
        }
        #[doc = "Operation Mode Setting Register 01"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Asima01(pub u8);
        impl Asima01 {
            #[doc = "Transmission and Reception Level Setting"]
            #[inline(always)]
            pub const fn alv(&self) -> super::vals::Alv {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Alv::from_bits(val as u8)
            }
            #[doc = "Transmission and Reception Level Setting"]
            #[inline(always)]
            pub fn set_alv(&mut self, val: super::vals::Alv) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Transmission and Reception Order Setting"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Dir {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Transmission and Reception Order Setting"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::Dir) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmission Stop Bit Length Setting"]
            #[inline(always)]
            pub const fn sl(&self) -> super::vals::Sl {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sl::from_bits(val as u8)
            }
            #[doc = "Transmission Stop Bit Length Setting"]
            #[inline(always)]
            pub fn set_sl(&mut self, val: super::vals::Sl) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmission and Reception Character Length Setting"]
            #[inline(always)]
            pub const fn cl(&self) -> super::vals::Cl {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Cl::from_bits(val as u8)
            }
            #[doc = "Transmission and Reception Character Length Setting"]
            #[inline(always)]
            pub fn set_cl(&mut self, val: super::vals::Cl) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u8) & 0x03) << 3usize);
            }
            #[doc = "Transmission and Reception Parity Bit Setting"]
            #[inline(always)]
            pub const fn ps(&self) -> super::vals::Ps {
                let val = (self.0 >> 5usize) & 0x03;
                super::vals::Ps::from_bits(val as u8)
            }
            #[doc = "Transmission and Reception Parity Bit Setting"]
            #[inline(always)]
            pub fn set_ps(&mut self, val: super::vals::Ps) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val.to_bits() as u8) & 0x03) << 5usize);
            }
        }
        impl Default for Asima01 {
            #[inline(always)]
            fn default() -> Asima01 {
                Asima01(0)
            }
        }
        impl core::fmt::Debug for Asima01 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Asima01")
                    .field("alv", &self.alv())
                    .field("dir", &self.dir())
                    .field("sl", &self.sl())
                    .field("cl", &self.cl())
                    .field("ps", &self.ps())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Asima01 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Asima01 {{ alv: {:?}, dir: {:?}, sl: {:?}, cl: {:?}, ps: {:?} }}",
                    self.alv(),
                    self.dir(),
                    self.sl(),
                    self.cl(),
                    self.ps()
                )
            }
        }
        #[doc = "Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Asisa0(pub u8);
        impl Asisa0 {
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn ovea(&self) -> super::vals::Ovea {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ovea::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_ovea(&mut self, val: super::vals::Ovea) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fea(&self) -> super::vals::Fea {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Fea::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fea(&mut self, val: super::vals::Fea) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn pea(&self) -> super::vals::Pea {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pea::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_pea(&mut self, val: super::vals::Pea) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmit Shift Register Data Flag"]
            #[inline(always)]
            pub const fn txsfa(&self) -> super::vals::Txsfa {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Txsfa::from_bits(val as u8)
            }
            #[doc = "Transmit Shift Register Data Flag"]
            #[inline(always)]
            pub fn set_txsfa(&mut self, val: super::vals::Txsfa) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Buffer Data Flag"]
            #[inline(always)]
            pub const fn txbfa(&self) -> super::vals::Txbfa {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Txbfa::from_bits(val as u8)
            }
            #[doc = "Transmit Buffer Data Flag"]
            #[inline(always)]
            pub fn set_txbfa(&mut self, val: super::vals::Txbfa) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Asisa0 {
            #[inline(always)]
            fn default() -> Asisa0 {
                Asisa0(0)
            }
        }
        impl core::fmt::Debug for Asisa0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Asisa0")
                    .field("ovea", &self.ovea())
                    .field("fea", &self.fea())
                    .field("pea", &self.pea())
                    .field("txsfa", &self.txsfa())
                    .field("txbfa", &self.txbfa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Asisa0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Asisa0 {{ ovea: {:?}, fea: {:?}, pea: {:?}, txsfa: {:?}, txbfa: {:?} }}",
                    self.ovea(),
                    self.fea(),
                    self.pea(),
                    self.txsfa(),
                    self.txbfa()
                )
            }
        }
        #[doc = "UARTA Clock Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Uta0ck(pub u8);
        impl Uta0ck {
            #[doc = "UARTA0 Operation Clock Select (fUTA0)"]
            #[inline(always)]
            pub const fn ck(&self) -> super::vals::Ck {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Ck::from_bits(val as u8)
            }
            #[doc = "UARTA0 Operation Clock Select (fUTA0)"]
            #[inline(always)]
            pub fn set_ck(&mut self, val: super::vals::Ck) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u8) & 0x0f) << 0usize);
            }
            #[doc = "fSEL Clock Select"]
            #[inline(always)]
            pub const fn sel(&self) -> super::vals::Sel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Sel::from_bits(val as u8)
            }
            #[doc = "fSEL Clock Select"]
            #[inline(always)]
            pub fn set_sel(&mut self, val: super::vals::Sel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Uta0ck {
            #[inline(always)]
            fn default() -> Uta0ck {
                Uta0ck(0)
            }
        }
        impl core::fmt::Debug for Uta0ck {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Uta0ck")
                    .field("ck", &self.ck())
                    .field("sel", &self.sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Uta0ck {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Uta0ck {{ ck: {:?}, sel: {:?} }}", self.ck(), self.sel())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Alv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Alv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Alv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Alv {
            #[inline(always)]
            fn from(val: u8) -> Alv {
                Alv::from_bits(val)
            }
        }
        impl From<Alv> for u8 {
            #[inline(always)]
            fn from(val: Alv) -> u8 {
                Alv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Ck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ck {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ck {
            #[inline(always)]
            fn from(val: u8) -> Ck {
                Ck::from_bits(val)
            }
        }
        impl From<Ck> for u8 {
            #[inline(always)]
            fn from(val: Ck) -> u8 {
                Ck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cl {
            #[inline(always)]
            fn from(val: u8) -> Cl {
                Cl::from_bits(val)
            }
        }
        impl From<Cl> for u8 {
            #[inline(always)]
            fn from(val: Cl) -> u8 {
                Cl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dir {
            #[inline(always)]
            fn from(val: u8) -> Dir {
                Dir::from_bits(val)
            }
        }
        impl From<Dir> for u8 {
            #[inline(always)]
            fn from(val: Dir) -> u8 {
                Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En {
            #[inline(always)]
            fn from(val: u8) -> En {
                En::from_bits(val)
            }
        }
        impl From<En> for u8 {
            #[inline(always)]
            fn from(val: En) -> u8 {
                En::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fea {
            #[inline(always)]
            fn from(val: u8) -> Fea {
                Fea::from_bits(val)
            }
        }
        impl From<Fea> for u8 {
            #[inline(always)]
            fn from(val: Fea) -> u8 {
                Fea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fecta {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fecta {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fecta {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fecta {
            #[inline(always)]
            fn from(val: u8) -> Fecta {
                Fecta::from_bits(val)
            }
        }
        impl From<Fecta> for u8 {
            #[inline(always)]
            fn from(val: Fecta) -> u8 {
                Fecta::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Isrma {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Isrma {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Isrma {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Isrma {
            #[inline(always)]
            fn from(val: u8) -> Isrma {
                Isrma::from_bits(val)
            }
        }
        impl From<Isrma> for u8 {
            #[inline(always)]
            fn from(val: Isrma) -> u8 {
                Isrma::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Issma {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Issma {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Issma {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Issma {
            #[inline(always)]
            fn from(val: u8) -> Issma {
                Issma::from_bits(val)
            }
        }
        impl From<Issma> for u8 {
            #[inline(always)]
            fn from(val: Issma) -> u8 {
                Issma::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovea {
            #[inline(always)]
            fn from(val: u8) -> Ovea {
                Ovea::from_bits(val)
            }
        }
        impl From<Ovea> for u8 {
            #[inline(always)]
            fn from(val: Ovea) -> u8 {
                Ovea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovecta {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovecta {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovecta {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovecta {
            #[inline(always)]
            fn from(val: u8) -> Ovecta {
                Ovecta::from_bits(val)
            }
        }
        impl From<Ovecta> for u8 {
            #[inline(always)]
            fn from(val: Ovecta) -> u8 {
                Ovecta::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pea {
            #[inline(always)]
            fn from(val: u8) -> Pea {
                Pea::from_bits(val)
            }
        }
        impl From<Pea> for u8 {
            #[inline(always)]
            fn from(val: Pea) -> u8 {
                Pea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pecta {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pecta {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pecta {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pecta {
            #[inline(always)]
            fn from(val: u8) -> Pecta {
                Pecta::from_bits(val)
            }
        }
        impl From<Pecta> for u8 {
            #[inline(always)]
            fn from(val: Pecta) -> u8 {
                Pecta::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ps {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ps {
            #[inline(always)]
            fn from(val: u8) -> Ps {
                Ps::from_bits(val)
            }
        }
        impl From<Ps> for u8 {
            #[inline(always)]
            fn from(val: Ps) -> u8 {
                Ps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxea {
            #[inline(always)]
            fn from(val: u8) -> Rxea {
                Rxea::from_bits(val)
            }
        }
        impl From<Rxea> for u8 {
            #[inline(always)]
            fn from(val: Rxea) -> u8 {
                Rxea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sel {
            #[inline(always)]
            fn from(val: u8) -> Sel {
                Sel::from_bits(val)
            }
        }
        impl From<Sel> for u8 {
            #[inline(always)]
            fn from(val: Sel) -> u8 {
                Sel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sl {
            #[inline(always)]
            fn from(val: u8) -> Sl {
                Sl::from_bits(val)
            }
        }
        impl From<Sl> for u8 {
            #[inline(always)]
            fn from(val: Sl) -> u8 {
                Sl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txbfa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Txbfa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txbfa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txbfa {
            #[inline(always)]
            fn from(val: u8) -> Txbfa {
                Txbfa::from_bits(val)
            }
        }
        impl From<Txbfa> for u8 {
            #[inline(always)]
            fn from(val: Txbfa) -> u8 {
                Txbfa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Txea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txea {
            #[inline(always)]
            fn from(val: u8) -> Txea {
                Txea::from_bits(val)
            }
        }
        impl From<Txea> for u8 {
            #[inline(always)]
            fn from(val: Txea) -> u8 {
                Txea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txsfa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Txsfa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txsfa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txsfa {
            #[inline(always)]
            fn from(val: u8) -> Txsfa {
                Txsfa::from_bits(val)
            }
        }
        impl From<Txsfa> for u8 {
            #[inline(always)]
            fn from(val: Txsfa) -> u8 {
                Txsfa::to_bits(val)
            }
        }
    }
}
