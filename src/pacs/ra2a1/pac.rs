#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![doc = "Peripheral access API (generated using chiptool v0.1.0 (d771c7b 2025-03-27))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "0 - ICU Interrupt 0"]
    IEL0 = 0,
    #[doc = "1 - ICU Interrupt 1"]
    IEL1 = 1,
    #[doc = "2 - ICU Interrupt 2"]
    IEL2 = 2,
    #[doc = "3 - ICU Interrupt 3"]
    IEL3 = 3,
    #[doc = "4 - ICU Interrupt 4"]
    IEL4 = 4,
    #[doc = "5 - ICU Interrupt 5"]
    IEL5 = 5,
    #[doc = "6 - ICU Interrupt 6"]
    IEL6 = 6,
    #[doc = "7 - ICU Interrupt 7"]
    IEL7 = 7,
    #[doc = "8 - ICU Interrupt 8"]
    IEL8 = 8,
    #[doc = "9 - ICU Interrupt 9"]
    IEL9 = 9,
    #[doc = "10 - ICU Interrupt 10"]
    IEL10 = 10,
    #[doc = "11 - ICU Interrupt 11"]
    IEL11 = 11,
    #[doc = "12 - ICU Interrupt 12"]
    IEL12 = 12,
    #[doc = "13 - ICU Interrupt 13"]
    IEL13 = 13,
    #[doc = "14 - ICU Interrupt 14"]
    IEL14 = 14,
    #[doc = "15 - ICU Interrupt 15"]
    IEL15 = 15,
    #[doc = "16 - ICU Interrupt 16"]
    IEL16 = 16,
    #[doc = "17 - ICU Interrupt 17"]
    IEL17 = 17,
    #[doc = "18 - ICU Interrupt 18"]
    IEL18 = 18,
    #[doc = "19 - ICU Interrupt 19"]
    IEL19 = 19,
    #[doc = "20 - ICU Interrupt 20"]
    IEL20 = 20,
    #[doc = "21 - ICU Interrupt 21"]
    IEL21 = 21,
    #[doc = "22 - ICU Interrupt 22"]
    IEL22 = 22,
    #[doc = "23 - ICU Interrupt 23"]
    IEL23 = 23,
    #[doc = "24 - ICU Interrupt 24"]
    IEL24 = 24,
    #[doc = "25 - ICU Interrupt 25"]
    IEL25 = 25,
    #[doc = "26 - ICU Interrupt 26"]
    IEL26 = 26,
    #[doc = "27 - ICU Interrupt 27"]
    IEL27 = 27,
    #[doc = "28 - ICU Interrupt 28"]
    IEL28 = 28,
    #[doc = "29 - ICU Interrupt 29"]
    IEL29 = 29,
    #[doc = "30 - ICU Interrupt 30"]
    IEL30 = 30,
    #[doc = "31 - ICU Interrupt 31"]
    IEL31 = 31,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    extern "C" {
        fn IEL0();
        fn IEL1();
        fn IEL2();
        fn IEL3();
        fn IEL4();
        fn IEL5();
        fn IEL6();
        fn IEL7();
        fn IEL8();
        fn IEL9();
        fn IEL10();
        fn IEL11();
        fn IEL12();
        fn IEL13();
        fn IEL14();
        fn IEL15();
        fn IEL16();
        fn IEL17();
        fn IEL18();
        fn IEL19();
        fn IEL20();
        fn IEL21();
        fn IEL22();
        fn IEL23();
        fn IEL24();
        fn IEL25();
        fn IEL26();
        fn IEL27();
        fn IEL28();
        fn IEL29();
        fn IEL30();
        fn IEL31();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    pub static __INTERRUPTS: [Vector; 32] = [
        Vector { _handler: IEL0 },
        Vector { _handler: IEL1 },
        Vector { _handler: IEL2 },
        Vector { _handler: IEL3 },
        Vector { _handler: IEL4 },
        Vector { _handler: IEL5 },
        Vector { _handler: IEL6 },
        Vector { _handler: IEL7 },
        Vector { _handler: IEL8 },
        Vector { _handler: IEL9 },
        Vector { _handler: IEL10 },
        Vector { _handler: IEL11 },
        Vector { _handler: IEL12 },
        Vector { _handler: IEL13 },
        Vector { _handler: IEL14 },
        Vector { _handler: IEL15 },
        Vector { _handler: IEL16 },
        Vector { _handler: IEL17 },
        Vector { _handler: IEL18 },
        Vector { _handler: IEL19 },
        Vector { _handler: IEL20 },
        Vector { _handler: IEL21 },
        Vector { _handler: IEL22 },
        Vector { _handler: IEL23 },
        Vector { _handler: IEL24 },
        Vector { _handler: IEL25 },
        Vector { _handler: IEL26 },
        Vector { _handler: IEL27 },
        Vector { _handler: IEL28 },
        Vector { _handler: IEL29 },
        Vector { _handler: IEL30 },
        Vector { _handler: IEL31 },
    ];
}
#[doc = "Bus Master MPU"]
pub const MMPU: mmpu::Mmpu = unsafe { mmpu::Mmpu::from_ptr(0x4000_0000usize as _) };
#[doc = "Bus Slave MPU"]
pub const SMPU: smpu::Smpu = unsafe { smpu::Smpu::from_ptr(0x4000_0c00usize as _) };
#[doc = "CPU Stack Pointer Monitor"]
pub const SPMON: spmon::Spmon = unsafe { spmon::Spmon::from_ptr(0x4000_0d00usize as _) };
#[doc = "Memory Mirror Function"]
pub const MMF: mmf::Mmf = unsafe { mmf::Mmf::from_ptr(0x4000_1000usize as _) };
#[doc = "SRAM Control"]
pub const SRAM: sram::Sram = unsafe { sram::Sram::from_ptr(0x4000_2000usize as _) };
#[doc = "BUS Control"]
pub const BUS: bus::Bus = unsafe { bus::Bus::from_ptr(0x4000_3000usize as _) };
#[doc = "Data Transfer Controller"]
pub const DTC: dtc::Dtc = unsafe { dtc::Dtc::from_ptr(0x4000_5400usize as _) };
#[doc = "Interrupt Controller"]
pub const ICU: icu::Icu = unsafe { icu::Icu::from_ptr(0x4000_6000usize as _) };
#[doc = "Debug Function"]
pub const DBG: dbg::Dbg = unsafe { dbg::Dbg::from_ptr(0x4001_b000usize as _) };
#[doc = "Flash Cache"]
pub const FCACHE: fcache::Fcache = unsafe { fcache::Fcache::from_ptr(0x4001_c000usize as _) };
#[doc = "System Control"]
pub const SYSTEM: system::System = unsafe { system::System::from_ptr(0x4001_e000usize as _) };
#[doc = "Port 0 Control Registers"]
pub const PORT0: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0000usize as _) };
#[doc = "Port 1 Control Registers"]
pub const PORT1: port1::Port1 = unsafe { port1::Port1::from_ptr(0x4004_0020usize as _) };
#[doc = "Port 2 Control Registers"]
pub const PORT2: port1::Port1 = unsafe { port1::Port1::from_ptr(0x4004_0040usize as _) };
#[doc = "Port 3 Control Registers"]
pub const PORT3: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0060usize as _) };
#[doc = "Port 4 Control Registers"]
pub const PORT4: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0080usize as _) };
#[doc = "Port 5 Control Registers"]
pub const PORT5: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_00a0usize as _) };
#[doc = "Port 9 Control Registers"]
pub const PORT9: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0120usize as _) };
#[doc = "Pmn Pin Function Control Register"]
pub const PFS: pfs::Pfs = unsafe { pfs::Pfs::from_ptr(0x4004_0800usize as _) };
#[doc = "Miscellaneous Port Control Register"]
pub const PMISC: pmisc::Pmisc = unsafe { pmisc::Pmisc::from_ptr(0x4004_0d00usize as _) };
#[doc = "Event Link Controller"]
pub const ELC: elc::Elc = unsafe { elc::Elc::from_ptr(0x4004_1000usize as _) };
#[doc = "Port Output Enable Module for GPT"]
pub const POEG: poeg::Poeg = unsafe { poeg::Poeg::from_ptr(0x4004_2000usize as _) };
#[doc = "Realtime Clock"]
pub const RTC: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x4004_4000usize as _) };
#[doc = "Watchdog Timer"]
pub const WDT: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4004_4200usize as _) };
#[doc = "Independent Watchdog Timer"]
pub const IWDT: iwdt::Iwdt = unsafe { iwdt::Iwdt::from_ptr(0x4004_4400usize as _) };
#[doc = "Clock Frequency Accuracy Measurement Circuit"]
pub const CAC: cac::Cac = unsafe { cac::Cac::from_ptr(0x4004_4600usize as _) };
#[doc = "Module Stop Control B,C,D"]
pub const MSTP: mstp::Mstp = unsafe { mstp::Mstp::from_ptr(0x4004_7000usize as _) };
#[doc = "CAN0 Module"]
pub const CAN0: can0::Can0 = unsafe { can0::Can0::from_ptr(0x4005_0000usize as _) };
#[doc = "Inter,Integrated Circuit 0"]
pub const IIC0: iic0::Iic0 = unsafe { iic0::Iic0::from_ptr(0x4005_3000usize as _) };
#[doc = "Inter,Integrated Circuit 1"]
pub const IIC1: iic1::Iic1 = unsafe { iic1::Iic1::from_ptr(0x4005_3100usize as _) };
#[doc = "Data Operation Circuit"]
pub const DOC: doc::Doc = unsafe { doc::Doc::from_ptr(0x4005_4100usize as _) };
#[doc = "16-bit A/D Converter"]
pub const ADC160: adc160::Adc160 = unsafe { adc160::Adc160::from_ptr(0x4005_c000usize as _) };
#[doc = "12-bit D/A converter"]
pub const DAC12: dac12::Dac12 = unsafe { dac12::Dac12::from_ptr(0x4005_e000usize as _) };
#[doc = "Serial Communication Interface 0"]
pub const SCI0: sci0::Sci0 = unsafe { sci0::Sci0::from_ptr(0x4007_0000usize as _) };
#[doc = "Serial Communication Interface 1"]
pub const SCI1: sci1::Sci1 = unsafe { sci1::Sci1::from_ptr(0x4007_0020usize as _) };
#[doc = "Serial Communication Interface 9"]
pub const SCI9: sci1::Sci1 = unsafe { sci1::Sci1::from_ptr(0x4007_0120usize as _) };
#[doc = "Serial Peripheral Interface 0"]
pub const SPI0: spi0::Spi0 = unsafe { spi0::Spi0::from_ptr(0x4007_2000usize as _) };
#[doc = "Serial Peripheral Interface 1"]
pub const SPI1: spi0::Spi0 = unsafe { spi0::Spi0::from_ptr(0x4007_2100usize as _) };
#[doc = "CRC Calculator"]
pub const CRC: crc::Crc = unsafe { crc::Crc::from_ptr(0x4007_4000usize as _) };
#[doc = "General PWM Timer 0 (32-bit)"]
pub const GPT320: gpt320::Gpt320 = unsafe { gpt320::Gpt320::from_ptr(0x4007_8000usize as _) };
#[doc = "General PWM Timer 1 (16-bit)"]
pub const GPT161: gpt161::Gpt161 = unsafe { gpt161::Gpt161::from_ptr(0x4007_8100usize as _) };
#[doc = "General PWM Timer 2 (16-bit)"]
pub const GPT162: gpt161::Gpt161 = unsafe { gpt161::Gpt161::from_ptr(0x4007_8200usize as _) };
#[doc = "General PWM Timer 3 (16-bit)"]
pub const GPT163: gpt161::Gpt161 = unsafe { gpt161::Gpt161::from_ptr(0x4007_8300usize as _) };
#[doc = "General PWM Timer 4 (16-bit)"]
pub const GPT164: gpt161::Gpt161 = unsafe { gpt161::Gpt161::from_ptr(0x4007_8400usize as _) };
#[doc = "General PWM Timer 5 (16-bit)"]
pub const GPT165: gpt161::Gpt161 = unsafe { gpt161::Gpt161::from_ptr(0x4007_8500usize as _) };
#[doc = "General PWM Timer 6 (16-bit)"]
pub const GPT166: gpt161::Gpt161 = unsafe { gpt161::Gpt161::from_ptr(0x4007_8600usize as _) };
#[doc = "Output Phase Switching Controller"]
pub const GPT_OPS: gpt_ops::GptOps = unsafe { gpt_ops::GptOps::from_ptr(0x4007_8ff0usize as _) };
#[doc = "Key Interrupt Function"]
pub const KINT: kint::Kint = unsafe { kint::Kint::from_ptr(0x4008_0000usize as _) };
#[doc = "Capacitive Touch Sensing Unit"]
pub const CTSU: ctsu::Ctsu = unsafe { ctsu::Ctsu::from_ptr(0x4008_1000usize as _) };
#[doc = "Asynchronous General purpose Timer 0"]
pub const AGT0: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4000usize as _) };
#[doc = "Asynchronous General purpose Timer 1"]
pub const AGT1: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4100usize as _) };
#[doc = "High,Speed Analog Comparator 0"]
pub const ACMPHS0: acmphs0::Acmphs0 = unsafe { acmphs0::Acmphs0::from_ptr(0x4008_5000usize as _) };
#[doc = "Low,Power Analog Comparator"]
pub const ACMPLP: acmplp::Acmplp = unsafe { acmplp::Acmplp::from_ptr(0x4008_5e00usize as _) };
#[doc = "OperationalAmplifier"]
pub const OPAMP: opamp::Opamp = unsafe { opamp::Opamp::from_ptr(0x4008_6800usize as _) };
#[doc = "USB 2.0 FS Module"]
pub const USBFS: usbfs::Usbfs = unsafe { usbfs::Usbfs::from_ptr(0x4009_0000usize as _) };
#[doc = "24-Bit Sigma,Delta A/D Converter"]
pub const SDADC24: sdadc24::Sdadc24 = unsafe { sdadc24::Sdadc24::from_ptr(0x4009_c000usize as _) };
#[doc = "8-bit D/A converter"]
pub const DAC8: dac8::Dac8 = unsafe { dac8::Dac8::from_ptr(0x4009_e000usize as _) };
#[doc = "Temperature Sensor"]
pub const TSN: tsn::Tsn = unsafe { tsn::Tsn::from_ptr(0x407e_c000usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
#[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
pub mod acmphs0 {
    #[doc = "High,Speed Analog Comparator 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Acmphs0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Acmphs0 {}
    unsafe impl Sync for Acmphs0 {}
    impl Acmphs0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Comparator Control Register"]
        #[inline(always)]
        pub const fn cmpctl(self) -> crate::common::Reg<regs::Cmpctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Comparator Input Select Register"]
        #[inline(always)]
        pub const fn cmpsel0(self) -> crate::common::Reg<regs::Cmpsel0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Comparator Reference Voltage Select Register"]
        #[inline(always)]
        pub const fn cmpsel1(self) -> crate::common::Reg<regs::Cmpsel1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Comparator Output Monitor Register"]
        #[inline(always)]
        pub const fn cmpmon(self) -> crate::common::Reg<regs::Cmpmon, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Comparator Output Control Register"]
        #[inline(always)]
        pub const fn cpioc(self) -> crate::common::Reg<regs::Cpioc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Comparator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmpctl(pub u8);
        impl Cmpctl {
            #[doc = "Comparator output polarity selection"]
            #[inline(always)]
            pub const fn cinv(&self) -> super::vals::Cinv {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cinv::from_bits(val as u8)
            }
            #[doc = "Comparator output polarity selection"]
            #[inline(always)]
            pub fn set_cinv(&mut self, val: super::vals::Cinv) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Comparator output enable"]
            #[inline(always)]
            pub const fn coe(&self) -> super::vals::Coe {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Coe::from_bits(val as u8)
            }
            #[doc = "Comparator output enable"]
            #[inline(always)]
            pub fn set_coe(&mut self, val: super::vals::Coe) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_2_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_2_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Selection of valid edge (Edge selector)"]
            #[inline(always)]
            pub const fn ceg(&self) -> super::vals::Ceg {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Ceg::from_bits(val as u8)
            }
            #[doc = "Selection of valid edge (Edge selector)"]
            #[inline(always)]
            pub fn set_ceg(&mut self, val: super::vals::Ceg) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u8) & 0x03) << 3usize);
            }
            #[doc = "Noise filter selection"]
            #[inline(always)]
            pub const fn cdfs(&self) -> super::vals::Cdfs {
                let val = (self.0 >> 5usize) & 0x03;
                super::vals::Cdfs::from_bits(val as u8)
            }
            #[doc = "Noise filter selection"]
            #[inline(always)]
            pub fn set_cdfs(&mut self, val: super::vals::Cdfs) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val.to_bits() as u8) & 0x03) << 5usize);
            }
            #[doc = "Comparator operation control"]
            #[inline(always)]
            pub const fn hcmpon(&self) -> super::vals::Hcmpon {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Hcmpon::from_bits(val as u8)
            }
            #[doc = "Comparator operation control"]
            #[inline(always)]
            pub fn set_hcmpon(&mut self, val: super::vals::Hcmpon) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Cmpctl {
            #[inline(always)]
            fn default() -> Cmpctl {
                Cmpctl(0)
            }
        }
        impl core::fmt::Debug for Cmpctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmpctl")
                    .field("cinv", &self.cinv())
                    .field("coe", &self.coe())
                    .field("reserved_2_2", &self.reserved_2_2())
                    .field("ceg", &self.ceg())
                    .field("cdfs", &self.cdfs())
                    .field("hcmpon", &self.hcmpon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmpctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cmpctl {{ cinv: {:?}, coe: {:?}, reserved_2_2: {=bool:?}, ceg: {:?}, cdfs: {:?}, hcmpon: {:?} }}" , self . cinv () , self . coe () , self . reserved_2_2 () , self . ceg () , self . cdfs () , self . hcmpon ())
            }
        }
        #[doc = "Comparator Output Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmpmon(pub u8);
        impl Cmpmon {
            #[doc = "Comparator output monitor"]
            #[inline(always)]
            pub const fn cmpmon(&self) -> super::vals::Cmpmon {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpmon::from_bits(val as u8)
            }
            #[doc = "Comparator output monitor"]
            #[inline(always)]
            pub fn set_cmpmon(&mut self, val: super::vals::Cmpmon) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Cmpmon {
            #[inline(always)]
            fn default() -> Cmpmon {
                Cmpmon(0)
            }
        }
        impl core::fmt::Debug for Cmpmon {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmpmon")
                    .field("cmpmon", &self.cmpmon())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmpmon {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cmpmon {{ cmpmon: {:?}, reserved_1_7: {=u8:?} }}",
                    self.cmpmon(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "Comparator Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmpsel0(pub u8);
        impl Cmpsel0 {
            #[doc = "Comparator input selection"]
            #[inline(always)]
            pub const fn cmpsel(&self) -> super::vals::Cmpsel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Cmpsel::from_bits(val as u8)
            }
            #[doc = "Comparator input selection"]
            #[inline(always)]
            pub fn set_cmpsel(&mut self, val: super::vals::Cmpsel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Cmpsel0 {
            #[inline(always)]
            fn default() -> Cmpsel0 {
                Cmpsel0(0)
            }
        }
        impl core::fmt::Debug for Cmpsel0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmpsel0")
                    .field("cmpsel", &self.cmpsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmpsel0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cmpsel0 {{ cmpsel: {:?} }}", self.cmpsel())
            }
        }
        #[doc = "Comparator Reference Voltage Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmpsel1(pub u8);
        impl Cmpsel1 {
            #[doc = "Reference voltage selection"]
            #[inline(always)]
            pub const fn crvs(&self) -> super::vals::Crvs {
                let val = (self.0 >> 0usize) & 0x3f;
                super::vals::Crvs::from_bits(val as u8)
            }
            #[doc = "Reference voltage selection"]
            #[inline(always)]
            pub fn set_crvs(&mut self, val: super::vals::Crvs) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val.to_bits() as u8) & 0x3f) << 0usize);
            }
        }
        impl Default for Cmpsel1 {
            #[inline(always)]
            fn default() -> Cmpsel1 {
                Cmpsel1(0)
            }
        }
        impl core::fmt::Debug for Cmpsel1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmpsel1")
                    .field("crvs", &self.crvs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmpsel1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cmpsel1 {{ crvs: {:?} }}", self.crvs())
            }
        }
        #[doc = "Comparator Output Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cpioc(pub u8);
        impl Cpioc {
            #[doc = "Comparator output selection"]
            #[inline(always)]
            pub const fn cpoe(&self) -> super::vals::Cpoe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cpoe::from_bits(val as u8)
            }
            #[doc = "Comparator output selection"]
            #[inline(always)]
            pub fn set_cpoe(&mut self, val: super::vals::Cpoe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_1_6(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_1_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 1usize)) | (((val as u8) & 0x3f) << 1usize);
            }
            #[doc = "Internal Vref enable"]
            #[inline(always)]
            pub const fn vrefen(&self) -> super::vals::Vrefen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Vrefen::from_bits(val as u8)
            }
            #[doc = "Internal Vref enable"]
            #[inline(always)]
            pub fn set_vrefen(&mut self, val: super::vals::Vrefen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Cpioc {
            #[inline(always)]
            fn default() -> Cpioc {
                Cpioc(0)
            }
        }
        impl core::fmt::Debug for Cpioc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cpioc")
                    .field("cpoe", &self.cpoe())
                    .field("reserved_1_6", &self.reserved_1_6())
                    .field("vrefen", &self.vrefen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cpioc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cpioc {{ cpoe: {:?}, reserved_1_6: {=u8:?}, vrefen: {:?} }}",
                    self.cpoe(),
                    self.reserved_1_6(),
                    self.vrefen()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdfs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cdfs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdfs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdfs {
            #[inline(always)]
            fn from(val: u8) -> Cdfs {
                Cdfs::from_bits(val)
            }
        }
        impl From<Cdfs> for u8 {
            #[inline(always)]
            fn from(val: Cdfs) -> u8 {
                Cdfs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ceg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ceg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ceg {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ceg {
            #[inline(always)]
            fn from(val: u8) -> Ceg {
                Ceg::from_bits(val)
            }
        }
        impl From<Ceg> for u8 {
            #[inline(always)]
            fn from(val: Ceg) -> u8 {
                Ceg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cinv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cinv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cinv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cinv {
            #[inline(always)]
            fn from(val: u8) -> Cinv {
                Cinv::from_bits(val)
            }
        }
        impl From<Cinv> for u8 {
            #[inline(always)]
            fn from(val: Cinv) -> u8 {
                Cinv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpmon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpmon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpmon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpmon {
            #[inline(always)]
            fn from(val: u8) -> Cmpmon {
                Cmpmon::from_bits(val)
            }
        }
        impl From<Cmpmon> for u8 {
            #[inline(always)]
            fn from(val: Cmpmon) -> u8 {
                Cmpmon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cmpsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpsel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpsel {
            #[inline(always)]
            fn from(val: u8) -> Cmpsel {
                Cmpsel::from_bits(val)
            }
        }
        impl From<Cmpsel> for u8 {
            #[inline(always)]
            fn from(val: Cmpsel) -> u8 {
                Cmpsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Coe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Coe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Coe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Coe {
            #[inline(always)]
            fn from(val: u8) -> Coe {
                Coe::from_bits(val)
            }
        }
        impl From<Coe> for u8 {
            #[inline(always)]
            fn from(val: Coe) -> u8 {
                Coe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cpoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpoe {
            #[inline(always)]
            fn from(val: u8) -> Cpoe {
                Cpoe::from_bits(val)
            }
        }
        impl From<Cpoe> for u8 {
            #[inline(always)]
            fn from(val: Cpoe) -> u8 {
                Cpoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crvs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
            _RESERVED_20 = 0x20,
            _RESERVED_21 = 0x21,
            _RESERVED_22 = 0x22,
            _RESERVED_23 = 0x23,
            _RESERVED_24 = 0x24,
            _RESERVED_25 = 0x25,
            _RESERVED_26 = 0x26,
            _RESERVED_27 = 0x27,
            _RESERVED_28 = 0x28,
            _RESERVED_29 = 0x29,
            _RESERVED_2a = 0x2a,
            _RESERVED_2b = 0x2b,
            _RESERVED_2c = 0x2c,
            _RESERVED_2d = 0x2d,
            _RESERVED_2e = 0x2e,
            _RESERVED_2f = 0x2f,
            _RESERVED_30 = 0x30,
            _RESERVED_31 = 0x31,
            _RESERVED_32 = 0x32,
            _RESERVED_33 = 0x33,
            _RESERVED_34 = 0x34,
            _RESERVED_35 = 0x35,
            _RESERVED_36 = 0x36,
            _RESERVED_37 = 0x37,
            _RESERVED_38 = 0x38,
            _RESERVED_39 = 0x39,
            _RESERVED_3a = 0x3a,
            _RESERVED_3b = 0x3b,
            _RESERVED_3c = 0x3c,
            _RESERVED_3d = 0x3d,
            _RESERVED_3e = 0x3e,
            _RESERVED_3f = 0x3f,
        }
        impl Crvs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crvs {
                unsafe { core::mem::transmute(val & 0x3f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crvs {
            #[inline(always)]
            fn from(val: u8) -> Crvs {
                Crvs::from_bits(val)
            }
        }
        impl From<Crvs> for u8 {
            #[inline(always)]
            fn from(val: Crvs) -> u8 {
                Crvs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hcmpon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hcmpon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hcmpon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hcmpon {
            #[inline(always)]
            fn from(val: u8) -> Hcmpon {
                Hcmpon::from_bits(val)
            }
        }
        impl From<Hcmpon> for u8 {
            #[inline(always)]
            fn from(val: Hcmpon) -> u8 {
                Hcmpon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vrefen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vrefen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vrefen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vrefen {
            #[inline(always)]
            fn from(val: u8) -> Vrefen {
                Vrefen::from_bits(val)
            }
        }
        impl From<Vrefen> for u8 {
            #[inline(always)]
            fn from(val: Vrefen) -> u8 {
                Vrefen::to_bits(val)
            }
        }
    }
}
pub mod acmplp {
    #[doc = "Low,Power Analog Comparator"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Acmplp {
        ptr: *mut u8,
    }
    unsafe impl Send for Acmplp {}
    unsafe impl Sync for Acmplp {}
    impl Acmplp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "ACMPLP Mode Setting Register"]
        #[inline(always)]
        pub const fn compmdr(self) -> crate::common::Reg<regs::Compmdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "ACMPLP Filter Control Register"]
        #[inline(always)]
        pub const fn compfir(self) -> crate::common::Reg<regs::Compfir, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "ACMPLP Output Control Register"]
        #[inline(always)]
        pub const fn compocr(self) -> crate::common::Reg<regs::Compocr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Comparator Input Select Register"]
        #[inline(always)]
        pub const fn compsel0(self) -> crate::common::Reg<regs::Compsel0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Comparator Reference voltage Select Register"]
        #[inline(always)]
        pub const fn compsel1(self) -> crate::common::Reg<regs::Compsel1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "ACMPLP Filter Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compfir(pub u8);
        impl Compfir {
            #[doc = "ACMPLP0 Edge Detection Selection"]
            #[inline(always)]
            pub const fn c0fck(&self) -> super::vals::C0fck {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::C0fck::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 Edge Detection Selection"]
            #[inline(always)]
            pub fn set_c0fck(&mut self, val: super::vals::C0fck) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "ACMPLP0 Edge Polarity Switching"]
            #[inline(always)]
            pub const fn c0epo(&self) -> super::vals::C0epo {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::C0epo::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 Edge Polarity Switching"]
            #[inline(always)]
            pub fn set_c0epo(&mut self, val: super::vals::C0epo) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "ACMPLP0 Filter Select"]
            #[inline(always)]
            pub const fn c0edg(&self) -> super::vals::C0edg {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::C0edg::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 Filter Select"]
            #[inline(always)]
            pub fn set_c0edg(&mut self, val: super::vals::C0edg) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "ACMPLP1 Edge Detection Selection"]
            #[inline(always)]
            pub const fn c1fck(&self) -> super::vals::C1fck {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::C1fck::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Edge Detection Selection"]
            #[inline(always)]
            pub fn set_c1fck(&mut self, val: super::vals::C1fck) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "ACMPLP1 Edge Polarity Switching"]
            #[inline(always)]
            pub const fn c1epo(&self) -> super::vals::C1epo {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::C1epo::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Edge Polarity Switching"]
            #[inline(always)]
            pub fn set_c1epo(&mut self, val: super::vals::C1epo) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "ACMPLP1 Filter Select"]
            #[inline(always)]
            pub const fn c1edg(&self) -> super::vals::C1edg {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::C1edg::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Filter Select"]
            #[inline(always)]
            pub fn set_c1edg(&mut self, val: super::vals::C1edg) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Compfir {
            #[inline(always)]
            fn default() -> Compfir {
                Compfir(0)
            }
        }
        impl core::fmt::Debug for Compfir {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compfir")
                    .field("c0fck", &self.c0fck())
                    .field("c0epo", &self.c0epo())
                    .field("c0edg", &self.c0edg())
                    .field("c1fck", &self.c1fck())
                    .field("c1epo", &self.c1epo())
                    .field("c1edg", &self.c1edg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compfir {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Compfir {{ c0fck: {:?}, c0epo: {:?}, c0edg: {:?}, c1fck: {:?}, c1epo: {:?}, c1edg: {:?} }}" , self . c0fck () , self . c0epo () , self . c0edg () , self . c1fck () , self . c1epo () , self . c1edg ())
            }
        }
        #[doc = "ACMPLP Mode Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compmdr(pub u8);
        impl Compmdr {
            #[doc = "ACMPLP0 Operation Enable"]
            #[inline(always)]
            pub const fn c0enb(&self) -> super::vals::C0enb {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::C0enb::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 Operation Enable"]
            #[inline(always)]
            pub fn set_c0enb(&mut self, val: super::vals::C0enb) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "ACMPLP0 Window Function Mode Enable"]
            #[inline(always)]
            pub const fn c0wde(&self) -> super::vals::C0wde {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::C0wde::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 Window Function Mode Enable"]
            #[inline(always)]
            pub fn set_c0wde(&mut self, val: super::vals::C0wde) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "ACMPLP0 Reference Voltage SelectionNote1: It's effective only at the time of standard mode.IVREF0 and IVREF1 are chosen at window mode condition in spite of setting of this bit."]
            #[inline(always)]
            pub const fn c0vrf(&self) -> super::vals::C0vrf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::C0vrf::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 Reference Voltage SelectionNote1: It's effective only at the time of standard mode.IVREF0 and IVREF1 are chosen at window mode condition in spite of setting of this bit."]
            #[inline(always)]
            pub fn set_c0vrf(&mut self, val: super::vals::C0vrf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "ACMPLP0 Monitor Flag"]
            #[inline(always)]
            pub const fn c0mon(&self) -> super::vals::C0mon {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::C0mon::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 Monitor Flag"]
            #[inline(always)]
            pub fn set_c0mon(&mut self, val: super::vals::C0mon) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "ACMPLP1 Operation Enable"]
            #[inline(always)]
            pub const fn c1enb(&self) -> super::vals::C1enb {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::C1enb::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Operation Enable"]
            #[inline(always)]
            pub fn set_c1enb(&mut self, val: super::vals::C1enb) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "ACMPLP1 Window Function Mode Enable"]
            #[inline(always)]
            pub const fn c1wde(&self) -> super::vals::C1wde {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::C1wde::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Window Function Mode Enable"]
            #[inline(always)]
            pub fn set_c1wde(&mut self, val: super::vals::C1wde) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "ACMPLP1 Reference Voltage SelectionNote1: It's effective only at the time of standard mode.IVREF0 and IVREF1 are chosen at window mode condition in spite of setting of this bit."]
            #[inline(always)]
            pub const fn c1vrf(&self) -> super::vals::C1vrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::C1vrf::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Reference Voltage SelectionNote1: It's effective only at the time of standard mode.IVREF0 and IVREF1 are chosen at window mode condition in spite of setting of this bit."]
            #[inline(always)]
            pub fn set_c1vrf(&mut self, val: super::vals::C1vrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "ACMPLP1 Monitor Flag"]
            #[inline(always)]
            pub const fn c1mon(&self) -> super::vals::C1mon {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::C1mon::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Monitor Flag"]
            #[inline(always)]
            pub fn set_c1mon(&mut self, val: super::vals::C1mon) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Compmdr {
            #[inline(always)]
            fn default() -> Compmdr {
                Compmdr(0)
            }
        }
        impl core::fmt::Debug for Compmdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compmdr")
                    .field("c0enb", &self.c0enb())
                    .field("c0wde", &self.c0wde())
                    .field("c0vrf", &self.c0vrf())
                    .field("c0mon", &self.c0mon())
                    .field("c1enb", &self.c1enb())
                    .field("c1wde", &self.c1wde())
                    .field("c1vrf", &self.c1vrf())
                    .field("c1mon", &self.c1mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compmdr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Compmdr {{ c0enb: {:?}, c0wde: {:?}, c0vrf: {:?}, c0mon: {:?}, c1enb: {:?}, c1wde: {:?}, c1vrf: {:?}, c1mon: {:?} }}" , self . c0enb () , self . c0wde () , self . c0vrf () , self . c0mon () , self . c1enb () , self . c1wde () , self . c1vrf () , self . c1mon ())
            }
        }
        #[doc = "ACMPLP Output Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compocr(pub u8);
        impl Compocr {
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_0_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_0_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "ACMPLP0 VCOUT Pin Output Enable"]
            #[inline(always)]
            pub const fn c0oe(&self) -> super::vals::C0oe {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::C0oe::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 VCOUT Pin Output Enable"]
            #[inline(always)]
            pub fn set_c0oe(&mut self, val: super::vals::C0oe) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "ACMPLP0 VCOUT Output Polarity Selection"]
            #[inline(always)]
            pub const fn c0op(&self) -> super::vals::C0op {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::C0op::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 VCOUT Output Polarity Selection"]
            #[inline(always)]
            pub fn set_c0op(&mut self, val: super::vals::C0op) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_3_4(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_3_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val as u8) & 0x03) << 3usize);
            }
            #[doc = "ACMPLP1 VCOUT Pin Output Enable"]
            #[inline(always)]
            pub const fn c1oe(&self) -> super::vals::C1oe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::C1oe::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 VCOUT Pin Output Enable"]
            #[inline(always)]
            pub fn set_c1oe(&mut self, val: super::vals::C1oe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "ACMPLP1 VCOUT Output Polarity Selection"]
            #[inline(always)]
            pub const fn c1op(&self) -> super::vals::C1op {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::C1op::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 VCOUT Output Polarity Selection"]
            #[inline(always)]
            pub fn set_c1op(&mut self, val: super::vals::C1op) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "ACMPLP0/ACMPLP1 Speed Selection"]
            #[inline(always)]
            pub const fn spdmd(&self) -> super::vals::Spdmd {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Spdmd::from_bits(val as u8)
            }
            #[doc = "ACMPLP0/ACMPLP1 Speed Selection"]
            #[inline(always)]
            pub fn set_spdmd(&mut self, val: super::vals::Spdmd) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Compocr {
            #[inline(always)]
            fn default() -> Compocr {
                Compocr(0)
            }
        }
        impl core::fmt::Debug for Compocr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compocr")
                    .field("reserved_0_0", &self.reserved_0_0())
                    .field("c0oe", &self.c0oe())
                    .field("c0op", &self.c0op())
                    .field("reserved_3_4", &self.reserved_3_4())
                    .field("c1oe", &self.c1oe())
                    .field("c1op", &self.c1op())
                    .field("spdmd", &self.spdmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compocr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Compocr {{ reserved_0_0: {=bool:?}, c0oe: {:?}, c0op: {:?}, reserved_3_4: {=u8:?}, c1oe: {:?}, c1op: {:?}, spdmd: {:?} }}" , self . reserved_0_0 () , self . c0oe () , self . c0op () , self . reserved_3_4 () , self . c1oe () , self . c1op () , self . spdmd ())
            }
        }
        #[doc = "Comparator Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compsel0(pub u8);
        impl Compsel0 {
            #[doc = "ACMPLP0 Input (IVCMP0) Selection"]
            #[inline(always)]
            pub const fn cmpsel10(&self) -> super::vals::Cmpsel10 {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Cmpsel10::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 Input (IVCMP0) Selection"]
            #[inline(always)]
            pub fn set_cmpsel10(&mut self, val: super::vals::Cmpsel10) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_2_3(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_2_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "ACMPLP1 Input (IVCMP1) Selection"]
            #[inline(always)]
            pub const fn cmpsel54(&self) -> super::vals::Cmpsel54 {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Cmpsel54::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Input (IVCMP1) Selection"]
            #[inline(always)]
            pub fn set_cmpsel54(&mut self, val: super::vals::Cmpsel54) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Compsel0 {
            #[inline(always)]
            fn default() -> Compsel0 {
                Compsel0(0)
            }
        }
        impl core::fmt::Debug for Compsel0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compsel0")
                    .field("cmpsel10", &self.cmpsel10())
                    .field("reserved_2_3", &self.reserved_2_3())
                    .field("cmpsel54", &self.cmpsel54())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compsel0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Compsel0 {{ cmpsel10: {:?}, reserved_2_3: {=u8:?}, cmpsel54: {:?}, reserved_6_7: {=u8:?} }}" , self . cmpsel10 () , self . reserved_2_3 () , self . cmpsel54 () , self . reserved_6_7 ())
            }
        }
        #[doc = "Comparator Reference voltage Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compsel1(pub u8);
        impl Compsel1 {
            #[doc = "ACMPLP0 Reference Voltage (IVREF0) Selection"]
            #[inline(always)]
            pub const fn crvs10(&self) -> super::vals::Crvs10 {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Crvs10::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 Reference Voltage (IVREF0) Selection"]
            #[inline(always)]
            pub fn set_crvs10(&mut self, val: super::vals::Crvs10) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_2_3(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_2_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "ACMPLP1 Reference Voltage(IVREF1) Selection"]
            #[inline(always)]
            pub const fn crvs54(&self) -> super::vals::Crvs54 {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Crvs54::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Reference Voltage(IVREF1) Selection"]
            #[inline(always)]
            pub fn set_crvs54(&mut self, val: super::vals::Crvs54) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "ACMPLP1 Reference Voltage Selection"]
            #[inline(always)]
            pub const fn c1vrf2(&self) -> super::vals::C1vrf2 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::C1vrf2::from_bits(val as u8)
            }
            #[doc = "ACMPLP1 Reference Voltage Selection"]
            #[inline(always)]
            pub fn set_c1vrf2(&mut self, val: super::vals::C1vrf2) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Compsel1 {
            #[inline(always)]
            fn default() -> Compsel1 {
                Compsel1(0)
            }
        }
        impl core::fmt::Debug for Compsel1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compsel1")
                    .field("crvs10", &self.crvs10())
                    .field("reserved_2_3", &self.reserved_2_3())
                    .field("crvs54", &self.crvs54())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("c1vrf2", &self.c1vrf2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compsel1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Compsel1 {{ crvs10: {:?}, reserved_2_3: {=u8:?}, crvs54: {:?}, reserved_6_6: {=bool:?}, c1vrf2: {:?} }}" , self . crvs10 () , self . reserved_2_3 () , self . crvs54 () , self . reserved_6_6 () , self . c1vrf2 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C0edg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C0edg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C0edg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C0edg {
            #[inline(always)]
            fn from(val: u8) -> C0edg {
                C0edg::from_bits(val)
            }
        }
        impl From<C0edg> for u8 {
            #[inline(always)]
            fn from(val: C0edg) -> u8 {
                C0edg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C0enb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C0enb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C0enb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C0enb {
            #[inline(always)]
            fn from(val: u8) -> C0enb {
                C0enb::from_bits(val)
            }
        }
        impl From<C0enb> for u8 {
            #[inline(always)]
            fn from(val: C0enb) -> u8 {
                C0enb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C0epo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C0epo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C0epo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C0epo {
            #[inline(always)]
            fn from(val: u8) -> C0epo {
                C0epo::from_bits(val)
            }
        }
        impl From<C0epo> for u8 {
            #[inline(always)]
            fn from(val: C0epo) -> u8 {
                C0epo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C0fck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl C0fck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C0fck {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C0fck {
            #[inline(always)]
            fn from(val: u8) -> C0fck {
                C0fck::from_bits(val)
            }
        }
        impl From<C0fck> for u8 {
            #[inline(always)]
            fn from(val: C0fck) -> u8 {
                C0fck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C0mon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C0mon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C0mon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C0mon {
            #[inline(always)]
            fn from(val: u8) -> C0mon {
                C0mon::from_bits(val)
            }
        }
        impl From<C0mon> for u8 {
            #[inline(always)]
            fn from(val: C0mon) -> u8 {
                C0mon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C0oe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C0oe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C0oe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C0oe {
            #[inline(always)]
            fn from(val: u8) -> C0oe {
                C0oe::from_bits(val)
            }
        }
        impl From<C0oe> for u8 {
            #[inline(always)]
            fn from(val: C0oe) -> u8 {
                C0oe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C0op {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C0op {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C0op {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C0op {
            #[inline(always)]
            fn from(val: u8) -> C0op {
                C0op::from_bits(val)
            }
        }
        impl From<C0op> for u8 {
            #[inline(always)]
            fn from(val: C0op) -> u8 {
                C0op::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C0vrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C0vrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C0vrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C0vrf {
            #[inline(always)]
            fn from(val: u8) -> C0vrf {
                C0vrf::from_bits(val)
            }
        }
        impl From<C0vrf> for u8 {
            #[inline(always)]
            fn from(val: C0vrf) -> u8 {
                C0vrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C0wde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C0wde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C0wde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C0wde {
            #[inline(always)]
            fn from(val: u8) -> C0wde {
                C0wde::from_bits(val)
            }
        }
        impl From<C0wde> for u8 {
            #[inline(always)]
            fn from(val: C0wde) -> u8 {
                C0wde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1edg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C1edg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1edg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1edg {
            #[inline(always)]
            fn from(val: u8) -> C1edg {
                C1edg::from_bits(val)
            }
        }
        impl From<C1edg> for u8 {
            #[inline(always)]
            fn from(val: C1edg) -> u8 {
                C1edg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1enb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C1enb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1enb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1enb {
            #[inline(always)]
            fn from(val: u8) -> C1enb {
                C1enb::from_bits(val)
            }
        }
        impl From<C1enb> for u8 {
            #[inline(always)]
            fn from(val: C1enb) -> u8 {
                C1enb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1epo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C1epo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1epo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1epo {
            #[inline(always)]
            fn from(val: u8) -> C1epo {
                C1epo::from_bits(val)
            }
        }
        impl From<C1epo> for u8 {
            #[inline(always)]
            fn from(val: C1epo) -> u8 {
                C1epo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1fck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl C1fck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1fck {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1fck {
            #[inline(always)]
            fn from(val: u8) -> C1fck {
                C1fck::from_bits(val)
            }
        }
        impl From<C1fck> for u8 {
            #[inline(always)]
            fn from(val: C1fck) -> u8 {
                C1fck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1mon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C1mon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1mon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1mon {
            #[inline(always)]
            fn from(val: u8) -> C1mon {
                C1mon::from_bits(val)
            }
        }
        impl From<C1mon> for u8 {
            #[inline(always)]
            fn from(val: C1mon) -> u8 {
                C1mon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1oe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C1oe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1oe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1oe {
            #[inline(always)]
            fn from(val: u8) -> C1oe {
                C1oe::from_bits(val)
            }
        }
        impl From<C1oe> for u8 {
            #[inline(always)]
            fn from(val: C1oe) -> u8 {
                C1oe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1op {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C1op {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1op {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1op {
            #[inline(always)]
            fn from(val: u8) -> C1op {
                C1op::from_bits(val)
            }
        }
        impl From<C1op> for u8 {
            #[inline(always)]
            fn from(val: C1op) -> u8 {
                C1op::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1vrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C1vrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1vrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1vrf {
            #[inline(always)]
            fn from(val: u8) -> C1vrf {
                C1vrf::from_bits(val)
            }
        }
        impl From<C1vrf> for u8 {
            #[inline(always)]
            fn from(val: C1vrf) -> u8 {
                C1vrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1vrf2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C1vrf2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1vrf2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1vrf2 {
            #[inline(always)]
            fn from(val: u8) -> C1vrf2 {
                C1vrf2::from_bits(val)
            }
        }
        impl From<C1vrf2> for u8 {
            #[inline(always)]
            fn from(val: C1vrf2) -> u8 {
                C1vrf2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum C1wde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl C1wde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> C1wde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for C1wde {
            #[inline(always)]
            fn from(val: u8) -> C1wde {
                C1wde::from_bits(val)
            }
        }
        impl From<C1wde> for u8 {
            #[inline(always)]
            fn from(val: C1wde) -> u8 {
                C1wde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpsel10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cmpsel10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpsel10 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpsel10 {
            #[inline(always)]
            fn from(val: u8) -> Cmpsel10 {
                Cmpsel10::from_bits(val)
            }
        }
        impl From<Cmpsel10> for u8 {
            #[inline(always)]
            fn from(val: Cmpsel10) -> u8 {
                Cmpsel10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpsel54 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cmpsel54 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpsel54 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpsel54 {
            #[inline(always)]
            fn from(val: u8) -> Cmpsel54 {
                Cmpsel54::from_bits(val)
            }
        }
        impl From<Cmpsel54> for u8 {
            #[inline(always)]
            fn from(val: Cmpsel54) -> u8 {
                Cmpsel54::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crvs10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Crvs10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crvs10 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crvs10 {
            #[inline(always)]
            fn from(val: u8) -> Crvs10 {
                Crvs10::from_bits(val)
            }
        }
        impl From<Crvs10> for u8 {
            #[inline(always)]
            fn from(val: Crvs10) -> u8 {
                Crvs10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crvs54 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Crvs54 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crvs54 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crvs54 {
            #[inline(always)]
            fn from(val: u8) -> Crvs54 {
                Crvs54::from_bits(val)
            }
        }
        impl From<Crvs54> for u8 {
            #[inline(always)]
            fn from(val: Crvs54) -> u8 {
                Crvs54::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spdmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spdmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spdmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spdmd {
            #[inline(always)]
            fn from(val: u8) -> Spdmd {
                Spdmd::from_bits(val)
            }
        }
        impl From<Spdmd> for u8 {
            #[inline(always)]
            fn from(val: Spdmd) -> u8 {
                Spdmd::to_bits(val)
            }
        }
    }
}
pub mod adc160 {
    #[doc = "16-bit A/D Converter"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Adc160 {
        ptr: *mut u8,
    }
    unsafe impl Send for Adc160 {}
    unsafe impl Sync for Adc160 {}
    impl Adc160 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A/D Control Register"]
        #[inline(always)]
        pub const fn adcsr(self) -> crate::common::Reg<regs::Adcsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "A/D Channel Select Register A0"]
        #[inline(always)]
        pub const fn adansa0(self) -> crate::common::Reg<regs::Adansa0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "A/D Channel Select Register A1"]
        #[inline(always)]
        pub const fn adansa1(self) -> crate::common::Reg<regs::Adansa1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "A/D,Converted Value Average Channel Select Register 0"]
        #[inline(always)]
        pub const fn adads0(self) -> crate::common::Reg<regs::Adads0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "A/D,Converted Value Average Channel Select Register 1"]
        #[inline(always)]
        pub const fn adads1(self) -> crate::common::Reg<regs::Adads1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "A/D,Converted Value Average Count Select Register"]
        #[inline(always)]
        pub const fn adadc(self) -> crate::common::Reg<regs::Adadc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "A/D Control Extended Register"]
        #[inline(always)]
        pub const fn adcer(self) -> crate::common::Reg<regs::Adcer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "A/D Conversion Start Trigger Select Register"]
        #[inline(always)]
        pub const fn adstrgr(self) -> crate::common::Reg<regs::Adstrgr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "A/D Conversion Extended Input Control Register"]
        #[inline(always)]
        pub const fn adexicr(self) -> crate::common::Reg<regs::Adexicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "A/D Channel Select Register B0"]
        #[inline(always)]
        pub const fn adansb0(self) -> crate::common::Reg<regs::Adansb0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "A/D Channel Select Register B1"]
        #[inline(always)]
        pub const fn adansb1(self) -> crate::common::Reg<regs::Adansb1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "A/D Data Duplexing Register"]
        #[inline(always)]
        pub const fn addbldr(self) -> crate::common::Reg<regs::Addbldr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "A/D Temperature Sensor Data Register"]
        #[inline(always)]
        pub const fn adtsdr(self) -> crate::common::Reg<regs::Adtsdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "A/D Internal Reference Voltage Data Register"]
        #[inline(always)]
        pub const fn adocdr(self) -> crate::common::Reg<regs::Adocdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "A/D Data Register %s"]
        #[inline(always)]
        pub const fn addr(self, n: usize) -> crate::common::Reg<regs::Addr, crate::common::R> {
            assert!(n < 9usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 2usize) as _) }
        }
        #[doc = "A/D Data Register %s"]
        #[inline(always)]
        pub const fn addr_1(self, n: usize) -> crate::common::Reg<regs::Addr1, crate::common::R> {
            assert!(n < 9usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 2usize) as _) }
        }
        #[doc = "A/D Disconnection Detection Control Register"]
        #[inline(always)]
        pub const fn addiscr(self) -> crate::common::Reg<regs::Addiscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7ausize) as _) }
        }
        #[doc = "A/D Interrupt Control Register"]
        #[inline(always)]
        pub const fn adicr(self) -> crate::common::Reg<regs::Adicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7dusize) as _) }
        }
        #[doc = "A/D Group Scan Priority Control Register"]
        #[inline(always)]
        pub const fn adgspcr(self) -> crate::common::Reg<regs::Adgspcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "A/D Data Duplexing Register A"]
        #[inline(always)]
        pub const fn addbldra(self) -> crate::common::Reg<regs::Addbldra, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "A/D Data Duplexing Register B"]
        #[inline(always)]
        pub const fn addbldrb(self) -> crate::common::Reg<regs::Addbldrb, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x86usize) as _) }
        }
        #[doc = "A/D Compare Function Window A/B Status Monitor Register"]
        #[inline(always)]
        pub const fn adwinmon(self) -> crate::common::Reg<regs::Adwinmon, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "A/D Compare Function Control Register"]
        #[inline(always)]
        pub const fn adcmpcr(self) -> crate::common::Reg<regs::Adcmpcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Extended Input Select Register"]
        #[inline(always)]
        pub const fn adcmpanser(self) -> crate::common::Reg<regs::Adcmpanser, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x92usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Extended Input Comparison Condition Setting Register"]
        #[inline(always)]
        pub const fn adcmpler(self) -> crate::common::Reg<regs::Adcmpler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x93usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 0"]
        #[inline(always)]
        pub const fn adcmpansr0(self) -> crate::common::Reg<regs::Adcmpansr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 1"]
        #[inline(always)]
        pub const fn adcmpansr1(self) -> crate::common::Reg<regs::Adcmpansr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x96usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 0"]
        #[inline(always)]
        pub const fn adcmplr0(self) -> crate::common::Reg<regs::Adcmplr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 1"]
        #[inline(always)]
        pub const fn adcmplr1(self) -> crate::common::Reg<regs::Adcmplr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9ausize) as _) }
        }
        #[doc = "A/D Compare Function Window A Lower,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adcmpdr0(self) -> crate::common::Reg<regs::Adcmpdr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize) as _) }
        }
        #[doc = "A/D Compare Function Window A Upper,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adcmpdr1(self) -> crate::common::Reg<regs::Adcmpdr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9eusize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register 0"]
        #[inline(always)]
        pub const fn adcmpsr0(self) -> crate::common::Reg<regs::Adcmpsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register 1"]
        #[inline(always)]
        pub const fn adcmpsr1(self) -> crate::common::Reg<regs::Adcmpsr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa2usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Extended Input Channel Status Register"]
        #[inline(always)]
        pub const fn adcmpser(self) -> crate::common::Reg<regs::Adcmpser, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "A/D Compare Function Window B Channel Selection Register"]
        #[inline(always)]
        pub const fn adcmpbnsr(self) -> crate::common::Reg<regs::Adcmpbnsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa6usize) as _) }
        }
        #[doc = "A/D Compare Function Window B Lower,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adwinllb(self) -> crate::common::Reg<regs::Adwinllb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "A/D Compare Function Window B Upper,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adwinulb(self) -> crate::common::Reg<regs::Adwinulb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xaausize) as _) }
        }
        #[doc = "A/D Compare Function Window B Status Register"]
        #[inline(always)]
        pub const fn adcmpbsr(self) -> crate::common::Reg<regs::Adcmpbsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xacusize) as _) }
        }
        #[doc = "A/D Sampling State Register L"]
        #[inline(always)]
        pub const fn adsstrl(self) -> crate::common::Reg<regs::Adsstrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xddusize) as _) }
        }
        #[doc = "A/D Sampling State Register T"]
        #[inline(always)]
        pub const fn adsstrt(self) -> crate::common::Reg<regs::Adsstrt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdeusize) as _) }
        }
        #[doc = "A/D Sampling State Register O"]
        #[inline(always)]
        pub const fn adsstro(self) -> crate::common::Reg<regs::Adsstro, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdfusize) as _) }
        }
        #[doc = "A/D Sampling State Register %s"]
        #[inline(always)]
        pub const fn adsstr0(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Adsstr0, crate::common::RW> {
            assert!(n < 9usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize + n * 1usize) as _) }
        }
        #[doc = "A/D Channel Input Mode Select Register"]
        #[inline(always)]
        pub const fn adanim(self) -> crate::common::Reg<regs::Adanim, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf0usize) as _) }
        }
        #[doc = "A/D Calibration Execution Register"]
        #[inline(always)]
        pub const fn adcalexe(self) -> crate::common::Reg<regs::Adcalexe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf2usize) as _) }
        }
        #[doc = "A/D Dedicated Reference Voltage Circuit Control Register"]
        #[inline(always)]
        pub const fn vrefampcnt(self) -> crate::common::Reg<regs::Vrefampcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf4usize) as _) }
        }
        #[doc = "A/D Self,Diagnosis Data Register"]
        #[inline(always)]
        pub const fn adrd(self) -> crate::common::Reg<regs::Adrd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf8usize) as _) }
        }
        #[doc = "A/D Self,Diagnostic Status Register"]
        #[inline(always)]
        pub const fn adrst(self) -> crate::common::Reg<regs::Adrst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xfausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "A/D,Converted Value Average Count Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adadc(pub u8);
        impl Adadc {
            #[doc = "Count Select"]
            #[inline(always)]
            pub const fn adc(&self) -> super::vals::Adc {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Adc::from_bits(val as u8)
            }
            #[doc = "Count Select"]
            #[inline(always)]
            pub fn set_adc(&mut self, val: super::vals::Adc) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Adadc {
            #[inline(always)]
            fn default() -> Adadc {
                Adadc(0)
            }
        }
        impl core::fmt::Debug for Adadc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adadc")
                    .field("adc", &self.adc())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adadc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adadc {{ adc: {:?}, reserved_3_7: {=u8:?} }}",
                    self.adc(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "A/D,Converted Value Average Channel Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adads0(pub u16);
        impl Adads0 {
            #[doc = "A/D,Converted Value Average Channel AN000 Select"]
            #[inline(always)]
            pub const fn ads00(&self) -> super::vals::Ads00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ads00::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN000 Select"]
            #[inline(always)]
            pub fn set_ads00(&mut self, val: super::vals::Ads00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN001 Select"]
            #[inline(always)]
            pub const fn ads01(&self) -> super::vals::Ads01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ads01::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN001 Select"]
            #[inline(always)]
            pub fn set_ads01(&mut self, val: super::vals::Ads01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN002 Select"]
            #[inline(always)]
            pub const fn ads02(&self) -> super::vals::Ads02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ads02::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN002 Select"]
            #[inline(always)]
            pub fn set_ads02(&mut self, val: super::vals::Ads02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN003 Select"]
            #[inline(always)]
            pub const fn ads03(&self) -> super::vals::Ads03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ads03::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN003 Select"]
            #[inline(always)]
            pub fn set_ads03(&mut self, val: super::vals::Ads03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN004 Select"]
            #[inline(always)]
            pub const fn ads04(&self) -> super::vals::Ads04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ads04::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN004 Select"]
            #[inline(always)]
            pub fn set_ads04(&mut self, val: super::vals::Ads04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN005 Select"]
            #[inline(always)]
            pub const fn ads05(&self) -> super::vals::Ads05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ads05::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN005 Select"]
            #[inline(always)]
            pub fn set_ads05(&mut self, val: super::vals::Ads05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN006 Select"]
            #[inline(always)]
            pub const fn ads06(&self) -> super::vals::Ads06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ads06::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN006 Select"]
            #[inline(always)]
            pub fn set_ads06(&mut self, val: super::vals::Ads06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN007 Select"]
            #[inline(always)]
            pub const fn ads07(&self) -> super::vals::Ads07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ads07::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN007 Select"]
            #[inline(always)]
            pub fn set_ads07(&mut self, val: super::vals::Ads07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN008 Select"]
            #[inline(always)]
            pub const fn ads08(&self) -> super::vals::Ads08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ads08::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN008 Select"]
            #[inline(always)]
            pub fn set_ads08(&mut self, val: super::vals::Ads08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adads0 {
            #[inline(always)]
            fn default() -> Adads0 {
                Adads0(0)
            }
        }
        impl core::fmt::Debug for Adads0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adads0")
                    .field("ads00", &self.ads00())
                    .field("ads01", &self.ads01())
                    .field("ads02", &self.ads02())
                    .field("ads03", &self.ads03())
                    .field("ads04", &self.ads04())
                    .field("ads05", &self.ads05())
                    .field("ads06", &self.ads06())
                    .field("ads07", &self.ads07())
                    .field("ads08", &self.ads08())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adads0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adads0 {{ ads00: {:?}, ads01: {:?}, ads02: {:?}, ads03: {:?}, ads04: {:?}, ads05: {:?}, ads06: {:?}, ads07: {:?}, ads08: {:?}, reserved_9_15: {=u8:?} }}" , self . ads00 () , self . ads01 () , self . ads02 () , self . ads03 () , self . ads04 () , self . ads05 () , self . ads06 () , self . ads07 () , self . ads08 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D,Converted Value Average Channel Select Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adads1(pub u16);
        impl Adads1 {
            #[doc = "A/D,Converted Value Average Channel AN016 Select"]
            #[inline(always)]
            pub const fn ads16(&self) -> super::vals::Ads16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ads16::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN016 Select"]
            #[inline(always)]
            pub fn set_ads16(&mut self, val: super::vals::Ads16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN017 Select"]
            #[inline(always)]
            pub const fn ads17(&self) -> super::vals::Ads17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ads17::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN017 Select"]
            #[inline(always)]
            pub fn set_ads17(&mut self, val: super::vals::Ads17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN018 Select"]
            #[inline(always)]
            pub const fn ads18(&self) -> super::vals::Ads18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ads18::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN018 Select"]
            #[inline(always)]
            pub fn set_ads18(&mut self, val: super::vals::Ads18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN019 Select"]
            #[inline(always)]
            pub const fn ads19(&self) -> super::vals::Ads19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ads19::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN019 Select"]
            #[inline(always)]
            pub fn set_ads19(&mut self, val: super::vals::Ads19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN020 Select"]
            #[inline(always)]
            pub const fn ads20(&self) -> super::vals::Ads20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ads20::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN020 Select"]
            #[inline(always)]
            pub fn set_ads20(&mut self, val: super::vals::Ads20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN021 Select"]
            #[inline(always)]
            pub const fn ads21(&self) -> super::vals::Ads21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ads21::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN021 Select"]
            #[inline(always)]
            pub fn set_ads21(&mut self, val: super::vals::Ads21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN022 Select"]
            #[inline(always)]
            pub const fn ads22(&self) -> super::vals::Ads22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ads22::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN022 Select"]
            #[inline(always)]
            pub fn set_ads22(&mut self, val: super::vals::Ads22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN023 Select"]
            #[inline(always)]
            pub const fn ads23(&self) -> super::vals::Ads23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ads23::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN023 Select"]
            #[inline(always)]
            pub fn set_ads23(&mut self, val: super::vals::Ads23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "A/D,Converted Value Average Channel AN024 Select"]
            #[inline(always)]
            pub const fn ads24(&self) -> super::vals::Ads24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ads24::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Average Channel AN024 Select"]
            #[inline(always)]
            pub fn set_ads24(&mut self, val: super::vals::Ads24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adads1 {
            #[inline(always)]
            fn default() -> Adads1 {
                Adads1(0)
            }
        }
        impl core::fmt::Debug for Adads1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adads1")
                    .field("ads16", &self.ads16())
                    .field("ads17", &self.ads17())
                    .field("ads18", &self.ads18())
                    .field("ads19", &self.ads19())
                    .field("ads20", &self.ads20())
                    .field("ads21", &self.ads21())
                    .field("ads22", &self.ads22())
                    .field("ads23", &self.ads23())
                    .field("ads24", &self.ads24())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adads1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adads1 {{ ads16: {:?}, ads17: {:?}, ads18: {:?}, ads19: {:?}, ads20: {:?}, ads21: {:?}, ads22: {:?}, ads23: {:?}, ads24: {:?}, reserved_9_15: {=u8:?} }}" , self . ads16 () , self . ads17 () , self . ads18 () , self . ads19 () , self . ads20 () , self . ads21 () , self . ads22 () , self . ads23 () , self . ads24 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Channel Input Mode Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adanim(pub u16);
        impl Adanim {
            #[doc = "Analog Channel Input Mode Select"]
            #[inline(always)]
            pub const fn anim(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Analog Channel Input Mode Select"]
            #[inline(always)]
            pub fn set_anim(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub const fn reserved_4_15(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub fn set_reserved_4_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u16) & 0x0fff) << 4usize);
            }
        }
        impl Default for Adanim {
            #[inline(always)]
            fn default() -> Adanim {
                Adanim(0)
            }
        }
        impl core::fmt::Debug for Adanim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adanim")
                    .field("anim", &self.anim())
                    .field("reserved_4_15", &self.reserved_4_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adanim {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adanim {{ anim: {=u8:?}, reserved_4_15: {=u16:?} }}",
                    self.anim(),
                    self.reserved_4_15()
                )
            }
        }
        #[doc = "A/D Channel Select Register A0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansa0(pub u16);
        impl Adansa0 {
            #[doc = "AN000 Select"]
            #[inline(always)]
            pub const fn ansa00(&self) -> super::vals::Ansa00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansa00::from_bits(val as u8)
            }
            #[doc = "AN000 Select"]
            #[inline(always)]
            pub fn set_ansa00(&mut self, val: super::vals::Ansa00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "AN001 Select"]
            #[inline(always)]
            pub const fn ansa01(&self) -> super::vals::Ansa01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansa01::from_bits(val as u8)
            }
            #[doc = "AN001 Select"]
            #[inline(always)]
            pub fn set_ansa01(&mut self, val: super::vals::Ansa01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "AN002 Select"]
            #[inline(always)]
            pub const fn ansa02(&self) -> super::vals::Ansa02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansa02::from_bits(val as u8)
            }
            #[doc = "AN002 Select"]
            #[inline(always)]
            pub fn set_ansa02(&mut self, val: super::vals::Ansa02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "AN003 Select"]
            #[inline(always)]
            pub const fn ansa03(&self) -> super::vals::Ansa03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansa03::from_bits(val as u8)
            }
            #[doc = "AN003 Select"]
            #[inline(always)]
            pub fn set_ansa03(&mut self, val: super::vals::Ansa03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "AN004 Select"]
            #[inline(always)]
            pub const fn ansa04(&self) -> super::vals::Ansa04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ansa04::from_bits(val as u8)
            }
            #[doc = "AN004 Select"]
            #[inline(always)]
            pub fn set_ansa04(&mut self, val: super::vals::Ansa04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "AN005 Select"]
            #[inline(always)]
            pub const fn ansa05(&self) -> super::vals::Ansa05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ansa05::from_bits(val as u8)
            }
            #[doc = "AN005 Select"]
            #[inline(always)]
            pub fn set_ansa05(&mut self, val: super::vals::Ansa05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "AN006 Select"]
            #[inline(always)]
            pub const fn ansa06(&self) -> super::vals::Ansa06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ansa06::from_bits(val as u8)
            }
            #[doc = "AN006 Select"]
            #[inline(always)]
            pub fn set_ansa06(&mut self, val: super::vals::Ansa06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "AN007 Select"]
            #[inline(always)]
            pub const fn ansa07(&self) -> super::vals::Ansa07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ansa07::from_bits(val as u8)
            }
            #[doc = "AN007 Select"]
            #[inline(always)]
            pub fn set_ansa07(&mut self, val: super::vals::Ansa07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "AN008 Select"]
            #[inline(always)]
            pub const fn ansa08(&self) -> super::vals::Ansa08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ansa08::from_bits(val as u8)
            }
            #[doc = "AN008 Select"]
            #[inline(always)]
            pub fn set_ansa08(&mut self, val: super::vals::Ansa08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adansa0 {
            #[inline(always)]
            fn default() -> Adansa0 {
                Adansa0(0)
            }
        }
        impl core::fmt::Debug for Adansa0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansa0")
                    .field("ansa00", &self.ansa00())
                    .field("ansa01", &self.ansa01())
                    .field("ansa02", &self.ansa02())
                    .field("ansa03", &self.ansa03())
                    .field("ansa04", &self.ansa04())
                    .field("ansa05", &self.ansa05())
                    .field("ansa06", &self.ansa06())
                    .field("ansa07", &self.ansa07())
                    .field("ansa08", &self.ansa08())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansa0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adansa0 {{ ansa00: {:?}, ansa01: {:?}, ansa02: {:?}, ansa03: {:?}, ansa04: {:?}, ansa05: {:?}, ansa06: {:?}, ansa07: {:?}, ansa08: {:?}, reserved_9_15: {=u8:?} }}" , self . ansa00 () , self . ansa01 () , self . ansa02 () , self . ansa03 () , self . ansa04 () , self . ansa05 () , self . ansa06 () , self . ansa07 () , self . ansa08 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Channel Select Register A1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansa1(pub u16);
        impl Adansa1 {
            #[doc = "AN016 Select"]
            #[inline(always)]
            pub const fn ansa16(&self) -> super::vals::Ansa16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansa16::from_bits(val as u8)
            }
            #[doc = "AN016 Select"]
            #[inline(always)]
            pub fn set_ansa16(&mut self, val: super::vals::Ansa16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "AN017 Select"]
            #[inline(always)]
            pub const fn ansa17(&self) -> super::vals::Ansa17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansa17::from_bits(val as u8)
            }
            #[doc = "AN017 Select"]
            #[inline(always)]
            pub fn set_ansa17(&mut self, val: super::vals::Ansa17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "AN018 Select"]
            #[inline(always)]
            pub const fn ansa18(&self) -> super::vals::Ansa18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansa18::from_bits(val as u8)
            }
            #[doc = "AN018 Select"]
            #[inline(always)]
            pub fn set_ansa18(&mut self, val: super::vals::Ansa18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "AN019 Select"]
            #[inline(always)]
            pub const fn ansa19(&self) -> super::vals::Ansa19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansa19::from_bits(val as u8)
            }
            #[doc = "AN019 Select"]
            #[inline(always)]
            pub fn set_ansa19(&mut self, val: super::vals::Ansa19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "AN020 Select"]
            #[inline(always)]
            pub const fn ansa20(&self) -> super::vals::Ansa20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ansa20::from_bits(val as u8)
            }
            #[doc = "AN020 Select"]
            #[inline(always)]
            pub fn set_ansa20(&mut self, val: super::vals::Ansa20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "AN021 Select"]
            #[inline(always)]
            pub const fn ansa21(&self) -> super::vals::Ansa21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ansa21::from_bits(val as u8)
            }
            #[doc = "AN021 Select"]
            #[inline(always)]
            pub fn set_ansa21(&mut self, val: super::vals::Ansa21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "AN022 Select"]
            #[inline(always)]
            pub const fn ansa22(&self) -> super::vals::Ansa22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ansa22::from_bits(val as u8)
            }
            #[doc = "AN022 Select"]
            #[inline(always)]
            pub fn set_ansa22(&mut self, val: super::vals::Ansa22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "AN023 Select"]
            #[inline(always)]
            pub const fn ansa23(&self) -> super::vals::Ansa23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ansa23::from_bits(val as u8)
            }
            #[doc = "AN023 Select"]
            #[inline(always)]
            pub fn set_ansa23(&mut self, val: super::vals::Ansa23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "AN024 Select"]
            #[inline(always)]
            pub const fn ansa24(&self) -> super::vals::Ansa24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ansa24::from_bits(val as u8)
            }
            #[doc = "AN024 Select"]
            #[inline(always)]
            pub fn set_ansa24(&mut self, val: super::vals::Ansa24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adansa1 {
            #[inline(always)]
            fn default() -> Adansa1 {
                Adansa1(0)
            }
        }
        impl core::fmt::Debug for Adansa1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansa1")
                    .field("ansa16", &self.ansa16())
                    .field("ansa17", &self.ansa17())
                    .field("ansa18", &self.ansa18())
                    .field("ansa19", &self.ansa19())
                    .field("ansa20", &self.ansa20())
                    .field("ansa21", &self.ansa21())
                    .field("ansa22", &self.ansa22())
                    .field("ansa23", &self.ansa23())
                    .field("ansa24", &self.ansa24())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansa1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adansa1 {{ ansa16: {:?}, ansa17: {:?}, ansa18: {:?}, ansa19: {:?}, ansa20: {:?}, ansa21: {:?}, ansa22: {:?}, ansa23: {:?}, ansa24: {:?}, reserved_9_15: {=u8:?} }}" , self . ansa16 () , self . ansa17 () , self . ansa18 () , self . ansa19 () , self . ansa20 () , self . ansa21 () , self . ansa22 () , self . ansa23 () , self . ansa24 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Channel Select Register B0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansb0(pub u16);
        impl Adansb0 {
            #[doc = "AN000 Select"]
            #[inline(always)]
            pub const fn ansb00(&self) -> super::vals::Ansb00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansb00::from_bits(val as u8)
            }
            #[doc = "AN000 Select"]
            #[inline(always)]
            pub fn set_ansb00(&mut self, val: super::vals::Ansb00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "AN001 Select"]
            #[inline(always)]
            pub const fn ansb01(&self) -> super::vals::Ansb01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansb01::from_bits(val as u8)
            }
            #[doc = "AN001 Select"]
            #[inline(always)]
            pub fn set_ansb01(&mut self, val: super::vals::Ansb01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "AN002 Select"]
            #[inline(always)]
            pub const fn ansb02(&self) -> super::vals::Ansb02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansb02::from_bits(val as u8)
            }
            #[doc = "AN002 Select"]
            #[inline(always)]
            pub fn set_ansb02(&mut self, val: super::vals::Ansb02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "AN003 Select"]
            #[inline(always)]
            pub const fn ansb03(&self) -> super::vals::Ansb03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansb03::from_bits(val as u8)
            }
            #[doc = "AN003 Select"]
            #[inline(always)]
            pub fn set_ansb03(&mut self, val: super::vals::Ansb03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "AN004 Select"]
            #[inline(always)]
            pub const fn ansb04(&self) -> super::vals::Ansb04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ansb04::from_bits(val as u8)
            }
            #[doc = "AN004 Select"]
            #[inline(always)]
            pub fn set_ansb04(&mut self, val: super::vals::Ansb04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "AN005 Select"]
            #[inline(always)]
            pub const fn ansb05(&self) -> super::vals::Ansb05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ansb05::from_bits(val as u8)
            }
            #[doc = "AN005 Select"]
            #[inline(always)]
            pub fn set_ansb05(&mut self, val: super::vals::Ansb05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "AN006 Select"]
            #[inline(always)]
            pub const fn ansb06(&self) -> super::vals::Ansb06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ansb06::from_bits(val as u8)
            }
            #[doc = "AN006 Select"]
            #[inline(always)]
            pub fn set_ansb06(&mut self, val: super::vals::Ansb06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "AN007 Select"]
            #[inline(always)]
            pub const fn ansb07(&self) -> super::vals::Ansb07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ansb07::from_bits(val as u8)
            }
            #[doc = "AN007 Select"]
            #[inline(always)]
            pub fn set_ansb07(&mut self, val: super::vals::Ansb07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "AN008 Select"]
            #[inline(always)]
            pub const fn ansb08(&self) -> super::vals::Ansb08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ansb08::from_bits(val as u8)
            }
            #[doc = "AN008 Select"]
            #[inline(always)]
            pub fn set_ansb08(&mut self, val: super::vals::Ansb08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adansb0 {
            #[inline(always)]
            fn default() -> Adansb0 {
                Adansb0(0)
            }
        }
        impl core::fmt::Debug for Adansb0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansb0")
                    .field("ansb00", &self.ansb00())
                    .field("ansb01", &self.ansb01())
                    .field("ansb02", &self.ansb02())
                    .field("ansb03", &self.ansb03())
                    .field("ansb04", &self.ansb04())
                    .field("ansb05", &self.ansb05())
                    .field("ansb06", &self.ansb06())
                    .field("ansb07", &self.ansb07())
                    .field("ansb08", &self.ansb08())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansb0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adansb0 {{ ansb00: {:?}, ansb01: {:?}, ansb02: {:?}, ansb03: {:?}, ansb04: {:?}, ansb05: {:?}, ansb06: {:?}, ansb07: {:?}, ansb08: {:?}, reserved_9_15: {=u8:?} }}" , self . ansb00 () , self . ansb01 () , self . ansb02 () , self . ansb03 () , self . ansb04 () , self . ansb05 () , self . ansb06 () , self . ansb07 () , self . ansb08 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Channel Select Register B1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansb1(pub u16);
        impl Adansb1 {
            #[doc = "AN016 Select"]
            #[inline(always)]
            pub const fn ansb16(&self) -> super::vals::Ansb16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansb16::from_bits(val as u8)
            }
            #[doc = "AN016 Select"]
            #[inline(always)]
            pub fn set_ansb16(&mut self, val: super::vals::Ansb16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "AN017 Select"]
            #[inline(always)]
            pub const fn ansb17(&self) -> super::vals::Ansb17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansb17::from_bits(val as u8)
            }
            #[doc = "AN017 Select"]
            #[inline(always)]
            pub fn set_ansb17(&mut self, val: super::vals::Ansb17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "AN018 Select"]
            #[inline(always)]
            pub const fn ansb18(&self) -> super::vals::Ansb18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansb18::from_bits(val as u8)
            }
            #[doc = "AN018 Select"]
            #[inline(always)]
            pub fn set_ansb18(&mut self, val: super::vals::Ansb18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "AN019 Select"]
            #[inline(always)]
            pub const fn ansb19(&self) -> super::vals::Ansb19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansb19::from_bits(val as u8)
            }
            #[doc = "AN019 Select"]
            #[inline(always)]
            pub fn set_ansb19(&mut self, val: super::vals::Ansb19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "AN020 Select"]
            #[inline(always)]
            pub const fn ansb20(&self) -> super::vals::Ansb20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ansb20::from_bits(val as u8)
            }
            #[doc = "AN020 Select"]
            #[inline(always)]
            pub fn set_ansb20(&mut self, val: super::vals::Ansb20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "AN021 Select"]
            #[inline(always)]
            pub const fn ansb21(&self) -> super::vals::Ansb21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ansb21::from_bits(val as u8)
            }
            #[doc = "AN021 Select"]
            #[inline(always)]
            pub fn set_ansb21(&mut self, val: super::vals::Ansb21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "AN022 Select"]
            #[inline(always)]
            pub const fn ansb22(&self) -> super::vals::Ansb22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ansb22::from_bits(val as u8)
            }
            #[doc = "AN022 Select"]
            #[inline(always)]
            pub fn set_ansb22(&mut self, val: super::vals::Ansb22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "AN023 Select"]
            #[inline(always)]
            pub const fn ansb23(&self) -> super::vals::Ansb23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ansb23::from_bits(val as u8)
            }
            #[doc = "AN023 Select"]
            #[inline(always)]
            pub fn set_ansb23(&mut self, val: super::vals::Ansb23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "AN024 Select"]
            #[inline(always)]
            pub const fn ansb24(&self) -> super::vals::Ansb24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ansb24::from_bits(val as u8)
            }
            #[doc = "AN024 Select"]
            #[inline(always)]
            pub fn set_ansb24(&mut self, val: super::vals::Ansb24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adansb1 {
            #[inline(always)]
            fn default() -> Adansb1 {
                Adansb1(0)
            }
        }
        impl core::fmt::Debug for Adansb1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansb1")
                    .field("ansb16", &self.ansb16())
                    .field("ansb17", &self.ansb17())
                    .field("ansb18", &self.ansb18())
                    .field("ansb19", &self.ansb19())
                    .field("ansb20", &self.ansb20())
                    .field("ansb21", &self.ansb21())
                    .field("ansb22", &self.ansb22())
                    .field("ansb23", &self.ansb23())
                    .field("ansb24", &self.ansb24())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansb1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adansb1 {{ ansb16: {:?}, ansb17: {:?}, ansb18: {:?}, ansb19: {:?}, ansb20: {:?}, ansb21: {:?}, ansb22: {:?}, ansb23: {:?}, ansb24: {:?}, reserved_9_15: {=u8:?} }}" , self . ansb16 () , self . ansb17 () , self . ansb18 () , self . ansb19 () , self . ansb20 () , self . ansb21 () , self . ansb22 () , self . ansb23 () , self . ansb24 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Calibration Execution Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcalexe(pub u8);
        impl Adcalexe {
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_0_5(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_0_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "Calibration Status Flag"]
            #[inline(always)]
            pub const fn calmon(&self) -> super::vals::Calmon {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Calmon::from_bits(val as u8)
            }
            #[doc = "Calibration Status Flag"]
            #[inline(always)]
            pub fn set_calmon(&mut self, val: super::vals::Calmon) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Calibration Start"]
            #[inline(always)]
            pub const fn calexe(&self) -> super::vals::Calexe {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Calexe::from_bits(val as u8)
            }
            #[doc = "Calibration Start"]
            #[inline(always)]
            pub fn set_calexe(&mut self, val: super::vals::Calexe) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Adcalexe {
            #[inline(always)]
            fn default() -> Adcalexe {
                Adcalexe(0)
            }
        }
        impl core::fmt::Debug for Adcalexe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcalexe")
                    .field("reserved_0_5", &self.reserved_0_5())
                    .field("calmon", &self.calmon())
                    .field("calexe", &self.calexe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcalexe {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcalexe {{ reserved_0_5: {=u8:?}, calmon: {:?}, calexe: {:?} }}",
                    self.reserved_0_5(),
                    self.calmon(),
                    self.calexe()
                )
            }
        }
        #[doc = "A/D Control Extended Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcer(pub u16);
        impl Adcer {
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_0_4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_0_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u16) & 0x1f) << 0usize);
            }
            #[doc = "A/D Data Register Automatic Clearing Enable"]
            #[inline(always)]
            pub const fn ace(&self) -> super::vals::Ace {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ace::from_bits(val as u8)
            }
            #[doc = "A/D Data Register Automatic Clearing Enable"]
            #[inline(always)]
            pub fn set_ace(&mut self, val: super::vals::Ace) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u16) & 0x03) << 6usize);
            }
            #[doc = "Self,Diagnosis Conversion Voltage Select"]
            #[inline(always)]
            pub const fn diagval(&self) -> super::vals::Diagval {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Diagval::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Conversion Voltage Select"]
            #[inline(always)]
            pub fn set_diagval(&mut self, val: super::vals::Diagval) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Self,Diagnosis Mode Select"]
            #[inline(always)]
            pub const fn diagld(&self) -> super::vals::Diagld {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Diagld::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Mode Select"]
            #[inline(always)]
            pub fn set_diagld(&mut self, val: super::vals::Diagld) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Self,Diagnosis Enable"]
            #[inline(always)]
            pub const fn diagm(&self) -> super::vals::Diagm {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Diagm::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Enable"]
            #[inline(always)]
            pub fn set_diagm(&mut self, val: super::vals::Diagm) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_12_13(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_12_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u16) & 0x03) << 12usize);
            }
            #[doc = "Single,End Input A/D Converted Data Inversion Select"]
            #[inline(always)]
            pub const fn adinv(&self) -> super::vals::Adinv {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Adinv::from_bits(val as u8)
            }
            #[doc = "Single,End Input A/D Converted Data Inversion Select"]
            #[inline(always)]
            pub fn set_adinv(&mut self, val: super::vals::Adinv) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_15_15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_15_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcer {
            #[inline(always)]
            fn default() -> Adcer {
                Adcer(0)
            }
        }
        impl core::fmt::Debug for Adcer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcer")
                    .field("reserved_0_4", &self.reserved_0_4())
                    .field("ace", &self.ace())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .field("diagval", &self.diagval())
                    .field("diagld", &self.diagld())
                    .field("diagm", &self.diagm())
                    .field("reserved_12_13", &self.reserved_12_13())
                    .field("adinv", &self.adinv())
                    .field("reserved_15_15", &self.reserved_15_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcer {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcer {{ reserved_0_4: {=u8:?}, ace: {:?}, reserved_6_7: {=u8:?}, diagval: {:?}, diagld: {:?}, diagm: {:?}, reserved_12_13: {=u8:?}, adinv: {:?}, reserved_15_15: {=bool:?} }}" , self . reserved_0_4 () , self . ace () , self . reserved_6_7 () , self . diagval () , self . diagld () , self . diagm () , self . reserved_12_13 () , self . adinv () , self . reserved_15_15 ())
            }
        }
        #[doc = "A/D Compare Function Window A Extended Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpanser(pub u8);
        impl Adcmpanser {
            #[doc = "Temperature sensor output Compare selection bit."]
            #[inline(always)]
            pub const fn cmptsa(&self) -> super::vals::Cmptsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmptsa::from_bits(val as u8)
            }
            #[doc = "Temperature sensor output Compare selection bit."]
            #[inline(always)]
            pub fn set_cmptsa(&mut self, val: super::vals::Cmptsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Internal reference voltage Compare selection bit."]
            #[inline(always)]
            pub const fn cmpoca(&self) -> super::vals::Cmpoca {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpoca::from_bits(val as u8)
            }
            #[doc = "Internal reference voltage Compare selection bit."]
            #[inline(always)]
            pub fn set_cmpoca(&mut self, val: super::vals::Cmpoca) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Adcmpanser {
            #[inline(always)]
            fn default() -> Adcmpanser {
                Adcmpanser(0)
            }
        }
        impl core::fmt::Debug for Adcmpanser {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpanser")
                    .field("cmptsa", &self.cmptsa())
                    .field("cmpoca", &self.cmpoca())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpanser {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpanser {{ cmptsa: {:?}, cmpoca: {:?}, reserved_2_7: {=u8:?} }}",
                    self.cmptsa(),
                    self.cmpoca(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpansr0(pub u16);
        impl Adcmpansr0 {
            #[doc = "AN000 Select"]
            #[inline(always)]
            pub const fn cmpcha00(&self) -> super::vals::Cmpcha00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpcha00::from_bits(val as u8)
            }
            #[doc = "AN000 Select"]
            #[inline(always)]
            pub fn set_cmpcha00(&mut self, val: super::vals::Cmpcha00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "AN001 Select"]
            #[inline(always)]
            pub const fn cmpcha01(&self) -> super::vals::Cmpcha01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpcha01::from_bits(val as u8)
            }
            #[doc = "AN001 Select"]
            #[inline(always)]
            pub fn set_cmpcha01(&mut self, val: super::vals::Cmpcha01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "AN002 Select"]
            #[inline(always)]
            pub const fn cmpcha02(&self) -> super::vals::Cmpcha02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpcha02::from_bits(val as u8)
            }
            #[doc = "AN002 Select"]
            #[inline(always)]
            pub fn set_cmpcha02(&mut self, val: super::vals::Cmpcha02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "AN003 Select"]
            #[inline(always)]
            pub const fn cmpcha03(&self) -> super::vals::Cmpcha03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpcha03::from_bits(val as u8)
            }
            #[doc = "AN003 Select"]
            #[inline(always)]
            pub fn set_cmpcha03(&mut self, val: super::vals::Cmpcha03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "AN004 Select"]
            #[inline(always)]
            pub const fn cmpcha04(&self) -> super::vals::Cmpcha04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmpcha04::from_bits(val as u8)
            }
            #[doc = "AN004 Select"]
            #[inline(always)]
            pub fn set_cmpcha04(&mut self, val: super::vals::Cmpcha04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "AN005 Select"]
            #[inline(always)]
            pub const fn cmpcha05(&self) -> super::vals::Cmpcha05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmpcha05::from_bits(val as u8)
            }
            #[doc = "AN005 Select"]
            #[inline(always)]
            pub fn set_cmpcha05(&mut self, val: super::vals::Cmpcha05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "AN006 Select"]
            #[inline(always)]
            pub const fn cmpcha06(&self) -> super::vals::Cmpcha06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmpcha06::from_bits(val as u8)
            }
            #[doc = "AN006 Select"]
            #[inline(always)]
            pub fn set_cmpcha06(&mut self, val: super::vals::Cmpcha06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "AN007 Select"]
            #[inline(always)]
            pub const fn cmpcha07(&self) -> super::vals::Cmpcha07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmpcha07::from_bits(val as u8)
            }
            #[doc = "AN007 Select"]
            #[inline(always)]
            pub fn set_cmpcha07(&mut self, val: super::vals::Cmpcha07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "AN008 Select"]
            #[inline(always)]
            pub const fn cmpcha08(&self) -> super::vals::Cmpcha08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmpcha08::from_bits(val as u8)
            }
            #[doc = "AN008 Select"]
            #[inline(always)]
            pub fn set_cmpcha08(&mut self, val: super::vals::Cmpcha08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adcmpansr0 {
            #[inline(always)]
            fn default() -> Adcmpansr0 {
                Adcmpansr0(0)
            }
        }
        impl core::fmt::Debug for Adcmpansr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpansr0")
                    .field("cmpcha00", &self.cmpcha00())
                    .field("cmpcha01", &self.cmpcha01())
                    .field("cmpcha02", &self.cmpcha02())
                    .field("cmpcha03", &self.cmpcha03())
                    .field("cmpcha04", &self.cmpcha04())
                    .field("cmpcha05", &self.cmpcha05())
                    .field("cmpcha06", &self.cmpcha06())
                    .field("cmpcha07", &self.cmpcha07())
                    .field("cmpcha08", &self.cmpcha08())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpansr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpansr0 {{ cmpcha00: {:?}, cmpcha01: {:?}, cmpcha02: {:?}, cmpcha03: {:?}, cmpcha04: {:?}, cmpcha05: {:?}, cmpcha06: {:?}, cmpcha07: {:?}, cmpcha08: {:?}, reserved_9_15: {=u8:?} }}" , self . cmpcha00 () , self . cmpcha01 () , self . cmpcha02 () , self . cmpcha03 () , self . cmpcha04 () , self . cmpcha05 () , self . cmpcha06 () , self . cmpcha07 () , self . cmpcha08 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpansr1(pub u16);
        impl Adcmpansr1 {
            #[doc = "AN016 Select"]
            #[inline(always)]
            pub const fn cmpcha16(&self) -> super::vals::Cmpcha16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpcha16::from_bits(val as u8)
            }
            #[doc = "AN016 Select"]
            #[inline(always)]
            pub fn set_cmpcha16(&mut self, val: super::vals::Cmpcha16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "AN017 Select"]
            #[inline(always)]
            pub const fn cmpcha17(&self) -> super::vals::Cmpcha17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpcha17::from_bits(val as u8)
            }
            #[doc = "AN017 Select"]
            #[inline(always)]
            pub fn set_cmpcha17(&mut self, val: super::vals::Cmpcha17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "AN018 Select"]
            #[inline(always)]
            pub const fn cmpcha18(&self) -> super::vals::Cmpcha18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpcha18::from_bits(val as u8)
            }
            #[doc = "AN018 Select"]
            #[inline(always)]
            pub fn set_cmpcha18(&mut self, val: super::vals::Cmpcha18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "AN019 Select"]
            #[inline(always)]
            pub const fn cmpcha19(&self) -> super::vals::Cmpcha19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpcha19::from_bits(val as u8)
            }
            #[doc = "AN019 Select"]
            #[inline(always)]
            pub fn set_cmpcha19(&mut self, val: super::vals::Cmpcha19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "AN020 Select"]
            #[inline(always)]
            pub const fn cmpcha20(&self) -> super::vals::Cmpcha20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmpcha20::from_bits(val as u8)
            }
            #[doc = "AN020 Select"]
            #[inline(always)]
            pub fn set_cmpcha20(&mut self, val: super::vals::Cmpcha20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "AN021 Select"]
            #[inline(always)]
            pub const fn cmpcha21(&self) -> super::vals::Cmpcha21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmpcha21::from_bits(val as u8)
            }
            #[doc = "AN021 Select"]
            #[inline(always)]
            pub fn set_cmpcha21(&mut self, val: super::vals::Cmpcha21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "AN022 Select"]
            #[inline(always)]
            pub const fn cmpcha22(&self) -> super::vals::Cmpcha22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmpcha22::from_bits(val as u8)
            }
            #[doc = "AN022 Select"]
            #[inline(always)]
            pub fn set_cmpcha22(&mut self, val: super::vals::Cmpcha22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "AN023 Select"]
            #[inline(always)]
            pub const fn cmpcha23(&self) -> super::vals::Cmpcha23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmpcha23::from_bits(val as u8)
            }
            #[doc = "AN023 Select"]
            #[inline(always)]
            pub fn set_cmpcha23(&mut self, val: super::vals::Cmpcha23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "AN024 Select"]
            #[inline(always)]
            pub const fn cmpcha24(&self) -> super::vals::Cmpcha24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmpcha24::from_bits(val as u8)
            }
            #[doc = "AN024 Select"]
            #[inline(always)]
            pub fn set_cmpcha24(&mut self, val: super::vals::Cmpcha24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adcmpansr1 {
            #[inline(always)]
            fn default() -> Adcmpansr1 {
                Adcmpansr1(0)
            }
        }
        impl core::fmt::Debug for Adcmpansr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpansr1")
                    .field("cmpcha16", &self.cmpcha16())
                    .field("cmpcha17", &self.cmpcha17())
                    .field("cmpcha18", &self.cmpcha18())
                    .field("cmpcha19", &self.cmpcha19())
                    .field("cmpcha20", &self.cmpcha20())
                    .field("cmpcha21", &self.cmpcha21())
                    .field("cmpcha22", &self.cmpcha22())
                    .field("cmpcha23", &self.cmpcha23())
                    .field("cmpcha24", &self.cmpcha24())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpansr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpansr1 {{ cmpcha16: {:?}, cmpcha17: {:?}, cmpcha18: {:?}, cmpcha19: {:?}, cmpcha20: {:?}, cmpcha21: {:?}, cmpcha22: {:?}, cmpcha23: {:?}, cmpcha24: {:?}, reserved_9_15: {=u8:?} }}" , self . cmpcha16 () , self . cmpcha17 () , self . cmpcha18 () , self . cmpcha19 () , self . cmpcha20 () , self . cmpcha21 () , self . cmpcha22 () , self . cmpcha23 () , self . cmpcha24 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Compare Function Window B Channel Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpbnsr(pub u8);
        impl Adcmpbnsr {
            #[doc = "Compare window B channel selection bit.The channel that compares it on the condition of compare window B is selected."]
            #[inline(always)]
            pub const fn cmpchb(&self) -> super::vals::Cmpchb {
                let val = (self.0 >> 0usize) & 0x3f;
                super::vals::Cmpchb::from_bits(val as u8)
            }
            #[doc = "Compare window B channel selection bit.The channel that compares it on the condition of compare window B is selected."]
            #[inline(always)]
            pub fn set_cmpchb(&mut self, val: super::vals::Cmpchb) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val.to_bits() as u8) & 0x3f) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "Compare window B Compare condition setting bit."]
            #[inline(always)]
            pub const fn cmplb(&self) -> super::vals::Cmplb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmplb::from_bits(val as u8)
            }
            #[doc = "Compare window B Compare condition setting bit."]
            #[inline(always)]
            pub fn set_cmplb(&mut self, val: super::vals::Cmplb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Adcmpbnsr {
            #[inline(always)]
            fn default() -> Adcmpbnsr {
                Adcmpbnsr(0)
            }
        }
        impl core::fmt::Debug for Adcmpbnsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpbnsr")
                    .field("cmpchb", &self.cmpchb())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("cmplb", &self.cmplb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpbnsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpbnsr {{ cmpchb: {:?}, reserved_6_6: {=bool:?}, cmplb: {:?} }}",
                    self.cmpchb(),
                    self.reserved_6_6(),
                    self.cmplb()
                )
            }
        }
        #[doc = "A/D Compare Function Window B Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpbsr(pub u8);
        impl Adcmpbsr {
            #[doc = "Compare window B flagWhen window B operation is enabled (ADCMPCR.CMPBE = 1), this bit indicates the comparison result of channels AN000 to AN008, AN016 to AN023, reference voltage of SDADC24 (SBIAS/VREFI), temperature sensor output, and internal reference voltage to which window B comparison conditions are applied."]
            #[inline(always)]
            pub const fn cmpstb(&self) -> super::vals::Cmpstb {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpstb::from_bits(val as u8)
            }
            #[doc = "Compare window B flagWhen window B operation is enabled (ADCMPCR.CMPBE = 1), this bit indicates the comparison result of channels AN000 to AN008, AN016 to AN023, reference voltage of SDADC24 (SBIAS/VREFI), temperature sensor output, and internal reference voltage to which window B comparison conditions are applied."]
            #[inline(always)]
            pub fn set_cmpstb(&mut self, val: super::vals::Cmpstb) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Adcmpbsr {
            #[inline(always)]
            fn default() -> Adcmpbsr {
                Adcmpbsr(0)
            }
        }
        impl core::fmt::Debug for Adcmpbsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpbsr")
                    .field("cmpstb", &self.cmpstb())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpbsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpbsr {{ cmpstb: {:?}, reserved_1_7: {=u8:?} }}",
                    self.cmpstb(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "A/D Compare Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpcr(pub u16);
        impl Adcmpcr {
            #[doc = "Window A/B Composite Conditions SettingNOTE: These bits are valid when both window A and window B are enabled (CMPAE = 1 and CMPBE = 1)."]
            #[inline(always)]
            pub const fn cmpab(&self) -> super::vals::Cmpab {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Cmpab::from_bits(val as u8)
            }
            #[doc = "Window A/B Composite Conditions SettingNOTE: These bits are valid when both window A and window B are enabled (CMPAE = 1 and CMPBE = 1)."]
            #[inline(always)]
            pub fn set_cmpab(&mut self, val: super::vals::Cmpab) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_2_8(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_2_8(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 2usize)) | (((val as u16) & 0x7f) << 2usize);
            }
            #[doc = "Compare Window B Operation Enable"]
            #[inline(always)]
            pub const fn cmpbe(&self) -> super::vals::Cmpbe {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cmpbe::from_bits(val as u8)
            }
            #[doc = "Compare Window B Operation Enable"]
            #[inline(always)]
            pub fn set_cmpbe(&mut self, val: super::vals::Cmpbe) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_10_10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_10_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u16) & 0x01) << 10usize);
            }
            #[doc = "Compare Window A Operation Enable"]
            #[inline(always)]
            pub const fn cmpae(&self) -> super::vals::Cmpae {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cmpae::from_bits(val as u8)
            }
            #[doc = "Compare Window A Operation Enable"]
            #[inline(always)]
            pub fn set_cmpae(&mut self, val: super::vals::Cmpae) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_12_12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_12_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u16) & 0x01) << 12usize);
            }
            #[doc = "Compare B Interrupt Enable"]
            #[inline(always)]
            pub const fn cmpbie(&self) -> super::vals::Cmpbie {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cmpbie::from_bits(val as u8)
            }
            #[doc = "Compare B Interrupt Enable"]
            #[inline(always)]
            pub fn set_cmpbie(&mut self, val: super::vals::Cmpbie) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Window Function Setting"]
            #[inline(always)]
            pub const fn wcmpe(&self) -> super::vals::Wcmpe {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Wcmpe::from_bits(val as u8)
            }
            #[doc = "Window Function Setting"]
            #[inline(always)]
            pub fn set_wcmpe(&mut self, val: super::vals::Wcmpe) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Compare A Interrupt Enable"]
            #[inline(always)]
            pub const fn cmpaie(&self) -> super::vals::Cmpaie {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cmpaie::from_bits(val as u8)
            }
            #[doc = "Compare A Interrupt Enable"]
            #[inline(always)]
            pub fn set_cmpaie(&mut self, val: super::vals::Cmpaie) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcmpcr {
            #[inline(always)]
            fn default() -> Adcmpcr {
                Adcmpcr(0)
            }
        }
        impl core::fmt::Debug for Adcmpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpcr")
                    .field("cmpab", &self.cmpab())
                    .field("reserved_2_8", &self.reserved_2_8())
                    .field("cmpbe", &self.cmpbe())
                    .field("reserved_10_10", &self.reserved_10_10())
                    .field("cmpae", &self.cmpae())
                    .field("reserved_12_12", &self.reserved_12_12())
                    .field("cmpbie", &self.cmpbie())
                    .field("wcmpe", &self.wcmpe())
                    .field("cmpaie", &self.cmpaie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpcr {{ cmpab: {:?}, reserved_2_8: {=u8:?}, cmpbe: {:?}, reserved_10_10: {=bool:?}, cmpae: {:?}, reserved_12_12: {=bool:?}, cmpbie: {:?}, wcmpe: {:?}, cmpaie: {:?} }}" , self . cmpab () , self . reserved_2_8 () , self . cmpbe () , self . reserved_10_10 () , self . cmpae () , self . reserved_12_12 () , self . cmpbie () , self . wcmpe () , self . cmpaie ())
            }
        }
        #[doc = "A/D Compare Function Window A Lower,Side Level Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpdr0(pub u16);
        impl Adcmpdr0 {
            #[doc = "The ADCMPDR0 register sets the reference data when the compare window A function is used. ADCMPDR0 sets the lower,side level of window A."]
            #[inline(always)]
            pub const fn adcmpdr0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "The ADCMPDR0 register sets the reference data when the compare window A function is used. ADCMPDR0 sets the lower,side level of window A."]
            #[inline(always)]
            pub fn set_adcmpdr0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adcmpdr0 {
            #[inline(always)]
            fn default() -> Adcmpdr0 {
                Adcmpdr0(0)
            }
        }
        impl core::fmt::Debug for Adcmpdr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpdr0")
                    .field("adcmpdr0", &self.adcmpdr0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpdr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adcmpdr0 {{ adcmpdr0: {=u16:?} }}", self.adcmpdr0())
            }
        }
        #[doc = "A/D Compare Function Window A Upper,Side Level Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpdr1(pub u16);
        impl Adcmpdr1 {
            #[doc = "The ADCMPDR1 register sets the reference data when the compare window A function is used. ADCMPDR1 sets the upper,side level of window A."]
            #[inline(always)]
            pub const fn adcmpdr1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "The ADCMPDR1 register sets the reference data when the compare window A function is used. ADCMPDR1 sets the upper,side level of window A."]
            #[inline(always)]
            pub fn set_adcmpdr1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adcmpdr1 {
            #[inline(always)]
            fn default() -> Adcmpdr1 {
                Adcmpdr1(0)
            }
        }
        impl core::fmt::Debug for Adcmpdr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpdr1")
                    .field("adcmpdr1", &self.adcmpdr1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpdr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adcmpdr1 {{ adcmpdr1: {=u16:?} }}", self.adcmpdr1())
            }
        }
        #[doc = "A/D Compare Function Window A Extended Input Comparison Condition Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpler(pub u8);
        impl Adcmpler {
            #[doc = "Compare Window A Temperature Sensor Output Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmpltsa(&self) -> super::vals::Cmpltsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpltsa::from_bits(val as u8)
            }
            #[doc = "Compare Window A Temperature Sensor Output Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmpltsa(&mut self, val: super::vals::Cmpltsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Internal Reference Voltage ComparisonCondition Select"]
            #[inline(always)]
            pub const fn cmploca(&self) -> super::vals::Cmploca {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmploca::from_bits(val as u8)
            }
            #[doc = "Compare Window A Internal Reference Voltage ComparisonCondition Select"]
            #[inline(always)]
            pub fn set_cmploca(&mut self, val: super::vals::Cmploca) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Adcmpler {
            #[inline(always)]
            fn default() -> Adcmpler {
                Adcmpler(0)
            }
        }
        impl core::fmt::Debug for Adcmpler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpler")
                    .field("cmpltsa", &self.cmpltsa())
                    .field("cmploca", &self.cmploca())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpler {{ cmpltsa: {:?}, cmploca: {:?}, reserved_2_7: {=u8:?} }}",
                    self.cmpltsa(),
                    self.cmploca(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmplr0(pub u16);
        impl Adcmplr0 {
            #[doc = "Comparison condition of AN000"]
            #[inline(always)]
            pub const fn cmplcha00(&self) -> super::vals::Cmplcha00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmplcha00::from_bits(val as u8)
            }
            #[doc = "Comparison condition of AN000"]
            #[inline(always)]
            pub fn set_cmplcha00(&mut self, val: super::vals::Cmplcha00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Comparison condition of AN001"]
            #[inline(always)]
            pub const fn cmplcha01(&self) -> super::vals::Cmplcha01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmplcha01::from_bits(val as u8)
            }
            #[doc = "Comparison condition of AN001"]
            #[inline(always)]
            pub fn set_cmplcha01(&mut self, val: super::vals::Cmplcha01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Comparison condition of AN002"]
            #[inline(always)]
            pub const fn cmplcha02(&self) -> super::vals::Cmplcha02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmplcha02::from_bits(val as u8)
            }
            #[doc = "Comparison condition of AN002"]
            #[inline(always)]
            pub fn set_cmplcha02(&mut self, val: super::vals::Cmplcha02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Comparison condition of AN003"]
            #[inline(always)]
            pub const fn cmplcha03(&self) -> super::vals::Cmplcha03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmplcha03::from_bits(val as u8)
            }
            #[doc = "Comparison condition of AN003"]
            #[inline(always)]
            pub fn set_cmplcha03(&mut self, val: super::vals::Cmplcha03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Comparison condition of AN004"]
            #[inline(always)]
            pub const fn cmplcha04(&self) -> super::vals::Cmplcha04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmplcha04::from_bits(val as u8)
            }
            #[doc = "Comparison condition of AN004"]
            #[inline(always)]
            pub fn set_cmplcha04(&mut self, val: super::vals::Cmplcha04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Comparison condition of AN005"]
            #[inline(always)]
            pub const fn cmplcha05(&self) -> super::vals::Cmplcha05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmplcha05::from_bits(val as u8)
            }
            #[doc = "Comparison condition of AN005"]
            #[inline(always)]
            pub fn set_cmplcha05(&mut self, val: super::vals::Cmplcha05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Comparison condition of AN006"]
            #[inline(always)]
            pub const fn cmplcha06(&self) -> super::vals::Cmplcha06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmplcha06::from_bits(val as u8)
            }
            #[doc = "Comparison condition of AN006"]
            #[inline(always)]
            pub fn set_cmplcha06(&mut self, val: super::vals::Cmplcha06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Comparison condition of AN007"]
            #[inline(always)]
            pub const fn cmplcha07(&self) -> super::vals::Cmplcha07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmplcha07::from_bits(val as u8)
            }
            #[doc = "Comparison condition of AN007"]
            #[inline(always)]
            pub fn set_cmplcha07(&mut self, val: super::vals::Cmplcha07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Comparison condition of AN008"]
            #[inline(always)]
            pub const fn cmplcha08(&self) -> super::vals::Cmplcha08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmplcha08::from_bits(val as u8)
            }
            #[doc = "Comparison condition of AN008"]
            #[inline(always)]
            pub fn set_cmplcha08(&mut self, val: super::vals::Cmplcha08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adcmplr0 {
            #[inline(always)]
            fn default() -> Adcmplr0 {
                Adcmplr0(0)
            }
        }
        impl core::fmt::Debug for Adcmplr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmplr0")
                    .field("cmplcha00", &self.cmplcha00())
                    .field("cmplcha01", &self.cmplcha01())
                    .field("cmplcha02", &self.cmplcha02())
                    .field("cmplcha03", &self.cmplcha03())
                    .field("cmplcha04", &self.cmplcha04())
                    .field("cmplcha05", &self.cmplcha05())
                    .field("cmplcha06", &self.cmplcha06())
                    .field("cmplcha07", &self.cmplcha07())
                    .field("cmplcha08", &self.cmplcha08())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmplr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmplr0 {{ cmplcha00: {:?}, cmplcha01: {:?}, cmplcha02: {:?}, cmplcha03: {:?}, cmplcha04: {:?}, cmplcha05: {:?}, cmplcha06: {:?}, cmplcha07: {:?}, cmplcha08: {:?}, reserved_9_15: {=u8:?} }}" , self . cmplcha00 () , self . cmplcha01 () , self . cmplcha02 () , self . cmplcha03 () , self . cmplcha04 () , self . cmplcha05 () , self . cmplcha06 () , self . cmplcha07 () , self . cmplcha08 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmplr1(pub u16);
        impl Adcmplr1 {
            #[doc = "Comparison condition for AN016"]
            #[inline(always)]
            pub const fn cmplcha16(&self) -> super::vals::Cmplcha16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmplcha16::from_bits(val as u8)
            }
            #[doc = "Comparison condition for AN016"]
            #[inline(always)]
            pub fn set_cmplcha16(&mut self, val: super::vals::Cmplcha16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Comparison condition for AN017"]
            #[inline(always)]
            pub const fn cmplcha17(&self) -> super::vals::Cmplcha17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmplcha17::from_bits(val as u8)
            }
            #[doc = "Comparison condition for AN017"]
            #[inline(always)]
            pub fn set_cmplcha17(&mut self, val: super::vals::Cmplcha17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Comparison condition for AN018"]
            #[inline(always)]
            pub const fn cmplcha18(&self) -> super::vals::Cmplcha18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmplcha18::from_bits(val as u8)
            }
            #[doc = "Comparison condition for AN018"]
            #[inline(always)]
            pub fn set_cmplcha18(&mut self, val: super::vals::Cmplcha18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Comparison condition for AN019"]
            #[inline(always)]
            pub const fn cmplcha19(&self) -> super::vals::Cmplcha19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmplcha19::from_bits(val as u8)
            }
            #[doc = "Comparison condition for AN019"]
            #[inline(always)]
            pub fn set_cmplcha19(&mut self, val: super::vals::Cmplcha19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Comparison condition for AN020"]
            #[inline(always)]
            pub const fn cmplcha20(&self) -> super::vals::Cmplcha20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmplcha20::from_bits(val as u8)
            }
            #[doc = "Comparison condition for AN020"]
            #[inline(always)]
            pub fn set_cmplcha20(&mut self, val: super::vals::Cmplcha20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Comparison condition for AN021"]
            #[inline(always)]
            pub const fn cmplcha21(&self) -> super::vals::Cmplcha21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmplcha21::from_bits(val as u8)
            }
            #[doc = "Comparison condition for AN021"]
            #[inline(always)]
            pub fn set_cmplcha21(&mut self, val: super::vals::Cmplcha21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Comparison condition for AN022"]
            #[inline(always)]
            pub const fn cmplcha22(&self) -> super::vals::Cmplcha22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmplcha22::from_bits(val as u8)
            }
            #[doc = "Comparison condition for AN022"]
            #[inline(always)]
            pub fn set_cmplcha22(&mut self, val: super::vals::Cmplcha22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Comparison condition for AN023"]
            #[inline(always)]
            pub const fn cmplcha23(&self) -> super::vals::Cmplcha23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmplcha23::from_bits(val as u8)
            }
            #[doc = "Comparison condition for AN023"]
            #[inline(always)]
            pub fn set_cmplcha23(&mut self, val: super::vals::Cmplcha23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Comparison condition for AN024"]
            #[inline(always)]
            pub const fn cmplcha24(&self) -> super::vals::Cmplcha24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmplcha24::from_bits(val as u8)
            }
            #[doc = "Comparison condition for AN024"]
            #[inline(always)]
            pub fn set_cmplcha24(&mut self, val: super::vals::Cmplcha24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adcmplr1 {
            #[inline(always)]
            fn default() -> Adcmplr1 {
                Adcmplr1(0)
            }
        }
        impl core::fmt::Debug for Adcmplr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmplr1")
                    .field("cmplcha16", &self.cmplcha16())
                    .field("cmplcha17", &self.cmplcha17())
                    .field("cmplcha18", &self.cmplcha18())
                    .field("cmplcha19", &self.cmplcha19())
                    .field("cmplcha20", &self.cmplcha20())
                    .field("cmplcha21", &self.cmplcha21())
                    .field("cmplcha22", &self.cmplcha22())
                    .field("cmplcha23", &self.cmplcha23())
                    .field("cmplcha24", &self.cmplcha24())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmplr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmplr1 {{ cmplcha16: {:?}, cmplcha17: {:?}, cmplcha18: {:?}, cmplcha19: {:?}, cmplcha20: {:?}, cmplcha21: {:?}, cmplcha22: {:?}, cmplcha23: {:?}, cmplcha24: {:?}, reserved_9_15: {=u8:?} }}" , self . cmplcha16 () , self . cmplcha17 () , self . cmplcha18 () , self . cmplcha19 () , self . cmplcha20 () , self . cmplcha21 () , self . cmplcha22 () , self . cmplcha23 () , self . cmplcha24 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Compare Function Window A Extended Input Channel Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpser(pub u8);
        impl Adcmpser {
            #[doc = "Compare Window A Temperature Sensor Output Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time."]
            #[inline(always)]
            pub const fn cmpsttsa(&self) -> super::vals::Cmpsttsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpsttsa::from_bits(val as u8)
            }
            #[doc = "Compare Window A Temperature Sensor Output Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time."]
            #[inline(always)]
            pub fn set_cmpsttsa(&mut self, val: super::vals::Cmpsttsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Internal Reference Voltage Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time."]
            #[inline(always)]
            pub const fn cmpstoca(&self) -> super::vals::Cmpstoca {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpstoca::from_bits(val as u8)
            }
            #[doc = "Compare Window A Internal Reference Voltage Compare Flag When window A operation is enabled (ADCMPCR.CMPAE = 1b), this bit indicates the temperature sensor output comparison result. When window A operation is disabled (ADCMPCR.CMPAE = 0b), comparison conditions for CMPSTTSA are not met any time."]
            #[inline(always)]
            pub fn set_cmpstoca(&mut self, val: super::vals::Cmpstoca) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Adcmpser {
            #[inline(always)]
            fn default() -> Adcmpser {
                Adcmpser(0)
            }
        }
        impl core::fmt::Debug for Adcmpser {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpser")
                    .field("cmpsttsa", &self.cmpsttsa())
                    .field("cmpstoca", &self.cmpstoca())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpser {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpser {{ cmpsttsa: {:?}, cmpstoca: {:?}, reserved_2_7: {=u8:?} }}",
                    self.cmpsttsa(),
                    self.cmpstoca(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpsr0(pub u16);
        impl Adcmpsr0 {
            #[doc = "Compare window A flag for AN000"]
            #[inline(always)]
            pub const fn cmpstcha00(&self) -> super::vals::Cmpstcha00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpstcha00::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN000"]
            #[inline(always)]
            pub fn set_cmpstcha00(&mut self, val: super::vals::Cmpstcha00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare window A flag for AN001"]
            #[inline(always)]
            pub const fn cmpstcha01(&self) -> super::vals::Cmpstcha01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpstcha01::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN001"]
            #[inline(always)]
            pub fn set_cmpstcha01(&mut self, val: super::vals::Cmpstcha01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare window A flag for AN002"]
            #[inline(always)]
            pub const fn cmpstcha02(&self) -> super::vals::Cmpstcha02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpstcha02::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN002"]
            #[inline(always)]
            pub fn set_cmpstcha02(&mut self, val: super::vals::Cmpstcha02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare window A flag for AN003"]
            #[inline(always)]
            pub const fn cmpstcha03(&self) -> super::vals::Cmpstcha03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpstcha03::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN003"]
            #[inline(always)]
            pub fn set_cmpstcha03(&mut self, val: super::vals::Cmpstcha03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Compare window A flag for AN004"]
            #[inline(always)]
            pub const fn cmpstcha04(&self) -> super::vals::Cmpstcha04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmpstcha04::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN004"]
            #[inline(always)]
            pub fn set_cmpstcha04(&mut self, val: super::vals::Cmpstcha04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Compare window A flag for AN005"]
            #[inline(always)]
            pub const fn cmpstcha05(&self) -> super::vals::Cmpstcha05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmpstcha05::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN005"]
            #[inline(always)]
            pub fn set_cmpstcha05(&mut self, val: super::vals::Cmpstcha05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Compare window A flag for AN006"]
            #[inline(always)]
            pub const fn cmpstcha06(&self) -> super::vals::Cmpstcha06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmpstcha06::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN006"]
            #[inline(always)]
            pub fn set_cmpstcha06(&mut self, val: super::vals::Cmpstcha06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Compare window A flag for AN007"]
            #[inline(always)]
            pub const fn cmpstcha07(&self) -> super::vals::Cmpstcha07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmpstcha07::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN007"]
            #[inline(always)]
            pub fn set_cmpstcha07(&mut self, val: super::vals::Cmpstcha07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Compare window A flag for AN008"]
            #[inline(always)]
            pub const fn cmpstcha08(&self) -> super::vals::Cmpstcha08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmpstcha08::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN008"]
            #[inline(always)]
            pub fn set_cmpstcha08(&mut self, val: super::vals::Cmpstcha08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adcmpsr0 {
            #[inline(always)]
            fn default() -> Adcmpsr0 {
                Adcmpsr0(0)
            }
        }
        impl core::fmt::Debug for Adcmpsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpsr0")
                    .field("cmpstcha00", &self.cmpstcha00())
                    .field("cmpstcha01", &self.cmpstcha01())
                    .field("cmpstcha02", &self.cmpstcha02())
                    .field("cmpstcha03", &self.cmpstcha03())
                    .field("cmpstcha04", &self.cmpstcha04())
                    .field("cmpstcha05", &self.cmpstcha05())
                    .field("cmpstcha06", &self.cmpstcha06())
                    .field("cmpstcha07", &self.cmpstcha07())
                    .field("cmpstcha08", &self.cmpstcha08())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpsr0 {{ cmpstcha00: {:?}, cmpstcha01: {:?}, cmpstcha02: {:?}, cmpstcha03: {:?}, cmpstcha04: {:?}, cmpstcha05: {:?}, cmpstcha06: {:?}, cmpstcha07: {:?}, cmpstcha08: {:?}, reserved_9_15: {=u8:?} }}" , self . cmpstcha00 () , self . cmpstcha01 () , self . cmpstcha02 () , self . cmpstcha03 () , self . cmpstcha04 () , self . cmpstcha05 () , self . cmpstcha06 () , self . cmpstcha07 () , self . cmpstcha08 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpsr1(pub u16);
        impl Adcmpsr1 {
            #[doc = "Compare window A flag for AN016"]
            #[inline(always)]
            pub const fn cmpstcha16(&self) -> super::vals::Cmpstcha16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpstcha16::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN016"]
            #[inline(always)]
            pub fn set_cmpstcha16(&mut self, val: super::vals::Cmpstcha16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare window A flag for AN017"]
            #[inline(always)]
            pub const fn cmpstcha17(&self) -> super::vals::Cmpstcha17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpstcha17::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN017"]
            #[inline(always)]
            pub fn set_cmpstcha17(&mut self, val: super::vals::Cmpstcha17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare window A flag for AN018"]
            #[inline(always)]
            pub const fn cmpstcha18(&self) -> super::vals::Cmpstcha18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpstcha18::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN018"]
            #[inline(always)]
            pub fn set_cmpstcha18(&mut self, val: super::vals::Cmpstcha18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare window A flag for AN019"]
            #[inline(always)]
            pub const fn cmpstcha19(&self) -> super::vals::Cmpstcha19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpstcha19::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN019"]
            #[inline(always)]
            pub fn set_cmpstcha19(&mut self, val: super::vals::Cmpstcha19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Compare window A flag for AN020"]
            #[inline(always)]
            pub const fn cmpstcha20(&self) -> super::vals::Cmpstcha20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmpstcha20::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN020"]
            #[inline(always)]
            pub fn set_cmpstcha20(&mut self, val: super::vals::Cmpstcha20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Compare window A flag for AN021"]
            #[inline(always)]
            pub const fn cmpstcha21(&self) -> super::vals::Cmpstcha21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmpstcha21::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN021"]
            #[inline(always)]
            pub fn set_cmpstcha21(&mut self, val: super::vals::Cmpstcha21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Compare window A flag for AN022"]
            #[inline(always)]
            pub const fn cmpstcha22(&self) -> super::vals::Cmpstcha22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmpstcha22::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN022"]
            #[inline(always)]
            pub fn set_cmpstcha22(&mut self, val: super::vals::Cmpstcha22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Compare window A flag for AN023"]
            #[inline(always)]
            pub const fn cmpstcha23(&self) -> super::vals::Cmpstcha23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmpstcha23::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN023"]
            #[inline(always)]
            pub fn set_cmpstcha23(&mut self, val: super::vals::Cmpstcha23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Compare window A flag for AN024"]
            #[inline(always)]
            pub const fn cmpstcha24(&self) -> super::vals::Cmpstcha24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmpstcha24::from_bits(val as u8)
            }
            #[doc = "Compare window A flag for AN024"]
            #[inline(always)]
            pub fn set_cmpstcha24(&mut self, val: super::vals::Cmpstcha24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Adcmpsr1 {
            #[inline(always)]
            fn default() -> Adcmpsr1 {
                Adcmpsr1(0)
            }
        }
        impl core::fmt::Debug for Adcmpsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpsr1")
                    .field("cmpstcha16", &self.cmpstcha16())
                    .field("cmpstcha17", &self.cmpstcha17())
                    .field("cmpstcha18", &self.cmpstcha18())
                    .field("cmpstcha19", &self.cmpstcha19())
                    .field("cmpstcha20", &self.cmpstcha20())
                    .field("cmpstcha21", &self.cmpstcha21())
                    .field("cmpstcha22", &self.cmpstcha22())
                    .field("cmpstcha23", &self.cmpstcha23())
                    .field("cmpstcha24", &self.cmpstcha24())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpsr1 {{ cmpstcha16: {:?}, cmpstcha17: {:?}, cmpstcha18: {:?}, cmpstcha19: {:?}, cmpstcha20: {:?}, cmpstcha21: {:?}, cmpstcha22: {:?}, cmpstcha23: {:?}, cmpstcha24: {:?}, reserved_9_15: {=u8:?} }}" , self . cmpstcha16 () , self . cmpstcha17 () , self . cmpstcha18 () , self . cmpstcha19 () , self . cmpstcha20 () , self . cmpstcha21 () , self . cmpstcha22 () , self . cmpstcha23 () , self . cmpstcha24 () , self . reserved_9_15 ())
            }
        }
        #[doc = "A/D Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcsr(pub u16);
        impl Adcsr {
            #[doc = "Double Trigger Channel SelectThese bits select one analog input channel for double triggered operation. The setting is only effective while double trigger mode is selected."]
            #[inline(always)]
            pub const fn dblans(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Double Trigger Channel SelectThese bits select one analog input channel for double triggered operation. The setting is only effective while double trigger mode is selected."]
            #[inline(always)]
            pub fn set_dblans(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u16) & 0x1f) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u16) & 0x01) << 5usize);
            }
            #[doc = "Group B Scan End Interrupt Enable"]
            #[inline(always)]
            pub const fn gbadie(&self) -> super::vals::Gbadie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Gbadie::from_bits(val as u8)
            }
            #[doc = "Group B Scan End Interrupt Enable"]
            #[inline(always)]
            pub fn set_gbadie(&mut self, val: super::vals::Gbadie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Double Trigger Mode Select"]
            #[inline(always)]
            pub const fn dble(&self) -> super::vals::Dble {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dble::from_bits(val as u8)
            }
            #[doc = "Double Trigger Mode Select"]
            #[inline(always)]
            pub fn set_dble(&mut self, val: super::vals::Dble) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Trigger Select"]
            #[inline(always)]
            pub const fn extrg(&self) -> super::vals::Extrg {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Extrg::from_bits(val as u8)
            }
            #[doc = "Trigger Select"]
            #[inline(always)]
            pub fn set_extrg(&mut self, val: super::vals::Extrg) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Trigger Start Enable"]
            #[inline(always)]
            pub const fn trge(&self) -> super::vals::Trge {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Trge::from_bits(val as u8)
            }
            #[doc = "Trigger Start Enable"]
            #[inline(always)]
            pub fn set_trge(&mut self, val: super::vals::Trge) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "A/D Conversion Operation Mode Select"]
            #[inline(always)]
            pub const fn adhsc(&self) -> super::vals::Adhsc {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Adhsc::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Operation Mode Select"]
            #[inline(always)]
            pub fn set_adhsc(&mut self, val: super::vals::Adhsc) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_11_12(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_11_12(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 11usize)) | (((val as u16) & 0x03) << 11usize);
            }
            #[doc = "Scan Mode Select"]
            #[inline(always)]
            pub const fn adcs(&self) -> super::vals::Adcs {
                let val = (self.0 >> 13usize) & 0x03;
                super::vals::Adcs::from_bits(val as u8)
            }
            #[doc = "Scan Mode Select"]
            #[inline(always)]
            pub fn set_adcs(&mut self, val: super::vals::Adcs) {
                self.0 =
                    (self.0 & !(0x03 << 13usize)) | (((val.to_bits() as u16) & 0x03) << 13usize);
            }
            #[doc = "A/D Conversion Start"]
            #[inline(always)]
            pub const fn adst(&self) -> super::vals::Adst {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Adst::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Start"]
            #[inline(always)]
            pub fn set_adst(&mut self, val: super::vals::Adst) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcsr {
            #[inline(always)]
            fn default() -> Adcsr {
                Adcsr(0)
            }
        }
        impl core::fmt::Debug for Adcsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcsr")
                    .field("dblans", &self.dblans())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("gbadie", &self.gbadie())
                    .field("dble", &self.dble())
                    .field("extrg", &self.extrg())
                    .field("trge", &self.trge())
                    .field("adhsc", &self.adhsc())
                    .field("reserved_11_12", &self.reserved_11_12())
                    .field("adcs", &self.adcs())
                    .field("adst", &self.adst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcsr {{ dblans: {=u8:?}, reserved_5_5: {=bool:?}, gbadie: {:?}, dble: {:?}, extrg: {:?}, trge: {:?}, adhsc: {:?}, reserved_11_12: {=u8:?}, adcs: {:?}, adst: {:?} }}" , self . dblans () , self . reserved_5_5 () , self . gbadie () , self . dble () , self . extrg () , self . trge () , self . adhsc () , self . reserved_11_12 () , self . adcs () , self . adst ())
            }
        }
        #[doc = "A/D Data Duplexing Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addbldr(pub u16);
        impl Addbldr {
            #[doc = "This is a 16-bit read,only register for storing the result of A/D conversion in response to the second trigger in double trigger mode."]
            #[inline(always)]
            pub const fn addbldr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is a 16-bit read,only register for storing the result of A/D conversion in response to the second trigger in double trigger mode."]
            #[inline(always)]
            pub fn set_addbldr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addbldr {
            #[inline(always)]
            fn default() -> Addbldr {
                Addbldr(0)
            }
        }
        impl core::fmt::Debug for Addbldr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addbldr")
                    .field("addbldr", &self.addbldr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addbldr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addbldr {{ addbldr: {=u16:?} }}", self.addbldr())
            }
        }
        #[doc = "A/D Data Duplexing Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addbldra(pub u16);
        impl Addbldra {
            #[doc = "This register is a 16-bit read,only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode."]
            #[inline(always)]
            pub const fn addbldra(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This register is a 16-bit read,only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode."]
            #[inline(always)]
            pub fn set_addbldra(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addbldra {
            #[inline(always)]
            fn default() -> Addbldra {
                Addbldra(0)
            }
        }
        impl core::fmt::Debug for Addbldra {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addbldra")
                    .field("addbldra", &self.addbldra())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addbldra {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addbldra {{ addbldra: {=u16:?} }}", self.addbldra())
            }
        }
        #[doc = "A/D Data Duplexing Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addbldrb(pub u16);
        impl Addbldrb {
            #[doc = "This register is a 16-bit read,only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode."]
            #[inline(always)]
            pub const fn addbldrb(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This register is a 16-bit read,only registers for storing the result of A/D conversion in response to the respective triggers during extended operation in double trigger mode."]
            #[inline(always)]
            pub fn set_addbldrb(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addbldrb {
            #[inline(always)]
            fn default() -> Addbldrb {
                Addbldrb(0)
            }
        }
        impl core::fmt::Debug for Addbldrb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addbldrb")
                    .field("addbldrb", &self.addbldrb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addbldrb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addbldrb {{ addbldrb: {=u16:?} }}", self.addbldrb())
            }
        }
        #[doc = "A/D Disconnection Detection Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addiscr(pub u8);
        impl Addiscr {
            #[doc = "Precharg/discharge period"]
            #[inline(always)]
            pub const fn adndis(&self) -> super::vals::Adndis {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Adndis::from_bits(val as u8)
            }
            #[doc = "Precharg/discharge period"]
            #[inline(always)]
            pub fn set_adndis(&mut self, val: super::vals::Adndis) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u8) & 0x0f) << 0usize);
            }
            #[doc = "Precharge/discharge select for odd analog input channels from AN000 to AN007"]
            #[inline(always)]
            pub const fn pchg2(&self) -> super::vals::Pchg2 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pchg2::from_bits(val as u8)
            }
            #[doc = "Precharge/discharge select for odd analog input channels from AN000 to AN007"]
            #[inline(always)]
            pub fn set_pchg2(&mut self, val: super::vals::Pchg2) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Precharge/discharge select for even analog input channels from AN000 to AN008 or analog input channels from AN016 to AN023"]
            #[inline(always)]
            pub const fn pchg1(&self) -> super::vals::Pchg1 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pchg1::from_bits(val as u8)
            }
            #[doc = "Precharge/discharge select for even analog input channels from AN000 to AN008 or analog input channels from AN016 to AN023"]
            #[inline(always)]
            pub fn set_pchg1(&mut self, val: super::vals::Pchg1) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Addiscr {
            #[inline(always)]
            fn default() -> Addiscr {
                Addiscr(0)
            }
        }
        impl core::fmt::Debug for Addiscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addiscr")
                    .field("adndis", &self.adndis())
                    .field("pchg2", &self.pchg2())
                    .field("pchg1", &self.pchg1())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addiscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Addiscr {{ adndis: {:?}, pchg2: {:?}, pchg1: {:?}, reserved_6_7: {=u8:?} }}",
                    self.adndis(),
                    self.pchg2(),
                    self.pchg1(),
                    self.reserved_6_7()
                )
            }
        }
        #[doc = "A/D Data Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addr(pub u16);
        impl Addr {
            #[doc = "The ADDR register is a 16-bit read,only registers for storing the result of A/D conversion."]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "The ADDR register is a 16-bit read,only registers for storing the result of A/D conversion."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addr {
            #[inline(always)]
            fn default() -> Addr {
                Addr(0)
            }
        }
        impl core::fmt::Debug for Addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addr").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addr {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "A/D Data Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addr1(pub u16);
        impl Addr1 {
            #[doc = "The ADDR register is a 16-bit read,only registers for storing the result of A/D conversion."]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "The ADDR register is a 16-bit read,only registers for storing the result of A/D conversion."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addr1 {
            #[inline(always)]
            fn default() -> Addr1 {
                Addr1(0)
            }
        }
        impl core::fmt::Debug for Addr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addr1").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addr1 {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "A/D Conversion Extended Input Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adexicr(pub u16);
        impl Adexicr {
            #[doc = "Temperature Sensor Output A/D converted Value Average Mode Select"]
            #[inline(always)]
            pub const fn tssad(&self) -> super::vals::Tssad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tssad::from_bits(val as u8)
            }
            #[doc = "Temperature Sensor Output A/D converted Value Average Mode Select"]
            #[inline(always)]
            pub fn set_tssad(&mut self, val: super::vals::Tssad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Internal Reference Voltage A/D converted Value Average Mode Select"]
            #[inline(always)]
            pub const fn ocsad(&self) -> super::vals::Ocsad {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ocsad::from_bits(val as u8)
            }
            #[doc = "Internal Reference Voltage A/D converted Value Average Mode Select"]
            #[inline(always)]
            pub fn set_ocsad(&mut self, val: super::vals::Ocsad) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u16) & 0x3f) << 2usize);
            }
            #[doc = "Temperature Sensor Output A/D Conversion Select"]
            #[inline(always)]
            pub const fn tssa(&self) -> super::vals::Tssa {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Tssa::from_bits(val as u8)
            }
            #[doc = "Temperature Sensor Output A/D Conversion Select"]
            #[inline(always)]
            pub fn set_tssa(&mut self, val: super::vals::Tssa) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Internal Reference Voltage A/D Conversion Select"]
            #[inline(always)]
            pub const fn ocsa(&self) -> super::vals::Ocsa {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ocsa::from_bits(val as u8)
            }
            #[doc = "Internal Reference Voltage A/D Conversion Select"]
            #[inline(always)]
            pub fn set_ocsa(&mut self, val: super::vals::Ocsa) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Adexicr {
            #[inline(always)]
            fn default() -> Adexicr {
                Adexicr(0)
            }
        }
        impl core::fmt::Debug for Adexicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adexicr")
                    .field("tssad", &self.tssad())
                    .field("ocsad", &self.ocsad())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .field("tssa", &self.tssa())
                    .field("ocsa", &self.ocsa())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adexicr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adexicr {{ tssad: {:?}, ocsad: {:?}, reserved_2_7: {=u8:?}, tssa: {:?}, ocsa: {:?}, reserved_10_15: {=u8:?} }}" , self . tssad () , self . ocsad () , self . reserved_2_7 () , self . tssa () , self . ocsa () , self . reserved_10_15 ())
            }
        }
        #[doc = "A/D Group Scan Priority Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adgspcr(pub u16);
        impl Adgspcr {
            #[doc = "Group A priority control setting bit.Note: When the PGS bit is to be set to 1, the ADCSR.ADCS\\[1:0\\] bits must be set to 01b (group scan mode). If the bits are set to any other values, proper operation is not guaranteed."]
            #[inline(always)]
            pub const fn pgs(&self) -> super::vals::Pgs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pgs::from_bits(val as u8)
            }
            #[doc = "Group A priority control setting bit.Note: When the PGS bit is to be set to 1, the ADCSR.ADCS\\[1:0\\] bits must be set to 01b (group scan mode). If the bits are set to any other values, proper operation is not guaranteed."]
            #[inline(always)]
            pub fn set_pgs(&mut self, val: super::vals::Pgs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Group B Restart Setting(Enabled only when PGS = 1. Reserved when PGS = 0.)"]
            #[inline(always)]
            pub const fn gbrscn(&self) -> super::vals::Gbrscn {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Gbrscn::from_bits(val as u8)
            }
            #[doc = "Group B Restart Setting(Enabled only when PGS = 1. Reserved when PGS = 0.)"]
            #[inline(always)]
            pub fn set_gbrscn(&mut self, val: super::vals::Gbrscn) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 0000000000000. The write value should be 0000000000000."]
            #[inline(always)]
            pub const fn reserved_2_14(&self) -> u16 {
                let val = (self.0 >> 2usize) & 0x1fff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000. The write value should be 0000000000000."]
            #[inline(always)]
            pub fn set_reserved_2_14(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 2usize)) | (((val as u16) & 0x1fff) << 2usize);
            }
            #[doc = "Group B Single Scan Continuous Start(Enabled only when PGS = 1. Reserved when PGS = 0.)Note: When the GBRP bit has been set to 1, single scan is performed continuously for group B regardless of the setting of the GBRSCN bit."]
            #[inline(always)]
            pub const fn gbrp(&self) -> super::vals::Gbrp {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Gbrp::from_bits(val as u8)
            }
            #[doc = "Group B Single Scan Continuous Start(Enabled only when PGS = 1. Reserved when PGS = 0.)Note: When the GBRP bit has been set to 1, single scan is performed continuously for group B regardless of the setting of the GBRSCN bit."]
            #[inline(always)]
            pub fn set_gbrp(&mut self, val: super::vals::Gbrp) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adgspcr {
            #[inline(always)]
            fn default() -> Adgspcr {
                Adgspcr(0)
            }
        }
        impl core::fmt::Debug for Adgspcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adgspcr")
                    .field("pgs", &self.pgs())
                    .field("gbrscn", &self.gbrscn())
                    .field("reserved_2_14", &self.reserved_2_14())
                    .field("gbrp", &self.gbrp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adgspcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adgspcr {{ pgs: {:?}, gbrscn: {:?}, reserved_2_14: {=u16:?}, gbrp: {:?} }}",
                    self.pgs(),
                    self.gbrscn(),
                    self.reserved_2_14(),
                    self.gbrp()
                )
            }
        }
        #[doc = "A/D Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adicr(pub u8);
        impl Adicr {
            #[doc = "A/D Interrupt Control"]
            #[inline(always)]
            pub const fn adic(&self) -> super::vals::Adic {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Adic::from_bits(val as u8)
            }
            #[doc = "A/D Interrupt Control"]
            #[inline(always)]
            pub fn set_adic(&mut self, val: super::vals::Adic) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Adicr {
            #[inline(always)]
            fn default() -> Adicr {
                Adicr(0)
            }
        }
        impl core::fmt::Debug for Adicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adicr")
                    .field("adic", &self.adic())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adicr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adicr {{ adic: {:?}, reserved_2_7: {=u8:?} }}",
                    self.adic(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "A/D Internal Reference Voltage Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adocdr(pub u16);
        impl Adocdr {
            #[doc = "This is a 16-bit read,only register for storing the A/D result of internal reference voltage."]
            #[inline(always)]
            pub const fn adocdr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is a 16-bit read,only register for storing the A/D result of internal reference voltage."]
            #[inline(always)]
            pub fn set_adocdr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adocdr {
            #[inline(always)]
            fn default() -> Adocdr {
                Adocdr(0)
            }
        }
        impl core::fmt::Debug for Adocdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adocdr")
                    .field("adocdr", &self.adocdr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adocdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adocdr {{ adocdr: {=u16:?} }}", self.adocdr())
            }
        }
        #[doc = "A/D Self,Diagnosis Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adrd(pub u16);
        impl Adrd {
            #[doc = "The ADRD register is a 16-bit read,only register that holds the A/D conversion results based on the self,diagnosis of the ADC16."]
            #[inline(always)]
            pub const fn adrd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "The ADRD register is a 16-bit read,only register that holds the A/D conversion results based on the self,diagnosis of the ADC16."]
            #[inline(always)]
            pub fn set_adrd(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adrd {
            #[inline(always)]
            fn default() -> Adrd {
                Adrd(0)
            }
        }
        impl core::fmt::Debug for Adrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adrd").field("adrd", &self.adrd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adrd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adrd {{ adrd: {=u16:?} }}", self.adrd())
            }
        }
        #[doc = "A/D Self,Diagnostic Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adrst(pub u8);
        impl Adrst {
            #[doc = "Self,Diagnosis Status"]
            #[inline(always)]
            pub const fn diagst(&self) -> super::vals::Diagst {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Diagst::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Status"]
            #[inline(always)]
            pub fn set_diagst(&mut self, val: super::vals::Diagst) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Adrst {
            #[inline(always)]
            fn default() -> Adrst {
                Adrst(0)
            }
        }
        impl core::fmt::Debug for Adrst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adrst")
                    .field("diagst", &self.diagst())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adrst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adrst {{ diagst: {:?}, reserved_2_7: {=u8:?} }}",
                    self.diagst(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "A/D Sampling State Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstr0(pub u8);
        impl Adsstr0 {
            #[doc = "Sampling time setting"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling time setting"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstr0 {
            #[inline(always)]
            fn default() -> Adsstr0 {
                Adsstr0(0)
            }
        }
        impl core::fmt::Debug for Adsstr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstr0").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstr0 {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Sampling State Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstrl(pub u8);
        impl Adsstrl {
            #[doc = "Sampling Time Setting (AN016-AN023, SBIAS/VREFI)"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting (AN016-AN023, SBIAS/VREFI)"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstrl {
            #[inline(always)]
            fn default() -> Adsstrl {
                Adsstrl(0)
            }
        }
        impl core::fmt::Debug for Adsstrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstrl").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstrl {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Sampling State Register O"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstro(pub u8);
        impl Adsstro {
            #[doc = "Sampling Time Setting (Internal reference voltage)"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting (Internal reference voltage)"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstro {
            #[inline(always)]
            fn default() -> Adsstro {
                Adsstro(0)
            }
        }
        impl core::fmt::Debug for Adsstro {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstro").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstro {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstro {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Sampling State Register T"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstrt(pub u8);
        impl Adsstrt {
            #[doc = "Sampling Time Setting (Temperature sensor output)"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting (Temperature sensor output)"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstrt {
            #[inline(always)]
            fn default() -> Adsstrt {
                Adsstrt(0)
            }
        }
        impl core::fmt::Debug for Adsstrt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstrt").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstrt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstrt {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Conversion Start Trigger Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adstrgr(pub u16);
        impl Adstrgr {
            #[doc = "A/D Conversion Start Trigger Select for Group BSelect the A/D conversion start trigger for group B in group scan mode."]
            #[inline(always)]
            pub const fn trsb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "A/D Conversion Start Trigger Select for Group BSelect the A/D conversion start trigger for group B in group scan mode."]
            #[inline(always)]
            pub fn set_trsb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u16) & 0x3f) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u16) & 0x03) << 6usize);
            }
            #[doc = "A/D Conversion Start Trigger SelectSelect the A/D conversion start trigger in single scan mode and continuous mode. In group scan mode, the A/D conversion start trigger for group A is selected."]
            #[inline(always)]
            pub const fn trsa(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "A/D Conversion Start Trigger SelectSelect the A/D conversion start trigger in single scan mode and continuous mode. In group scan mode, the A/D conversion start trigger for group A is selected."]
            #[inline(always)]
            pub fn set_trsa(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u16) & 0x3f) << 8usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_14_15(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_14_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 14usize)) | (((val as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Adstrgr {
            #[inline(always)]
            fn default() -> Adstrgr {
                Adstrgr(0)
            }
        }
        impl core::fmt::Debug for Adstrgr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adstrgr")
                    .field("trsb", &self.trsb())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .field("trsa", &self.trsa())
                    .field("reserved_14_15", &self.reserved_14_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adstrgr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adstrgr {{ trsb: {=u8:?}, reserved_6_7: {=u8:?}, trsa: {=u8:?}, reserved_14_15: {=u8:?} }}" , self . trsb () , self . reserved_6_7 () , self . trsa () , self . reserved_14_15 ())
            }
        }
        #[doc = "A/D Temperature Sensor Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adtsdr(pub u16);
        impl Adtsdr {
            #[doc = "This is a 16-bit read,only register for storing the A/D conversion result of temperature sensor output."]
            #[inline(always)]
            pub const fn adtsdr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is a 16-bit read,only register for storing the A/D conversion result of temperature sensor output."]
            #[inline(always)]
            pub fn set_adtsdr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adtsdr {
            #[inline(always)]
            fn default() -> Adtsdr {
                Adtsdr(0)
            }
        }
        impl core::fmt::Debug for Adtsdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adtsdr")
                    .field("adtsdr", &self.adtsdr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adtsdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adtsdr {{ adtsdr: {=u16:?} }}", self.adtsdr())
            }
        }
        #[doc = "A/D Compare Function Window B Lower,Side Level Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adwinllb(pub u16);
        impl Adwinllb {
            #[doc = "This register is used to compare A window function is used to set the lower level of the window B."]
            #[inline(always)]
            pub const fn adwinllb(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This register is used to compare A window function is used to set the lower level of the window B."]
            #[inline(always)]
            pub fn set_adwinllb(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adwinllb {
            #[inline(always)]
            fn default() -> Adwinllb {
                Adwinllb(0)
            }
        }
        impl core::fmt::Debug for Adwinllb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adwinllb")
                    .field("adwinllb", &self.adwinllb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adwinllb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adwinllb {{ adwinllb: {=u16:?} }}", self.adwinllb())
            }
        }
        #[doc = "A/D Compare Function Window A/B Status Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adwinmon(pub u8);
        impl Adwinmon {
            #[doc = "Combination result monitorThis bit indicates the combination result. This bit is valid when both window A operation and window B operation are enabled."]
            #[inline(always)]
            pub const fn moncomb(&self) -> super::vals::Moncomb {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Moncomb::from_bits(val as u8)
            }
            #[doc = "Combination result monitorThis bit indicates the combination result. This bit is valid when both window A operation and window B operation are enabled."]
            #[inline(always)]
            pub fn set_moncomb(&mut self, val: super::vals::Moncomb) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub const fn reserved_1_3(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub fn set_reserved_1_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "Comparison Result Monitor A"]
            #[inline(always)]
            pub const fn moncmpa(&self) -> super::vals::Moncmpa {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Moncmpa::from_bits(val as u8)
            }
            #[doc = "Comparison Result Monitor A"]
            #[inline(always)]
            pub fn set_moncmpa(&mut self, val: super::vals::Moncmpa) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Comparison Result Monitor B"]
            #[inline(always)]
            pub const fn moncmpb(&self) -> super::vals::Moncmpb {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Moncmpb::from_bits(val as u8)
            }
            #[doc = "Comparison Result Monitor B"]
            #[inline(always)]
            pub fn set_moncmpb(&mut self, val: super::vals::Moncmpb) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Adwinmon {
            #[inline(always)]
            fn default() -> Adwinmon {
                Adwinmon(0)
            }
        }
        impl core::fmt::Debug for Adwinmon {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adwinmon")
                    .field("moncomb", &self.moncomb())
                    .field("reserved_1_3", &self.reserved_1_3())
                    .field("moncmpa", &self.moncmpa())
                    .field("moncmpb", &self.moncmpb())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adwinmon {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adwinmon {{ moncomb: {:?}, reserved_1_3: {=u8:?}, moncmpa: {:?}, moncmpb: {:?}, reserved_6_7: {=u8:?} }}" , self . moncomb () , self . reserved_1_3 () , self . moncmpa () , self . moncmpb () , self . reserved_6_7 ())
            }
        }
        #[doc = "A/D Compare Function Window B Upper,Side Level Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adwinulb(pub u16);
        impl Adwinulb {
            #[doc = "This register is used to compare A window function is used to set the higher level of the window B."]
            #[inline(always)]
            pub const fn adwinulb(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This register is used to compare A window function is used to set the higher level of the window B."]
            #[inline(always)]
            pub fn set_adwinulb(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adwinulb {
            #[inline(always)]
            fn default() -> Adwinulb {
                Adwinulb(0)
            }
        }
        impl core::fmt::Debug for Adwinulb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adwinulb")
                    .field("adwinulb", &self.adwinulb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adwinulb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adwinulb {{ adwinulb: {=u16:?} }}", self.adwinulb())
            }
        }
        #[doc = "A/D Dedicated Reference Voltage Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vrefampcnt(pub u8);
        impl Vrefampcnt {
            #[doc = "OLDET Enable"]
            #[inline(always)]
            pub const fn oldeten(&self) -> super::vals::Oldeten {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Oldeten::from_bits(val as u8)
            }
            #[doc = "OLDET Enable"]
            #[inline(always)]
            pub fn set_oldeten(&mut self, val: super::vals::Oldeten) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "VREFADC Output Voltage Control"]
            #[inline(always)]
            pub const fn vrefadcg(&self) -> super::vals::Vrefadcg {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Vrefadcg::from_bits(val as u8)
            }
            #[doc = "VREFADC Output Voltage Control"]
            #[inline(always)]
            pub fn set_vrefadcg(&mut self, val: super::vals::Vrefadcg) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u8) & 0x03) << 1usize);
            }
            #[doc = "VREFADCG Enable"]
            #[inline(always)]
            pub const fn vrefadcen(&self) -> super::vals::Vrefadcen {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Vrefadcen::from_bits(val as u8)
            }
            #[doc = "VREFADCG Enable"]
            #[inline(always)]
            pub fn set_vrefadcen(&mut self, val: super::vals::Vrefadcen) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Low,Potential Reference Voltage Select"]
            #[inline(always)]
            pub const fn bgren(&self) -> super::vals::Bgren {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Bgren::from_bits(val as u8)
            }
            #[doc = "Low,Potential Reference Voltage Select"]
            #[inline(always)]
            pub fn set_bgren(&mut self, val: super::vals::Bgren) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_5_6(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_5_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u8) & 0x03) << 5usize);
            }
            #[doc = "Sleep"]
            #[inline(always)]
            pub const fn adslp(&self) -> super::vals::Adslp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Adslp::from_bits(val as u8)
            }
            #[doc = "Sleep"]
            #[inline(always)]
            pub fn set_adslp(&mut self, val: super::vals::Adslp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Vrefampcnt {
            #[inline(always)]
            fn default() -> Vrefampcnt {
                Vrefampcnt(0)
            }
        }
        impl core::fmt::Debug for Vrefampcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vrefampcnt")
                    .field("oldeten", &self.oldeten())
                    .field("vrefadcg", &self.vrefadcg())
                    .field("vrefadcen", &self.vrefadcen())
                    .field("bgren", &self.bgren())
                    .field("reserved_5_6", &self.reserved_5_6())
                    .field("adslp", &self.adslp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vrefampcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Vrefampcnt {{ oldeten: {:?}, vrefadcg: {:?}, vrefadcen: {:?}, bgren: {:?}, reserved_5_6: {=u8:?}, adslp: {:?} }}" , self . oldeten () , self . vrefadcg () , self . vrefadcen () , self . bgren () , self . reserved_5_6 () , self . adslp ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ace {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ace {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ace {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ace {
            #[inline(always)]
            fn from(val: u8) -> Ace {
                Ace::from_bits(val)
            }
        }
        impl From<Ace> for u8 {
            #[inline(always)]
            fn from(val: Ace) -> u8 {
                Ace::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Adc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adc {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adc {
            #[inline(always)]
            fn from(val: u8) -> Adc {
                Adc::from_bits(val)
            }
        }
        impl From<Adc> for u8 {
            #[inline(always)]
            fn from(val: Adc) -> u8 {
                Adc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Adcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adcs {
            #[inline(always)]
            fn from(val: u8) -> Adcs {
                Adcs::from_bits(val)
            }
        }
        impl From<Adcs> for u8 {
            #[inline(always)]
            fn from(val: Adcs) -> u8 {
                Adcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adhsc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adhsc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adhsc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adhsc {
            #[inline(always)]
            fn from(val: u8) -> Adhsc {
                Adhsc::from_bits(val)
            }
        }
        impl From<Adhsc> for u8 {
            #[inline(always)]
            fn from(val: Adhsc) -> u8 {
                Adhsc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adic {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Adic {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adic {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adic {
            #[inline(always)]
            fn from(val: u8) -> Adic {
                Adic::from_bits(val)
            }
        }
        impl From<Adic> for u8 {
            #[inline(always)]
            fn from(val: Adic) -> u8 {
                Adic::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adinv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adinv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adinv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adinv {
            #[inline(always)]
            fn from(val: u8) -> Adinv {
                Adinv::from_bits(val)
            }
        }
        impl From<Adinv> for u8 {
            #[inline(always)]
            fn from(val: Adinv) -> u8 {
                Adinv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adndis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Adndis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adndis {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adndis {
            #[inline(always)]
            fn from(val: u8) -> Adndis {
                Adndis::from_bits(val)
            }
        }
        impl From<Adndis> for u8 {
            #[inline(always)]
            fn from(val: Adndis) -> u8 {
                Adndis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads00 {
            #[inline(always)]
            fn from(val: u8) -> Ads00 {
                Ads00::from_bits(val)
            }
        }
        impl From<Ads00> for u8 {
            #[inline(always)]
            fn from(val: Ads00) -> u8 {
                Ads00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads01 {
            #[inline(always)]
            fn from(val: u8) -> Ads01 {
                Ads01::from_bits(val)
            }
        }
        impl From<Ads01> for u8 {
            #[inline(always)]
            fn from(val: Ads01) -> u8 {
                Ads01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads02 {
            #[inline(always)]
            fn from(val: u8) -> Ads02 {
                Ads02::from_bits(val)
            }
        }
        impl From<Ads02> for u8 {
            #[inline(always)]
            fn from(val: Ads02) -> u8 {
                Ads02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads03 {
            #[inline(always)]
            fn from(val: u8) -> Ads03 {
                Ads03::from_bits(val)
            }
        }
        impl From<Ads03> for u8 {
            #[inline(always)]
            fn from(val: Ads03) -> u8 {
                Ads03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads04 {
            #[inline(always)]
            fn from(val: u8) -> Ads04 {
                Ads04::from_bits(val)
            }
        }
        impl From<Ads04> for u8 {
            #[inline(always)]
            fn from(val: Ads04) -> u8 {
                Ads04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads05 {
            #[inline(always)]
            fn from(val: u8) -> Ads05 {
                Ads05::from_bits(val)
            }
        }
        impl From<Ads05> for u8 {
            #[inline(always)]
            fn from(val: Ads05) -> u8 {
                Ads05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads06 {
            #[inline(always)]
            fn from(val: u8) -> Ads06 {
                Ads06::from_bits(val)
            }
        }
        impl From<Ads06> for u8 {
            #[inline(always)]
            fn from(val: Ads06) -> u8 {
                Ads06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads07 {
            #[inline(always)]
            fn from(val: u8) -> Ads07 {
                Ads07::from_bits(val)
            }
        }
        impl From<Ads07> for u8 {
            #[inline(always)]
            fn from(val: Ads07) -> u8 {
                Ads07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads08 {
            #[inline(always)]
            fn from(val: u8) -> Ads08 {
                Ads08::from_bits(val)
            }
        }
        impl From<Ads08> for u8 {
            #[inline(always)]
            fn from(val: Ads08) -> u8 {
                Ads08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads16 {
            #[inline(always)]
            fn from(val: u8) -> Ads16 {
                Ads16::from_bits(val)
            }
        }
        impl From<Ads16> for u8 {
            #[inline(always)]
            fn from(val: Ads16) -> u8 {
                Ads16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads17 {
            #[inline(always)]
            fn from(val: u8) -> Ads17 {
                Ads17::from_bits(val)
            }
        }
        impl From<Ads17> for u8 {
            #[inline(always)]
            fn from(val: Ads17) -> u8 {
                Ads17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads18 {
            #[inline(always)]
            fn from(val: u8) -> Ads18 {
                Ads18::from_bits(val)
            }
        }
        impl From<Ads18> for u8 {
            #[inline(always)]
            fn from(val: Ads18) -> u8 {
                Ads18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads19 {
            #[inline(always)]
            fn from(val: u8) -> Ads19 {
                Ads19::from_bits(val)
            }
        }
        impl From<Ads19> for u8 {
            #[inline(always)]
            fn from(val: Ads19) -> u8 {
                Ads19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads20 {
            #[inline(always)]
            fn from(val: u8) -> Ads20 {
                Ads20::from_bits(val)
            }
        }
        impl From<Ads20> for u8 {
            #[inline(always)]
            fn from(val: Ads20) -> u8 {
                Ads20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads21 {
            #[inline(always)]
            fn from(val: u8) -> Ads21 {
                Ads21::from_bits(val)
            }
        }
        impl From<Ads21> for u8 {
            #[inline(always)]
            fn from(val: Ads21) -> u8 {
                Ads21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads22 {
            #[inline(always)]
            fn from(val: u8) -> Ads22 {
                Ads22::from_bits(val)
            }
        }
        impl From<Ads22> for u8 {
            #[inline(always)]
            fn from(val: Ads22) -> u8 {
                Ads22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads23 {
            #[inline(always)]
            fn from(val: u8) -> Ads23 {
                Ads23::from_bits(val)
            }
        }
        impl From<Ads23> for u8 {
            #[inline(always)]
            fn from(val: Ads23) -> u8 {
                Ads23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads24 {
            #[inline(always)]
            fn from(val: u8) -> Ads24 {
                Ads24::from_bits(val)
            }
        }
        impl From<Ads24> for u8 {
            #[inline(always)]
            fn from(val: Ads24) -> u8 {
                Ads24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adslp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adslp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adslp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adslp {
            #[inline(always)]
            fn from(val: u8) -> Adslp {
                Adslp::from_bits(val)
            }
        }
        impl From<Adslp> for u8 {
            #[inline(always)]
            fn from(val: Adslp) -> u8 {
                Adslp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adst {
            #[inline(always)]
            fn from(val: u8) -> Adst {
                Adst::from_bits(val)
            }
        }
        impl From<Adst> for u8 {
            #[inline(always)]
            fn from(val: Adst) -> u8 {
                Adst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa00 {
            #[inline(always)]
            fn from(val: u8) -> Ansa00 {
                Ansa00::from_bits(val)
            }
        }
        impl From<Ansa00> for u8 {
            #[inline(always)]
            fn from(val: Ansa00) -> u8 {
                Ansa00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa01 {
            #[inline(always)]
            fn from(val: u8) -> Ansa01 {
                Ansa01::from_bits(val)
            }
        }
        impl From<Ansa01> for u8 {
            #[inline(always)]
            fn from(val: Ansa01) -> u8 {
                Ansa01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa02 {
            #[inline(always)]
            fn from(val: u8) -> Ansa02 {
                Ansa02::from_bits(val)
            }
        }
        impl From<Ansa02> for u8 {
            #[inline(always)]
            fn from(val: Ansa02) -> u8 {
                Ansa02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa03 {
            #[inline(always)]
            fn from(val: u8) -> Ansa03 {
                Ansa03::from_bits(val)
            }
        }
        impl From<Ansa03> for u8 {
            #[inline(always)]
            fn from(val: Ansa03) -> u8 {
                Ansa03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa04 {
            #[inline(always)]
            fn from(val: u8) -> Ansa04 {
                Ansa04::from_bits(val)
            }
        }
        impl From<Ansa04> for u8 {
            #[inline(always)]
            fn from(val: Ansa04) -> u8 {
                Ansa04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa05 {
            #[inline(always)]
            fn from(val: u8) -> Ansa05 {
                Ansa05::from_bits(val)
            }
        }
        impl From<Ansa05> for u8 {
            #[inline(always)]
            fn from(val: Ansa05) -> u8 {
                Ansa05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa06 {
            #[inline(always)]
            fn from(val: u8) -> Ansa06 {
                Ansa06::from_bits(val)
            }
        }
        impl From<Ansa06> for u8 {
            #[inline(always)]
            fn from(val: Ansa06) -> u8 {
                Ansa06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa07 {
            #[inline(always)]
            fn from(val: u8) -> Ansa07 {
                Ansa07::from_bits(val)
            }
        }
        impl From<Ansa07> for u8 {
            #[inline(always)]
            fn from(val: Ansa07) -> u8 {
                Ansa07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa08 {
            #[inline(always)]
            fn from(val: u8) -> Ansa08 {
                Ansa08::from_bits(val)
            }
        }
        impl From<Ansa08> for u8 {
            #[inline(always)]
            fn from(val: Ansa08) -> u8 {
                Ansa08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa16 {
            #[inline(always)]
            fn from(val: u8) -> Ansa16 {
                Ansa16::from_bits(val)
            }
        }
        impl From<Ansa16> for u8 {
            #[inline(always)]
            fn from(val: Ansa16) -> u8 {
                Ansa16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa17 {
            #[inline(always)]
            fn from(val: u8) -> Ansa17 {
                Ansa17::from_bits(val)
            }
        }
        impl From<Ansa17> for u8 {
            #[inline(always)]
            fn from(val: Ansa17) -> u8 {
                Ansa17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa18 {
            #[inline(always)]
            fn from(val: u8) -> Ansa18 {
                Ansa18::from_bits(val)
            }
        }
        impl From<Ansa18> for u8 {
            #[inline(always)]
            fn from(val: Ansa18) -> u8 {
                Ansa18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa19 {
            #[inline(always)]
            fn from(val: u8) -> Ansa19 {
                Ansa19::from_bits(val)
            }
        }
        impl From<Ansa19> for u8 {
            #[inline(always)]
            fn from(val: Ansa19) -> u8 {
                Ansa19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa20 {
            #[inline(always)]
            fn from(val: u8) -> Ansa20 {
                Ansa20::from_bits(val)
            }
        }
        impl From<Ansa20> for u8 {
            #[inline(always)]
            fn from(val: Ansa20) -> u8 {
                Ansa20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa21 {
            #[inline(always)]
            fn from(val: u8) -> Ansa21 {
                Ansa21::from_bits(val)
            }
        }
        impl From<Ansa21> for u8 {
            #[inline(always)]
            fn from(val: Ansa21) -> u8 {
                Ansa21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa22 {
            #[inline(always)]
            fn from(val: u8) -> Ansa22 {
                Ansa22::from_bits(val)
            }
        }
        impl From<Ansa22> for u8 {
            #[inline(always)]
            fn from(val: Ansa22) -> u8 {
                Ansa22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa23 {
            #[inline(always)]
            fn from(val: u8) -> Ansa23 {
                Ansa23::from_bits(val)
            }
        }
        impl From<Ansa23> for u8 {
            #[inline(always)]
            fn from(val: Ansa23) -> u8 {
                Ansa23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa24 {
            #[inline(always)]
            fn from(val: u8) -> Ansa24 {
                Ansa24::from_bits(val)
            }
        }
        impl From<Ansa24> for u8 {
            #[inline(always)]
            fn from(val: Ansa24) -> u8 {
                Ansa24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb00 {
            #[inline(always)]
            fn from(val: u8) -> Ansb00 {
                Ansb00::from_bits(val)
            }
        }
        impl From<Ansb00> for u8 {
            #[inline(always)]
            fn from(val: Ansb00) -> u8 {
                Ansb00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb01 {
            #[inline(always)]
            fn from(val: u8) -> Ansb01 {
                Ansb01::from_bits(val)
            }
        }
        impl From<Ansb01> for u8 {
            #[inline(always)]
            fn from(val: Ansb01) -> u8 {
                Ansb01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb02 {
            #[inline(always)]
            fn from(val: u8) -> Ansb02 {
                Ansb02::from_bits(val)
            }
        }
        impl From<Ansb02> for u8 {
            #[inline(always)]
            fn from(val: Ansb02) -> u8 {
                Ansb02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb03 {
            #[inline(always)]
            fn from(val: u8) -> Ansb03 {
                Ansb03::from_bits(val)
            }
        }
        impl From<Ansb03> for u8 {
            #[inline(always)]
            fn from(val: Ansb03) -> u8 {
                Ansb03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb04 {
            #[inline(always)]
            fn from(val: u8) -> Ansb04 {
                Ansb04::from_bits(val)
            }
        }
        impl From<Ansb04> for u8 {
            #[inline(always)]
            fn from(val: Ansb04) -> u8 {
                Ansb04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb05 {
            #[inline(always)]
            fn from(val: u8) -> Ansb05 {
                Ansb05::from_bits(val)
            }
        }
        impl From<Ansb05> for u8 {
            #[inline(always)]
            fn from(val: Ansb05) -> u8 {
                Ansb05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb06 {
            #[inline(always)]
            fn from(val: u8) -> Ansb06 {
                Ansb06::from_bits(val)
            }
        }
        impl From<Ansb06> for u8 {
            #[inline(always)]
            fn from(val: Ansb06) -> u8 {
                Ansb06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb07 {
            #[inline(always)]
            fn from(val: u8) -> Ansb07 {
                Ansb07::from_bits(val)
            }
        }
        impl From<Ansb07> for u8 {
            #[inline(always)]
            fn from(val: Ansb07) -> u8 {
                Ansb07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb08 {
            #[inline(always)]
            fn from(val: u8) -> Ansb08 {
                Ansb08::from_bits(val)
            }
        }
        impl From<Ansb08> for u8 {
            #[inline(always)]
            fn from(val: Ansb08) -> u8 {
                Ansb08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb16 {
            #[inline(always)]
            fn from(val: u8) -> Ansb16 {
                Ansb16::from_bits(val)
            }
        }
        impl From<Ansb16> for u8 {
            #[inline(always)]
            fn from(val: Ansb16) -> u8 {
                Ansb16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb17 {
            #[inline(always)]
            fn from(val: u8) -> Ansb17 {
                Ansb17::from_bits(val)
            }
        }
        impl From<Ansb17> for u8 {
            #[inline(always)]
            fn from(val: Ansb17) -> u8 {
                Ansb17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb18 {
            #[inline(always)]
            fn from(val: u8) -> Ansb18 {
                Ansb18::from_bits(val)
            }
        }
        impl From<Ansb18> for u8 {
            #[inline(always)]
            fn from(val: Ansb18) -> u8 {
                Ansb18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb19 {
            #[inline(always)]
            fn from(val: u8) -> Ansb19 {
                Ansb19::from_bits(val)
            }
        }
        impl From<Ansb19> for u8 {
            #[inline(always)]
            fn from(val: Ansb19) -> u8 {
                Ansb19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb20 {
            #[inline(always)]
            fn from(val: u8) -> Ansb20 {
                Ansb20::from_bits(val)
            }
        }
        impl From<Ansb20> for u8 {
            #[inline(always)]
            fn from(val: Ansb20) -> u8 {
                Ansb20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb21 {
            #[inline(always)]
            fn from(val: u8) -> Ansb21 {
                Ansb21::from_bits(val)
            }
        }
        impl From<Ansb21> for u8 {
            #[inline(always)]
            fn from(val: Ansb21) -> u8 {
                Ansb21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb22 {
            #[inline(always)]
            fn from(val: u8) -> Ansb22 {
                Ansb22::from_bits(val)
            }
        }
        impl From<Ansb22> for u8 {
            #[inline(always)]
            fn from(val: Ansb22) -> u8 {
                Ansb22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb23 {
            #[inline(always)]
            fn from(val: u8) -> Ansb23 {
                Ansb23::from_bits(val)
            }
        }
        impl From<Ansb23> for u8 {
            #[inline(always)]
            fn from(val: Ansb23) -> u8 {
                Ansb23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb24 {
            #[inline(always)]
            fn from(val: u8) -> Ansb24 {
                Ansb24::from_bits(val)
            }
        }
        impl From<Ansb24> for u8 {
            #[inline(always)]
            fn from(val: Ansb24) -> u8 {
                Ansb24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bgren {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bgren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bgren {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bgren {
            #[inline(always)]
            fn from(val: u8) -> Bgren {
                Bgren::from_bits(val)
            }
        }
        impl From<Bgren> for u8 {
            #[inline(always)]
            fn from(val: Bgren) -> u8 {
                Bgren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Calexe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Calexe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Calexe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Calexe {
            #[inline(always)]
            fn from(val: u8) -> Calexe {
                Calexe::from_bits(val)
            }
        }
        impl From<Calexe> for u8 {
            #[inline(always)]
            fn from(val: Calexe) -> u8 {
                Calexe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Calmon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Calmon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Calmon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Calmon {
            #[inline(always)]
            fn from(val: u8) -> Calmon {
                Calmon::from_bits(val)
            }
        }
        impl From<Calmon> for u8 {
            #[inline(always)]
            fn from(val: Calmon) -> u8 {
                Calmon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpab {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cmpab {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpab {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpab {
            #[inline(always)]
            fn from(val: u8) -> Cmpab {
                Cmpab::from_bits(val)
            }
        }
        impl From<Cmpab> for u8 {
            #[inline(always)]
            fn from(val: Cmpab) -> u8 {
                Cmpab::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpae {
            #[inline(always)]
            fn from(val: u8) -> Cmpae {
                Cmpae::from_bits(val)
            }
        }
        impl From<Cmpae> for u8 {
            #[inline(always)]
            fn from(val: Cmpae) -> u8 {
                Cmpae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpaie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpaie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpaie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpaie {
            #[inline(always)]
            fn from(val: u8) -> Cmpaie {
                Cmpaie::from_bits(val)
            }
        }
        impl From<Cmpaie> for u8 {
            #[inline(always)]
            fn from(val: Cmpaie) -> u8 {
                Cmpaie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpbe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpbe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpbe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpbe {
            #[inline(always)]
            fn from(val: u8) -> Cmpbe {
                Cmpbe::from_bits(val)
            }
        }
        impl From<Cmpbe> for u8 {
            #[inline(always)]
            fn from(val: Cmpbe) -> u8 {
                Cmpbe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpbie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpbie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpbie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpbie {
            #[inline(always)]
            fn from(val: u8) -> Cmpbie {
                Cmpbie::from_bits(val)
            }
        }
        impl From<Cmpbie> for u8 {
            #[inline(always)]
            fn from(val: Cmpbie) -> u8 {
                Cmpbie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha00 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha00 {
                Cmpcha00::from_bits(val)
            }
        }
        impl From<Cmpcha00> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha00) -> u8 {
                Cmpcha00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha01 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha01 {
                Cmpcha01::from_bits(val)
            }
        }
        impl From<Cmpcha01> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha01) -> u8 {
                Cmpcha01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha02 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha02 {
                Cmpcha02::from_bits(val)
            }
        }
        impl From<Cmpcha02> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha02) -> u8 {
                Cmpcha02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha03 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha03 {
                Cmpcha03::from_bits(val)
            }
        }
        impl From<Cmpcha03> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha03) -> u8 {
                Cmpcha03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha04 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha04 {
                Cmpcha04::from_bits(val)
            }
        }
        impl From<Cmpcha04> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha04) -> u8 {
                Cmpcha04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha05 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha05 {
                Cmpcha05::from_bits(val)
            }
        }
        impl From<Cmpcha05> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha05) -> u8 {
                Cmpcha05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha06 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha06 {
                Cmpcha06::from_bits(val)
            }
        }
        impl From<Cmpcha06> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha06) -> u8 {
                Cmpcha06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha07 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha07 {
                Cmpcha07::from_bits(val)
            }
        }
        impl From<Cmpcha07> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha07) -> u8 {
                Cmpcha07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha08 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha08 {
                Cmpcha08::from_bits(val)
            }
        }
        impl From<Cmpcha08> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha08) -> u8 {
                Cmpcha08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha16 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha16 {
                Cmpcha16::from_bits(val)
            }
        }
        impl From<Cmpcha16> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha16) -> u8 {
                Cmpcha16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha17 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha17 {
                Cmpcha17::from_bits(val)
            }
        }
        impl From<Cmpcha17> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha17) -> u8 {
                Cmpcha17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha18 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha18 {
                Cmpcha18::from_bits(val)
            }
        }
        impl From<Cmpcha18> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha18) -> u8 {
                Cmpcha18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha19 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha19 {
                Cmpcha19::from_bits(val)
            }
        }
        impl From<Cmpcha19> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha19) -> u8 {
                Cmpcha19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha20 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha20 {
                Cmpcha20::from_bits(val)
            }
        }
        impl From<Cmpcha20> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha20) -> u8 {
                Cmpcha20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha21 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha21 {
                Cmpcha21::from_bits(val)
            }
        }
        impl From<Cmpcha21> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha21) -> u8 {
                Cmpcha21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha22 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha22 {
                Cmpcha22::from_bits(val)
            }
        }
        impl From<Cmpcha22> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha22) -> u8 {
                Cmpcha22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha23 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha23 {
                Cmpcha23::from_bits(val)
            }
        }
        impl From<Cmpcha23> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha23) -> u8 {
                Cmpcha23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha24 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha24 {
                Cmpcha24::from_bits(val)
            }
        }
        impl From<Cmpcha24> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha24) -> u8 {
                Cmpcha24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpchb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
            _RESERVED_20 = 0x20,
            _RESERVED_21 = 0x21,
            _RESERVED_22 = 0x22,
            _RESERVED_23 = 0x23,
            _RESERVED_24 = 0x24,
            _RESERVED_25 = 0x25,
            _RESERVED_26 = 0x26,
            _RESERVED_27 = 0x27,
            _RESERVED_28 = 0x28,
            _RESERVED_29 = 0x29,
            _RESERVED_2a = 0x2a,
            _RESERVED_2b = 0x2b,
            _RESERVED_2c = 0x2c,
            _RESERVED_2d = 0x2d,
            _RESERVED_2e = 0x2e,
            _RESERVED_2f = 0x2f,
            _RESERVED_30 = 0x30,
            _RESERVED_31 = 0x31,
            _RESERVED_32 = 0x32,
            _RESERVED_33 = 0x33,
            _RESERVED_34 = 0x34,
            _RESERVED_35 = 0x35,
            _RESERVED_36 = 0x36,
            _RESERVED_37 = 0x37,
            _RESERVED_38 = 0x38,
            _RESERVED_39 = 0x39,
            _RESERVED_3a = 0x3a,
            _RESERVED_3b = 0x3b,
            _RESERVED_3c = 0x3c,
            _RESERVED_3d = 0x3d,
            _RESERVED_3e = 0x3e,
            _RESERVED_3f = 0x3f,
        }
        impl Cmpchb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpchb {
                unsafe { core::mem::transmute(val & 0x3f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpchb {
            #[inline(always)]
            fn from(val: u8) -> Cmpchb {
                Cmpchb::from_bits(val)
            }
        }
        impl From<Cmpchb> for u8 {
            #[inline(always)]
            fn from(val: Cmpchb) -> u8 {
                Cmpchb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplb {
            #[inline(always)]
            fn from(val: u8) -> Cmplb {
                Cmplb::from_bits(val)
            }
        }
        impl From<Cmplb> for u8 {
            #[inline(always)]
            fn from(val: Cmplb) -> u8 {
                Cmplb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha00 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha00 {
                Cmplcha00::from_bits(val)
            }
        }
        impl From<Cmplcha00> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha00) -> u8 {
                Cmplcha00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha01 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha01 {
                Cmplcha01::from_bits(val)
            }
        }
        impl From<Cmplcha01> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha01) -> u8 {
                Cmplcha01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha02 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha02 {
                Cmplcha02::from_bits(val)
            }
        }
        impl From<Cmplcha02> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha02) -> u8 {
                Cmplcha02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha03 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha03 {
                Cmplcha03::from_bits(val)
            }
        }
        impl From<Cmplcha03> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha03) -> u8 {
                Cmplcha03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha04 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha04 {
                Cmplcha04::from_bits(val)
            }
        }
        impl From<Cmplcha04> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha04) -> u8 {
                Cmplcha04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha05 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha05 {
                Cmplcha05::from_bits(val)
            }
        }
        impl From<Cmplcha05> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha05) -> u8 {
                Cmplcha05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha06 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha06 {
                Cmplcha06::from_bits(val)
            }
        }
        impl From<Cmplcha06> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha06) -> u8 {
                Cmplcha06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha07 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha07 {
                Cmplcha07::from_bits(val)
            }
        }
        impl From<Cmplcha07> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha07) -> u8 {
                Cmplcha07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha08 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha08 {
                Cmplcha08::from_bits(val)
            }
        }
        impl From<Cmplcha08> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha08) -> u8 {
                Cmplcha08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha16 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha16 {
                Cmplcha16::from_bits(val)
            }
        }
        impl From<Cmplcha16> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha16) -> u8 {
                Cmplcha16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha17 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha17 {
                Cmplcha17::from_bits(val)
            }
        }
        impl From<Cmplcha17> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha17) -> u8 {
                Cmplcha17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha18 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha18 {
                Cmplcha18::from_bits(val)
            }
        }
        impl From<Cmplcha18> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha18) -> u8 {
                Cmplcha18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha19 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha19 {
                Cmplcha19::from_bits(val)
            }
        }
        impl From<Cmplcha19> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha19) -> u8 {
                Cmplcha19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha20 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha20 {
                Cmplcha20::from_bits(val)
            }
        }
        impl From<Cmplcha20> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha20) -> u8 {
                Cmplcha20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha21 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha21 {
                Cmplcha21::from_bits(val)
            }
        }
        impl From<Cmplcha21> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha21) -> u8 {
                Cmplcha21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha22 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha22 {
                Cmplcha22::from_bits(val)
            }
        }
        impl From<Cmplcha22> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha22) -> u8 {
                Cmplcha22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha23 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha23 {
                Cmplcha23::from_bits(val)
            }
        }
        impl From<Cmplcha23> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha23) -> u8 {
                Cmplcha23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha24 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha24 {
                Cmplcha24::from_bits(val)
            }
        }
        impl From<Cmplcha24> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha24) -> u8 {
                Cmplcha24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmploca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmploca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmploca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmploca {
            #[inline(always)]
            fn from(val: u8) -> Cmploca {
                Cmploca::from_bits(val)
            }
        }
        impl From<Cmploca> for u8 {
            #[inline(always)]
            fn from(val: Cmploca) -> u8 {
                Cmploca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpltsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpltsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpltsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpltsa {
            #[inline(always)]
            fn from(val: u8) -> Cmpltsa {
                Cmpltsa::from_bits(val)
            }
        }
        impl From<Cmpltsa> for u8 {
            #[inline(always)]
            fn from(val: Cmpltsa) -> u8 {
                Cmpltsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpoca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpoca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpoca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpoca {
            #[inline(always)]
            fn from(val: u8) -> Cmpoca {
                Cmpoca::from_bits(val)
            }
        }
        impl From<Cmpoca> for u8 {
            #[inline(always)]
            fn from(val: Cmpoca) -> u8 {
                Cmpoca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstb {
            #[inline(always)]
            fn from(val: u8) -> Cmpstb {
                Cmpstb::from_bits(val)
            }
        }
        impl From<Cmpstb> for u8 {
            #[inline(always)]
            fn from(val: Cmpstb) -> u8 {
                Cmpstb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha00 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha00 {
                Cmpstcha00::from_bits(val)
            }
        }
        impl From<Cmpstcha00> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha00) -> u8 {
                Cmpstcha00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha01 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha01 {
                Cmpstcha01::from_bits(val)
            }
        }
        impl From<Cmpstcha01> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha01) -> u8 {
                Cmpstcha01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha02 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha02 {
                Cmpstcha02::from_bits(val)
            }
        }
        impl From<Cmpstcha02> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha02) -> u8 {
                Cmpstcha02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha03 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha03 {
                Cmpstcha03::from_bits(val)
            }
        }
        impl From<Cmpstcha03> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha03) -> u8 {
                Cmpstcha03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha04 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha04 {
                Cmpstcha04::from_bits(val)
            }
        }
        impl From<Cmpstcha04> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha04) -> u8 {
                Cmpstcha04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha05 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha05 {
                Cmpstcha05::from_bits(val)
            }
        }
        impl From<Cmpstcha05> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha05) -> u8 {
                Cmpstcha05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha06 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha06 {
                Cmpstcha06::from_bits(val)
            }
        }
        impl From<Cmpstcha06> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha06) -> u8 {
                Cmpstcha06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha07 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha07 {
                Cmpstcha07::from_bits(val)
            }
        }
        impl From<Cmpstcha07> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha07) -> u8 {
                Cmpstcha07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha08 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha08 {
                Cmpstcha08::from_bits(val)
            }
        }
        impl From<Cmpstcha08> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha08) -> u8 {
                Cmpstcha08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha16 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha16 {
                Cmpstcha16::from_bits(val)
            }
        }
        impl From<Cmpstcha16> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha16) -> u8 {
                Cmpstcha16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha17 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha17 {
                Cmpstcha17::from_bits(val)
            }
        }
        impl From<Cmpstcha17> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha17) -> u8 {
                Cmpstcha17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha18 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha18 {
                Cmpstcha18::from_bits(val)
            }
        }
        impl From<Cmpstcha18> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha18) -> u8 {
                Cmpstcha18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha19 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha19 {
                Cmpstcha19::from_bits(val)
            }
        }
        impl From<Cmpstcha19> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha19) -> u8 {
                Cmpstcha19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha20 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha20 {
                Cmpstcha20::from_bits(val)
            }
        }
        impl From<Cmpstcha20> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha20) -> u8 {
                Cmpstcha20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha21 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha21 {
                Cmpstcha21::from_bits(val)
            }
        }
        impl From<Cmpstcha21> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha21) -> u8 {
                Cmpstcha21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha22 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha22 {
                Cmpstcha22::from_bits(val)
            }
        }
        impl From<Cmpstcha22> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha22) -> u8 {
                Cmpstcha22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha23 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha23 {
                Cmpstcha23::from_bits(val)
            }
        }
        impl From<Cmpstcha23> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha23) -> u8 {
                Cmpstcha23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha24 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha24 {
                Cmpstcha24::from_bits(val)
            }
        }
        impl From<Cmpstcha24> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha24) -> u8 {
                Cmpstcha24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstoca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstoca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstoca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstoca {
            #[inline(always)]
            fn from(val: u8) -> Cmpstoca {
                Cmpstoca::from_bits(val)
            }
        }
        impl From<Cmpstoca> for u8 {
            #[inline(always)]
            fn from(val: Cmpstoca) -> u8 {
                Cmpstoca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpsttsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpsttsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpsttsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpsttsa {
            #[inline(always)]
            fn from(val: u8) -> Cmpsttsa {
                Cmpsttsa::from_bits(val)
            }
        }
        impl From<Cmpsttsa> for u8 {
            #[inline(always)]
            fn from(val: Cmpsttsa) -> u8 {
                Cmpsttsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmptsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmptsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmptsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmptsa {
            #[inline(always)]
            fn from(val: u8) -> Cmptsa {
                Cmptsa::from_bits(val)
            }
        }
        impl From<Cmptsa> for u8 {
            #[inline(always)]
            fn from(val: Cmptsa) -> u8 {
                Cmptsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dble {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dble {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dble {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dble {
            #[inline(always)]
            fn from(val: u8) -> Dble {
                Dble::from_bits(val)
            }
        }
        impl From<Dble> for u8 {
            #[inline(always)]
            fn from(val: Dble) -> u8 {
                Dble::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Diagld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagld {
            #[inline(always)]
            fn from(val: u8) -> Diagld {
                Diagld::from_bits(val)
            }
        }
        impl From<Diagld> for u8 {
            #[inline(always)]
            fn from(val: Diagld) -> u8 {
                Diagld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Diagm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagm {
            #[inline(always)]
            fn from(val: u8) -> Diagm {
                Diagm::from_bits(val)
            }
        }
        impl From<Diagm> for u8 {
            #[inline(always)]
            fn from(val: Diagm) -> u8 {
                Diagm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Diagst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagst {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagst {
            #[inline(always)]
            fn from(val: u8) -> Diagst {
                Diagst::from_bits(val)
            }
        }
        impl From<Diagst> for u8 {
            #[inline(always)]
            fn from(val: Diagst) -> u8 {
                Diagst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagval {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Diagval {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagval {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagval {
            #[inline(always)]
            fn from(val: u8) -> Diagval {
                Diagval::from_bits(val)
            }
        }
        impl From<Diagval> for u8 {
            #[inline(always)]
            fn from(val: Diagval) -> u8 {
                Diagval::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extrg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Extrg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extrg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extrg {
            #[inline(always)]
            fn from(val: u8) -> Extrg {
                Extrg::from_bits(val)
            }
        }
        impl From<Extrg> for u8 {
            #[inline(always)]
            fn from(val: Extrg) -> u8 {
                Extrg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gbadie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gbadie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gbadie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gbadie {
            #[inline(always)]
            fn from(val: u8) -> Gbadie {
                Gbadie::from_bits(val)
            }
        }
        impl From<Gbadie> for u8 {
            #[inline(always)]
            fn from(val: Gbadie) -> u8 {
                Gbadie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gbrp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gbrp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gbrp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gbrp {
            #[inline(always)]
            fn from(val: u8) -> Gbrp {
                Gbrp::from_bits(val)
            }
        }
        impl From<Gbrp> for u8 {
            #[inline(always)]
            fn from(val: Gbrp) -> u8 {
                Gbrp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gbrscn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gbrscn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gbrscn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gbrscn {
            #[inline(always)]
            fn from(val: u8) -> Gbrscn {
                Gbrscn::from_bits(val)
            }
        }
        impl From<Gbrscn> for u8 {
            #[inline(always)]
            fn from(val: Gbrscn) -> u8 {
                Gbrscn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moncmpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moncmpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moncmpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moncmpa {
            #[inline(always)]
            fn from(val: u8) -> Moncmpa {
                Moncmpa::from_bits(val)
            }
        }
        impl From<Moncmpa> for u8 {
            #[inline(always)]
            fn from(val: Moncmpa) -> u8 {
                Moncmpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moncmpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moncmpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moncmpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moncmpb {
            #[inline(always)]
            fn from(val: u8) -> Moncmpb {
                Moncmpb::from_bits(val)
            }
        }
        impl From<Moncmpb> for u8 {
            #[inline(always)]
            fn from(val: Moncmpb) -> u8 {
                Moncmpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moncomb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moncomb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moncomb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moncomb {
            #[inline(always)]
            fn from(val: u8) -> Moncomb {
                Moncomb::from_bits(val)
            }
        }
        impl From<Moncomb> for u8 {
            #[inline(always)]
            fn from(val: Moncomb) -> u8 {
                Moncomb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ocsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ocsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ocsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ocsa {
            #[inline(always)]
            fn from(val: u8) -> Ocsa {
                Ocsa::from_bits(val)
            }
        }
        impl From<Ocsa> for u8 {
            #[inline(always)]
            fn from(val: Ocsa) -> u8 {
                Ocsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ocsad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ocsad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ocsad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ocsad {
            #[inline(always)]
            fn from(val: u8) -> Ocsad {
                Ocsad::from_bits(val)
            }
        }
        impl From<Ocsad> for u8 {
            #[inline(always)]
            fn from(val: Ocsad) -> u8 {
                Ocsad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oldeten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oldeten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oldeten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oldeten {
            #[inline(always)]
            fn from(val: u8) -> Oldeten {
                Oldeten::from_bits(val)
            }
        }
        impl From<Oldeten> for u8 {
            #[inline(always)]
            fn from(val: Oldeten) -> u8 {
                Oldeten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pchg1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pchg1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pchg1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pchg1 {
            #[inline(always)]
            fn from(val: u8) -> Pchg1 {
                Pchg1::from_bits(val)
            }
        }
        impl From<Pchg1> for u8 {
            #[inline(always)]
            fn from(val: Pchg1) -> u8 {
                Pchg1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pchg2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pchg2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pchg2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pchg2 {
            #[inline(always)]
            fn from(val: u8) -> Pchg2 {
                Pchg2::from_bits(val)
            }
        }
        impl From<Pchg2> for u8 {
            #[inline(always)]
            fn from(val: Pchg2) -> u8 {
                Pchg2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgs {
            #[inline(always)]
            fn from(val: u8) -> Pgs {
                Pgs::from_bits(val)
            }
        }
        impl From<Pgs> for u8 {
            #[inline(always)]
            fn from(val: Pgs) -> u8 {
                Pgs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trge {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trge {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trge {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trge {
            #[inline(always)]
            fn from(val: u8) -> Trge {
                Trge::from_bits(val)
            }
        }
        impl From<Trge> for u8 {
            #[inline(always)]
            fn from(val: Trge) -> u8 {
                Trge::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tssa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tssa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tssa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tssa {
            #[inline(always)]
            fn from(val: u8) -> Tssa {
                Tssa::from_bits(val)
            }
        }
        impl From<Tssa> for u8 {
            #[inline(always)]
            fn from(val: Tssa) -> u8 {
                Tssa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tssad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tssad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tssad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tssad {
            #[inline(always)]
            fn from(val: u8) -> Tssad {
                Tssad::from_bits(val)
            }
        }
        impl From<Tssad> for u8 {
            #[inline(always)]
            fn from(val: Tssad) -> u8 {
                Tssad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vrefadcen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vrefadcen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vrefadcen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vrefadcen {
            #[inline(always)]
            fn from(val: u8) -> Vrefadcen {
                Vrefadcen::from_bits(val)
            }
        }
        impl From<Vrefadcen> for u8 {
            #[inline(always)]
            fn from(val: Vrefadcen) -> u8 {
                Vrefadcen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vrefadcg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Vrefadcg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vrefadcg {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vrefadcg {
            #[inline(always)]
            fn from(val: u8) -> Vrefadcg {
                Vrefadcg::from_bits(val)
            }
        }
        impl From<Vrefadcg> for u8 {
            #[inline(always)]
            fn from(val: Vrefadcg) -> u8 {
                Vrefadcg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wcmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wcmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wcmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wcmpe {
            #[inline(always)]
            fn from(val: u8) -> Wcmpe {
                Wcmpe::from_bits(val)
            }
        }
        impl From<Wcmpe> for u8 {
            #[inline(always)]
            fn from(val: Wcmpe) -> u8 {
                Wcmpe::to_bits(val)
            }
        }
    }
}
pub mod agt0 {
    #[doc = "Asynchronous General purpose Timer 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Agt0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Agt0 {}
    unsafe impl Sync for Agt0 {}
    impl Agt0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "AGT Counter Register"]
        #[inline(always)]
        pub const fn agt(self) -> crate::common::Reg<regs::Agt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "AGT Compare Match A Register"]
        #[inline(always)]
        pub const fn agtcma(self) -> crate::common::Reg<regs::Agtcma, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "AGT Compare Match B Register"]
        #[inline(always)]
        pub const fn agtcmb(self) -> crate::common::Reg<regs::Agtcmb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "AGT Control Register"]
        #[inline(always)]
        pub const fn agtcr(self) -> crate::common::Reg<regs::Agtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "AGT Mode Register 1"]
        #[inline(always)]
        pub const fn agtmr1(self) -> crate::common::Reg<regs::Agtmr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "AGT Mode Register 2"]
        #[inline(always)]
        pub const fn agtmr2(self) -> crate::common::Reg<regs::Agtmr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "AGT I/O Control Register"]
        #[inline(always)]
        pub const fn agtioc(self) -> crate::common::Reg<regs::Agtioc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "AGT Event Pin Select Register"]
        #[inline(always)]
        pub const fn agtisr(self) -> crate::common::Reg<regs::Agtisr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "AGT Compare Match Function Select Register"]
        #[inline(always)]
        pub const fn agtcmsr(self) -> crate::common::Reg<regs::Agtcmsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "AGT Pin Select Register"]
        #[inline(always)]
        pub const fn agtiosel(self) -> crate::common::Reg<regs::Agtiosel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "AGT Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agt(pub u16);
        impl Agt {
            #[doc = "16bit counter and reload registerNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, the 16-bit counter is forcibly stopped and set to FFFFH."]
            #[inline(always)]
            pub const fn agt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "16bit counter and reload registerNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, the 16-bit counter is forcibly stopped and set to FFFFH."]
            #[inline(always)]
            pub fn set_agt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Agt {
            #[inline(always)]
            fn default() -> Agt {
                Agt(0)
            }
        }
        impl core::fmt::Debug for Agt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agt").field("agt", &self.agt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Agt {{ agt: {=u16:?} }}", self.agt())
            }
        }
        #[doc = "AGT Compare Match A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcma(pub u16);
        impl Agtcma {
            #[doc = "AGT Compare Match A RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, set to FFFFH"]
            #[inline(always)]
            pub const fn agtcma(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "AGT Compare Match A RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCRn register, set to FFFFH"]
            #[inline(always)]
            pub fn set_agtcma(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Agtcma {
            #[inline(always)]
            fn default() -> Agtcma {
                Agtcma(0)
            }
        }
        impl core::fmt::Debug for Agtcma {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcma")
                    .field("agtcma", &self.agtcma())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcma {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Agtcma {{ agtcma: {=u16:?} }}", self.agtcma())
            }
        }
        #[doc = "AGT Compare Match B Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcmb(pub u16);
        impl Agtcmb {
            #[doc = "AGT Compare Match B RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCR register, set to FFFFH"]
            #[inline(always)]
            pub const fn agtcmb(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "AGT Compare Match B RegisterNOTE : When 1 is written to the TSTOP bit in the AGTCR register, set to FFFFH"]
            #[inline(always)]
            pub fn set_agtcmb(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Agtcmb {
            #[inline(always)]
            fn default() -> Agtcmb {
                Agtcmb(0)
            }
        }
        impl core::fmt::Debug for Agtcmb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcmb")
                    .field("agtcmb", &self.agtcmb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcmb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Agtcmb {{ agtcmb: {=u16:?} }}", self.agtcmb())
            }
        }
        #[doc = "AGT Compare Match Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcmsr(pub u8);
        impl Agtcmsr {
            #[doc = "Compare match A register enable"]
            #[inline(always)]
            pub const fn tcmea(&self) -> super::vals::Tcmea {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tcmea::from_bits(val as u8)
            }
            #[doc = "Compare match A register enable"]
            #[inline(always)]
            pub fn set_tcmea(&mut self, val: super::vals::Tcmea) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AGTOA output enable"]
            #[inline(always)]
            pub const fn toea(&self) -> super::vals::Toea {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Toea::from_bits(val as u8)
            }
            #[doc = "AGTOA output enable"]
            #[inline(always)]
            pub fn set_toea(&mut self, val: super::vals::Toea) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AGTOA polarity select"]
            #[inline(always)]
            pub const fn topola(&self) -> super::vals::Topola {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Topola::from_bits(val as u8)
            }
            #[doc = "AGTOA polarity select"]
            #[inline(always)]
            pub fn set_topola(&mut self, val: super::vals::Topola) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Compare match B register enable"]
            #[inline(always)]
            pub const fn tcmeb(&self) -> super::vals::Tcmeb {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tcmeb::from_bits(val as u8)
            }
            #[doc = "Compare match B register enable"]
            #[inline(always)]
            pub fn set_tcmeb(&mut self, val: super::vals::Tcmeb) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "AGTOB output enable"]
            #[inline(always)]
            pub const fn toeb(&self) -> super::vals::Toeb {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Toeb::from_bits(val as u8)
            }
            #[doc = "AGTOB output enable"]
            #[inline(always)]
            pub fn set_toeb(&mut self, val: super::vals::Toeb) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "AGTOB polarity select"]
            #[inline(always)]
            pub const fn topolb(&self) -> super::vals::Topolb {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Topolb::from_bits(val as u8)
            }
            #[doc = "AGTOB polarity select"]
            #[inline(always)]
            pub fn set_topolb(&mut self, val: super::vals::Topolb) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtcmsr {
            #[inline(always)]
            fn default() -> Agtcmsr {
                Agtcmsr(0)
            }
        }
        impl core::fmt::Debug for Agtcmsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcmsr")
                    .field("tcmea", &self.tcmea())
                    .field("toea", &self.toea())
                    .field("topola", &self.topola())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("tcmeb", &self.tcmeb())
                    .field("toeb", &self.toeb())
                    .field("topolb", &self.topolb())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcmsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Agtcmsr {{ tcmea: {:?}, toea: {:?}, topola: {:?}, reserved_3_3: {=bool:?}, tcmeb: {:?}, toeb: {:?}, topolb: {:?}, reserved_7_7: {=bool:?} }}" , self . tcmea () , self . toea () , self . topola () , self . reserved_3_3 () , self . tcmeb () , self . toeb () , self . topolb () , self . reserved_7_7 ())
            }
        }
        #[doc = "AGT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcr(pub u8);
        impl Agtcr {
            #[doc = "AGT count start"]
            #[inline(always)]
            pub const fn tstart(&self) -> super::vals::Tstart {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tstart::from_bits(val as u8)
            }
            #[doc = "AGT count start"]
            #[inline(always)]
            pub fn set_tstart(&mut self, val: super::vals::Tstart) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AGT count status flag"]
            #[inline(always)]
            pub const fn tcstf(&self) -> super::vals::Tcstf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tcstf::from_bits(val as u8)
            }
            #[doc = "AGT count status flag"]
            #[inline(always)]
            pub fn set_tcstf(&mut self, val: super::vals::Tcstf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AGT count forced stop"]
            #[inline(always)]
            pub const fn tstop(&self) -> super::vals::Tstop {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tstop::from_bits(val as u8)
            }
            #[doc = "AGT count forced stop"]
            #[inline(always)]
            pub fn set_tstop(&mut self, val: super::vals::Tstop) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Active edge judgement flag"]
            #[inline(always)]
            pub const fn tedgf(&self) -> super::vals::Tedgf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tedgf::from_bits(val as u8)
            }
            #[doc = "Active edge judgement flag"]
            #[inline(always)]
            pub fn set_tedgf(&mut self, val: super::vals::Tedgf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "AGT underflow flag"]
            #[inline(always)]
            pub const fn tundf(&self) -> super::vals::Tundf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tundf::from_bits(val as u8)
            }
            #[doc = "AGT underflow flag"]
            #[inline(always)]
            pub fn set_tundf(&mut self, val: super::vals::Tundf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "AGT compare match A flag"]
            #[inline(always)]
            pub const fn tcmaf(&self) -> super::vals::Tcmaf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tcmaf::from_bits(val as u8)
            }
            #[doc = "AGT compare match A flag"]
            #[inline(always)]
            pub fn set_tcmaf(&mut self, val: super::vals::Tcmaf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "AGT compare match B flag"]
            #[inline(always)]
            pub const fn tcmbf(&self) -> super::vals::Tcmbf {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tcmbf::from_bits(val as u8)
            }
            #[doc = "AGT compare match B flag"]
            #[inline(always)]
            pub fn set_tcmbf(&mut self, val: super::vals::Tcmbf) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtcr {
            #[inline(always)]
            fn default() -> Agtcr {
                Agtcr(0)
            }
        }
        impl core::fmt::Debug for Agtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcr")
                    .field("tstart", &self.tstart())
                    .field("tcstf", &self.tcstf())
                    .field("tstop", &self.tstop())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("tedgf", &self.tedgf())
                    .field("tundf", &self.tundf())
                    .field("tcmaf", &self.tcmaf())
                    .field("tcmbf", &self.tcmbf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Agtcr {{ tstart: {:?}, tcstf: {:?}, tstop: {:?}, reserved_3_3: {=bool:?}, tedgf: {:?}, tundf: {:?}, tcmaf: {:?}, tcmbf: {:?} }}" , self . tstart () , self . tcstf () , self . tstop () , self . reserved_3_3 () , self . tedgf () , self . tundf () , self . tcmaf () , self . tcmbf ())
            }
        }
        #[doc = "AGT I/O Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtioc(pub u8);
        impl Agtioc {
            #[doc = "I/O polarity switchFunction varies depending on the operating mode."]
            #[inline(always)]
            pub const fn tedgsel(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "I/O polarity switchFunction varies depending on the operating mode."]
            #[inline(always)]
            pub fn set_tedgsel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "AGTO output enable"]
            #[inline(always)]
            pub const fn toe(&self) -> super::vals::Toe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Toe::from_bits(val as u8)
            }
            #[doc = "AGTO output enable"]
            #[inline(always)]
            pub fn set_toe(&mut self, val: super::vals::Toe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "AGTIO input filter select"]
            #[inline(always)]
            pub const fn tipf(&self) -> super::vals::Tipf {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Tipf::from_bits(val as u8)
            }
            #[doc = "AGTIO input filter select"]
            #[inline(always)]
            pub fn set_tipf(&mut self, val: super::vals::Tipf) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "AGTIO count control"]
            #[inline(always)]
            pub const fn tiogt(&self) -> super::vals::Tiogt {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tiogt::from_bits(val as u8)
            }
            #[doc = "AGTIO count control"]
            #[inline(always)]
            pub fn set_tiogt(&mut self, val: super::vals::Tiogt) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Agtioc {
            #[inline(always)]
            fn default() -> Agtioc {
                Agtioc(0)
            }
        }
        impl core::fmt::Debug for Agtioc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtioc")
                    .field("tedgsel", &self.tedgsel())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("toe", &self.toe())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("tipf", &self.tipf())
                    .field("tiogt", &self.tiogt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtioc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Agtioc {{ tedgsel: {=bool:?}, reserved_1_1: {=bool:?}, toe: {:?}, reserved_3_3: {=bool:?}, tipf: {:?}, tiogt: {:?} }}" , self . tedgsel () , self . reserved_1_1 () , self . toe () , self . reserved_3_3 () , self . tipf () , self . tiogt ())
            }
        }
        #[doc = "AGT Pin Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtiosel(pub u8);
        impl Agtiosel {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "AGTIO input enable"]
            #[inline(always)]
            pub const fn ties(&self) -> super::vals::Ties {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ties::from_bits(val as u8)
            }
            #[doc = "AGTIO input enable"]
            #[inline(always)]
            pub fn set_ties(&mut self, val: super::vals::Ties) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Agtiosel {
            #[inline(always)]
            fn default() -> Agtiosel {
                Agtiosel(0)
            }
        }
        impl core::fmt::Debug for Agtiosel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtiosel")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("ties", &self.ties())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtiosel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtiosel {{ reserved_0_3: {=u8:?}, ties: {:?}, reserved_5_7: {=u8:?} }}",
                    self.reserved_0_3(),
                    self.ties(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "AGT Event Pin Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtisr(pub u8);
        impl Agtisr {
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_0_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_0_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "AGTEE polarty selection"]
            #[inline(always)]
            pub const fn eeps(&self) -> super::vals::Eeps {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Eeps::from_bits(val as u8)
            }
            #[doc = "AGTEE polarty selection"]
            #[inline(always)]
            pub fn set_eeps(&mut self, val: super::vals::Eeps) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Agtisr {
            #[inline(always)]
            fn default() -> Agtisr {
                Agtisr(0)
            }
        }
        impl core::fmt::Debug for Agtisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtisr")
                    .field("reserved_0_1", &self.reserved_0_1())
                    .field("eeps", &self.eeps())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtisr {{ reserved_0_1: {=u8:?}, eeps: {:?}, reserved_3_7: {=u8:?} }}",
                    self.reserved_0_1(),
                    self.eeps(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "AGT Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtmr1(pub u8);
        impl Agtmr1 {
            #[doc = "AGT operating mode select"]
            #[inline(always)]
            pub const fn tmod(&self) -> super::vals::Tmod {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Tmod::from_bits(val as u8)
            }
            #[doc = "AGT operating mode select"]
            #[inline(always)]
            pub fn set_tmod(&mut self, val: super::vals::Tmod) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "AGTIO edge polarity select"]
            #[inline(always)]
            pub const fn tedgpl(&self) -> super::vals::Tedgpl {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tedgpl::from_bits(val as u8)
            }
            #[doc = "AGTIO edge polarity select"]
            #[inline(always)]
            pub fn set_tedgpl(&mut self, val: super::vals::Tedgpl) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "AGT count source select"]
            #[inline(always)]
            pub const fn tck(&self) -> super::vals::Tck {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Tck::from_bits(val as u8)
            }
            #[doc = "AGT count source select"]
            #[inline(always)]
            pub fn set_tck(&mut self, val: super::vals::Tck) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtmr1 {
            #[inline(always)]
            fn default() -> Agtmr1 {
                Agtmr1(0)
            }
        }
        impl core::fmt::Debug for Agtmr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtmr1")
                    .field("tmod", &self.tmod())
                    .field("tedgpl", &self.tedgpl())
                    .field("tck", &self.tck())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtmr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtmr1 {{ tmod: {:?}, tedgpl: {:?}, tck: {:?}, reserved_7_7: {=bool:?} }}",
                    self.tmod(),
                    self.tedgpl(),
                    self.tck(),
                    self.reserved_7_7()
                )
            }
        }
        #[doc = "AGT Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtmr2(pub u8);
        impl Agtmr2 {
            #[doc = "fsub/LOCO count source clock frequency division ratio select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Cks {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Cks::from_bits(val as u8)
            }
            #[doc = "fsub/LOCO count source clock frequency division ratio select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Cks) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_3_6(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_3_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 3usize)) | (((val as u8) & 0x0f) << 3usize);
            }
            #[doc = "Low Power Mode"]
            #[inline(always)]
            pub const fn lpm(&self) -> super::vals::Lpm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lpm::from_bits(val as u8)
            }
            #[doc = "Low Power Mode"]
            #[inline(always)]
            pub fn set_lpm(&mut self, val: super::vals::Lpm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtmr2 {
            #[inline(always)]
            fn default() -> Agtmr2 {
                Agtmr2(0)
            }
        }
        impl core::fmt::Debug for Agtmr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtmr2")
                    .field("cks", &self.cks())
                    .field("reserved_3_6", &self.reserved_3_6())
                    .field("lpm", &self.lpm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtmr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtmr2 {{ cks: {:?}, reserved_3_6: {=u8:?}, lpm: {:?} }}",
                    self.cks(),
                    self.reserved_3_6(),
                    self.lpm()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cks {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cks {
            #[inline(always)]
            fn from(val: u8) -> Cks {
                Cks::from_bits(val)
            }
        }
        impl From<Cks> for u8 {
            #[inline(always)]
            fn from(val: Cks) -> u8 {
                Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eeps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eeps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eeps {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eeps {
            #[inline(always)]
            fn from(val: u8) -> Eeps {
                Eeps::from_bits(val)
            }
        }
        impl From<Eeps> for u8 {
            #[inline(always)]
            fn from(val: Eeps) -> u8 {
                Eeps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lpm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpm {
            #[inline(always)]
            fn from(val: u8) -> Lpm {
                Lpm::from_bits(val)
            }
        }
        impl From<Lpm> for u8 {
            #[inline(always)]
            fn from(val: Lpm) -> u8 {
                Lpm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tck {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tck {
            #[inline(always)]
            fn from(val: u8) -> Tck {
                Tck::from_bits(val)
            }
        }
        impl From<Tck> for u8 {
            #[inline(always)]
            fn from(val: Tck) -> u8 {
                Tck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmaf {
            #[inline(always)]
            fn from(val: u8) -> Tcmaf {
                Tcmaf::from_bits(val)
            }
        }
        impl From<Tcmaf> for u8 {
            #[inline(always)]
            fn from(val: Tcmaf) -> u8 {
                Tcmaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmbf {
            #[inline(always)]
            fn from(val: u8) -> Tcmbf {
                Tcmbf::from_bits(val)
            }
        }
        impl From<Tcmbf> for u8 {
            #[inline(always)]
            fn from(val: Tcmbf) -> u8 {
                Tcmbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmea {
            #[inline(always)]
            fn from(val: u8) -> Tcmea {
                Tcmea::from_bits(val)
            }
        }
        impl From<Tcmea> for u8 {
            #[inline(always)]
            fn from(val: Tcmea) -> u8 {
                Tcmea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmeb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmeb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmeb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmeb {
            #[inline(always)]
            fn from(val: u8) -> Tcmeb {
                Tcmeb::from_bits(val)
            }
        }
        impl From<Tcmeb> for u8 {
            #[inline(always)]
            fn from(val: Tcmeb) -> u8 {
                Tcmeb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcstf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcstf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcstf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcstf {
            #[inline(always)]
            fn from(val: u8) -> Tcstf {
                Tcstf::from_bits(val)
            }
        }
        impl From<Tcstf> for u8 {
            #[inline(always)]
            fn from(val: Tcstf) -> u8 {
                Tcstf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tedgf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tedgf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tedgf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tedgf {
            #[inline(always)]
            fn from(val: u8) -> Tedgf {
                Tedgf::from_bits(val)
            }
        }
        impl From<Tedgf> for u8 {
            #[inline(always)]
            fn from(val: Tedgf) -> u8 {
                Tedgf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tedgpl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tedgpl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tedgpl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tedgpl {
            #[inline(always)]
            fn from(val: u8) -> Tedgpl {
                Tedgpl::from_bits(val)
            }
        }
        impl From<Tedgpl> for u8 {
            #[inline(always)]
            fn from(val: Tedgpl) -> u8 {
                Tedgpl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ties {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ties {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ties {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ties {
            #[inline(always)]
            fn from(val: u8) -> Ties {
                Ties::from_bits(val)
            }
        }
        impl From<Ties> for u8 {
            #[inline(always)]
            fn from(val: Ties) -> u8 {
                Ties::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tiogt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tiogt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tiogt {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tiogt {
            #[inline(always)]
            fn from(val: u8) -> Tiogt {
                Tiogt::from_bits(val)
            }
        }
        impl From<Tiogt> for u8 {
            #[inline(always)]
            fn from(val: Tiogt) -> u8 {
                Tiogt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tipf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tipf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tipf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tipf {
            #[inline(always)]
            fn from(val: u8) -> Tipf {
                Tipf::from_bits(val)
            }
        }
        impl From<Tipf> for u8 {
            #[inline(always)]
            fn from(val: Tipf) -> u8 {
                Tipf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmod {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmod {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmod {
            #[inline(always)]
            fn from(val: u8) -> Tmod {
                Tmod::from_bits(val)
            }
        }
        impl From<Tmod> for u8 {
            #[inline(always)]
            fn from(val: Tmod) -> u8 {
                Tmod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toe {
            #[inline(always)]
            fn from(val: u8) -> Toe {
                Toe::from_bits(val)
            }
        }
        impl From<Toe> for u8 {
            #[inline(always)]
            fn from(val: Toe) -> u8 {
                Toe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toea {
            #[inline(always)]
            fn from(val: u8) -> Toea {
                Toea::from_bits(val)
            }
        }
        impl From<Toea> for u8 {
            #[inline(always)]
            fn from(val: Toea) -> u8 {
                Toea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toeb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toeb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toeb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toeb {
            #[inline(always)]
            fn from(val: u8) -> Toeb {
                Toeb::from_bits(val)
            }
        }
        impl From<Toeb> for u8 {
            #[inline(always)]
            fn from(val: Toeb) -> u8 {
                Toeb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Topola {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Topola {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Topola {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Topola {
            #[inline(always)]
            fn from(val: u8) -> Topola {
                Topola::from_bits(val)
            }
        }
        impl From<Topola> for u8 {
            #[inline(always)]
            fn from(val: Topola) -> u8 {
                Topola::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Topolb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Topolb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Topolb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Topolb {
            #[inline(always)]
            fn from(val: u8) -> Topolb {
                Topolb::from_bits(val)
            }
        }
        impl From<Topolb> for u8 {
            #[inline(always)]
            fn from(val: Topolb) -> u8 {
                Topolb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstart {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstart {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstart {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstart {
            #[inline(always)]
            fn from(val: u8) -> Tstart {
                Tstart::from_bits(val)
            }
        }
        impl From<Tstart> for u8 {
            #[inline(always)]
            fn from(val: Tstart) -> u8 {
                Tstart::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstop {
            #[inline(always)]
            fn from(val: u8) -> Tstop {
                Tstop::from_bits(val)
            }
        }
        impl From<Tstop> for u8 {
            #[inline(always)]
            fn from(val: Tstop) -> u8 {
                Tstop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tundf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tundf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tundf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tundf {
            #[inline(always)]
            fn from(val: u8) -> Tundf {
                Tundf::from_bits(val)
            }
        }
        impl From<Tundf> for u8 {
            #[inline(always)]
            fn from(val: Tundf) -> u8 {
                Tundf::to_bits(val)
            }
        }
    }
}
pub mod bus {
    #[doc = "BUS Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bus {
        ptr: *mut u8,
    }
    unsafe impl Send for Bus {}
    unsafe impl Sync for Bus {}
    impl Bus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Master Bus Control Register SYS"]
        #[inline(always)]
        pub const fn busmcntsys(self) -> crate::common::Reg<regs::Busmcntsys, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1008usize) as _) }
        }
        #[doc = "Master Bus Control Register DMA"]
        #[inline(always)]
        pub const fn busmcntdma(self) -> crate::common::Reg<regs::Busmcntdma, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x100cusize) as _) }
        }
        #[doc = "Slave Bus Control Register FLI"]
        #[inline(always)]
        pub const fn busscntfli(self) -> crate::common::Reg<regs::Busscntfli, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
        }
        #[doc = "Slave Bus Control Register RAM0"]
        #[inline(always)]
        pub const fn busscntram0(self) -> crate::common::Reg<regs::Busscntram0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x110cusize) as _) }
        }
        #[doc = "Slave Bus Control Register %s"]
        #[inline(always)]
        pub const fn busscnt(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Busscnt, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1114usize + n * 4usize) as _) }
        }
        #[doc = "Slave Bus Control Register P4B"]
        #[inline(always)]
        pub const fn busscntp4b(self) -> crate::common::Reg<regs::Busscntp4b, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1120usize) as _) }
        }
        #[doc = "Slave Bus Control Register P6B"]
        #[inline(always)]
        pub const fn busscntp6b(self) -> crate::common::Reg<regs::Busscntp6b, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1128usize) as _) }
        }
        #[doc = "Slave Bus Control Register FBU"]
        #[inline(always)]
        pub const fn busscntfbu(self) -> crate::common::Reg<regs::Busscntfbu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1130usize) as _) }
        }
        #[doc = "Bus Error Address Register %s"]
        #[inline(always)]
        pub const fn buserradd(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Buserradd, crate::common::R> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1820usize + n * 16usize) as _) }
        }
        #[doc = "Bus Error Status Register %s"]
        #[inline(always)]
        pub const fn buserrstat(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Buserrstat, crate::common::R> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1824usize + n * 16usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bus Error Address Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Buserradd(pub u32);
        impl Buserradd {
            #[doc = "Bus Error AddressWhen a bus error occurs, It stores an error address."]
            #[inline(always)]
            pub const fn berad(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Bus Error AddressWhen a bus error occurs, It stores an error address."]
            #[inline(always)]
            pub fn set_berad(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Buserradd {
            #[inline(always)]
            fn default() -> Buserradd {
                Buserradd(0)
            }
        }
        impl core::fmt::Debug for Buserradd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Buserradd")
                    .field("berad", &self.berad())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Buserradd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Buserradd {{ berad: {=u32:?} }}", self.berad())
            }
        }
        #[doc = "Bus Error Status Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Buserrstat(pub u8);
        impl Buserrstat {
            #[doc = "Error access statusThe status at the time of the error"]
            #[inline(always)]
            pub const fn accstat(&self) -> super::vals::Accstat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Accstat::from_bits(val as u8)
            }
            #[doc = "Error access statusThe status at the time of the error"]
            #[inline(always)]
            pub fn set_accstat(&mut self, val: super::vals::Accstat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000."]
            #[inline(always)]
            pub const fn reserved_1_6(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000."]
            #[inline(always)]
            pub fn set_reserved_1_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 1usize)) | (((val as u8) & 0x3f) << 1usize);
            }
            #[doc = "Bus Error StatusWhen bus error assert, error flag occurs."]
            #[inline(always)]
            pub const fn errstat(&self) -> super::vals::Errstat {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Errstat::from_bits(val as u8)
            }
            #[doc = "Bus Error StatusWhen bus error assert, error flag occurs."]
            #[inline(always)]
            pub fn set_errstat(&mut self, val: super::vals::Errstat) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Buserrstat {
            #[inline(always)]
            fn default() -> Buserrstat {
                Buserrstat(0)
            }
        }
        impl core::fmt::Debug for Buserrstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Buserrstat")
                    .field("accstat", &self.accstat())
                    .field("reserved_1_6", &self.reserved_1_6())
                    .field("errstat", &self.errstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Buserrstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Buserrstat {{ accstat: {:?}, reserved_1_6: {=u8:?}, errstat: {:?} }}",
                    self.accstat(),
                    self.reserved_1_6(),
                    self.errstat()
                )
            }
        }
        #[doc = "Master Bus Control Register DMA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busmcntdma(pub u16);
        impl Busmcntdma {
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub const fn reserved_0_14(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_0_14(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u16) & 0x7fff) << 0usize);
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub const fn ieres(&self) -> super::vals::BusmcntdmaIeres {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::BusmcntdmaIeres::from_bits(val as u8)
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub fn set_ieres(&mut self, val: super::vals::BusmcntdmaIeres) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Busmcntdma {
            #[inline(always)]
            fn default() -> Busmcntdma {
                Busmcntdma(0)
            }
        }
        impl core::fmt::Debug for Busmcntdma {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busmcntdma")
                    .field("reserved_0_14", &self.reserved_0_14())
                    .field("ieres", &self.ieres())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busmcntdma {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busmcntdma {{ reserved_0_14: {=u16:?}, ieres: {:?} }}",
                    self.reserved_0_14(),
                    self.ieres()
                )
            }
        }
        #[doc = "Master Bus Control Register SYS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busmcntsys(pub u16);
        impl Busmcntsys {
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub const fn reserved_0_14(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_0_14(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u16) & 0x7fff) << 0usize);
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub const fn ieres(&self) -> super::vals::BusmcntsysIeres {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::BusmcntsysIeres::from_bits(val as u8)
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub fn set_ieres(&mut self, val: super::vals::BusmcntsysIeres) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Busmcntsys {
            #[inline(always)]
            fn default() -> Busmcntsys {
                Busmcntsys(0)
            }
        }
        impl core::fmt::Debug for Busmcntsys {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busmcntsys")
                    .field("reserved_0_14", &self.reserved_0_14())
                    .field("ieres", &self.ieres())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busmcntsys {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busmcntsys {{ reserved_0_14: {=u16:?}, ieres: {:?} }}",
                    self.reserved_0_14(),
                    self.ieres()
                )
            }
        }
        #[doc = "Slave Bus Control Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busscnt(pub u16);
        impl Busscnt {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub const fn arbmet(&self) -> super::vals::BusscntArbmet {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::BusscntArbmet::from_bits(val as u8)
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub fn set_arbmet(&mut self, val: super::vals::BusscntArbmet) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u16) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub const fn reserved_6_15(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub fn set_reserved_6_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u16) & 0x03ff) << 6usize);
            }
        }
        impl Default for Busscnt {
            #[inline(always)]
            fn default() -> Busscnt {
                Busscnt(0)
            }
        }
        impl core::fmt::Debug for Busscnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busscnt")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("arbmet", &self.arbmet())
                    .field("reserved_6_15", &self.reserved_6_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busscnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busscnt {{ reserved_0_3: {=u8:?}, arbmet: {:?}, reserved_6_15: {=u16:?} }}",
                    self.reserved_0_3(),
                    self.arbmet(),
                    self.reserved_6_15()
                )
            }
        }
        #[doc = "Slave Bus Control Register FBU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busscntfbu(pub u16);
        impl Busscntfbu {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub const fn arbmet(&self) -> super::vals::BusscntfbuArbmet {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::BusscntfbuArbmet::from_bits(val as u8)
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub fn set_arbmet(&mut self, val: super::vals::BusscntfbuArbmet) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u16) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub const fn reserved_6_15(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub fn set_reserved_6_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u16) & 0x03ff) << 6usize);
            }
        }
        impl Default for Busscntfbu {
            #[inline(always)]
            fn default() -> Busscntfbu {
                Busscntfbu(0)
            }
        }
        impl core::fmt::Debug for Busscntfbu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busscntfbu")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("arbmet", &self.arbmet())
                    .field("reserved_6_15", &self.reserved_6_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busscntfbu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busscntfbu {{ reserved_0_3: {=u8:?}, arbmet: {:?}, reserved_6_15: {=u16:?} }}",
                    self.reserved_0_3(),
                    self.arbmet(),
                    self.reserved_6_15()
                )
            }
        }
        #[doc = "Slave Bus Control Register FLI"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busscntfli(pub u16);
        impl Busscntfli {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub const fn arbmet(&self) -> super::vals::BusscntfliArbmet {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::BusscntfliArbmet::from_bits(val as u8)
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub fn set_arbmet(&mut self, val: super::vals::BusscntfliArbmet) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u16) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub const fn reserved_6_15(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub fn set_reserved_6_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u16) & 0x03ff) << 6usize);
            }
        }
        impl Default for Busscntfli {
            #[inline(always)]
            fn default() -> Busscntfli {
                Busscntfli(0)
            }
        }
        impl core::fmt::Debug for Busscntfli {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busscntfli")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("arbmet", &self.arbmet())
                    .field("reserved_6_15", &self.reserved_6_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busscntfli {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busscntfli {{ reserved_0_3: {=u8:?}, arbmet: {:?}, reserved_6_15: {=u16:?} }}",
                    self.reserved_0_3(),
                    self.arbmet(),
                    self.reserved_6_15()
                )
            }
        }
        #[doc = "Slave Bus Control Register P4B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busscntp4b(pub u16);
        impl Busscntp4b {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub const fn arbmet(&self) -> super::vals::Busscntp4bArbmet {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Busscntp4bArbmet::from_bits(val as u8)
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub fn set_arbmet(&mut self, val: super::vals::Busscntp4bArbmet) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u16) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub const fn reserved_6_15(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub fn set_reserved_6_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u16) & 0x03ff) << 6usize);
            }
        }
        impl Default for Busscntp4b {
            #[inline(always)]
            fn default() -> Busscntp4b {
                Busscntp4b(0)
            }
        }
        impl core::fmt::Debug for Busscntp4b {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busscntp4b")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("arbmet", &self.arbmet())
                    .field("reserved_6_15", &self.reserved_6_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busscntp4b {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busscntp4b {{ reserved_0_3: {=u8:?}, arbmet: {:?}, reserved_6_15: {=u16:?} }}",
                    self.reserved_0_3(),
                    self.arbmet(),
                    self.reserved_6_15()
                )
            }
        }
        #[doc = "Slave Bus Control Register P6B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busscntp6b(pub u16);
        impl Busscntp6b {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub const fn arbmet(&self) -> super::vals::Busscntp6bArbmet {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Busscntp6bArbmet::from_bits(val as u8)
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub fn set_arbmet(&mut self, val: super::vals::Busscntp6bArbmet) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u16) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub const fn reserved_6_15(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub fn set_reserved_6_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u16) & 0x03ff) << 6usize);
            }
        }
        impl Default for Busscntp6b {
            #[inline(always)]
            fn default() -> Busscntp6b {
                Busscntp6b(0)
            }
        }
        impl core::fmt::Debug for Busscntp6b {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busscntp6b")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("arbmet", &self.arbmet())
                    .field("reserved_6_15", &self.reserved_6_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busscntp6b {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busscntp6b {{ reserved_0_3: {=u8:?}, arbmet: {:?}, reserved_6_15: {=u16:?} }}",
                    self.reserved_0_3(),
                    self.arbmet(),
                    self.reserved_6_15()
                )
            }
        }
        #[doc = "Slave Bus Control Register RAM0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busscntram0(pub u16);
        impl Busscntram0 {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub const fn arbmet(&self) -> super::vals::Busscntram0Arbmet {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Busscntram0Arbmet::from_bits(val as u8)
            }
            #[doc = "Arbitration MethodSpecify the priority between groups"]
            #[inline(always)]
            pub fn set_arbmet(&mut self, val: super::vals::Busscntram0Arbmet) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u16) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub const fn reserved_6_15(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000. The write value should be 0000000000."]
            #[inline(always)]
            pub fn set_reserved_6_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u16) & 0x03ff) << 6usize);
            }
        }
        impl Default for Busscntram0 {
            #[inline(always)]
            fn default() -> Busscntram0 {
                Busscntram0(0)
            }
        }
        impl core::fmt::Debug for Busscntram0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busscntram0")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("arbmet", &self.arbmet())
                    .field("reserved_6_15", &self.reserved_6_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busscntram0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Busscntram0 {{ reserved_0_3: {=u8:?}, arbmet: {:?}, reserved_6_15: {=u16:?} }}" , self . reserved_0_3 () , self . arbmet () , self . reserved_6_15 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Accstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Accstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Accstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Accstat {
            #[inline(always)]
            fn from(val: u8) -> Accstat {
                Accstat::from_bits(val)
            }
        }
        impl From<Accstat> for u8 {
            #[inline(always)]
            fn from(val: Accstat) -> u8 {
                Accstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusmcntdmaIeres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl BusmcntdmaIeres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusmcntdmaIeres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusmcntdmaIeres {
            #[inline(always)]
            fn from(val: u8) -> BusmcntdmaIeres {
                BusmcntdmaIeres::from_bits(val)
            }
        }
        impl From<BusmcntdmaIeres> for u8 {
            #[inline(always)]
            fn from(val: BusmcntdmaIeres) -> u8 {
                BusmcntdmaIeres::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusmcntsysIeres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl BusmcntsysIeres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusmcntsysIeres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusmcntsysIeres {
            #[inline(always)]
            fn from(val: u8) -> BusmcntsysIeres {
                BusmcntsysIeres::from_bits(val)
            }
        }
        impl From<BusmcntsysIeres> for u8 {
            #[inline(always)]
            fn from(val: BusmcntsysIeres) -> u8 {
                BusmcntsysIeres::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusscntArbmet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl BusscntArbmet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusscntArbmet {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusscntArbmet {
            #[inline(always)]
            fn from(val: u8) -> BusscntArbmet {
                BusscntArbmet::from_bits(val)
            }
        }
        impl From<BusscntArbmet> for u8 {
            #[inline(always)]
            fn from(val: BusscntArbmet) -> u8 {
                BusscntArbmet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusscntfbuArbmet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl BusscntfbuArbmet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusscntfbuArbmet {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusscntfbuArbmet {
            #[inline(always)]
            fn from(val: u8) -> BusscntfbuArbmet {
                BusscntfbuArbmet::from_bits(val)
            }
        }
        impl From<BusscntfbuArbmet> for u8 {
            #[inline(always)]
            fn from(val: BusscntfbuArbmet) -> u8 {
                BusscntfbuArbmet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusscntfliArbmet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl BusscntfliArbmet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusscntfliArbmet {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusscntfliArbmet {
            #[inline(always)]
            fn from(val: u8) -> BusscntfliArbmet {
                BusscntfliArbmet::from_bits(val)
            }
        }
        impl From<BusscntfliArbmet> for u8 {
            #[inline(always)]
            fn from(val: BusscntfliArbmet) -> u8 {
                BusscntfliArbmet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busscntp4bArbmet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Busscntp4bArbmet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busscntp4bArbmet {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busscntp4bArbmet {
            #[inline(always)]
            fn from(val: u8) -> Busscntp4bArbmet {
                Busscntp4bArbmet::from_bits(val)
            }
        }
        impl From<Busscntp4bArbmet> for u8 {
            #[inline(always)]
            fn from(val: Busscntp4bArbmet) -> u8 {
                Busscntp4bArbmet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busscntp6bArbmet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Busscntp6bArbmet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busscntp6bArbmet {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busscntp6bArbmet {
            #[inline(always)]
            fn from(val: u8) -> Busscntp6bArbmet {
                Busscntp6bArbmet::from_bits(val)
            }
        }
        impl From<Busscntp6bArbmet> for u8 {
            #[inline(always)]
            fn from(val: Busscntp6bArbmet) -> u8 {
                Busscntp6bArbmet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busscntram0Arbmet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Busscntram0Arbmet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busscntram0Arbmet {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busscntram0Arbmet {
            #[inline(always)]
            fn from(val: u8) -> Busscntram0Arbmet {
                Busscntram0Arbmet::from_bits(val)
            }
        }
        impl From<Busscntram0Arbmet> for u8 {
            #[inline(always)]
            fn from(val: Busscntram0Arbmet) -> u8 {
                Busscntram0Arbmet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Errstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errstat {
            #[inline(always)]
            fn from(val: u8) -> Errstat {
                Errstat::from_bits(val)
            }
        }
        impl From<Errstat> for u8 {
            #[inline(always)]
            fn from(val: Errstat) -> u8 {
                Errstat::to_bits(val)
            }
        }
    }
}
pub mod cac {
    #[doc = "Clock Frequency Accuracy Measurement Circuit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cac {
        ptr: *mut u8,
    }
    unsafe impl Send for Cac {}
    unsafe impl Sync for Cac {}
    impl Cac {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CAC Control Register 0"]
        #[inline(always)]
        pub const fn cacr0(self) -> crate::common::Reg<regs::Cacr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CAC Control Register 1"]
        #[inline(always)]
        pub const fn cacr1(self) -> crate::common::Reg<regs::Cacr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "CAC Control Register 2"]
        #[inline(always)]
        pub const fn cacr2(self) -> crate::common::Reg<regs::Cacr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "CAC Interrupt Control Register"]
        #[inline(always)]
        pub const fn caicr(self) -> crate::common::Reg<regs::Caicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "CAC Status Register"]
        #[inline(always)]
        pub const fn castr(self) -> crate::common::Reg<regs::Castr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CAC Upper,Limit Value Setting Register"]
        #[inline(always)]
        pub const fn caulvr(self) -> crate::common::Reg<regs::Caulvr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "CAC Lower,Limit Value Setting Register"]
        #[inline(always)]
        pub const fn callvr(self) -> crate::common::Reg<regs::Callvr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CAC Counter Buffer Register"]
        #[inline(always)]
        pub const fn cacntbr(self) -> crate::common::Reg<regs::Cacntbr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CAC Counter Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacntbr(pub u16);
        impl Cacntbr {
            #[doc = "CACNTBR is a 16-bit read,only register that retains the counter value at the time a valid reference signal edge is input"]
            #[inline(always)]
            pub const fn cacntbr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "CACNTBR is a 16-bit read,only register that retains the counter value at the time a valid reference signal edge is input"]
            #[inline(always)]
            pub fn set_cacntbr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Cacntbr {
            #[inline(always)]
            fn default() -> Cacntbr {
                Cacntbr(0)
            }
        }
        impl core::fmt::Debug for Cacntbr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacntbr")
                    .field("cacntbr", &self.cacntbr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacntbr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cacntbr {{ cacntbr: {=u16:?} }}", self.cacntbr())
            }
        }
        #[doc = "CAC Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacr0(pub u8);
        impl Cacr0 {
            #[doc = "Clock Frequency Measurement Enable."]
            #[inline(always)]
            pub const fn cfme(&self) -> super::vals::Cfme {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cfme::from_bits(val as u8)
            }
            #[doc = "Clock Frequency Measurement Enable."]
            #[inline(always)]
            pub fn set_cfme(&mut self, val: super::vals::Cfme) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Cacr0 {
            #[inline(always)]
            fn default() -> Cacr0 {
                Cacr0(0)
            }
        }
        impl core::fmt::Debug for Cacr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacr0")
                    .field("cfme", &self.cfme())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cacr0 {{ cfme: {:?}, reserved_1_7: {=u8:?} }}",
                    self.cfme(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "CAC Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacr1(pub u8);
        impl Cacr1 {
            #[doc = "CACREF Pin Input Enable"]
            #[inline(always)]
            pub const fn cacrefe(&self) -> super::vals::Cacrefe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cacrefe::from_bits(val as u8)
            }
            #[doc = "CACREF Pin Input Enable"]
            #[inline(always)]
            pub fn set_cacrefe(&mut self, val: super::vals::Cacrefe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement Target Clock Select"]
            #[inline(always)]
            pub const fn fmcs(&self) -> super::vals::Fmcs {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Fmcs::from_bits(val as u8)
            }
            #[doc = "Measurement Target Clock Select"]
            #[inline(always)]
            pub fn set_fmcs(&mut self, val: super::vals::Fmcs) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u8) & 0x07) << 1usize);
            }
            #[doc = "Measurement Target Clock Frequency Division Ratio Select"]
            #[inline(always)]
            pub const fn tcss(&self) -> super::vals::Tcss {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Tcss::from_bits(val as u8)
            }
            #[doc = "Measurement Target Clock Frequency Division Ratio Select"]
            #[inline(always)]
            pub fn set_tcss(&mut self, val: super::vals::Tcss) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "Valid Edge Select"]
            #[inline(always)]
            pub const fn edges(&self) -> super::vals::Edges {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Edges::from_bits(val as u8)
            }
            #[doc = "Valid Edge Select"]
            #[inline(always)]
            pub fn set_edges(&mut self, val: super::vals::Edges) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Cacr1 {
            #[inline(always)]
            fn default() -> Cacr1 {
                Cacr1(0)
            }
        }
        impl core::fmt::Debug for Cacr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacr1")
                    .field("cacrefe", &self.cacrefe())
                    .field("fmcs", &self.fmcs())
                    .field("tcss", &self.tcss())
                    .field("edges", &self.edges())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cacr1 {{ cacrefe: {:?}, fmcs: {:?}, tcss: {:?}, edges: {:?} }}",
                    self.cacrefe(),
                    self.fmcs(),
                    self.tcss(),
                    self.edges()
                )
            }
        }
        #[doc = "CAC Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacr2(pub u8);
        impl Cacr2 {
            #[doc = "Reference Signal Select"]
            #[inline(always)]
            pub const fn rps(&self) -> super::vals::Rps {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rps::from_bits(val as u8)
            }
            #[doc = "Reference Signal Select"]
            #[inline(always)]
            pub fn set_rps(&mut self, val: super::vals::Rps) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement Reference Clock Select"]
            #[inline(always)]
            pub const fn rscs(&self) -> super::vals::Rscs {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Rscs::from_bits(val as u8)
            }
            #[doc = "Measurement Reference Clock Select"]
            #[inline(always)]
            pub fn set_rscs(&mut self, val: super::vals::Rscs) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u8) & 0x07) << 1usize);
            }
            #[doc = "Measurement Reference Clock Frequency Division Ratio Select"]
            #[inline(always)]
            pub const fn rcds(&self) -> super::vals::Rcds {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Rcds::from_bits(val as u8)
            }
            #[doc = "Measurement Reference Clock Frequency Division Ratio Select"]
            #[inline(always)]
            pub fn set_rcds(&mut self, val: super::vals::Rcds) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "Digital Filter Selection"]
            #[inline(always)]
            pub const fn dfs(&self) -> super::vals::Dfs {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Dfs::from_bits(val as u8)
            }
            #[doc = "Digital Filter Selection"]
            #[inline(always)]
            pub fn set_dfs(&mut self, val: super::vals::Dfs) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Cacr2 {
            #[inline(always)]
            fn default() -> Cacr2 {
                Cacr2(0)
            }
        }
        impl core::fmt::Debug for Cacr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacr2")
                    .field("rps", &self.rps())
                    .field("rscs", &self.rscs())
                    .field("rcds", &self.rcds())
                    .field("dfs", &self.dfs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cacr2 {{ rps: {:?}, rscs: {:?}, rcds: {:?}, dfs: {:?} }}",
                    self.rps(),
                    self.rscs(),
                    self.rcds(),
                    self.dfs()
                )
            }
        }
        #[doc = "CAC Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Caicr(pub u8);
        impl Caicr {
            #[doc = "Frequency Error Interrupt Request Enable"]
            #[inline(always)]
            pub const fn ferrie(&self) -> super::vals::Ferrie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ferrie::from_bits(val as u8)
            }
            #[doc = "Frequency Error Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_ferrie(&mut self, val: super::vals::Ferrie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement End Interrupt Request Enable"]
            #[inline(always)]
            pub const fn mendie(&self) -> super::vals::Mendie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mendie::from_bits(val as u8)
            }
            #[doc = "Measurement End Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_mendie(&mut self, val: super::vals::Mendie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Overflow Interrupt Request Enable"]
            #[inline(always)]
            pub const fn ovfie(&self) -> super::vals::Ovfie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ovfie::from_bits(val as u8)
            }
            #[doc = "Overflow Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_ovfie(&mut self, val: super::vals::Ovfie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "FERRF Clear"]
            #[inline(always)]
            pub const fn ferrfcl(&self) -> super::vals::Ferrfcl {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ferrfcl::from_bits(val as u8)
            }
            #[doc = "FERRF Clear"]
            #[inline(always)]
            pub fn set_ferrfcl(&mut self, val: super::vals::Ferrfcl) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "MENDF Clear"]
            #[inline(always)]
            pub const fn mendfcl(&self) -> super::vals::Mendfcl {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Mendfcl::from_bits(val as u8)
            }
            #[doc = "MENDF Clear"]
            #[inline(always)]
            pub fn set_mendfcl(&mut self, val: super::vals::Mendfcl) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "OVFF Clear"]
            #[inline(always)]
            pub const fn ovffcl(&self) -> super::vals::Ovffcl {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ovffcl::from_bits(val as u8)
            }
            #[doc = "OVFF Clear"]
            #[inline(always)]
            pub fn set_ovffcl(&mut self, val: super::vals::Ovffcl) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Caicr {
            #[inline(always)]
            fn default() -> Caicr {
                Caicr(0)
            }
        }
        impl core::fmt::Debug for Caicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Caicr")
                    .field("ferrie", &self.ferrie())
                    .field("mendie", &self.mendie())
                    .field("ovfie", &self.ovfie())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("ferrfcl", &self.ferrfcl())
                    .field("mendfcl", &self.mendfcl())
                    .field("ovffcl", &self.ovffcl())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Caicr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Caicr {{ ferrie: {:?}, mendie: {:?}, ovfie: {:?}, reserved_3_3: {=bool:?}, ferrfcl: {:?}, mendfcl: {:?}, ovffcl: {:?}, reserved_7_7: {=bool:?} }}" , self . ferrie () , self . mendie () , self . ovfie () , self . reserved_3_3 () , self . ferrfcl () , self . mendfcl () , self . ovffcl () , self . reserved_7_7 ())
            }
        }
        #[doc = "CAC Lower,Limit Value Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Callvr(pub u16);
        impl Callvr {
            #[doc = "CALLVR is a 16-bit readable/writable register that stores the lower,limit value of the frequency."]
            #[inline(always)]
            pub const fn callvr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "CALLVR is a 16-bit readable/writable register that stores the lower,limit value of the frequency."]
            #[inline(always)]
            pub fn set_callvr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Callvr {
            #[inline(always)]
            fn default() -> Callvr {
                Callvr(0)
            }
        }
        impl core::fmt::Debug for Callvr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Callvr")
                    .field("callvr", &self.callvr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Callvr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Callvr {{ callvr: {=u16:?} }}", self.callvr())
            }
        }
        #[doc = "CAC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Castr(pub u8);
        impl Castr {
            #[doc = "Frequency Error Flag"]
            #[inline(always)]
            pub const fn ferrf(&self) -> super::vals::Ferrf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ferrf::from_bits(val as u8)
            }
            #[doc = "Frequency Error Flag"]
            #[inline(always)]
            pub fn set_ferrf(&mut self, val: super::vals::Ferrf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement End Flag"]
            #[inline(always)]
            pub const fn mendf(&self) -> super::vals::Mendf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mendf::from_bits(val as u8)
            }
            #[doc = "Measurement End Flag"]
            #[inline(always)]
            pub fn set_mendf(&mut self, val: super::vals::Mendf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Counter Overflow Flag"]
            #[inline(always)]
            pub const fn ovff(&self) -> super::vals::Ovff {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ovff::from_bits(val as u8)
            }
            #[doc = "Counter Overflow Flag"]
            #[inline(always)]
            pub fn set_ovff(&mut self, val: super::vals::Ovff) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Castr {
            #[inline(always)]
            fn default() -> Castr {
                Castr(0)
            }
        }
        impl core::fmt::Debug for Castr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Castr")
                    .field("ferrf", &self.ferrf())
                    .field("mendf", &self.mendf())
                    .field("ovff", &self.ovff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Castr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Castr {{ ferrf: {:?}, mendf: {:?}, ovff: {:?} }}",
                    self.ferrf(),
                    self.mendf(),
                    self.ovff()
                )
            }
        }
        #[doc = "CAC Upper,Limit Value Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Caulvr(pub u16);
        impl Caulvr {
            #[doc = "CAULVR is a 16-bit readable/writable register that stores the upper,limit value of the frequency."]
            #[inline(always)]
            pub const fn caulvr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "CAULVR is a 16-bit readable/writable register that stores the upper,limit value of the frequency."]
            #[inline(always)]
            pub fn set_caulvr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Caulvr {
            #[inline(always)]
            fn default() -> Caulvr {
                Caulvr(0)
            }
        }
        impl core::fmt::Debug for Caulvr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Caulvr")
                    .field("caulvr", &self.caulvr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Caulvr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Caulvr {{ caulvr: {=u16:?} }}", self.caulvr())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cacrefe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cacrefe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cacrefe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cacrefe {
            #[inline(always)]
            fn from(val: u8) -> Cacrefe {
                Cacrefe::from_bits(val)
            }
        }
        impl From<Cacrefe> for u8 {
            #[inline(always)]
            fn from(val: Cacrefe) -> u8 {
                Cacrefe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cfme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cfme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cfme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cfme {
            #[inline(always)]
            fn from(val: u8) -> Cfme {
                Cfme::from_bits(val)
            }
        }
        impl From<Cfme> for u8 {
            #[inline(always)]
            fn from(val: Cfme) -> u8 {
                Cfme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Dfs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfs {
            #[inline(always)]
            fn from(val: u8) -> Dfs {
                Dfs::from_bits(val)
            }
        }
        impl From<Dfs> for u8 {
            #[inline(always)]
            fn from(val: Dfs) -> u8 {
                Dfs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edges {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Edges {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edges {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edges {
            #[inline(always)]
            fn from(val: u8) -> Edges {
                Edges::from_bits(val)
            }
        }
        impl From<Edges> for u8 {
            #[inline(always)]
            fn from(val: Edges) -> u8 {
                Edges::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ferrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ferrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ferrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ferrf {
            #[inline(always)]
            fn from(val: u8) -> Ferrf {
                Ferrf::from_bits(val)
            }
        }
        impl From<Ferrf> for u8 {
            #[inline(always)]
            fn from(val: Ferrf) -> u8 {
                Ferrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ferrfcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ferrfcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ferrfcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ferrfcl {
            #[inline(always)]
            fn from(val: u8) -> Ferrfcl {
                Ferrfcl::from_bits(val)
            }
        }
        impl From<Ferrfcl> for u8 {
            #[inline(always)]
            fn from(val: Ferrfcl) -> u8 {
                Ferrfcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ferrie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ferrie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ferrie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ferrie {
            #[inline(always)]
            fn from(val: u8) -> Ferrie {
                Ferrie::from_bits(val)
            }
        }
        impl From<Ferrie> for u8 {
            #[inline(always)]
            fn from(val: Ferrie) -> u8 {
                Ferrie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fmcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fmcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fmcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fmcs {
            #[inline(always)]
            fn from(val: u8) -> Fmcs {
                Fmcs::from_bits(val)
            }
        }
        impl From<Fmcs> for u8 {
            #[inline(always)]
            fn from(val: Fmcs) -> u8 {
                Fmcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mendf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mendf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mendf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mendf {
            #[inline(always)]
            fn from(val: u8) -> Mendf {
                Mendf::from_bits(val)
            }
        }
        impl From<Mendf> for u8 {
            #[inline(always)]
            fn from(val: Mendf) -> u8 {
                Mendf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mendfcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mendfcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mendfcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mendfcl {
            #[inline(always)]
            fn from(val: u8) -> Mendfcl {
                Mendfcl::from_bits(val)
            }
        }
        impl From<Mendfcl> for u8 {
            #[inline(always)]
            fn from(val: Mendfcl) -> u8 {
                Mendfcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mendie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mendie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mendie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mendie {
            #[inline(always)]
            fn from(val: u8) -> Mendie {
                Mendie::from_bits(val)
            }
        }
        impl From<Mendie> for u8 {
            #[inline(always)]
            fn from(val: Mendie) -> u8 {
                Mendie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovff {
            #[inline(always)]
            fn from(val: u8) -> Ovff {
                Ovff::from_bits(val)
            }
        }
        impl From<Ovff> for u8 {
            #[inline(always)]
            fn from(val: Ovff) -> u8 {
                Ovff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovffcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovffcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovffcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovffcl {
            #[inline(always)]
            fn from(val: u8) -> Ovffcl {
                Ovffcl::from_bits(val)
            }
        }
        impl From<Ovffcl> for u8 {
            #[inline(always)]
            fn from(val: Ovffcl) -> u8 {
                Ovffcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovfie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovfie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovfie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovfie {
            #[inline(always)]
            fn from(val: u8) -> Ovfie {
                Ovfie::from_bits(val)
            }
        }
        impl From<Ovfie> for u8 {
            #[inline(always)]
            fn from(val: Ovfie) -> u8 {
                Ovfie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcds {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rcds {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcds {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcds {
            #[inline(always)]
            fn from(val: u8) -> Rcds {
                Rcds::from_bits(val)
            }
        }
        impl From<Rcds> for u8 {
            #[inline(always)]
            fn from(val: Rcds) -> u8 {
                Rcds::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rps {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rps {
            #[inline(always)]
            fn from(val: u8) -> Rps {
                Rps::from_bits(val)
            }
        }
        impl From<Rps> for u8 {
            #[inline(always)]
            fn from(val: Rps) -> u8 {
                Rps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rscs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rscs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rscs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rscs {
            #[inline(always)]
            fn from(val: u8) -> Rscs {
                Rscs::from_bits(val)
            }
        }
        impl From<Rscs> for u8 {
            #[inline(always)]
            fn from(val: Rscs) -> u8 {
                Rscs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tcss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcss {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcss {
            #[inline(always)]
            fn from(val: u8) -> Tcss {
                Tcss::from_bits(val)
            }
        }
        impl From<Tcss> for u8 {
            #[inline(always)]
            fn from(val: Tcss) -> u8 {
                Tcss::to_bits(val)
            }
        }
    }
}
pub mod can0 {
    #[doc = "CAN0 Module"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Can0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Can0 {}
    unsafe impl Sync for Can0 {}
    impl Can0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_id(self, n: usize) -> crate::common::Reg<regs::MbId, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_dl(self, n: usize) -> crate::common::Reg<regs::MbDl, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_d0(self, n: usize) -> crate::common::Reg<regs::MbD0, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0206usize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_d1(self, n: usize) -> crate::common::Reg<regs::MbD1, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0207usize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_d2(self, n: usize) -> crate::common::Reg<regs::MbD2, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_d3(self, n: usize) -> crate::common::Reg<regs::MbD3, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0209usize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_d4(self, n: usize) -> crate::common::Reg<regs::MbD4, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020ausize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_d5(self, n: usize) -> crate::common::Reg<regs::MbD5, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020busize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_d6(self, n: usize) -> crate::common::Reg<regs::MbD6, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020cusize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_d7(self, n: usize) -> crate::common::Reg<regs::MbD7, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020dusize + n * 16usize) as _) }
        }
        #[doc = "Mailbox Register"]
        #[inline(always)]
        pub const fn mb_ts(self, n: usize) -> crate::common::Reg<regs::MbTs, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020eusize + n * 16usize) as _) }
        }
        #[doc = "Mask Register"]
        #[inline(always)]
        pub const fn mkr(self, n: usize) -> crate::common::Reg<regs::Mkr, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize + n * 4usize) as _) }
        }
        #[doc = "FIFO Received ID Compare Registers"]
        #[inline(always)]
        pub const fn fidcr(self, n: usize) -> crate::common::Reg<regs::Fidcr, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0420usize + n * 4usize) as _) }
        }
        #[doc = "Mask Invalid Register"]
        #[inline(always)]
        pub const fn mkivlr(self) -> crate::common::Reg<regs::Mkivlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0428usize) as _) }
        }
        #[doc = "Mailbox Interrupt Enable Register (Normal mailbox mode)"]
        #[inline(always)]
        pub const fn mier(self) -> crate::common::Reg<regs::Mier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x042cusize) as _) }
        }
        #[doc = "Mailbox Interrupt Enable Register(FIFO mailbox mode)"]
        #[inline(always)]
        pub const fn mier_fifo(self) -> crate::common::Reg<regs::MierFifo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x042cusize) as _) }
        }
        #[doc = "Message Control Register( Receive mode (when the TRMREQ bit is 0 and the RECREQ bit is 1))"]
        #[inline(always)]
        pub const fn mctl_rx(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::MctlRx, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0820usize + n * 1usize) as _) }
        }
        #[doc = "Message Control Register(Transmit mode (when the TRMREQ bit is 1 and the RECREQ bit is 0))"]
        #[inline(always)]
        pub const fn mctl_tx(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::MctlTx, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0820usize + n * 1usize) as _) }
        }
        #[doc = "Control Register"]
        #[inline(always)]
        pub const fn ctlr(self) -> crate::common::Reg<regs::Ctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0840usize) as _) }
        }
        #[doc = "Status Register"]
        #[inline(always)]
        pub const fn str(self) -> crate::common::Reg<regs::Str, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0842usize) as _) }
        }
        #[doc = "Bit Configuration Register"]
        #[inline(always)]
        pub const fn bcr(self) -> crate::common::Reg<regs::Bcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0844usize) as _) }
        }
        #[doc = "Receive FIFO Control Register"]
        #[inline(always)]
        pub const fn rfcr(self) -> crate::common::Reg<regs::Rfcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0848usize) as _) }
        }
        #[doc = "Receive FIFO Pointer Control Register"]
        #[inline(always)]
        pub const fn rfpcr(self) -> crate::common::Reg<regs::Rfpcr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0849usize) as _) }
        }
        #[doc = "Transmit FIFO Control Register"]
        #[inline(always)]
        pub const fn tfcr(self) -> crate::common::Reg<regs::Tfcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x084ausize) as _) }
        }
        #[doc = "Transmit FIFO Pointer Control Register"]
        #[inline(always)]
        pub const fn tfpcr(self) -> crate::common::Reg<regs::Tfpcr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x084busize) as _) }
        }
        #[doc = "Error Interrupt Enable Register"]
        #[inline(always)]
        pub const fn eier(self) -> crate::common::Reg<regs::Eier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x084cusize) as _) }
        }
        #[doc = "Error Interrupt Factor Judge Register"]
        #[inline(always)]
        pub const fn eifr(self) -> crate::common::Reg<regs::Eifr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x084dusize) as _) }
        }
        #[doc = "Receive Error Count Register"]
        #[inline(always)]
        pub const fn recr(self) -> crate::common::Reg<regs::Recr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x084eusize) as _) }
        }
        #[doc = "Transmit Error Count Register"]
        #[inline(always)]
        pub const fn tecr(self) -> crate::common::Reg<regs::Tecr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x084fusize) as _) }
        }
        #[doc = "Error Code Store Register"]
        #[inline(always)]
        pub const fn ecsr(self) -> crate::common::Reg<regs::Ecsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0850usize) as _) }
        }
        #[doc = "Channel Search Support Register"]
        #[inline(always)]
        pub const fn cssr(self) -> crate::common::Reg<regs::Cssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0851usize) as _) }
        }
        #[doc = "Mailbox Search Status Register"]
        #[inline(always)]
        pub const fn mssr(self) -> crate::common::Reg<regs::Mssr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0852usize) as _) }
        }
        #[doc = "Mailbox Search Mode Register"]
        #[inline(always)]
        pub const fn msmr(self) -> crate::common::Reg<regs::Msmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0853usize) as _) }
        }
        #[doc = "Time Stamp Register"]
        #[inline(always)]
        pub const fn tsr(self) -> crate::common::Reg<regs::Tsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0854usize) as _) }
        }
        #[doc = "Acceptance Filter Support Register"]
        #[inline(always)]
        pub const fn afsr(self) -> crate::common::Reg<regs::Afsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0856usize) as _) }
        }
        #[doc = "Test Control Register"]
        #[inline(always)]
        pub const fn tcr(self) -> crate::common::Reg<regs::Tcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0858usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Acceptance Filter Support Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Afsr(pub u16);
        impl Afsr {
            #[doc = "After the standard ID of a received message is written, the value converted for data table search can be read."]
            #[inline(always)]
            pub const fn afsr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "After the standard ID of a received message is written, the value converted for data table search can be read."]
            #[inline(always)]
            pub fn set_afsr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Afsr {
            #[inline(always)]
            fn default() -> Afsr {
                Afsr(0)
            }
        }
        impl core::fmt::Debug for Afsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Afsr").field("afsr", &self.afsr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Afsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Afsr {{ afsr: {=u16:?} }}", self.afsr())
            }
        }
        #[doc = "Bit Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcr(pub u32);
        impl Bcr {
            #[doc = "CAN Clock Source Selection"]
            #[inline(always)]
            pub const fn cclks(&self) -> super::vals::Cclks {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cclks::from_bits(val as u8)
            }
            #[doc = "CAN Clock Source Selection"]
            #[inline(always)]
            pub fn set_cclks(&mut self, val: super::vals::Cclks) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u32) & 0x7f) << 1usize);
            }
            #[doc = "Time Segment 2 Control"]
            #[inline(always)]
            pub const fn tseg2(&self) -> super::vals::Tseg2 {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tseg2::from_bits(val as u8)
            }
            #[doc = "Time Segment 2 Control"]
            #[inline(always)]
            pub fn set_tseg2(&mut self, val: super::vals::Tseg2) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_11_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_11_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Resynchronization Jump Width Control"]
            #[inline(always)]
            pub const fn sjw(&self) -> super::vals::Sjw {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Sjw::from_bits(val as u8)
            }
            #[doc = "Resynchronization Jump Width Control"]
            #[inline(always)]
            pub fn set_sjw(&mut self, val: super::vals::Sjw) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_14_15(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_14_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 14usize)) | (((val as u32) & 0x03) << 14usize);
            }
            #[doc = "Baud Rate Prescaler select . These bits set the frequency of the CAN communication clock (fCANCLK)."]
            #[inline(always)]
            pub const fn brp(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Baud Rate Prescaler select . These bits set the frequency of the CAN communication clock (fCANCLK)."]
            #[inline(always)]
            pub fn set_brp(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_26_27(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_26_27(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 26usize)) | (((val as u32) & 0x03) << 26usize);
            }
            #[doc = "Time Segment 1 Control"]
            #[inline(always)]
            pub const fn tseg1(&self) -> super::vals::Tseg1 {
                let val = (self.0 >> 28usize) & 0x0f;
                super::vals::Tseg1::from_bits(val as u8)
            }
            #[doc = "Time Segment 1 Control"]
            #[inline(always)]
            pub fn set_tseg1(&mut self, val: super::vals::Tseg1) {
                self.0 =
                    (self.0 & !(0x0f << 28usize)) | (((val.to_bits() as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Bcr {
            #[inline(always)]
            fn default() -> Bcr {
                Bcr(0)
            }
        }
        impl core::fmt::Debug for Bcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcr")
                    .field("cclks", &self.cclks())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("tseg2", &self.tseg2())
                    .field("reserved_11_11", &self.reserved_11_11())
                    .field("sjw", &self.sjw())
                    .field("reserved_14_15", &self.reserved_14_15())
                    .field("brp", &self.brp())
                    .field("reserved_26_27", &self.reserved_26_27())
                    .field("tseg1", &self.tseg1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bcr {{ cclks: {:?}, reserved_1_7: {=u8:?}, tseg2: {:?}, reserved_11_11: {=bool:?}, sjw: {:?}, reserved_14_15: {=u8:?}, brp: {=u16:?}, reserved_26_27: {=u8:?}, tseg1: {:?} }}" , self . cclks () , self . reserved_1_7 () , self . tseg2 () , self . reserved_11_11 () , self . sjw () , self . reserved_14_15 () , self . brp () , self . reserved_26_27 () , self . tseg1 ())
            }
        }
        #[doc = "Channel Search Support Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cssr(pub u8);
        impl Cssr {
            #[doc = "When the value for the channel search is input, the channel number is output to MSSR."]
            #[inline(always)]
            pub const fn cssr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When the value for the channel search is input, the channel number is output to MSSR."]
            #[inline(always)]
            pub fn set_cssr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Cssr {
            #[inline(always)]
            fn default() -> Cssr {
                Cssr(0)
            }
        }
        impl core::fmt::Debug for Cssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cssr").field("cssr", &self.cssr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cssr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cssr {{ cssr: {=u8:?} }}", self.cssr())
            }
        }
        #[doc = "Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctlr(pub u16);
        impl Ctlr {
            #[doc = "CAN Mailbox Mode Select"]
            #[inline(always)]
            pub const fn mbm(&self) -> super::vals::Mbm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mbm::from_bits(val as u8)
            }
            #[doc = "CAN Mailbox Mode Select"]
            #[inline(always)]
            pub fn set_mbm(&mut self, val: super::vals::Mbm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "ID Format Mode Select"]
            #[inline(always)]
            pub const fn idfm(&self) -> super::vals::Idfm {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Idfm::from_bits(val as u8)
            }
            #[doc = "ID Format Mode Select"]
            #[inline(always)]
            pub fn set_idfm(&mut self, val: super::vals::Idfm) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u16) & 0x03) << 1usize);
            }
            #[doc = "Message Lost Mode Select"]
            #[inline(always)]
            pub const fn mlm(&self) -> super::vals::Mlm {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mlm::from_bits(val as u8)
            }
            #[doc = "Message Lost Mode Select"]
            #[inline(always)]
            pub fn set_mlm(&mut self, val: super::vals::Mlm) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Transmission Priority Mode Select"]
            #[inline(always)]
            pub const fn tpm(&self) -> super::vals::Tpm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tpm::from_bits(val as u8)
            }
            #[doc = "Transmission Priority Mode Select"]
            #[inline(always)]
            pub fn set_tpm(&mut self, val: super::vals::Tpm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Time Stamp Counter Reset Command"]
            #[inline(always)]
            pub const fn tsrc(&self) -> super::vals::Tsrc {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tsrc::from_bits(val as u8)
            }
            #[doc = "Time Stamp Counter Reset Command"]
            #[inline(always)]
            pub fn set_tsrc(&mut self, val: super::vals::Tsrc) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Time Stamp Prescaler Select"]
            #[inline(always)]
            pub const fn tsps(&self) -> super::vals::Tsps {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tsps::from_bits(val as u8)
            }
            #[doc = "Time Stamp Prescaler Select"]
            #[inline(always)]
            pub fn set_tsps(&mut self, val: super::vals::Tsps) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u16) & 0x03) << 6usize);
            }
            #[doc = "CAN Mode of Operation Select"]
            #[inline(always)]
            pub const fn canm(&self) -> super::vals::Canm {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Canm::from_bits(val as u8)
            }
            #[doc = "CAN Mode of Operation Select"]
            #[inline(always)]
            pub fn set_canm(&mut self, val: super::vals::Canm) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "CAN Sleep Mode"]
            #[inline(always)]
            pub const fn slpm(&self) -> super::vals::Slpm {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Slpm::from_bits(val as u8)
            }
            #[doc = "CAN Sleep Mode"]
            #[inline(always)]
            pub fn set_slpm(&mut self, val: super::vals::Slpm) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus,Off Recovery Mode"]
            #[inline(always)]
            pub const fn bom(&self) -> super::vals::Bom {
                let val = (self.0 >> 11usize) & 0x03;
                super::vals::Bom::from_bits(val as u8)
            }
            #[doc = "Bus,Off Recovery Mode"]
            #[inline(always)]
            pub fn set_bom(&mut self, val: super::vals::Bom) {
                self.0 =
                    (self.0 & !(0x03 << 11usize)) | (((val.to_bits() as u16) & 0x03) << 11usize);
            }
            #[doc = "Forcible Return From Bus,Off"]
            #[inline(always)]
            pub const fn rboc(&self) -> super::vals::Rboc {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Rboc::from_bits(val as u8)
            }
            #[doc = "Forcible Return From Bus,Off"]
            #[inline(always)]
            pub fn set_rboc(&mut self, val: super::vals::Rboc) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_14_15(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_14_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 14usize)) | (((val as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Ctlr {
            #[inline(always)]
            fn default() -> Ctlr {
                Ctlr(0)
            }
        }
        impl core::fmt::Debug for Ctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctlr")
                    .field("mbm", &self.mbm())
                    .field("idfm", &self.idfm())
                    .field("mlm", &self.mlm())
                    .field("tpm", &self.tpm())
                    .field("tsrc", &self.tsrc())
                    .field("tsps", &self.tsps())
                    .field("canm", &self.canm())
                    .field("slpm", &self.slpm())
                    .field("bom", &self.bom())
                    .field("rboc", &self.rboc())
                    .field("reserved_14_15", &self.reserved_14_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctlr {{ mbm: {:?}, idfm: {:?}, mlm: {:?}, tpm: {:?}, tsrc: {:?}, tsps: {:?}, canm: {:?}, slpm: {:?}, bom: {:?}, rboc: {:?}, reserved_14_15: {=u8:?} }}" , self . mbm () , self . idfm () , self . mlm () , self . tpm () , self . tsrc () , self . tsps () , self . canm () , self . slpm () , self . bom () , self . rboc () , self . reserved_14_15 ())
            }
        }
        #[doc = "Error Code Store Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ecsr(pub u8);
        impl Ecsr {
            #[doc = "Stuff Error Flag"]
            #[inline(always)]
            pub const fn sef(&self) -> super::vals::Sef {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sef::from_bits(val as u8)
            }
            #[doc = "Stuff Error Flag"]
            #[inline(always)]
            pub fn set_sef(&mut self, val: super::vals::Sef) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Form Error Flag"]
            #[inline(always)]
            pub const fn fef(&self) -> super::vals::Fef {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Fef::from_bits(val as u8)
            }
            #[doc = "Form Error Flag"]
            #[inline(always)]
            pub fn set_fef(&mut self, val: super::vals::Fef) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "ACK Error Flag"]
            #[inline(always)]
            pub const fn aef(&self) -> super::vals::Aef {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Aef::from_bits(val as u8)
            }
            #[doc = "ACK Error Flag"]
            #[inline(always)]
            pub fn set_aef(&mut self, val: super::vals::Aef) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "CRC Error Flag"]
            #[inline(always)]
            pub const fn cef(&self) -> super::vals::Cef {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cef::from_bits(val as u8)
            }
            #[doc = "CRC Error Flag"]
            #[inline(always)]
            pub fn set_cef(&mut self, val: super::vals::Cef) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Bit Error (recessive) Flag"]
            #[inline(always)]
            pub const fn be1f(&self) -> super::vals::Be1f {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Be1f::from_bits(val as u8)
            }
            #[doc = "Bit Error (recessive) Flag"]
            #[inline(always)]
            pub fn set_be1f(&mut self, val: super::vals::Be1f) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Bit Error (dominant) Flag"]
            #[inline(always)]
            pub const fn be0f(&self) -> super::vals::Be0f {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Be0f::from_bits(val as u8)
            }
            #[doc = "Bit Error (dominant) Flag"]
            #[inline(always)]
            pub fn set_be0f(&mut self, val: super::vals::Be0f) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "ACK Delimiter Error Flag"]
            #[inline(always)]
            pub const fn adef(&self) -> super::vals::Adef {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Adef::from_bits(val as u8)
            }
            #[doc = "ACK Delimiter Error Flag"]
            #[inline(always)]
            pub fn set_adef(&mut self, val: super::vals::Adef) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Error Display Mode Select"]
            #[inline(always)]
            pub const fn edpm(&self) -> super::vals::Edpm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Edpm::from_bits(val as u8)
            }
            #[doc = "Error Display Mode Select"]
            #[inline(always)]
            pub fn set_edpm(&mut self, val: super::vals::Edpm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ecsr {
            #[inline(always)]
            fn default() -> Ecsr {
                Ecsr(0)
            }
        }
        impl core::fmt::Debug for Ecsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ecsr")
                    .field("sef", &self.sef())
                    .field("fef", &self.fef())
                    .field("aef", &self.aef())
                    .field("cef", &self.cef())
                    .field("be1f", &self.be1f())
                    .field("be0f", &self.be0f())
                    .field("adef", &self.adef())
                    .field("edpm", &self.edpm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ecsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ecsr {{ sef: {:?}, fef: {:?}, aef: {:?}, cef: {:?}, be1f: {:?}, be0f: {:?}, adef: {:?}, edpm: {:?} }}" , self . sef () , self . fef () , self . aef () , self . cef () , self . be1f () , self . be0f () , self . adef () , self . edpm ())
            }
        }
        #[doc = "Error Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eier(pub u8);
        impl Eier {
            #[doc = "Bus Error Interrupt Enable"]
            #[inline(always)]
            pub const fn beie(&self) -> super::vals::Beie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Beie::from_bits(val as u8)
            }
            #[doc = "Bus Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_beie(&mut self, val: super::vals::Beie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Error,Warning Interrupt Enable"]
            #[inline(always)]
            pub const fn ewie(&self) -> super::vals::Ewie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ewie::from_bits(val as u8)
            }
            #[doc = "Error,Warning Interrupt Enable"]
            #[inline(always)]
            pub fn set_ewie(&mut self, val: super::vals::Ewie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Error,Passive Interrupt Enable"]
            #[inline(always)]
            pub const fn epie(&self) -> super::vals::Epie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Epie::from_bits(val as u8)
            }
            #[doc = "Error,Passive Interrupt Enable"]
            #[inline(always)]
            pub fn set_epie(&mut self, val: super::vals::Epie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Bus,Off Entry Interrupt Enable"]
            #[inline(always)]
            pub const fn boeie(&self) -> super::vals::Boeie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Boeie::from_bits(val as u8)
            }
            #[doc = "Bus,Off Entry Interrupt Enable"]
            #[inline(always)]
            pub fn set_boeie(&mut self, val: super::vals::Boeie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Bus,Off Recovery Interrupt Enable"]
            #[inline(always)]
            pub const fn borie(&self) -> super::vals::Borie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Borie::from_bits(val as u8)
            }
            #[doc = "Bus,Off Recovery Interrupt Enable"]
            #[inline(always)]
            pub fn set_borie(&mut self, val: super::vals::Borie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Interrupt Enable"]
            #[inline(always)]
            pub const fn orie(&self) -> super::vals::Orie {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Orie::from_bits(val as u8)
            }
            #[doc = "Overrun Interrupt Enable"]
            #[inline(always)]
            pub fn set_orie(&mut self, val: super::vals::Orie) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Overload Frame Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn olie(&self) -> super::vals::Olie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Olie::from_bits(val as u8)
            }
            #[doc = "Overload Frame Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_olie(&mut self, val: super::vals::Olie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Bus Lock Interrupt Enable"]
            #[inline(always)]
            pub const fn blie(&self) -> super::vals::Blie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Blie::from_bits(val as u8)
            }
            #[doc = "Bus Lock Interrupt Enable"]
            #[inline(always)]
            pub fn set_blie(&mut self, val: super::vals::Blie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Eier {
            #[inline(always)]
            fn default() -> Eier {
                Eier(0)
            }
        }
        impl core::fmt::Debug for Eier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eier")
                    .field("beie", &self.beie())
                    .field("ewie", &self.ewie())
                    .field("epie", &self.epie())
                    .field("boeie", &self.boeie())
                    .field("borie", &self.borie())
                    .field("orie", &self.orie())
                    .field("olie", &self.olie())
                    .field("blie", &self.blie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eier {{ beie: {:?}, ewie: {:?}, epie: {:?}, boeie: {:?}, borie: {:?}, orie: {:?}, olie: {:?}, blie: {:?} }}" , self . beie () , self . ewie () , self . epie () , self . boeie () , self . borie () , self . orie () , self . olie () , self . blie ())
            }
        }
        #[doc = "Error Interrupt Factor Judge Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eifr(pub u8);
        impl Eifr {
            #[doc = "Bus Error Detect Flag"]
            #[inline(always)]
            pub const fn beif(&self) -> super::vals::Beif {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Beif::from_bits(val as u8)
            }
            #[doc = "Bus Error Detect Flag"]
            #[inline(always)]
            pub fn set_beif(&mut self, val: super::vals::Beif) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Error,Warning Detect Flag"]
            #[inline(always)]
            pub const fn ewif(&self) -> super::vals::Ewif {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ewif::from_bits(val as u8)
            }
            #[doc = "Error,Warning Detect Flag"]
            #[inline(always)]
            pub fn set_ewif(&mut self, val: super::vals::Ewif) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Error,Passive Detect Flag"]
            #[inline(always)]
            pub const fn epif(&self) -> super::vals::Epif {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Epif::from_bits(val as u8)
            }
            #[doc = "Error,Passive Detect Flag"]
            #[inline(always)]
            pub fn set_epif(&mut self, val: super::vals::Epif) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Bus,Off Entry Detect Flag"]
            #[inline(always)]
            pub const fn boeif(&self) -> super::vals::Boeif {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Boeif::from_bits(val as u8)
            }
            #[doc = "Bus,Off Entry Detect Flag"]
            #[inline(always)]
            pub fn set_boeif(&mut self, val: super::vals::Boeif) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Bus,Off Recovery Detect Flag"]
            #[inline(always)]
            pub const fn borif(&self) -> super::vals::Borif {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Borif::from_bits(val as u8)
            }
            #[doc = "Bus,Off Recovery Detect Flag"]
            #[inline(always)]
            pub fn set_borif(&mut self, val: super::vals::Borif) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Receive Overrun Detect Flag"]
            #[inline(always)]
            pub const fn orif(&self) -> super::vals::Orif {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Orif::from_bits(val as u8)
            }
            #[doc = "Receive Overrun Detect Flag"]
            #[inline(always)]
            pub fn set_orif(&mut self, val: super::vals::Orif) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Overload Frame Transmission Detect Flag"]
            #[inline(always)]
            pub const fn olif(&self) -> super::vals::Olif {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Olif::from_bits(val as u8)
            }
            #[doc = "Overload Frame Transmission Detect Flag"]
            #[inline(always)]
            pub fn set_olif(&mut self, val: super::vals::Olif) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Bus Lock Detect Flag"]
            #[inline(always)]
            pub const fn blif(&self) -> super::vals::Blif {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Blif::from_bits(val as u8)
            }
            #[doc = "Bus Lock Detect Flag"]
            #[inline(always)]
            pub fn set_blif(&mut self, val: super::vals::Blif) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Eifr {
            #[inline(always)]
            fn default() -> Eifr {
                Eifr(0)
            }
        }
        impl core::fmt::Debug for Eifr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eifr")
                    .field("beif", &self.beif())
                    .field("ewif", &self.ewif())
                    .field("epif", &self.epif())
                    .field("boeif", &self.boeif())
                    .field("borif", &self.borif())
                    .field("orif", &self.orif())
                    .field("olif", &self.olif())
                    .field("blif", &self.blif())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eifr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eifr {{ beif: {:?}, ewif: {:?}, epif: {:?}, boeif: {:?}, borif: {:?}, orif: {:?}, olif: {:?}, blif: {:?} }}" , self . beif () , self . ewif () , self . epif () , self . boeif () , self . borif () , self . orif () , self . olif () , self . blif ())
            }
        }
        #[doc = "FIFO Received ID Compare Registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fidcr(pub u32);
        impl Fidcr {
            #[doc = "Extended ID"]
            #[inline(always)]
            pub const fn eid(&self) -> super::vals::FidcrEid {
                let val = (self.0 >> 0usize) & 0x0003_ffff;
                super::vals::FidcrEid::from_bits(val as u32)
            }
            #[doc = "Extended ID"]
            #[inline(always)]
            pub fn set_eid(&mut self, val: super::vals::FidcrEid) {
                self.0 = (self.0 & !(0x0003_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0x0003_ffff) << 0usize);
            }
            #[doc = "Standard ID"]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::FidcrSid {
                let val = (self.0 >> 18usize) & 0x07ff;
                super::vals::FidcrSid::from_bits(val as u16)
            }
            #[doc = "Standard ID"]
            #[inline(always)]
            pub fn set_sid(&mut self, val: super::vals::FidcrSid) {
                self.0 = (self.0 & !(0x07ff << 18usize))
                    | (((val.to_bits() as u32) & 0x07ff) << 18usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_29_29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_29_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Remote Transmission Request"]
            #[inline(always)]
            pub const fn rtr(&self) -> super::vals::FidcrRtr {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::FidcrRtr::from_bits(val as u8)
            }
            #[doc = "Remote Transmission Request"]
            #[inline(always)]
            pub fn set_rtr(&mut self, val: super::vals::FidcrRtr) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "ID Extension"]
            #[inline(always)]
            pub const fn ide(&self) -> super::vals::FidcrIde {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::FidcrIde::from_bits(val as u8)
            }
            #[doc = "ID Extension"]
            #[inline(always)]
            pub fn set_ide(&mut self, val: super::vals::FidcrIde) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Fidcr {
            #[inline(always)]
            fn default() -> Fidcr {
                Fidcr(0)
            }
        }
        impl core::fmt::Debug for Fidcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fidcr")
                    .field("eid", &self.eid())
                    .field("sid", &self.sid())
                    .field("reserved_29_29", &self.reserved_29_29())
                    .field("rtr", &self.rtr())
                    .field("ide", &self.ide())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fidcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fidcr {{ eid: {:?}, sid: {:?}, reserved_29_29: {=bool:?}, rtr: {:?}, ide: {:?} }}" , self . eid () , self . sid () , self . reserved_29_29 () , self . rtr () , self . ide ())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbD0(pub u8);
        impl MbD0 {
            #[doc = "Data Bytes 0.DATA0 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub const fn data0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data Bytes 0.DATA0 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub fn set_data0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbD0 {
            #[inline(always)]
            fn default() -> MbD0 {
                MbD0(0)
            }
        }
        impl core::fmt::Debug for MbD0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbD0")
                    .field("data0", &self.data0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbD0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbD0 {{ data0: {=u8:?} }}", self.data0())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbD1(pub u8);
        impl MbD1 {
            #[doc = "Data Bytes 1DATA1 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub const fn data1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data Bytes 1DATA1 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub fn set_data1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbD1 {
            #[inline(always)]
            fn default() -> MbD1 {
                MbD1(0)
            }
        }
        impl core::fmt::Debug for MbD1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbD1")
                    .field("data1", &self.data1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbD1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbD1 {{ data1: {=u8:?} }}", self.data1())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbD2(pub u8);
        impl MbD2 {
            #[doc = "Data Bytes 2DATA2 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub const fn data2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data Bytes 2DATA2 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub fn set_data2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbD2 {
            #[inline(always)]
            fn default() -> MbD2 {
                MbD2(0)
            }
        }
        impl core::fmt::Debug for MbD2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbD2")
                    .field("data2", &self.data2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbD2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbD2 {{ data2: {=u8:?} }}", self.data2())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbD3(pub u8);
        impl MbD3 {
            #[doc = "Data Bytes 3DATA3 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub const fn data3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data Bytes 3DATA3 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub fn set_data3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbD3 {
            #[inline(always)]
            fn default() -> MbD3 {
                MbD3(0)
            }
        }
        impl core::fmt::Debug for MbD3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbD3")
                    .field("data3", &self.data3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbD3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbD3 {{ data3: {=u8:?} }}", self.data3())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbD4(pub u8);
        impl MbD4 {
            #[doc = "Data Bytes 4DATA4 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub const fn data4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data Bytes 4DATA4 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub fn set_data4(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbD4 {
            #[inline(always)]
            fn default() -> MbD4 {
                MbD4(0)
            }
        }
        impl core::fmt::Debug for MbD4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbD4")
                    .field("data4", &self.data4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbD4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbD4 {{ data4: {=u8:?} }}", self.data4())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbD5(pub u8);
        impl MbD5 {
            #[doc = "Data Bytes 5DATA5 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub const fn data5(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data Bytes 5DATA5 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub fn set_data5(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbD5 {
            #[inline(always)]
            fn default() -> MbD5 {
                MbD5(0)
            }
        }
        impl core::fmt::Debug for MbD5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbD5")
                    .field("data5", &self.data5())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbD5 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbD5 {{ data5: {=u8:?} }}", self.data5())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbD6(pub u8);
        impl MbD6 {
            #[doc = "Data Bytes 6DATA6 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub const fn data6(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data Bytes 6DATA6 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub fn set_data6(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbD6 {
            #[inline(always)]
            fn default() -> MbD6 {
                MbD6(0)
            }
        }
        impl core::fmt::Debug for MbD6 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbD6")
                    .field("data6", &self.data6())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbD6 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbD6 {{ data6: {=u8:?} }}", self.data6())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbD7(pub u8);
        impl MbD7 {
            #[doc = "Data Bytes 7DATA7 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub const fn data7(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data Bytes 7DATA7 store the transmitted or received CAN message data. Transmission or reception starts from DATA0. The bit order on the CAN bus is MSB first, and transmission or reception starts from bit 7."]
            #[inline(always)]
            pub fn set_data7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbD7 {
            #[inline(always)]
            fn default() -> MbD7 {
                MbD7(0)
            }
        }
        impl core::fmt::Debug for MbD7 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbD7")
                    .field("data7", &self.data7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbD7 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbD7 {{ data7: {=u8:?} }}", self.data7())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbDl(pub u16);
        impl MbDl {
            #[doc = "Data Length Code"]
            #[inline(always)]
            pub const fn dlc(&self) -> super::vals::Dlc {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Dlc::from_bits(val as u8)
            }
            #[doc = "Data Length Code"]
            #[inline(always)]
            pub fn set_dlc(&mut self, val: super::vals::Dlc) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub const fn reserved_4_15(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub fn set_reserved_4_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u16) & 0x0fff) << 4usize);
            }
        }
        impl Default for MbDl {
            #[inline(always)]
            fn default() -> MbDl {
                MbDl(0)
            }
        }
        impl core::fmt::Debug for MbDl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbDl")
                    .field("dlc", &self.dlc())
                    .field("reserved_4_15", &self.reserved_4_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbDl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MbDl {{ dlc: {:?}, reserved_4_15: {=u16:?} }}",
                    self.dlc(),
                    self.reserved_4_15()
                )
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbId(pub u32);
        impl MbId {
            #[doc = "Extended ID"]
            #[inline(always)]
            pub const fn eid(&self) -> super::vals::MbIdEid {
                let val = (self.0 >> 0usize) & 0x0003_ffff;
                super::vals::MbIdEid::from_bits(val as u32)
            }
            #[doc = "Extended ID"]
            #[inline(always)]
            pub fn set_eid(&mut self, val: super::vals::MbIdEid) {
                self.0 = (self.0 & !(0x0003_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0x0003_ffff) << 0usize);
            }
            #[doc = "Standard ID"]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::MbIdSid {
                let val = (self.0 >> 18usize) & 0x07ff;
                super::vals::MbIdSid::from_bits(val as u16)
            }
            #[doc = "Standard ID"]
            #[inline(always)]
            pub fn set_sid(&mut self, val: super::vals::MbIdSid) {
                self.0 = (self.0 & !(0x07ff << 18usize))
                    | (((val.to_bits() as u32) & 0x07ff) << 18usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_29_29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_29_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Remote Transmission Request"]
            #[inline(always)]
            pub const fn rtr(&self) -> super::vals::MbIdRtr {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::MbIdRtr::from_bits(val as u8)
            }
            #[doc = "Remote Transmission Request"]
            #[inline(always)]
            pub fn set_rtr(&mut self, val: super::vals::MbIdRtr) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "ID Extension"]
            #[inline(always)]
            pub const fn ide(&self) -> super::vals::MbIdIde {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::MbIdIde::from_bits(val as u8)
            }
            #[doc = "ID Extension"]
            #[inline(always)]
            pub fn set_ide(&mut self, val: super::vals::MbIdIde) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for MbId {
            #[inline(always)]
            fn default() -> MbId {
                MbId(0)
            }
        }
        impl core::fmt::Debug for MbId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbId")
                    .field("eid", &self.eid())
                    .field("sid", &self.sid())
                    .field("reserved_29_29", &self.reserved_29_29())
                    .field("rtr", &self.rtr())
                    .field("ide", &self.ide())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbId {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MbId {{ eid: {:?}, sid: {:?}, reserved_29_29: {=bool:?}, rtr: {:?}, ide: {:?} }}" , self . eid () , self . sid () , self . reserved_29_29 () , self . rtr () , self . ide ())
            }
        }
        #[doc = "Mailbox Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbTs(pub u16);
        impl MbTs {
            #[doc = "Time Stamp Higher ByteBits TSL\\[7:0\\] store the counter value of the time stamp when received messages are stored in the mailbox."]
            #[inline(always)]
            pub const fn tsl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Time Stamp Higher ByteBits TSL\\[7:0\\] store the counter value of the time stamp when received messages are stored in the mailbox."]
            #[inline(always)]
            pub fn set_tsl(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "Time Stamp Lower ByteBits TSH\\[7:0\\] store the counter value of the time stamp when received messages are stored in the mailbox."]
            #[inline(always)]
            pub const fn tsh(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Time Stamp Lower ByteBits TSH\\[7:0\\] store the counter value of the time stamp when received messages are stored in the mailbox."]
            #[inline(always)]
            pub fn set_tsh(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for MbTs {
            #[inline(always)]
            fn default() -> MbTs {
                MbTs(0)
            }
        }
        impl core::fmt::Debug for MbTs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbTs")
                    .field("tsl", &self.tsl())
                    .field("tsh", &self.tsh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbTs {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MbTs {{ tsl: {=u8:?}, tsh: {=u8:?} }}",
                    self.tsl(),
                    self.tsh()
                )
            }
        }
        #[doc = "Message Control Register( Receive mode (when the TRMREQ bit is 0 and the RECREQ bit is 1))"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MctlRx(pub u8);
        impl MctlRx {
            #[doc = "Reception Complete Flag"]
            #[inline(always)]
            pub const fn newdata(&self) -> super::vals::Newdata {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Newdata::from_bits(val as u8)
            }
            #[doc = "Reception Complete Flag"]
            #[inline(always)]
            pub fn set_newdata(&mut self, val: super::vals::Newdata) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Reception,in,Progress Status Flag (Receive mailbox setting enabled)"]
            #[inline(always)]
            pub const fn invaldata(&self) -> super::vals::Invaldata {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Invaldata::from_bits(val as u8)
            }
            #[doc = "Reception,in,Progress Status Flag (Receive mailbox setting enabled)"]
            #[inline(always)]
            pub fn set_invaldata(&mut self, val: super::vals::Invaldata) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Message Lost Flag(Receive mailbox setting enabled)"]
            #[inline(always)]
            pub const fn msglost(&self) -> super::vals::Msglost {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Msglost::from_bits(val as u8)
            }
            #[doc = "Message Lost Flag(Receive mailbox setting enabled)"]
            #[inline(always)]
            pub fn set_msglost(&mut self, val: super::vals::Msglost) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "One,Shot Enable"]
            #[inline(always)]
            pub const fn oneshot(&self) -> super::vals::MctlRxOneshot {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::MctlRxOneshot::from_bits(val as u8)
            }
            #[doc = "One,Shot Enable"]
            #[inline(always)]
            pub fn set_oneshot(&mut self, val: super::vals::MctlRxOneshot) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Mailbox Request"]
            #[inline(always)]
            pub const fn recreq(&self) -> super::vals::MctlRxRecreq {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::MctlRxRecreq::from_bits(val as u8)
            }
            #[doc = "Receive Mailbox Request"]
            #[inline(always)]
            pub fn set_recreq(&mut self, val: super::vals::MctlRxRecreq) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Mailbox Request"]
            #[inline(always)]
            pub const fn trmreq(&self) -> super::vals::MctlRxTrmreq {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::MctlRxTrmreq::from_bits(val as u8)
            }
            #[doc = "Transmit Mailbox Request"]
            #[inline(always)]
            pub fn set_trmreq(&mut self, val: super::vals::MctlRxTrmreq) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for MctlRx {
            #[inline(always)]
            fn default() -> MctlRx {
                MctlRx(0)
            }
        }
        impl core::fmt::Debug for MctlRx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MctlRx")
                    .field("newdata", &self.newdata())
                    .field("invaldata", &self.invaldata())
                    .field("msglost", &self.msglost())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("oneshot", &self.oneshot())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("recreq", &self.recreq())
                    .field("trmreq", &self.trmreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MctlRx {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MctlRx {{ newdata: {:?}, invaldata: {:?}, msglost: {:?}, reserved_3_3: {=bool:?}, oneshot: {:?}, reserved_5_5: {=bool:?}, recreq: {:?}, trmreq: {:?} }}" , self . newdata () , self . invaldata () , self . msglost () , self . reserved_3_3 () , self . oneshot () , self . reserved_5_5 () , self . recreq () , self . trmreq ())
            }
        }
        #[doc = "Message Control Register(Transmit mode (when the TRMREQ bit is 1 and the RECREQ bit is 0))"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MctlTx(pub u8);
        impl MctlTx {
            #[doc = "Transmission Complete Flag"]
            #[inline(always)]
            pub const fn sentdata(&self) -> super::vals::Sentdata {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sentdata::from_bits(val as u8)
            }
            #[doc = "Transmission Complete Flag"]
            #[inline(always)]
            pub fn set_sentdata(&mut self, val: super::vals::Sentdata) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Transmission,in,Progress Status Flag (Transmit mailbox setting enabled)"]
            #[inline(always)]
            pub const fn trmactive(&self) -> super::vals::Trmactive {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Trmactive::from_bits(val as u8)
            }
            #[doc = "Transmission,in,Progress Status Flag (Transmit mailbox setting enabled)"]
            #[inline(always)]
            pub fn set_trmactive(&mut self, val: super::vals::Trmactive) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmission Abort Complete Flag (Transmit mailbox setting enabled)"]
            #[inline(always)]
            pub const fn trmabt(&self) -> super::vals::Trmabt {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Trmabt::from_bits(val as u8)
            }
            #[doc = "Transmission Abort Complete Flag (Transmit mailbox setting enabled)"]
            #[inline(always)]
            pub fn set_trmabt(&mut self, val: super::vals::Trmabt) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "One,Shot Enable"]
            #[inline(always)]
            pub const fn oneshot(&self) -> super::vals::MctlTxOneshot {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::MctlTxOneshot::from_bits(val as u8)
            }
            #[doc = "One,Shot Enable"]
            #[inline(always)]
            pub fn set_oneshot(&mut self, val: super::vals::MctlTxOneshot) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Mailbox Request"]
            #[inline(always)]
            pub const fn recreq(&self) -> super::vals::MctlTxRecreq {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::MctlTxRecreq::from_bits(val as u8)
            }
            #[doc = "Receive Mailbox Request"]
            #[inline(always)]
            pub fn set_recreq(&mut self, val: super::vals::MctlTxRecreq) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Mailbox Request"]
            #[inline(always)]
            pub const fn trmreq(&self) -> super::vals::MctlTxTrmreq {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::MctlTxTrmreq::from_bits(val as u8)
            }
            #[doc = "Transmit Mailbox Request"]
            #[inline(always)]
            pub fn set_trmreq(&mut self, val: super::vals::MctlTxTrmreq) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for MctlTx {
            #[inline(always)]
            fn default() -> MctlTx {
                MctlTx(0)
            }
        }
        impl core::fmt::Debug for MctlTx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MctlTx")
                    .field("sentdata", &self.sentdata())
                    .field("trmactive", &self.trmactive())
                    .field("trmabt", &self.trmabt())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("oneshot", &self.oneshot())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("recreq", &self.recreq())
                    .field("trmreq", &self.trmreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MctlTx {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MctlTx {{ sentdata: {:?}, trmactive: {:?}, trmabt: {:?}, reserved_3_3: {=bool:?}, oneshot: {:?}, reserved_5_5: {=bool:?}, recreq: {:?}, trmreq: {:?} }}" , self . sentdata () , self . trmactive () , self . trmabt () , self . reserved_3_3 () , self . oneshot () , self . reserved_5_5 () , self . recreq () , self . trmreq ())
            }
        }
        #[doc = "Mailbox Interrupt Enable Register (Normal mailbox mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mier(pub u32);
        impl Mier {
            #[doc = "mailbox 0 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb0(&self) -> super::vals::MierMb0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MierMb0::from_bits(val as u8)
            }
            #[doc = "mailbox 0 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb0(&mut self, val: super::vals::MierMb0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "mailbox 1 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb1(&self) -> super::vals::MierMb1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::MierMb1::from_bits(val as u8)
            }
            #[doc = "mailbox 1 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb1(&mut self, val: super::vals::MierMb1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "mailbox 2 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb2(&self) -> super::vals::MierMb2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::MierMb2::from_bits(val as u8)
            }
            #[doc = "mailbox 2 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb2(&mut self, val: super::vals::MierMb2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "mailbox 3 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb3(&self) -> super::vals::MierMb3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::MierMb3::from_bits(val as u8)
            }
            #[doc = "mailbox 3 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb3(&mut self, val: super::vals::MierMb3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "mailbox 4 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb4(&self) -> super::vals::MierMb4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::MierMb4::from_bits(val as u8)
            }
            #[doc = "mailbox 4 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb4(&mut self, val: super::vals::MierMb4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "mailbox 5 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb5(&self) -> super::vals::MierMb5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::MierMb5::from_bits(val as u8)
            }
            #[doc = "mailbox 5 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb5(&mut self, val: super::vals::MierMb5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "mailbox 6 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb6(&self) -> super::vals::MierMb6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::MierMb6::from_bits(val as u8)
            }
            #[doc = "mailbox 6 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb6(&mut self, val: super::vals::MierMb6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "mailbox 7 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb7(&self) -> super::vals::MierMb7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::MierMb7::from_bits(val as u8)
            }
            #[doc = "mailbox 7 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb7(&mut self, val: super::vals::MierMb7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "mailbox 8 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb8(&self) -> super::vals::MierMb8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::MierMb8::from_bits(val as u8)
            }
            #[doc = "mailbox 8 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb8(&mut self, val: super::vals::MierMb8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "mailbox 9 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb9(&self) -> super::vals::MierMb9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::MierMb9::from_bits(val as u8)
            }
            #[doc = "mailbox 9 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb9(&mut self, val: super::vals::MierMb9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "mailbox 10 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb10(&self) -> super::vals::MierMb10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::MierMb10::from_bits(val as u8)
            }
            #[doc = "mailbox 10 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb10(&mut self, val: super::vals::MierMb10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "mailbox 11 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb11(&self) -> super::vals::MierMb11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::MierMb11::from_bits(val as u8)
            }
            #[doc = "mailbox 11 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb11(&mut self, val: super::vals::MierMb11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "mailbox 12 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb12(&self) -> super::vals::MierMb12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::MierMb12::from_bits(val as u8)
            }
            #[doc = "mailbox 12 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb12(&mut self, val: super::vals::MierMb12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "mailbox 13 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb13(&self) -> super::vals::MierMb13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::MierMb13::from_bits(val as u8)
            }
            #[doc = "mailbox 13 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb13(&mut self, val: super::vals::MierMb13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "mailbox 14 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb14(&self) -> super::vals::MierMb14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::MierMb14::from_bits(val as u8)
            }
            #[doc = "mailbox 14 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb14(&mut self, val: super::vals::MierMb14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "mailbox 15 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb15(&self) -> super::vals::MierMb15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::MierMb15::from_bits(val as u8)
            }
            #[doc = "mailbox 15 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb15(&mut self, val: super::vals::MierMb15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "mailbox 16 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb16(&self) -> super::vals::MierMb16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::MierMb16::from_bits(val as u8)
            }
            #[doc = "mailbox 16 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb16(&mut self, val: super::vals::MierMb16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "mailbox 17 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb17(&self) -> super::vals::MierMb17 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::MierMb17::from_bits(val as u8)
            }
            #[doc = "mailbox 17 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb17(&mut self, val: super::vals::MierMb17) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "mailbox 18 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb18(&self) -> super::vals::MierMb18 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::MierMb18::from_bits(val as u8)
            }
            #[doc = "mailbox 18 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb18(&mut self, val: super::vals::MierMb18) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "mailbox 19 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb19(&self) -> super::vals::MierMb19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::MierMb19::from_bits(val as u8)
            }
            #[doc = "mailbox 19 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb19(&mut self, val: super::vals::MierMb19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "mailbox 20 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb20(&self) -> super::vals::MierMb20 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::MierMb20::from_bits(val as u8)
            }
            #[doc = "mailbox 20 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb20(&mut self, val: super::vals::MierMb20) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "mailbox 21 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb21(&self) -> super::vals::MierMb21 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::MierMb21::from_bits(val as u8)
            }
            #[doc = "mailbox 21 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb21(&mut self, val: super::vals::MierMb21) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "mailbox 22 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb22(&self) -> super::vals::MierMb22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::MierMb22::from_bits(val as u8)
            }
            #[doc = "mailbox 22 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb22(&mut self, val: super::vals::MierMb22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "mailbox 23 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb23(&self) -> super::vals::MierMb23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::MierMb23::from_bits(val as u8)
            }
            #[doc = "mailbox 23 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb23(&mut self, val: super::vals::MierMb23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "mailbox 24 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb24(&self) -> super::vals::MierMb24 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::MierMb24::from_bits(val as u8)
            }
            #[doc = "mailbox 24 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb24(&mut self, val: super::vals::MierMb24) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "mailbox 25 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb25(&self) -> super::vals::MierMb25 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::MierMb25::from_bits(val as u8)
            }
            #[doc = "mailbox 25 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb25(&mut self, val: super::vals::MierMb25) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "mailbox 26 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb26(&self) -> super::vals::MierMb26 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::MierMb26::from_bits(val as u8)
            }
            #[doc = "mailbox 26 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb26(&mut self, val: super::vals::MierMb26) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "mailbox 27 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb27(&self) -> super::vals::MierMb27 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::MierMb27::from_bits(val as u8)
            }
            #[doc = "mailbox 27 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb27(&mut self, val: super::vals::MierMb27) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "mailbox 28 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb28(&self) -> super::vals::MierMb28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::MierMb28::from_bits(val as u8)
            }
            #[doc = "mailbox 28 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb28(&mut self, val: super::vals::MierMb28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "mailbox 29 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb29(&self) -> super::vals::MierMb29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::MierMb29::from_bits(val as u8)
            }
            #[doc = "mailbox 29 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb29(&mut self, val: super::vals::MierMb29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "mailbox 30 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb30(&self) -> super::vals::MierMb30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::MierMb30::from_bits(val as u8)
            }
            #[doc = "mailbox 30 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb30(&mut self, val: super::vals::MierMb30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "mailbox 31 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb31(&self) -> super::vals::MierMb31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::MierMb31::from_bits(val as u8)
            }
            #[doc = "mailbox 31 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb31(&mut self, val: super::vals::MierMb31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Mier {
            #[inline(always)]
            fn default() -> Mier {
                Mier(0)
            }
        }
        impl core::fmt::Debug for Mier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mier")
                    .field("mb0", &self.mb0())
                    .field("mb1", &self.mb1())
                    .field("mb2", &self.mb2())
                    .field("mb3", &self.mb3())
                    .field("mb4", &self.mb4())
                    .field("mb5", &self.mb5())
                    .field("mb6", &self.mb6())
                    .field("mb7", &self.mb7())
                    .field("mb8", &self.mb8())
                    .field("mb9", &self.mb9())
                    .field("mb10", &self.mb10())
                    .field("mb11", &self.mb11())
                    .field("mb12", &self.mb12())
                    .field("mb13", &self.mb13())
                    .field("mb14", &self.mb14())
                    .field("mb15", &self.mb15())
                    .field("mb16", &self.mb16())
                    .field("mb17", &self.mb17())
                    .field("mb18", &self.mb18())
                    .field("mb19", &self.mb19())
                    .field("mb20", &self.mb20())
                    .field("mb21", &self.mb21())
                    .field("mb22", &self.mb22())
                    .field("mb23", &self.mb23())
                    .field("mb24", &self.mb24())
                    .field("mb25", &self.mb25())
                    .field("mb26", &self.mb26())
                    .field("mb27", &self.mb27())
                    .field("mb28", &self.mb28())
                    .field("mb29", &self.mb29())
                    .field("mb30", &self.mb30())
                    .field("mb31", &self.mb31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mier {{ mb0: {:?}, mb1: {:?}, mb2: {:?}, mb3: {:?}, mb4: {:?}, mb5: {:?}, mb6: {:?}, mb7: {:?}, mb8: {:?}, mb9: {:?}, mb10: {:?}, mb11: {:?}, mb12: {:?}, mb13: {:?}, mb14: {:?}, mb15: {:?}, mb16: {:?}, mb17: {:?}, mb18: {:?}, mb19: {:?}, mb20: {:?}, mb21: {:?}, mb22: {:?}, mb23: {:?}, mb24: {:?}, mb25: {:?}, mb26: {:?}, mb27: {:?}, mb28: {:?}, mb29: {:?}, mb30: {:?}, mb31: {:?} }}" , self . mb0 () , self . mb1 () , self . mb2 () , self . mb3 () , self . mb4 () , self . mb5 () , self . mb6 () , self . mb7 () , self . mb8 () , self . mb9 () , self . mb10 () , self . mb11 () , self . mb12 () , self . mb13 () , self . mb14 () , self . mb15 () , self . mb16 () , self . mb17 () , self . mb18 () , self . mb19 () , self . mb20 () , self . mb21 () , self . mb22 () , self . mb23 () , self . mb24 () , self . mb25 () , self . mb26 () , self . mb27 () , self . mb28 () , self . mb29 () , self . mb30 () , self . mb31 ())
            }
        }
        #[doc = "Mailbox Interrupt Enable Register(FIFO mailbox mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MierFifo(pub u32);
        impl MierFifo {
            #[doc = "mailbox 0 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb0(&self) -> super::vals::MierFifoMb0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MierFifoMb0::from_bits(val as u8)
            }
            #[doc = "mailbox 0 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb0(&mut self, val: super::vals::MierFifoMb0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "mailbox 1 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb1(&self) -> super::vals::MierFifoMb1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::MierFifoMb1::from_bits(val as u8)
            }
            #[doc = "mailbox 1 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb1(&mut self, val: super::vals::MierFifoMb1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "mailbox 2 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb2(&self) -> super::vals::MierFifoMb2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::MierFifoMb2::from_bits(val as u8)
            }
            #[doc = "mailbox 2 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb2(&mut self, val: super::vals::MierFifoMb2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "mailbox 3 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb3(&self) -> super::vals::MierFifoMb3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::MierFifoMb3::from_bits(val as u8)
            }
            #[doc = "mailbox 3 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb3(&mut self, val: super::vals::MierFifoMb3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "mailbox 4 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb4(&self) -> super::vals::MierFifoMb4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::MierFifoMb4::from_bits(val as u8)
            }
            #[doc = "mailbox 4 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb4(&mut self, val: super::vals::MierFifoMb4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "mailbox 5 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb5(&self) -> super::vals::MierFifoMb5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::MierFifoMb5::from_bits(val as u8)
            }
            #[doc = "mailbox 5 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb5(&mut self, val: super::vals::MierFifoMb5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "mailbox 6 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb6(&self) -> super::vals::MierFifoMb6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::MierFifoMb6::from_bits(val as u8)
            }
            #[doc = "mailbox 6 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb6(&mut self, val: super::vals::MierFifoMb6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "mailbox 7 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb7(&self) -> super::vals::MierFifoMb7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::MierFifoMb7::from_bits(val as u8)
            }
            #[doc = "mailbox 7 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb7(&mut self, val: super::vals::MierFifoMb7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "mailbox 8 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb8(&self) -> super::vals::MierFifoMb8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::MierFifoMb8::from_bits(val as u8)
            }
            #[doc = "mailbox 8 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb8(&mut self, val: super::vals::MierFifoMb8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "mailbox 9 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb9(&self) -> super::vals::MierFifoMb9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::MierFifoMb9::from_bits(val as u8)
            }
            #[doc = "mailbox 9 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb9(&mut self, val: super::vals::MierFifoMb9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "mailbox 10 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb10(&self) -> super::vals::MierFifoMb10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::MierFifoMb10::from_bits(val as u8)
            }
            #[doc = "mailbox 10 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb10(&mut self, val: super::vals::MierFifoMb10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "mailbox 11 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb11(&self) -> super::vals::MierFifoMb11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::MierFifoMb11::from_bits(val as u8)
            }
            #[doc = "mailbox 11 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb11(&mut self, val: super::vals::MierFifoMb11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "mailbox 12 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb12(&self) -> super::vals::MierFifoMb12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::MierFifoMb12::from_bits(val as u8)
            }
            #[doc = "mailbox 12 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb12(&mut self, val: super::vals::MierFifoMb12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "mailbox 13 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb13(&self) -> super::vals::MierFifoMb13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::MierFifoMb13::from_bits(val as u8)
            }
            #[doc = "mailbox 13 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb13(&mut self, val: super::vals::MierFifoMb13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "mailbox 14 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb14(&self) -> super::vals::MierFifoMb14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::MierFifoMb14::from_bits(val as u8)
            }
            #[doc = "mailbox 14 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb14(&mut self, val: super::vals::MierFifoMb14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "mailbox 15 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb15(&self) -> super::vals::MierFifoMb15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::MierFifoMb15::from_bits(val as u8)
            }
            #[doc = "mailbox 15 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb15(&mut self, val: super::vals::MierFifoMb15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "mailbox 16 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb16(&self) -> super::vals::MierFifoMb16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::MierFifoMb16::from_bits(val as u8)
            }
            #[doc = "mailbox 16 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb16(&mut self, val: super::vals::MierFifoMb16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "mailbox 17 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb17(&self) -> super::vals::MierFifoMb17 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::MierFifoMb17::from_bits(val as u8)
            }
            #[doc = "mailbox 17 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb17(&mut self, val: super::vals::MierFifoMb17) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "mailbox 18 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb18(&self) -> super::vals::MierFifoMb18 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::MierFifoMb18::from_bits(val as u8)
            }
            #[doc = "mailbox 18 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb18(&mut self, val: super::vals::MierFifoMb18) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "mailbox 19 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb19(&self) -> super::vals::MierFifoMb19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::MierFifoMb19::from_bits(val as u8)
            }
            #[doc = "mailbox 19 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb19(&mut self, val: super::vals::MierFifoMb19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "mailbox 20 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb20(&self) -> super::vals::MierFifoMb20 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::MierFifoMb20::from_bits(val as u8)
            }
            #[doc = "mailbox 20 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb20(&mut self, val: super::vals::MierFifoMb20) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "mailbox 21 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb21(&self) -> super::vals::MierFifoMb21 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::MierFifoMb21::from_bits(val as u8)
            }
            #[doc = "mailbox 21 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb21(&mut self, val: super::vals::MierFifoMb21) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "mailbox 22 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb22(&self) -> super::vals::MierFifoMb22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::MierFifoMb22::from_bits(val as u8)
            }
            #[doc = "mailbox 22 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb22(&mut self, val: super::vals::MierFifoMb22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "mailbox 23 Interrupt Enable"]
            #[inline(always)]
            pub const fn mb23(&self) -> super::vals::MierFifoMb23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::MierFifoMb23::from_bits(val as u8)
            }
            #[doc = "mailbox 23 Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb23(&mut self, val: super::vals::MierFifoMb23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Transmit FIFO Interrupt Enable"]
            #[inline(always)]
            pub const fn mb24(&self) -> super::vals::MierFifoMb24 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::MierFifoMb24::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb24(&mut self, val: super::vals::MierFifoMb24) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Transmit FIFO Interrupt Generation Timing Control"]
            #[inline(always)]
            pub const fn mb25(&self) -> super::vals::MierFifoMb25 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::MierFifoMb25::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Interrupt Generation Timing Control"]
            #[inline(always)]
            pub fn set_mb25(&mut self, val: super::vals::MierFifoMb25) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_26_27(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_26_27(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 26usize)) | (((val as u32) & 0x03) << 26usize);
            }
            #[doc = "Receive FIFO Interrupt Enable"]
            #[inline(always)]
            pub const fn mb28(&self) -> super::vals::MierFifoMb28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::MierFifoMb28::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Interrupt Enable"]
            #[inline(always)]
            pub fn set_mb28(&mut self, val: super::vals::MierFifoMb28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Receive FIFO Interrupt Generation Timing Control"]
            #[inline(always)]
            pub const fn mb29(&self) -> super::vals::MierFifoMb29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::MierFifoMb29::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Interrupt Generation Timing Control"]
            #[inline(always)]
            pub fn set_mb29(&mut self, val: super::vals::MierFifoMb29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
        }
        impl Default for MierFifo {
            #[inline(always)]
            fn default() -> MierFifo {
                MierFifo(0)
            }
        }
        impl core::fmt::Debug for MierFifo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MierFifo")
                    .field("mb0", &self.mb0())
                    .field("mb1", &self.mb1())
                    .field("mb2", &self.mb2())
                    .field("mb3", &self.mb3())
                    .field("mb4", &self.mb4())
                    .field("mb5", &self.mb5())
                    .field("mb6", &self.mb6())
                    .field("mb7", &self.mb7())
                    .field("mb8", &self.mb8())
                    .field("mb9", &self.mb9())
                    .field("mb10", &self.mb10())
                    .field("mb11", &self.mb11())
                    .field("mb12", &self.mb12())
                    .field("mb13", &self.mb13())
                    .field("mb14", &self.mb14())
                    .field("mb15", &self.mb15())
                    .field("mb16", &self.mb16())
                    .field("mb17", &self.mb17())
                    .field("mb18", &self.mb18())
                    .field("mb19", &self.mb19())
                    .field("mb20", &self.mb20())
                    .field("mb21", &self.mb21())
                    .field("mb22", &self.mb22())
                    .field("mb23", &self.mb23())
                    .field("mb24", &self.mb24())
                    .field("mb25", &self.mb25())
                    .field("reserved_26_27", &self.reserved_26_27())
                    .field("mb28", &self.mb28())
                    .field("mb29", &self.mb29())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MierFifo {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MierFifo {{ mb0: {:?}, mb1: {:?}, mb2: {:?}, mb3: {:?}, mb4: {:?}, mb5: {:?}, mb6: {:?}, mb7: {:?}, mb8: {:?}, mb9: {:?}, mb10: {:?}, mb11: {:?}, mb12: {:?}, mb13: {:?}, mb14: {:?}, mb15: {:?}, mb16: {:?}, mb17: {:?}, mb18: {:?}, mb19: {:?}, mb20: {:?}, mb21: {:?}, mb22: {:?}, mb23: {:?}, mb24: {:?}, mb25: {:?}, reserved_26_27: {=u8:?}, mb28: {:?}, mb29: {:?} }}" , self . mb0 () , self . mb1 () , self . mb2 () , self . mb3 () , self . mb4 () , self . mb5 () , self . mb6 () , self . mb7 () , self . mb8 () , self . mb9 () , self . mb10 () , self . mb11 () , self . mb12 () , self . mb13 () , self . mb14 () , self . mb15 () , self . mb16 () , self . mb17 () , self . mb18 () , self . mb19 () , self . mb20 () , self . mb21 () , self . mb22 () , self . mb23 () , self . mb24 () , self . mb25 () , self . reserved_26_27 () , self . mb28 () , self . mb29 ())
            }
        }
        #[doc = "Mask Invalid Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mkivlr(pub u32);
        impl Mkivlr {
            #[doc = "mailbox 0 Mask Invalid"]
            #[inline(always)]
            pub const fn mb0(&self) -> super::vals::MkivlrMb0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MkivlrMb0::from_bits(val as u8)
            }
            #[doc = "mailbox 0 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb0(&mut self, val: super::vals::MkivlrMb0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "mailbox 1 Mask Invalid"]
            #[inline(always)]
            pub const fn mb1(&self) -> super::vals::MkivlrMb1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::MkivlrMb1::from_bits(val as u8)
            }
            #[doc = "mailbox 1 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb1(&mut self, val: super::vals::MkivlrMb1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "mailbox 2 Mask Invalid"]
            #[inline(always)]
            pub const fn mb2(&self) -> super::vals::MkivlrMb2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::MkivlrMb2::from_bits(val as u8)
            }
            #[doc = "mailbox 2 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb2(&mut self, val: super::vals::MkivlrMb2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "mailbox 3 Mask Invalid"]
            #[inline(always)]
            pub const fn mb3(&self) -> super::vals::MkivlrMb3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::MkivlrMb3::from_bits(val as u8)
            }
            #[doc = "mailbox 3 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb3(&mut self, val: super::vals::MkivlrMb3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "mailbox 4 Mask Invalid"]
            #[inline(always)]
            pub const fn mb4(&self) -> super::vals::MkivlrMb4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::MkivlrMb4::from_bits(val as u8)
            }
            #[doc = "mailbox 4 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb4(&mut self, val: super::vals::MkivlrMb4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "mailbox 5 Mask Invalid"]
            #[inline(always)]
            pub const fn mb5(&self) -> super::vals::MkivlrMb5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::MkivlrMb5::from_bits(val as u8)
            }
            #[doc = "mailbox 5 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb5(&mut self, val: super::vals::MkivlrMb5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "mailbox 6 Mask Invalid"]
            #[inline(always)]
            pub const fn mb6(&self) -> super::vals::MkivlrMb6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::MkivlrMb6::from_bits(val as u8)
            }
            #[doc = "mailbox 6 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb6(&mut self, val: super::vals::MkivlrMb6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "mailbox 7 Mask Invalid"]
            #[inline(always)]
            pub const fn mb7(&self) -> super::vals::MkivlrMb7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::MkivlrMb7::from_bits(val as u8)
            }
            #[doc = "mailbox 7 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb7(&mut self, val: super::vals::MkivlrMb7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "mailbox 8 Mask Invalid"]
            #[inline(always)]
            pub const fn mb8(&self) -> super::vals::MkivlrMb8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::MkivlrMb8::from_bits(val as u8)
            }
            #[doc = "mailbox 8 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb8(&mut self, val: super::vals::MkivlrMb8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "mailbox 9 Mask Invalid"]
            #[inline(always)]
            pub const fn mb9(&self) -> super::vals::MkivlrMb9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::MkivlrMb9::from_bits(val as u8)
            }
            #[doc = "mailbox 9 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb9(&mut self, val: super::vals::MkivlrMb9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "mailbox 10 Mask Invalid"]
            #[inline(always)]
            pub const fn mb10(&self) -> super::vals::MkivlrMb10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::MkivlrMb10::from_bits(val as u8)
            }
            #[doc = "mailbox 10 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb10(&mut self, val: super::vals::MkivlrMb10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "mailbox 11 Mask Invalid"]
            #[inline(always)]
            pub const fn mb11(&self) -> super::vals::MkivlrMb11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::MkivlrMb11::from_bits(val as u8)
            }
            #[doc = "mailbox 11 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb11(&mut self, val: super::vals::MkivlrMb11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "mailbox 12 Mask Invalid"]
            #[inline(always)]
            pub const fn mb12(&self) -> super::vals::MkivlrMb12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::MkivlrMb12::from_bits(val as u8)
            }
            #[doc = "mailbox 12 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb12(&mut self, val: super::vals::MkivlrMb12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "mailbox 13 Mask Invalid"]
            #[inline(always)]
            pub const fn mb13(&self) -> super::vals::MkivlrMb13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::MkivlrMb13::from_bits(val as u8)
            }
            #[doc = "mailbox 13 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb13(&mut self, val: super::vals::MkivlrMb13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "mailbox 14 Mask Invalid"]
            #[inline(always)]
            pub const fn mb14(&self) -> super::vals::MkivlrMb14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::MkivlrMb14::from_bits(val as u8)
            }
            #[doc = "mailbox 14 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb14(&mut self, val: super::vals::MkivlrMb14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "mailbox 15 Mask Invalid"]
            #[inline(always)]
            pub const fn mb15(&self) -> super::vals::MkivlrMb15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::MkivlrMb15::from_bits(val as u8)
            }
            #[doc = "mailbox 15 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb15(&mut self, val: super::vals::MkivlrMb15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "mailbox 16 Mask Invalid"]
            #[inline(always)]
            pub const fn mb16(&self) -> super::vals::MkivlrMb16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::MkivlrMb16::from_bits(val as u8)
            }
            #[doc = "mailbox 16 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb16(&mut self, val: super::vals::MkivlrMb16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "mailbox 17 Mask Invalid"]
            #[inline(always)]
            pub const fn mb17(&self) -> super::vals::MkivlrMb17 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::MkivlrMb17::from_bits(val as u8)
            }
            #[doc = "mailbox 17 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb17(&mut self, val: super::vals::MkivlrMb17) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "mailbox 18 Mask Invalid"]
            #[inline(always)]
            pub const fn mb18(&self) -> super::vals::MkivlrMb18 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::MkivlrMb18::from_bits(val as u8)
            }
            #[doc = "mailbox 18 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb18(&mut self, val: super::vals::MkivlrMb18) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "mailbox 19 Mask Invalid"]
            #[inline(always)]
            pub const fn mb19(&self) -> super::vals::MkivlrMb19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::MkivlrMb19::from_bits(val as u8)
            }
            #[doc = "mailbox 19 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb19(&mut self, val: super::vals::MkivlrMb19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "mailbox 20 Mask Invalid"]
            #[inline(always)]
            pub const fn mb20(&self) -> super::vals::MkivlrMb20 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::MkivlrMb20::from_bits(val as u8)
            }
            #[doc = "mailbox 20 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb20(&mut self, val: super::vals::MkivlrMb20) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "mailbox 21 Mask Invalid"]
            #[inline(always)]
            pub const fn mb21(&self) -> super::vals::MkivlrMb21 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::MkivlrMb21::from_bits(val as u8)
            }
            #[doc = "mailbox 21 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb21(&mut self, val: super::vals::MkivlrMb21) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "mailbox 22 Mask Invalid"]
            #[inline(always)]
            pub const fn mb22(&self) -> super::vals::MkivlrMb22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::MkivlrMb22::from_bits(val as u8)
            }
            #[doc = "mailbox 22 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb22(&mut self, val: super::vals::MkivlrMb22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "mailbox 23 Mask Invalid"]
            #[inline(always)]
            pub const fn mb23(&self) -> super::vals::MkivlrMb23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::MkivlrMb23::from_bits(val as u8)
            }
            #[doc = "mailbox 23 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb23(&mut self, val: super::vals::MkivlrMb23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "mailbox 24 Mask Invalid"]
            #[inline(always)]
            pub const fn mb24(&self) -> super::vals::MkivlrMb24 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::MkivlrMb24::from_bits(val as u8)
            }
            #[doc = "mailbox 24 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb24(&mut self, val: super::vals::MkivlrMb24) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "mailbox 25 Mask Invalid"]
            #[inline(always)]
            pub const fn mb25(&self) -> super::vals::MkivlrMb25 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::MkivlrMb25::from_bits(val as u8)
            }
            #[doc = "mailbox 25 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb25(&mut self, val: super::vals::MkivlrMb25) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "mailbox 26 Mask Invalid"]
            #[inline(always)]
            pub const fn mb26(&self) -> super::vals::MkivlrMb26 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::MkivlrMb26::from_bits(val as u8)
            }
            #[doc = "mailbox 26 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb26(&mut self, val: super::vals::MkivlrMb26) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "mailbox 27 Mask Invalid"]
            #[inline(always)]
            pub const fn mb27(&self) -> super::vals::MkivlrMb27 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::MkivlrMb27::from_bits(val as u8)
            }
            #[doc = "mailbox 27 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb27(&mut self, val: super::vals::MkivlrMb27) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "mailbox 28 Mask Invalid"]
            #[inline(always)]
            pub const fn mb28(&self) -> super::vals::MkivlrMb28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::MkivlrMb28::from_bits(val as u8)
            }
            #[doc = "mailbox 28 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb28(&mut self, val: super::vals::MkivlrMb28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "mailbox 29 Mask Invalid"]
            #[inline(always)]
            pub const fn mb29(&self) -> super::vals::MkivlrMb29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::MkivlrMb29::from_bits(val as u8)
            }
            #[doc = "mailbox 29 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb29(&mut self, val: super::vals::MkivlrMb29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "mailbox 30 Mask Invalid"]
            #[inline(always)]
            pub const fn mb30(&self) -> super::vals::MkivlrMb30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::MkivlrMb30::from_bits(val as u8)
            }
            #[doc = "mailbox 30 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb30(&mut self, val: super::vals::MkivlrMb30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "mailbox 31 Mask Invalid"]
            #[inline(always)]
            pub const fn mb31(&self) -> super::vals::MkivlrMb31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::MkivlrMb31::from_bits(val as u8)
            }
            #[doc = "mailbox 31 Mask Invalid"]
            #[inline(always)]
            pub fn set_mb31(&mut self, val: super::vals::MkivlrMb31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Mkivlr {
            #[inline(always)]
            fn default() -> Mkivlr {
                Mkivlr(0)
            }
        }
        impl core::fmt::Debug for Mkivlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mkivlr")
                    .field("mb0", &self.mb0())
                    .field("mb1", &self.mb1())
                    .field("mb2", &self.mb2())
                    .field("mb3", &self.mb3())
                    .field("mb4", &self.mb4())
                    .field("mb5", &self.mb5())
                    .field("mb6", &self.mb6())
                    .field("mb7", &self.mb7())
                    .field("mb8", &self.mb8())
                    .field("mb9", &self.mb9())
                    .field("mb10", &self.mb10())
                    .field("mb11", &self.mb11())
                    .field("mb12", &self.mb12())
                    .field("mb13", &self.mb13())
                    .field("mb14", &self.mb14())
                    .field("mb15", &self.mb15())
                    .field("mb16", &self.mb16())
                    .field("mb17", &self.mb17())
                    .field("mb18", &self.mb18())
                    .field("mb19", &self.mb19())
                    .field("mb20", &self.mb20())
                    .field("mb21", &self.mb21())
                    .field("mb22", &self.mb22())
                    .field("mb23", &self.mb23())
                    .field("mb24", &self.mb24())
                    .field("mb25", &self.mb25())
                    .field("mb26", &self.mb26())
                    .field("mb27", &self.mb27())
                    .field("mb28", &self.mb28())
                    .field("mb29", &self.mb29())
                    .field("mb30", &self.mb30())
                    .field("mb31", &self.mb31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mkivlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mkivlr {{ mb0: {:?}, mb1: {:?}, mb2: {:?}, mb3: {:?}, mb4: {:?}, mb5: {:?}, mb6: {:?}, mb7: {:?}, mb8: {:?}, mb9: {:?}, mb10: {:?}, mb11: {:?}, mb12: {:?}, mb13: {:?}, mb14: {:?}, mb15: {:?}, mb16: {:?}, mb17: {:?}, mb18: {:?}, mb19: {:?}, mb20: {:?}, mb21: {:?}, mb22: {:?}, mb23: {:?}, mb24: {:?}, mb25: {:?}, mb26: {:?}, mb27: {:?}, mb28: {:?}, mb29: {:?}, mb30: {:?}, mb31: {:?} }}" , self . mb0 () , self . mb1 () , self . mb2 () , self . mb3 () , self . mb4 () , self . mb5 () , self . mb6 () , self . mb7 () , self . mb8 () , self . mb9 () , self . mb10 () , self . mb11 () , self . mb12 () , self . mb13 () , self . mb14 () , self . mb15 () , self . mb16 () , self . mb17 () , self . mb18 () , self . mb19 () , self . mb20 () , self . mb21 () , self . mb22 () , self . mb23 () , self . mb24 () , self . mb25 () , self . mb26 () , self . mb27 () , self . mb28 () , self . mb29 () , self . mb30 () , self . mb31 ())
            }
        }
        #[doc = "Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mkr(pub u32);
        impl Mkr {
            #[doc = "Extended ID"]
            #[inline(always)]
            pub const fn eid(&self) -> super::vals::MkrEid {
                let val = (self.0 >> 0usize) & 0x0003_ffff;
                super::vals::MkrEid::from_bits(val as u32)
            }
            #[doc = "Extended ID"]
            #[inline(always)]
            pub fn set_eid(&mut self, val: super::vals::MkrEid) {
                self.0 = (self.0 & !(0x0003_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0x0003_ffff) << 0usize);
            }
            #[doc = "Standard ID"]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::MkrSid {
                let val = (self.0 >> 18usize) & 0x07ff;
                super::vals::MkrSid::from_bits(val as u16)
            }
            #[doc = "Standard ID"]
            #[inline(always)]
            pub fn set_sid(&mut self, val: super::vals::MkrSid) {
                self.0 = (self.0 & !(0x07ff << 18usize))
                    | (((val.to_bits() as u32) & 0x07ff) << 18usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_29_31(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_29_31(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
            }
        }
        impl Default for Mkr {
            #[inline(always)]
            fn default() -> Mkr {
                Mkr(0)
            }
        }
        impl core::fmt::Debug for Mkr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mkr")
                    .field("eid", &self.eid())
                    .field("sid", &self.sid())
                    .field("reserved_29_31", &self.reserved_29_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mkr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mkr {{ eid: {:?}, sid: {:?}, reserved_29_31: {=u8:?} }}",
                    self.eid(),
                    self.sid(),
                    self.reserved_29_31()
                )
            }
        }
        #[doc = "Mailbox Search Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msmr(pub u8);
        impl Msmr {
            #[doc = "Mailbox Search Mode Select"]
            #[inline(always)]
            pub const fn mbsm(&self) -> super::vals::Mbsm {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mbsm::from_bits(val as u8)
            }
            #[doc = "Mailbox Search Mode Select"]
            #[inline(always)]
            pub fn set_mbsm(&mut self, val: super::vals::Mbsm) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Msmr {
            #[inline(always)]
            fn default() -> Msmr {
                Msmr(0)
            }
        }
        impl core::fmt::Debug for Msmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msmr")
                    .field("mbsm", &self.mbsm())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msmr {{ mbsm: {:?}, reserved_2_7: {=u8:?} }}",
                    self.mbsm(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "Mailbox Search Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mssr(pub u8);
        impl Mssr {
            #[doc = "Search Result Mailbox Number Status These bits output the smallest mailbox number that is searched in each mode of MSMR."]
            #[inline(always)]
            pub const fn mbnst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Search Result Mailbox Number Status These bits output the smallest mailbox number that is searched in each mode of MSMR."]
            #[inline(always)]
            pub fn set_mbnst(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_5_6(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_5_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u8) & 0x03) << 5usize);
            }
            #[doc = "Search Result Status"]
            #[inline(always)]
            pub const fn sest(&self) -> super::vals::Sest {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sest::from_bits(val as u8)
            }
            #[doc = "Search Result Status"]
            #[inline(always)]
            pub fn set_sest(&mut self, val: super::vals::Sest) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Mssr {
            #[inline(always)]
            fn default() -> Mssr {
                Mssr(0)
            }
        }
        impl core::fmt::Debug for Mssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mssr")
                    .field("mbnst", &self.mbnst())
                    .field("reserved_5_6", &self.reserved_5_6())
                    .field("sest", &self.sest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mssr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mssr {{ mbnst: {=u8:?}, reserved_5_6: {=u8:?}, sest: {:?} }}",
                    self.mbnst(),
                    self.reserved_5_6(),
                    self.sest()
                )
            }
        }
        #[doc = "Receive Error Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Recr(pub u8);
        impl Recr {
            #[doc = "Receive error count functionRECR increments or decrements the counter value according to the error status of the CAN module during reception."]
            #[inline(always)]
            pub const fn recr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Receive error count functionRECR increments or decrements the counter value according to the error status of the CAN module during reception."]
            #[inline(always)]
            pub fn set_recr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Recr {
            #[inline(always)]
            fn default() -> Recr {
                Recr(0)
            }
        }
        impl core::fmt::Debug for Recr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Recr").field("recr", &self.recr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Recr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Recr {{ recr: {=u8:?} }}", self.recr())
            }
        }
        #[doc = "Receive FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rfcr(pub u8);
        impl Rfcr {
            #[doc = "Receive FIFO Enable"]
            #[inline(always)]
            pub const fn rfe(&self) -> super::vals::Rfe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rfe::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Enable"]
            #[inline(always)]
            pub fn set_rfe(&mut self, val: super::vals::Rfe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Receive FIFO Unread Message Number Status"]
            #[inline(always)]
            pub const fn rfust(&self) -> super::vals::Rfust {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Rfust::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Unread Message Number Status"]
            #[inline(always)]
            pub fn set_rfust(&mut self, val: super::vals::Rfust) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u8) & 0x07) << 1usize);
            }
            #[doc = "Receive FIFO Message Lost Flag"]
            #[inline(always)]
            pub const fn rfmlf(&self) -> super::vals::Rfmlf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rfmlf::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Message Lost Flag"]
            #[inline(always)]
            pub fn set_rfmlf(&mut self, val: super::vals::Rfmlf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Receive FIFO Full Status Flag"]
            #[inline(always)]
            pub const fn rffst(&self) -> super::vals::Rffst {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rffst::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Full Status Flag"]
            #[inline(always)]
            pub fn set_rffst(&mut self, val: super::vals::Rffst) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive FIFO Buffer Warning Status Flag"]
            #[inline(always)]
            pub const fn rfwst(&self) -> super::vals::Rfwst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Rfwst::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Buffer Warning Status Flag"]
            #[inline(always)]
            pub fn set_rfwst(&mut self, val: super::vals::Rfwst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Receive FIFO Empty Status Flag"]
            #[inline(always)]
            pub const fn rfest(&self) -> super::vals::Rfest {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rfest::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Empty Status Flag"]
            #[inline(always)]
            pub fn set_rfest(&mut self, val: super::vals::Rfest) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rfcr {
            #[inline(always)]
            fn default() -> Rfcr {
                Rfcr(0)
            }
        }
        impl core::fmt::Debug for Rfcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rfcr")
                    .field("rfe", &self.rfe())
                    .field("rfust", &self.rfust())
                    .field("rfmlf", &self.rfmlf())
                    .field("rffst", &self.rffst())
                    .field("rfwst", &self.rfwst())
                    .field("rfest", &self.rfest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rfcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rfcr {{ rfe: {:?}, rfust: {:?}, rfmlf: {:?}, rffst: {:?}, rfwst: {:?}, rfest: {:?} }}" , self . rfe () , self . rfust () , self . rfmlf () , self . rffst () , self . rfwst () , self . rfest ())
            }
        }
        #[doc = "Receive FIFO Pointer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rfpcr(pub u8);
        impl Rfpcr {
            #[doc = "The CPU,side pointer for the receive FIFO is incremented by writing FFh to RFPCR."]
            #[inline(always)]
            pub const fn rfpcr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The CPU,side pointer for the receive FIFO is incremented by writing FFh to RFPCR."]
            #[inline(always)]
            pub fn set_rfpcr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Rfpcr {
            #[inline(always)]
            fn default() -> Rfpcr {
                Rfpcr(0)
            }
        }
        impl core::fmt::Debug for Rfpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rfpcr")
                    .field("rfpcr", &self.rfpcr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rfpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rfpcr {{ rfpcr: {=u8:?} }}", self.rfpcr())
            }
        }
        #[doc = "Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Str(pub u16);
        impl Str {
            #[doc = "NEWDATA Status Flag"]
            #[inline(always)]
            pub const fn ndst(&self) -> super::vals::Ndst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ndst::from_bits(val as u8)
            }
            #[doc = "NEWDATA Status Flag"]
            #[inline(always)]
            pub fn set_ndst(&mut self, val: super::vals::Ndst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "SENTDATA Status Flag"]
            #[inline(always)]
            pub const fn sdst(&self) -> super::vals::Sdst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sdst::from_bits(val as u8)
            }
            #[doc = "SENTDATA Status Flag"]
            #[inline(always)]
            pub fn set_sdst(&mut self, val: super::vals::Sdst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Receive FIFO Status Flag"]
            #[inline(always)]
            pub const fn rfst(&self) -> super::vals::Rfst {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Rfst::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Status Flag"]
            #[inline(always)]
            pub fn set_rfst(&mut self, val: super::vals::Rfst) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Transmit FIFO Status Flag"]
            #[inline(always)]
            pub const fn tfst(&self) -> super::vals::Tfst {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tfst::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Status Flag"]
            #[inline(always)]
            pub fn set_tfst(&mut self, val: super::vals::Tfst) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Normal Mailbox Message Lost Status Flag"]
            #[inline(always)]
            pub const fn nmlst(&self) -> super::vals::Nmlst {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nmlst::from_bits(val as u8)
            }
            #[doc = "Normal Mailbox Message Lost Status Flag"]
            #[inline(always)]
            pub fn set_nmlst(&mut self, val: super::vals::Nmlst) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "FIFO Mailbox Message Lost Status Flag"]
            #[inline(always)]
            pub const fn fmlst(&self) -> super::vals::Fmlst {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Fmlst::from_bits(val as u8)
            }
            #[doc = "FIFO Mailbox Message Lost Status Flag"]
            #[inline(always)]
            pub fn set_fmlst(&mut self, val: super::vals::Fmlst) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Transmission Abort Status Flag"]
            #[inline(always)]
            pub const fn tabst(&self) -> super::vals::Tabst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tabst::from_bits(val as u8)
            }
            #[doc = "Transmission Abort Status Flag"]
            #[inline(always)]
            pub fn set_tabst(&mut self, val: super::vals::Tabst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Error Status Flag"]
            #[inline(always)]
            pub const fn est(&self) -> super::vals::Est {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Est::from_bits(val as u8)
            }
            #[doc = "Error Status Flag"]
            #[inline(always)]
            pub fn set_est(&mut self, val: super::vals::Est) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "CAN Reset Status Flag"]
            #[inline(always)]
            pub const fn rstst(&self) -> super::vals::Rstst {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rstst::from_bits(val as u8)
            }
            #[doc = "CAN Reset Status Flag"]
            #[inline(always)]
            pub fn set_rstst(&mut self, val: super::vals::Rstst) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "CAN Halt Status Flag"]
            #[inline(always)]
            pub const fn hltst(&self) -> super::vals::Hltst {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Hltst::from_bits(val as u8)
            }
            #[doc = "CAN Halt Status Flag"]
            #[inline(always)]
            pub fn set_hltst(&mut self, val: super::vals::Hltst) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "CAN Sleep Status Flag"]
            #[inline(always)]
            pub const fn slpst(&self) -> super::vals::Slpst {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Slpst::from_bits(val as u8)
            }
            #[doc = "CAN Sleep Status Flag"]
            #[inline(always)]
            pub fn set_slpst(&mut self, val: super::vals::Slpst) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Error,Passive Status Flag"]
            #[inline(always)]
            pub const fn epst(&self) -> super::vals::Epst {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Epst::from_bits(val as u8)
            }
            #[doc = "Error,Passive Status Flag"]
            #[inline(always)]
            pub fn set_epst(&mut self, val: super::vals::Epst) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Bus,Off Status Flag"]
            #[inline(always)]
            pub const fn bost(&self) -> super::vals::Bost {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Bost::from_bits(val as u8)
            }
            #[doc = "Bus,Off Status Flag"]
            #[inline(always)]
            pub fn set_bost(&mut self, val: super::vals::Bost) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Transmit Status Flag (transmitter)"]
            #[inline(always)]
            pub const fn trmst(&self) -> super::vals::Trmst {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Trmst::from_bits(val as u8)
            }
            #[doc = "Transmit Status Flag (transmitter)"]
            #[inline(always)]
            pub fn set_trmst(&mut self, val: super::vals::Trmst) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Receive Status Flag (receiver)"]
            #[inline(always)]
            pub const fn recst(&self) -> super::vals::Recst {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Recst::from_bits(val as u8)
            }
            #[doc = "Receive Status Flag (receiver)"]
            #[inline(always)]
            pub fn set_recst(&mut self, val: super::vals::Recst) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_15_15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_15_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Str {
            #[inline(always)]
            fn default() -> Str {
                Str(0)
            }
        }
        impl core::fmt::Debug for Str {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Str")
                    .field("ndst", &self.ndst())
                    .field("sdst", &self.sdst())
                    .field("rfst", &self.rfst())
                    .field("tfst", &self.tfst())
                    .field("nmlst", &self.nmlst())
                    .field("fmlst", &self.fmlst())
                    .field("tabst", &self.tabst())
                    .field("est", &self.est())
                    .field("rstst", &self.rstst())
                    .field("hltst", &self.hltst())
                    .field("slpst", &self.slpst())
                    .field("epst", &self.epst())
                    .field("bost", &self.bost())
                    .field("trmst", &self.trmst())
                    .field("recst", &self.recst())
                    .field("reserved_15_15", &self.reserved_15_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Str {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Str {{ ndst: {:?}, sdst: {:?}, rfst: {:?}, tfst: {:?}, nmlst: {:?}, fmlst: {:?}, tabst: {:?}, est: {:?}, rstst: {:?}, hltst: {:?}, slpst: {:?}, epst: {:?}, bost: {:?}, trmst: {:?}, recst: {:?}, reserved_15_15: {=bool:?} }}" , self . ndst () , self . sdst () , self . rfst () , self . tfst () , self . nmlst () , self . fmlst () , self . tabst () , self . est () , self . rstst () , self . hltst () , self . slpst () , self . epst () , self . bost () , self . trmst () , self . recst () , self . reserved_15_15 ())
            }
        }
        #[doc = "Test Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tcr(pub u8);
        impl Tcr {
            #[doc = "CAN Test Mode Enable"]
            #[inline(always)]
            pub const fn tste(&self) -> super::vals::Tste {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tste::from_bits(val as u8)
            }
            #[doc = "CAN Test Mode Enable"]
            #[inline(always)]
            pub fn set_tste(&mut self, val: super::vals::Tste) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "CAN Test Mode Select"]
            #[inline(always)]
            pub const fn tstm(&self) -> super::vals::Tstm {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Tstm::from_bits(val as u8)
            }
            #[doc = "CAN Test Mode Select"]
            #[inline(always)]
            pub fn set_tstm(&mut self, val: super::vals::Tstm) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u8) & 0x03) << 1usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Tcr {
            #[inline(always)]
            fn default() -> Tcr {
                Tcr(0)
            }
        }
        impl core::fmt::Debug for Tcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tcr")
                    .field("tste", &self.tste())
                    .field("tstm", &self.tstm())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tcr {{ tste: {:?}, tstm: {:?}, reserved_3_7: {=u8:?} }}",
                    self.tste(),
                    self.tstm(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "Transmit Error Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tecr(pub u8);
        impl Tecr {
            #[doc = "Transmit error count functionTECR increments or decrements the counter value according to the error status of the CAN module during transmission."]
            #[inline(always)]
            pub const fn tecr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Transmit error count functionTECR increments or decrements the counter value according to the error status of the CAN module during transmission."]
            #[inline(always)]
            pub fn set_tecr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Tecr {
            #[inline(always)]
            fn default() -> Tecr {
                Tecr(0)
            }
        }
        impl core::fmt::Debug for Tecr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tecr").field("tecr", &self.tecr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tecr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tecr {{ tecr: {=u8:?} }}", self.tecr())
            }
        }
        #[doc = "Transmit FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tfcr(pub u8);
        impl Tfcr {
            #[doc = "Transmit FIFO Enable"]
            #[inline(always)]
            pub const fn tfe(&self) -> super::vals::Tfe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tfe::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Enable"]
            #[inline(always)]
            pub fn set_tfe(&mut self, val: super::vals::Tfe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Transmit FIFO Unsent Message Number Status"]
            #[inline(always)]
            pub const fn tfust(&self) -> super::vals::Tfust {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Tfust::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Unsent Message Number Status"]
            #[inline(always)]
            pub fn set_tfust(&mut self, val: super::vals::Tfust) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u8) & 0x07) << 1usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_4_5(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_4_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "Transmit FIFO Full Status"]
            #[inline(always)]
            pub const fn tffst(&self) -> super::vals::Tffst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tffst::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Full Status"]
            #[inline(always)]
            pub fn set_tffst(&mut self, val: super::vals::Tffst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty Status"]
            #[inline(always)]
            pub const fn tfest(&self) -> super::vals::Tfest {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tfest::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Empty Status"]
            #[inline(always)]
            pub fn set_tfest(&mut self, val: super::vals::Tfest) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Tfcr {
            #[inline(always)]
            fn default() -> Tfcr {
                Tfcr(0)
            }
        }
        impl core::fmt::Debug for Tfcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tfcr")
                    .field("tfe", &self.tfe())
                    .field("tfust", &self.tfust())
                    .field("reserved_4_5", &self.reserved_4_5())
                    .field("tffst", &self.tffst())
                    .field("tfest", &self.tfest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tfcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tfcr {{ tfe: {:?}, tfust: {:?}, reserved_4_5: {=u8:?}, tffst: {:?}, tfest: {:?} }}" , self . tfe () , self . tfust () , self . reserved_4_5 () , self . tffst () , self . tfest ())
            }
        }
        #[doc = "Transmit FIFO Pointer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tfpcr(pub u8);
        impl Tfpcr {
            #[doc = "The CPU,side pointer for the transmit FIFO is incremented by writing FFh to TFPCR."]
            #[inline(always)]
            pub const fn tfpcr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The CPU,side pointer for the transmit FIFO is incremented by writing FFh to TFPCR."]
            #[inline(always)]
            pub fn set_tfpcr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Tfpcr {
            #[inline(always)]
            fn default() -> Tfpcr {
                Tfpcr(0)
            }
        }
        impl core::fmt::Debug for Tfpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tfpcr")
                    .field("tfpcr", &self.tfpcr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tfpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tfpcr {{ tfpcr: {=u8:?} }}", self.tfpcr())
            }
        }
        #[doc = "Time Stamp Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tsr(pub u16);
        impl Tsr {
            #[doc = "Free,running counter value for the time stamp function"]
            #[inline(always)]
            pub const fn tsr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Free,running counter value for the time stamp function"]
            #[inline(always)]
            pub fn set_tsr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Tsr {
            #[inline(always)]
            fn default() -> Tsr {
                Tsr(0)
            }
        }
        impl core::fmt::Debug for Tsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tsr").field("tsr", &self.tsr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tsr {{ tsr: {=u16:?} }}", self.tsr())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adef {
            #[inline(always)]
            fn from(val: u8) -> Adef {
                Adef::from_bits(val)
            }
        }
        impl From<Adef> for u8 {
            #[inline(always)]
            fn from(val: Adef) -> u8 {
                Adef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aef {
            #[inline(always)]
            fn from(val: u8) -> Aef {
                Aef::from_bits(val)
            }
        }
        impl From<Aef> for u8 {
            #[inline(always)]
            fn from(val: Aef) -> u8 {
                Aef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Be0f {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Be0f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Be0f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Be0f {
            #[inline(always)]
            fn from(val: u8) -> Be0f {
                Be0f::from_bits(val)
            }
        }
        impl From<Be0f> for u8 {
            #[inline(always)]
            fn from(val: Be0f) -> u8 {
                Be0f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Be1f {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Be1f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Be1f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Be1f {
            #[inline(always)]
            fn from(val: u8) -> Be1f {
                Be1f::from_bits(val)
            }
        }
        impl From<Be1f> for u8 {
            #[inline(always)]
            fn from(val: Be1f) -> u8 {
                Be1f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Beie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Beie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Beie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Beie {
            #[inline(always)]
            fn from(val: u8) -> Beie {
                Beie::from_bits(val)
            }
        }
        impl From<Beie> for u8 {
            #[inline(always)]
            fn from(val: Beie) -> u8 {
                Beie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Beif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Beif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Beif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Beif {
            #[inline(always)]
            fn from(val: u8) -> Beif {
                Beif::from_bits(val)
            }
        }
        impl From<Beif> for u8 {
            #[inline(always)]
            fn from(val: Beif) -> u8 {
                Beif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Blie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Blie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Blie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Blie {
            #[inline(always)]
            fn from(val: u8) -> Blie {
                Blie::from_bits(val)
            }
        }
        impl From<Blie> for u8 {
            #[inline(always)]
            fn from(val: Blie) -> u8 {
                Blie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Blif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Blif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Blif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Blif {
            #[inline(always)]
            fn from(val: u8) -> Blif {
                Blif::from_bits(val)
            }
        }
        impl From<Blif> for u8 {
            #[inline(always)]
            fn from(val: Blif) -> u8 {
                Blif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Boeie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Boeie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Boeie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Boeie {
            #[inline(always)]
            fn from(val: u8) -> Boeie {
                Boeie::from_bits(val)
            }
        }
        impl From<Boeie> for u8 {
            #[inline(always)]
            fn from(val: Boeie) -> u8 {
                Boeie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Boeif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Boeif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Boeif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Boeif {
            #[inline(always)]
            fn from(val: u8) -> Boeif {
                Boeif::from_bits(val)
            }
        }
        impl From<Boeif> for u8 {
            #[inline(always)]
            fn from(val: Boeif) -> u8 {
                Boeif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bom {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Bom {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bom {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bom {
            #[inline(always)]
            fn from(val: u8) -> Bom {
                Bom::from_bits(val)
            }
        }
        impl From<Bom> for u8 {
            #[inline(always)]
            fn from(val: Bom) -> u8 {
                Bom::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Borie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Borie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Borie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Borie {
            #[inline(always)]
            fn from(val: u8) -> Borie {
                Borie::from_bits(val)
            }
        }
        impl From<Borie> for u8 {
            #[inline(always)]
            fn from(val: Borie) -> u8 {
                Borie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Borif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Borif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Borif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Borif {
            #[inline(always)]
            fn from(val: u8) -> Borif {
                Borif::from_bits(val)
            }
        }
        impl From<Borif> for u8 {
            #[inline(always)]
            fn from(val: Borif) -> u8 {
                Borif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bost {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bost {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bost {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bost {
            #[inline(always)]
            fn from(val: u8) -> Bost {
                Bost::from_bits(val)
            }
        }
        impl From<Bost> for u8 {
            #[inline(always)]
            fn from(val: Bost) -> u8 {
                Bost::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Canm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Canm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Canm {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Canm {
            #[inline(always)]
            fn from(val: u8) -> Canm {
                Canm::from_bits(val)
            }
        }
        impl From<Canm> for u8 {
            #[inline(always)]
            fn from(val: Canm) -> u8 {
                Canm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclks {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclks {
            #[inline(always)]
            fn from(val: u8) -> Cclks {
                Cclks::from_bits(val)
            }
        }
        impl From<Cclks> for u8 {
            #[inline(always)]
            fn from(val: Cclks) -> u8 {
                Cclks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cef {
            #[inline(always)]
            fn from(val: u8) -> Cef {
                Cef::from_bits(val)
            }
        }
        impl From<Cef> for u8 {
            #[inline(always)]
            fn from(val: Cef) -> u8 {
                Cef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dlc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Dlc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dlc {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dlc {
            #[inline(always)]
            fn from(val: u8) -> Dlc {
                Dlc::from_bits(val)
            }
        }
        impl From<Dlc> for u8 {
            #[inline(always)]
            fn from(val: Dlc) -> u8 {
                Dlc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edpm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Edpm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edpm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edpm {
            #[inline(always)]
            fn from(val: u8) -> Edpm {
                Edpm::from_bits(val)
            }
        }
        impl From<Edpm> for u8 {
            #[inline(always)]
            fn from(val: Edpm) -> u8 {
                Edpm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Epie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Epie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Epie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Epie {
            #[inline(always)]
            fn from(val: u8) -> Epie {
                Epie::from_bits(val)
            }
        }
        impl From<Epie> for u8 {
            #[inline(always)]
            fn from(val: Epie) -> u8 {
                Epie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Epif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Epif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Epif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Epif {
            #[inline(always)]
            fn from(val: u8) -> Epif {
                Epif::from_bits(val)
            }
        }
        impl From<Epif> for u8 {
            #[inline(always)]
            fn from(val: Epif) -> u8 {
                Epif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Epst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Epst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Epst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Epst {
            #[inline(always)]
            fn from(val: u8) -> Epst {
                Epst::from_bits(val)
            }
        }
        impl From<Epst> for u8 {
            #[inline(always)]
            fn from(val: Epst) -> u8 {
                Epst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Est {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Est {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Est {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Est {
            #[inline(always)]
            fn from(val: u8) -> Est {
                Est::from_bits(val)
            }
        }
        impl From<Est> for u8 {
            #[inline(always)]
            fn from(val: Est) -> u8 {
                Est::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ewie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ewie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ewie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ewie {
            #[inline(always)]
            fn from(val: u8) -> Ewie {
                Ewie::from_bits(val)
            }
        }
        impl From<Ewie> for u8 {
            #[inline(always)]
            fn from(val: Ewie) -> u8 {
                Ewie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ewif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ewif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ewif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ewif {
            #[inline(always)]
            fn from(val: u8) -> Ewif {
                Ewif::from_bits(val)
            }
        }
        impl From<Ewif> for u8 {
            #[inline(always)]
            fn from(val: Ewif) -> u8 {
                Ewif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fef {
            #[inline(always)]
            fn from(val: u8) -> Fef {
                Fef::from_bits(val)
            }
        }
        impl From<Fef> for u8 {
            #[inline(always)]
            fn from(val: Fef) -> u8 {
                Fef::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct FidcrEid(u32);
        impl FidcrEid {}
        impl FidcrEid {
            pub const fn from_bits(val: u32) -> FidcrEid {
                Self(val & 0x0003_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for FidcrEid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FidcrEid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for FidcrEid {
            #[inline(always)]
            fn from(val: u32) -> FidcrEid {
                FidcrEid::from_bits(val)
            }
        }
        impl From<FidcrEid> for u32 {
            #[inline(always)]
            fn from(val: FidcrEid) -> u32 {
                FidcrEid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FidcrIde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FidcrIde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FidcrIde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FidcrIde {
            #[inline(always)]
            fn from(val: u8) -> FidcrIde {
                FidcrIde::from_bits(val)
            }
        }
        impl From<FidcrIde> for u8 {
            #[inline(always)]
            fn from(val: FidcrIde) -> u8 {
                FidcrIde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FidcrRtr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FidcrRtr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FidcrRtr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FidcrRtr {
            #[inline(always)]
            fn from(val: u8) -> FidcrRtr {
                FidcrRtr::from_bits(val)
            }
        }
        impl From<FidcrRtr> for u8 {
            #[inline(always)]
            fn from(val: FidcrRtr) -> u8 {
                FidcrRtr::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct FidcrSid(u16);
        impl FidcrSid {}
        impl FidcrSid {
            pub const fn from_bits(val: u16) -> FidcrSid {
                Self(val & 0x07ff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for FidcrSid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FidcrSid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for FidcrSid {
            #[inline(always)]
            fn from(val: u16) -> FidcrSid {
                FidcrSid::from_bits(val)
            }
        }
        impl From<FidcrSid> for u16 {
            #[inline(always)]
            fn from(val: FidcrSid) -> u16 {
                FidcrSid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fmlst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fmlst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fmlst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fmlst {
            #[inline(always)]
            fn from(val: u8) -> Fmlst {
                Fmlst::from_bits(val)
            }
        }
        impl From<Fmlst> for u8 {
            #[inline(always)]
            fn from(val: Fmlst) -> u8 {
                Fmlst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hltst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hltst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hltst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hltst {
            #[inline(always)]
            fn from(val: u8) -> Hltst {
                Hltst::from_bits(val)
            }
        }
        impl From<Hltst> for u8 {
            #[inline(always)]
            fn from(val: Hltst) -> u8 {
                Hltst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idfm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Idfm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idfm {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idfm {
            #[inline(always)]
            fn from(val: u8) -> Idfm {
                Idfm::from_bits(val)
            }
        }
        impl From<Idfm> for u8 {
            #[inline(always)]
            fn from(val: Idfm) -> u8 {
                Idfm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Invaldata {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Invaldata {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Invaldata {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Invaldata {
            #[inline(always)]
            fn from(val: u8) -> Invaldata {
                Invaldata::from_bits(val)
            }
        }
        impl From<Invaldata> for u8 {
            #[inline(always)]
            fn from(val: Invaldata) -> u8 {
                Invaldata::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MbIdEid(u32);
        impl MbIdEid {}
        impl MbIdEid {
            pub const fn from_bits(val: u32) -> MbIdEid {
                Self(val & 0x0003_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for MbIdEid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbIdEid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for MbIdEid {
            #[inline(always)]
            fn from(val: u32) -> MbIdEid {
                MbIdEid::from_bits(val)
            }
        }
        impl From<MbIdEid> for u32 {
            #[inline(always)]
            fn from(val: MbIdEid) -> u32 {
                MbIdEid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MbIdIde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MbIdIde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MbIdIde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MbIdIde {
            #[inline(always)]
            fn from(val: u8) -> MbIdIde {
                MbIdIde::from_bits(val)
            }
        }
        impl From<MbIdIde> for u8 {
            #[inline(always)]
            fn from(val: MbIdIde) -> u8 {
                MbIdIde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MbIdRtr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MbIdRtr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MbIdRtr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MbIdRtr {
            #[inline(always)]
            fn from(val: u8) -> MbIdRtr {
                MbIdRtr::from_bits(val)
            }
        }
        impl From<MbIdRtr> for u8 {
            #[inline(always)]
            fn from(val: MbIdRtr) -> u8 {
                MbIdRtr::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MbIdSid(u16);
        impl MbIdSid {}
        impl MbIdSid {
            pub const fn from_bits(val: u16) -> MbIdSid {
                Self(val & 0x07ff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for MbIdSid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbIdSid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for MbIdSid {
            #[inline(always)]
            fn from(val: u16) -> MbIdSid {
                MbIdSid::from_bits(val)
            }
        }
        impl From<MbIdSid> for u16 {
            #[inline(always)]
            fn from(val: MbIdSid) -> u16 {
                MbIdSid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mbm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mbm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mbm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mbm {
            #[inline(always)]
            fn from(val: u8) -> Mbm {
                Mbm::from_bits(val)
            }
        }
        impl From<Mbm> for u8 {
            #[inline(always)]
            fn from(val: Mbm) -> u8 {
                Mbm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mbsm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mbsm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mbsm {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mbsm {
            #[inline(always)]
            fn from(val: u8) -> Mbsm {
                Mbsm::from_bits(val)
            }
        }
        impl From<Mbsm> for u8 {
            #[inline(always)]
            fn from(val: Mbsm) -> u8 {
                Mbsm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MctlRxOneshot {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MctlRxOneshot {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MctlRxOneshot {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MctlRxOneshot {
            #[inline(always)]
            fn from(val: u8) -> MctlRxOneshot {
                MctlRxOneshot::from_bits(val)
            }
        }
        impl From<MctlRxOneshot> for u8 {
            #[inline(always)]
            fn from(val: MctlRxOneshot) -> u8 {
                MctlRxOneshot::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MctlRxRecreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MctlRxRecreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MctlRxRecreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MctlRxRecreq {
            #[inline(always)]
            fn from(val: u8) -> MctlRxRecreq {
                MctlRxRecreq::from_bits(val)
            }
        }
        impl From<MctlRxRecreq> for u8 {
            #[inline(always)]
            fn from(val: MctlRxRecreq) -> u8 {
                MctlRxRecreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MctlRxTrmreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MctlRxTrmreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MctlRxTrmreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MctlRxTrmreq {
            #[inline(always)]
            fn from(val: u8) -> MctlRxTrmreq {
                MctlRxTrmreq::from_bits(val)
            }
        }
        impl From<MctlRxTrmreq> for u8 {
            #[inline(always)]
            fn from(val: MctlRxTrmreq) -> u8 {
                MctlRxTrmreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MctlTxOneshot {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MctlTxOneshot {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MctlTxOneshot {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MctlTxOneshot {
            #[inline(always)]
            fn from(val: u8) -> MctlTxOneshot {
                MctlTxOneshot::from_bits(val)
            }
        }
        impl From<MctlTxOneshot> for u8 {
            #[inline(always)]
            fn from(val: MctlTxOneshot) -> u8 {
                MctlTxOneshot::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MctlTxRecreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MctlTxRecreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MctlTxRecreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MctlTxRecreq {
            #[inline(always)]
            fn from(val: u8) -> MctlTxRecreq {
                MctlTxRecreq::from_bits(val)
            }
        }
        impl From<MctlTxRecreq> for u8 {
            #[inline(always)]
            fn from(val: MctlTxRecreq) -> u8 {
                MctlTxRecreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MctlTxTrmreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MctlTxTrmreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MctlTxTrmreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MctlTxTrmreq {
            #[inline(always)]
            fn from(val: u8) -> MctlTxTrmreq {
                MctlTxTrmreq::from_bits(val)
            }
        }
        impl From<MctlTxTrmreq> for u8 {
            #[inline(always)]
            fn from(val: MctlTxTrmreq) -> u8 {
                MctlTxTrmreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb0 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb0 {
                MierFifoMb0::from_bits(val)
            }
        }
        impl From<MierFifoMb0> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb0) -> u8 {
                MierFifoMb0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb1 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb1 {
                MierFifoMb1::from_bits(val)
            }
        }
        impl From<MierFifoMb1> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb1) -> u8 {
                MierFifoMb1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb10 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb10 {
                MierFifoMb10::from_bits(val)
            }
        }
        impl From<MierFifoMb10> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb10) -> u8 {
                MierFifoMb10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb11 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb11 {
                MierFifoMb11::from_bits(val)
            }
        }
        impl From<MierFifoMb11> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb11) -> u8 {
                MierFifoMb11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb12 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb12 {
                MierFifoMb12::from_bits(val)
            }
        }
        impl From<MierFifoMb12> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb12) -> u8 {
                MierFifoMb12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb13 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb13 {
                MierFifoMb13::from_bits(val)
            }
        }
        impl From<MierFifoMb13> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb13) -> u8 {
                MierFifoMb13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb14 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb14 {
                MierFifoMb14::from_bits(val)
            }
        }
        impl From<MierFifoMb14> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb14) -> u8 {
                MierFifoMb14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb15 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb15 {
                MierFifoMb15::from_bits(val)
            }
        }
        impl From<MierFifoMb15> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb15) -> u8 {
                MierFifoMb15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb16 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb16 {
                MierFifoMb16::from_bits(val)
            }
        }
        impl From<MierFifoMb16> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb16) -> u8 {
                MierFifoMb16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb17 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb17 {
                MierFifoMb17::from_bits(val)
            }
        }
        impl From<MierFifoMb17> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb17) -> u8 {
                MierFifoMb17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb18 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb18 {
                MierFifoMb18::from_bits(val)
            }
        }
        impl From<MierFifoMb18> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb18) -> u8 {
                MierFifoMb18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb19 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb19 {
                MierFifoMb19::from_bits(val)
            }
        }
        impl From<MierFifoMb19> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb19) -> u8 {
                MierFifoMb19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb2 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb2 {
                MierFifoMb2::from_bits(val)
            }
        }
        impl From<MierFifoMb2> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb2) -> u8 {
                MierFifoMb2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb20 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb20 {
                MierFifoMb20::from_bits(val)
            }
        }
        impl From<MierFifoMb20> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb20) -> u8 {
                MierFifoMb20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb21 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb21 {
                MierFifoMb21::from_bits(val)
            }
        }
        impl From<MierFifoMb21> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb21) -> u8 {
                MierFifoMb21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb22 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb22 {
                MierFifoMb22::from_bits(val)
            }
        }
        impl From<MierFifoMb22> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb22) -> u8 {
                MierFifoMb22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb23 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb23 {
                MierFifoMb23::from_bits(val)
            }
        }
        impl From<MierFifoMb23> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb23) -> u8 {
                MierFifoMb23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb24 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb24 {
                MierFifoMb24::from_bits(val)
            }
        }
        impl From<MierFifoMb24> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb24) -> u8 {
                MierFifoMb24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb25 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb25 {
                MierFifoMb25::from_bits(val)
            }
        }
        impl From<MierFifoMb25> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb25) -> u8 {
                MierFifoMb25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb28 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb28 {
                MierFifoMb28::from_bits(val)
            }
        }
        impl From<MierFifoMb28> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb28) -> u8 {
                MierFifoMb28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb29 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb29 {
                MierFifoMb29::from_bits(val)
            }
        }
        impl From<MierFifoMb29> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb29) -> u8 {
                MierFifoMb29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb3 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb3 {
                MierFifoMb3::from_bits(val)
            }
        }
        impl From<MierFifoMb3> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb3) -> u8 {
                MierFifoMb3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb4 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb4 {
                MierFifoMb4::from_bits(val)
            }
        }
        impl From<MierFifoMb4> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb4) -> u8 {
                MierFifoMb4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb5 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb5 {
                MierFifoMb5::from_bits(val)
            }
        }
        impl From<MierFifoMb5> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb5) -> u8 {
                MierFifoMb5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb6 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb6 {
                MierFifoMb6::from_bits(val)
            }
        }
        impl From<MierFifoMb6> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb6) -> u8 {
                MierFifoMb6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb7 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb7 {
                MierFifoMb7::from_bits(val)
            }
        }
        impl From<MierFifoMb7> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb7) -> u8 {
                MierFifoMb7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb8 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb8 {
                MierFifoMb8::from_bits(val)
            }
        }
        impl From<MierFifoMb8> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb8) -> u8 {
                MierFifoMb8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierFifoMb9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierFifoMb9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierFifoMb9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierFifoMb9 {
            #[inline(always)]
            fn from(val: u8) -> MierFifoMb9 {
                MierFifoMb9::from_bits(val)
            }
        }
        impl From<MierFifoMb9> for u8 {
            #[inline(always)]
            fn from(val: MierFifoMb9) -> u8 {
                MierFifoMb9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb0 {
            #[inline(always)]
            fn from(val: u8) -> MierMb0 {
                MierMb0::from_bits(val)
            }
        }
        impl From<MierMb0> for u8 {
            #[inline(always)]
            fn from(val: MierMb0) -> u8 {
                MierMb0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb1 {
            #[inline(always)]
            fn from(val: u8) -> MierMb1 {
                MierMb1::from_bits(val)
            }
        }
        impl From<MierMb1> for u8 {
            #[inline(always)]
            fn from(val: MierMb1) -> u8 {
                MierMb1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb10 {
            #[inline(always)]
            fn from(val: u8) -> MierMb10 {
                MierMb10::from_bits(val)
            }
        }
        impl From<MierMb10> for u8 {
            #[inline(always)]
            fn from(val: MierMb10) -> u8 {
                MierMb10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb11 {
            #[inline(always)]
            fn from(val: u8) -> MierMb11 {
                MierMb11::from_bits(val)
            }
        }
        impl From<MierMb11> for u8 {
            #[inline(always)]
            fn from(val: MierMb11) -> u8 {
                MierMb11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb12 {
            #[inline(always)]
            fn from(val: u8) -> MierMb12 {
                MierMb12::from_bits(val)
            }
        }
        impl From<MierMb12> for u8 {
            #[inline(always)]
            fn from(val: MierMb12) -> u8 {
                MierMb12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb13 {
            #[inline(always)]
            fn from(val: u8) -> MierMb13 {
                MierMb13::from_bits(val)
            }
        }
        impl From<MierMb13> for u8 {
            #[inline(always)]
            fn from(val: MierMb13) -> u8 {
                MierMb13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb14 {
            #[inline(always)]
            fn from(val: u8) -> MierMb14 {
                MierMb14::from_bits(val)
            }
        }
        impl From<MierMb14> for u8 {
            #[inline(always)]
            fn from(val: MierMb14) -> u8 {
                MierMb14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb15 {
            #[inline(always)]
            fn from(val: u8) -> MierMb15 {
                MierMb15::from_bits(val)
            }
        }
        impl From<MierMb15> for u8 {
            #[inline(always)]
            fn from(val: MierMb15) -> u8 {
                MierMb15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb16 {
            #[inline(always)]
            fn from(val: u8) -> MierMb16 {
                MierMb16::from_bits(val)
            }
        }
        impl From<MierMb16> for u8 {
            #[inline(always)]
            fn from(val: MierMb16) -> u8 {
                MierMb16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb17 {
            #[inline(always)]
            fn from(val: u8) -> MierMb17 {
                MierMb17::from_bits(val)
            }
        }
        impl From<MierMb17> for u8 {
            #[inline(always)]
            fn from(val: MierMb17) -> u8 {
                MierMb17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb18 {
            #[inline(always)]
            fn from(val: u8) -> MierMb18 {
                MierMb18::from_bits(val)
            }
        }
        impl From<MierMb18> for u8 {
            #[inline(always)]
            fn from(val: MierMb18) -> u8 {
                MierMb18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb19 {
            #[inline(always)]
            fn from(val: u8) -> MierMb19 {
                MierMb19::from_bits(val)
            }
        }
        impl From<MierMb19> for u8 {
            #[inline(always)]
            fn from(val: MierMb19) -> u8 {
                MierMb19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb2 {
            #[inline(always)]
            fn from(val: u8) -> MierMb2 {
                MierMb2::from_bits(val)
            }
        }
        impl From<MierMb2> for u8 {
            #[inline(always)]
            fn from(val: MierMb2) -> u8 {
                MierMb2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb20 {
            #[inline(always)]
            fn from(val: u8) -> MierMb20 {
                MierMb20::from_bits(val)
            }
        }
        impl From<MierMb20> for u8 {
            #[inline(always)]
            fn from(val: MierMb20) -> u8 {
                MierMb20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb21 {
            #[inline(always)]
            fn from(val: u8) -> MierMb21 {
                MierMb21::from_bits(val)
            }
        }
        impl From<MierMb21> for u8 {
            #[inline(always)]
            fn from(val: MierMb21) -> u8 {
                MierMb21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb22 {
            #[inline(always)]
            fn from(val: u8) -> MierMb22 {
                MierMb22::from_bits(val)
            }
        }
        impl From<MierMb22> for u8 {
            #[inline(always)]
            fn from(val: MierMb22) -> u8 {
                MierMb22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb23 {
            #[inline(always)]
            fn from(val: u8) -> MierMb23 {
                MierMb23::from_bits(val)
            }
        }
        impl From<MierMb23> for u8 {
            #[inline(always)]
            fn from(val: MierMb23) -> u8 {
                MierMb23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb24 {
            #[inline(always)]
            fn from(val: u8) -> MierMb24 {
                MierMb24::from_bits(val)
            }
        }
        impl From<MierMb24> for u8 {
            #[inline(always)]
            fn from(val: MierMb24) -> u8 {
                MierMb24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb25 {
            #[inline(always)]
            fn from(val: u8) -> MierMb25 {
                MierMb25::from_bits(val)
            }
        }
        impl From<MierMb25> for u8 {
            #[inline(always)]
            fn from(val: MierMb25) -> u8 {
                MierMb25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb26 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb26 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb26 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb26 {
            #[inline(always)]
            fn from(val: u8) -> MierMb26 {
                MierMb26::from_bits(val)
            }
        }
        impl From<MierMb26> for u8 {
            #[inline(always)]
            fn from(val: MierMb26) -> u8 {
                MierMb26::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb27 {
            #[inline(always)]
            fn from(val: u8) -> MierMb27 {
                MierMb27::from_bits(val)
            }
        }
        impl From<MierMb27> for u8 {
            #[inline(always)]
            fn from(val: MierMb27) -> u8 {
                MierMb27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb28 {
            #[inline(always)]
            fn from(val: u8) -> MierMb28 {
                MierMb28::from_bits(val)
            }
        }
        impl From<MierMb28> for u8 {
            #[inline(always)]
            fn from(val: MierMb28) -> u8 {
                MierMb28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb29 {
            #[inline(always)]
            fn from(val: u8) -> MierMb29 {
                MierMb29::from_bits(val)
            }
        }
        impl From<MierMb29> for u8 {
            #[inline(always)]
            fn from(val: MierMb29) -> u8 {
                MierMb29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb3 {
            #[inline(always)]
            fn from(val: u8) -> MierMb3 {
                MierMb3::from_bits(val)
            }
        }
        impl From<MierMb3> for u8 {
            #[inline(always)]
            fn from(val: MierMb3) -> u8 {
                MierMb3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb30 {
            #[inline(always)]
            fn from(val: u8) -> MierMb30 {
                MierMb30::from_bits(val)
            }
        }
        impl From<MierMb30> for u8 {
            #[inline(always)]
            fn from(val: MierMb30) -> u8 {
                MierMb30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb31 {
            #[inline(always)]
            fn from(val: u8) -> MierMb31 {
                MierMb31::from_bits(val)
            }
        }
        impl From<MierMb31> for u8 {
            #[inline(always)]
            fn from(val: MierMb31) -> u8 {
                MierMb31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb4 {
            #[inline(always)]
            fn from(val: u8) -> MierMb4 {
                MierMb4::from_bits(val)
            }
        }
        impl From<MierMb4> for u8 {
            #[inline(always)]
            fn from(val: MierMb4) -> u8 {
                MierMb4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb5 {
            #[inline(always)]
            fn from(val: u8) -> MierMb5 {
                MierMb5::from_bits(val)
            }
        }
        impl From<MierMb5> for u8 {
            #[inline(always)]
            fn from(val: MierMb5) -> u8 {
                MierMb5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb6 {
            #[inline(always)]
            fn from(val: u8) -> MierMb6 {
                MierMb6::from_bits(val)
            }
        }
        impl From<MierMb6> for u8 {
            #[inline(always)]
            fn from(val: MierMb6) -> u8 {
                MierMb6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb7 {
            #[inline(always)]
            fn from(val: u8) -> MierMb7 {
                MierMb7::from_bits(val)
            }
        }
        impl From<MierMb7> for u8 {
            #[inline(always)]
            fn from(val: MierMb7) -> u8 {
                MierMb7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb8 {
            #[inline(always)]
            fn from(val: u8) -> MierMb8 {
                MierMb8::from_bits(val)
            }
        }
        impl From<MierMb8> for u8 {
            #[inline(always)]
            fn from(val: MierMb8) -> u8 {
                MierMb8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MierMb9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MierMb9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MierMb9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MierMb9 {
            #[inline(always)]
            fn from(val: u8) -> MierMb9 {
                MierMb9::from_bits(val)
            }
        }
        impl From<MierMb9> for u8 {
            #[inline(always)]
            fn from(val: MierMb9) -> u8 {
                MierMb9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb0 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb0 {
                MkivlrMb0::from_bits(val)
            }
        }
        impl From<MkivlrMb0> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb0) -> u8 {
                MkivlrMb0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb1 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb1 {
                MkivlrMb1::from_bits(val)
            }
        }
        impl From<MkivlrMb1> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb1) -> u8 {
                MkivlrMb1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb10 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb10 {
                MkivlrMb10::from_bits(val)
            }
        }
        impl From<MkivlrMb10> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb10) -> u8 {
                MkivlrMb10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb11 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb11 {
                MkivlrMb11::from_bits(val)
            }
        }
        impl From<MkivlrMb11> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb11) -> u8 {
                MkivlrMb11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb12 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb12 {
                MkivlrMb12::from_bits(val)
            }
        }
        impl From<MkivlrMb12> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb12) -> u8 {
                MkivlrMb12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb13 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb13 {
                MkivlrMb13::from_bits(val)
            }
        }
        impl From<MkivlrMb13> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb13) -> u8 {
                MkivlrMb13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb14 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb14 {
                MkivlrMb14::from_bits(val)
            }
        }
        impl From<MkivlrMb14> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb14) -> u8 {
                MkivlrMb14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb15 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb15 {
                MkivlrMb15::from_bits(val)
            }
        }
        impl From<MkivlrMb15> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb15) -> u8 {
                MkivlrMb15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb16 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb16 {
                MkivlrMb16::from_bits(val)
            }
        }
        impl From<MkivlrMb16> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb16) -> u8 {
                MkivlrMb16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb17 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb17 {
                MkivlrMb17::from_bits(val)
            }
        }
        impl From<MkivlrMb17> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb17) -> u8 {
                MkivlrMb17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb18 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb18 {
                MkivlrMb18::from_bits(val)
            }
        }
        impl From<MkivlrMb18> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb18) -> u8 {
                MkivlrMb18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb19 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb19 {
                MkivlrMb19::from_bits(val)
            }
        }
        impl From<MkivlrMb19> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb19) -> u8 {
                MkivlrMb19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb2 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb2 {
                MkivlrMb2::from_bits(val)
            }
        }
        impl From<MkivlrMb2> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb2) -> u8 {
                MkivlrMb2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb20 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb20 {
                MkivlrMb20::from_bits(val)
            }
        }
        impl From<MkivlrMb20> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb20) -> u8 {
                MkivlrMb20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb21 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb21 {
                MkivlrMb21::from_bits(val)
            }
        }
        impl From<MkivlrMb21> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb21) -> u8 {
                MkivlrMb21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb22 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb22 {
                MkivlrMb22::from_bits(val)
            }
        }
        impl From<MkivlrMb22> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb22) -> u8 {
                MkivlrMb22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb23 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb23 {
                MkivlrMb23::from_bits(val)
            }
        }
        impl From<MkivlrMb23> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb23) -> u8 {
                MkivlrMb23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb24 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb24 {
                MkivlrMb24::from_bits(val)
            }
        }
        impl From<MkivlrMb24> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb24) -> u8 {
                MkivlrMb24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb25 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb25 {
                MkivlrMb25::from_bits(val)
            }
        }
        impl From<MkivlrMb25> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb25) -> u8 {
                MkivlrMb25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb26 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb26 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb26 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb26 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb26 {
                MkivlrMb26::from_bits(val)
            }
        }
        impl From<MkivlrMb26> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb26) -> u8 {
                MkivlrMb26::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb27 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb27 {
                MkivlrMb27::from_bits(val)
            }
        }
        impl From<MkivlrMb27> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb27) -> u8 {
                MkivlrMb27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb28 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb28 {
                MkivlrMb28::from_bits(val)
            }
        }
        impl From<MkivlrMb28> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb28) -> u8 {
                MkivlrMb28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb29 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb29 {
                MkivlrMb29::from_bits(val)
            }
        }
        impl From<MkivlrMb29> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb29) -> u8 {
                MkivlrMb29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb3 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb3 {
                MkivlrMb3::from_bits(val)
            }
        }
        impl From<MkivlrMb3> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb3) -> u8 {
                MkivlrMb3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb30 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb30 {
                MkivlrMb30::from_bits(val)
            }
        }
        impl From<MkivlrMb30> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb30) -> u8 {
                MkivlrMb30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb31 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb31 {
                MkivlrMb31::from_bits(val)
            }
        }
        impl From<MkivlrMb31> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb31) -> u8 {
                MkivlrMb31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb4 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb4 {
                MkivlrMb4::from_bits(val)
            }
        }
        impl From<MkivlrMb4> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb4) -> u8 {
                MkivlrMb4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb5 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb5 {
                MkivlrMb5::from_bits(val)
            }
        }
        impl From<MkivlrMb5> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb5) -> u8 {
                MkivlrMb5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb6 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb6 {
                MkivlrMb6::from_bits(val)
            }
        }
        impl From<MkivlrMb6> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb6) -> u8 {
                MkivlrMb6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb7 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb7 {
                MkivlrMb7::from_bits(val)
            }
        }
        impl From<MkivlrMb7> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb7) -> u8 {
                MkivlrMb7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb8 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb8 {
                MkivlrMb8::from_bits(val)
            }
        }
        impl From<MkivlrMb8> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb8) -> u8 {
                MkivlrMb8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MkivlrMb9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MkivlrMb9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MkivlrMb9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MkivlrMb9 {
            #[inline(always)]
            fn from(val: u8) -> MkivlrMb9 {
                MkivlrMb9::from_bits(val)
            }
        }
        impl From<MkivlrMb9> for u8 {
            #[inline(always)]
            fn from(val: MkivlrMb9) -> u8 {
                MkivlrMb9::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MkrEid(u32);
        impl MkrEid {}
        impl MkrEid {
            pub const fn from_bits(val: u32) -> MkrEid {
                Self(val & 0x0003_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for MkrEid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MkrEid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for MkrEid {
            #[inline(always)]
            fn from(val: u32) -> MkrEid {
                MkrEid::from_bits(val)
            }
        }
        impl From<MkrEid> for u32 {
            #[inline(always)]
            fn from(val: MkrEid) -> u32 {
                MkrEid::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MkrSid(u16);
        impl MkrSid {}
        impl MkrSid {
            pub const fn from_bits(val: u16) -> MkrSid {
                Self(val & 0x07ff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for MkrSid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MkrSid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for MkrSid {
            #[inline(always)]
            fn from(val: u16) -> MkrSid {
                MkrSid::from_bits(val)
            }
        }
        impl From<MkrSid> for u16 {
            #[inline(always)]
            fn from(val: MkrSid) -> u16 {
                MkrSid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mlm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mlm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mlm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mlm {
            #[inline(always)]
            fn from(val: u8) -> Mlm {
                Mlm::from_bits(val)
            }
        }
        impl From<Mlm> for u8 {
            #[inline(always)]
            fn from(val: Mlm) -> u8 {
                Mlm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Msglost {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Msglost {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Msglost {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Msglost {
            #[inline(always)]
            fn from(val: u8) -> Msglost {
                Msglost::from_bits(val)
            }
        }
        impl From<Msglost> for u8 {
            #[inline(always)]
            fn from(val: Msglost) -> u8 {
                Msglost::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ndst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ndst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ndst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ndst {
            #[inline(always)]
            fn from(val: u8) -> Ndst {
                Ndst::from_bits(val)
            }
        }
        impl From<Ndst> for u8 {
            #[inline(always)]
            fn from(val: Ndst) -> u8 {
                Ndst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Newdata {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Newdata {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Newdata {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Newdata {
            #[inline(always)]
            fn from(val: u8) -> Newdata {
                Newdata::from_bits(val)
            }
        }
        impl From<Newdata> for u8 {
            #[inline(always)]
            fn from(val: Newdata) -> u8 {
                Newdata::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmlst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmlst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmlst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmlst {
            #[inline(always)]
            fn from(val: u8) -> Nmlst {
                Nmlst::from_bits(val)
            }
        }
        impl From<Nmlst> for u8 {
            #[inline(always)]
            fn from(val: Nmlst) -> u8 {
                Nmlst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Olie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Olie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Olie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Olie {
            #[inline(always)]
            fn from(val: u8) -> Olie {
                Olie::from_bits(val)
            }
        }
        impl From<Olie> for u8 {
            #[inline(always)]
            fn from(val: Olie) -> u8 {
                Olie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Olif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Olif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Olif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Olif {
            #[inline(always)]
            fn from(val: u8) -> Olif {
                Olif::from_bits(val)
            }
        }
        impl From<Olif> for u8 {
            #[inline(always)]
            fn from(val: Olif) -> u8 {
                Olif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Orie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Orie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Orie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Orie {
            #[inline(always)]
            fn from(val: u8) -> Orie {
                Orie::from_bits(val)
            }
        }
        impl From<Orie> for u8 {
            #[inline(always)]
            fn from(val: Orie) -> u8 {
                Orie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Orif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Orif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Orif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Orif {
            #[inline(always)]
            fn from(val: u8) -> Orif {
                Orif::from_bits(val)
            }
        }
        impl From<Orif> for u8 {
            #[inline(always)]
            fn from(val: Orif) -> u8 {
                Orif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rboc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rboc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rboc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rboc {
            #[inline(always)]
            fn from(val: u8) -> Rboc {
                Rboc::from_bits(val)
            }
        }
        impl From<Rboc> for u8 {
            #[inline(always)]
            fn from(val: Rboc) -> u8 {
                Rboc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Recst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Recst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Recst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Recst {
            #[inline(always)]
            fn from(val: u8) -> Recst {
                Recst::from_bits(val)
            }
        }
        impl From<Recst> for u8 {
            #[inline(always)]
            fn from(val: Recst) -> u8 {
                Recst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rfe {
            #[inline(always)]
            fn from(val: u8) -> Rfe {
                Rfe::from_bits(val)
            }
        }
        impl From<Rfe> for u8 {
            #[inline(always)]
            fn from(val: Rfe) -> u8 {
                Rfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rfest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rfest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rfest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rfest {
            #[inline(always)]
            fn from(val: u8) -> Rfest {
                Rfest::from_bits(val)
            }
        }
        impl From<Rfest> for u8 {
            #[inline(always)]
            fn from(val: Rfest) -> u8 {
                Rfest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rffst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rffst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rffst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rffst {
            #[inline(always)]
            fn from(val: u8) -> Rffst {
                Rffst::from_bits(val)
            }
        }
        impl From<Rffst> for u8 {
            #[inline(always)]
            fn from(val: Rffst) -> u8 {
                Rffst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rfmlf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rfmlf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rfmlf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rfmlf {
            #[inline(always)]
            fn from(val: u8) -> Rfmlf {
                Rfmlf::from_bits(val)
            }
        }
        impl From<Rfmlf> for u8 {
            #[inline(always)]
            fn from(val: Rfmlf) -> u8 {
                Rfmlf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rfst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rfst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rfst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rfst {
            #[inline(always)]
            fn from(val: u8) -> Rfst {
                Rfst::from_bits(val)
            }
        }
        impl From<Rfst> for u8 {
            #[inline(always)]
            fn from(val: Rfst) -> u8 {
                Rfst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rfust {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rfust {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rfust {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rfust {
            #[inline(always)]
            fn from(val: u8) -> Rfust {
                Rfust::from_bits(val)
            }
        }
        impl From<Rfust> for u8 {
            #[inline(always)]
            fn from(val: Rfust) -> u8 {
                Rfust::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rfwst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rfwst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rfwst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rfwst {
            #[inline(always)]
            fn from(val: u8) -> Rfwst {
                Rfwst::from_bits(val)
            }
        }
        impl From<Rfwst> for u8 {
            #[inline(always)]
            fn from(val: Rfwst) -> u8 {
                Rfwst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rstst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rstst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rstst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rstst {
            #[inline(always)]
            fn from(val: u8) -> Rstst {
                Rstst::from_bits(val)
            }
        }
        impl From<Rstst> for u8 {
            #[inline(always)]
            fn from(val: Rstst) -> u8 {
                Rstst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdst {
            #[inline(always)]
            fn from(val: u8) -> Sdst {
                Sdst::from_bits(val)
            }
        }
        impl From<Sdst> for u8 {
            #[inline(always)]
            fn from(val: Sdst) -> u8 {
                Sdst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sef {
            #[inline(always)]
            fn from(val: u8) -> Sef {
                Sef::from_bits(val)
            }
        }
        impl From<Sef> for u8 {
            #[inline(always)]
            fn from(val: Sef) -> u8 {
                Sef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sentdata {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sentdata {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sentdata {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sentdata {
            #[inline(always)]
            fn from(val: u8) -> Sentdata {
                Sentdata::from_bits(val)
            }
        }
        impl From<Sentdata> for u8 {
            #[inline(always)]
            fn from(val: Sentdata) -> u8 {
                Sentdata::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sest {
            #[inline(always)]
            fn from(val: u8) -> Sest {
                Sest::from_bits(val)
            }
        }
        impl From<Sest> for u8 {
            #[inline(always)]
            fn from(val: Sest) -> u8 {
                Sest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sjw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sjw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sjw {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sjw {
            #[inline(always)]
            fn from(val: u8) -> Sjw {
                Sjw::from_bits(val)
            }
        }
        impl From<Sjw> for u8 {
            #[inline(always)]
            fn from(val: Sjw) -> u8 {
                Sjw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slpm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Slpm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slpm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slpm {
            #[inline(always)]
            fn from(val: u8) -> Slpm {
                Slpm::from_bits(val)
            }
        }
        impl From<Slpm> for u8 {
            #[inline(always)]
            fn from(val: Slpm) -> u8 {
                Slpm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slpst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Slpst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slpst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slpst {
            #[inline(always)]
            fn from(val: u8) -> Slpst {
                Slpst::from_bits(val)
            }
        }
        impl From<Slpst> for u8 {
            #[inline(always)]
            fn from(val: Slpst) -> u8 {
                Slpst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tabst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tabst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tabst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tabst {
            #[inline(always)]
            fn from(val: u8) -> Tabst {
                Tabst::from_bits(val)
            }
        }
        impl From<Tabst> for u8 {
            #[inline(always)]
            fn from(val: Tabst) -> u8 {
                Tabst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tfe {
            #[inline(always)]
            fn from(val: u8) -> Tfe {
                Tfe::from_bits(val)
            }
        }
        impl From<Tfe> for u8 {
            #[inline(always)]
            fn from(val: Tfe) -> u8 {
                Tfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tfest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tfest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tfest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tfest {
            #[inline(always)]
            fn from(val: u8) -> Tfest {
                Tfest::from_bits(val)
            }
        }
        impl From<Tfest> for u8 {
            #[inline(always)]
            fn from(val: Tfest) -> u8 {
                Tfest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tffst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tffst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tffst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tffst {
            #[inline(always)]
            fn from(val: u8) -> Tffst {
                Tffst::from_bits(val)
            }
        }
        impl From<Tffst> for u8 {
            #[inline(always)]
            fn from(val: Tffst) -> u8 {
                Tffst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tfst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tfst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tfst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tfst {
            #[inline(always)]
            fn from(val: u8) -> Tfst {
                Tfst::from_bits(val)
            }
        }
        impl From<Tfst> for u8 {
            #[inline(always)]
            fn from(val: Tfst) -> u8 {
                Tfst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tfust {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tfust {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tfust {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tfust {
            #[inline(always)]
            fn from(val: u8) -> Tfust {
                Tfust::from_bits(val)
            }
        }
        impl From<Tfust> for u8 {
            #[inline(always)]
            fn from(val: Tfust) -> u8 {
                Tfust::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tpm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tpm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tpm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tpm {
            #[inline(always)]
            fn from(val: u8) -> Tpm {
                Tpm::from_bits(val)
            }
        }
        impl From<Tpm> for u8 {
            #[inline(always)]
            fn from(val: Tpm) -> u8 {
                Tpm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trmabt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trmabt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trmabt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trmabt {
            #[inline(always)]
            fn from(val: u8) -> Trmabt {
                Trmabt::from_bits(val)
            }
        }
        impl From<Trmabt> for u8 {
            #[inline(always)]
            fn from(val: Trmabt) -> u8 {
                Trmabt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trmactive {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trmactive {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trmactive {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trmactive {
            #[inline(always)]
            fn from(val: u8) -> Trmactive {
                Trmactive::from_bits(val)
            }
        }
        impl From<Trmactive> for u8 {
            #[inline(always)]
            fn from(val: Trmactive) -> u8 {
                Trmactive::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trmst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trmst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trmst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trmst {
            #[inline(always)]
            fn from(val: u8) -> Trmst {
                Trmst::from_bits(val)
            }
        }
        impl From<Trmst> for u8 {
            #[inline(always)]
            fn from(val: Trmst) -> u8 {
                Trmst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tseg1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Tseg1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tseg1 {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tseg1 {
            #[inline(always)]
            fn from(val: u8) -> Tseg1 {
                Tseg1::from_bits(val)
            }
        }
        impl From<Tseg1> for u8 {
            #[inline(always)]
            fn from(val: Tseg1) -> u8 {
                Tseg1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tseg2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tseg2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tseg2 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tseg2 {
            #[inline(always)]
            fn from(val: u8) -> Tseg2 {
                Tseg2::from_bits(val)
            }
        }
        impl From<Tseg2> for u8 {
            #[inline(always)]
            fn from(val: Tseg2) -> u8 {
                Tseg2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tsps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsps {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsps {
            #[inline(always)]
            fn from(val: u8) -> Tsps {
                Tsps::from_bits(val)
            }
        }
        impl From<Tsps> for u8 {
            #[inline(always)]
            fn from(val: Tsps) -> u8 {
                Tsps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsrc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tsrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsrc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsrc {
            #[inline(always)]
            fn from(val: u8) -> Tsrc {
                Tsrc::from_bits(val)
            }
        }
        impl From<Tsrc> for u8 {
            #[inline(always)]
            fn from(val: Tsrc) -> u8 {
                Tsrc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tste {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tste {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tste {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tste {
            #[inline(always)]
            fn from(val: u8) -> Tste {
                Tste::from_bits(val)
            }
        }
        impl From<Tste> for u8 {
            #[inline(always)]
            fn from(val: Tste) -> u8 {
                Tste::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tstm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstm {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstm {
            #[inline(always)]
            fn from(val: u8) -> Tstm {
                Tstm::from_bits(val)
            }
        }
        impl From<Tstm> for u8 {
            #[inline(always)]
            fn from(val: Tstm) -> u8 {
                Tstm::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = Default::default();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = self.read();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
}
pub mod crc {
    #[doc = "CRC Calculator"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Crc {
        ptr: *mut u8,
    }
    unsafe impl Send for Crc {}
    unsafe impl Sync for Crc {}
    impl Crc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CRC Control Register0"]
        #[inline(always)]
        pub const fn crccr0(self) -> crate::common::Reg<regs::Crccr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CRC Control Register1"]
        #[inline(always)]
        pub const fn crccr1(self) -> crate::common::Reg<regs::Crccr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "CRC Data Input Register"]
        #[inline(always)]
        pub const fn crcdir(self) -> crate::common::Reg<regs::Crcdir, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CRC Data Input Register (byte access)"]
        #[inline(always)]
        pub const fn crcdir_by(self) -> crate::common::Reg<regs::CrcdirBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CRC Data Output Register"]
        #[inline(always)]
        pub const fn crcdor(self) -> crate::common::Reg<regs::Crcdor, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CRC Data Output Register(byte access)"]
        #[inline(always)]
        pub const fn crcdor_by(self) -> crate::common::Reg<regs::CrcdorBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CRC Data Output Register (halfword access)"]
        #[inline(always)]
        pub const fn crcdor_ha(self) -> crate::common::Reg<regs::CrcdorHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Snoop Address Register"]
        #[inline(always)]
        pub const fn crcsar(self) -> crate::common::Reg<regs::Crcsar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CRC Control Register0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccr0(pub u8);
        impl Crccr0 {
            #[doc = "CRC Generating Polynomial Switching"]
            #[inline(always)]
            pub const fn gps(&self) -> super::vals::Gps {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Gps::from_bits(val as u8)
            }
            #[doc = "CRC Generating Polynomial Switching"]
            #[inline(always)]
            pub fn set_gps(&mut self, val: super::vals::Gps) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_3_5(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_3_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 3usize)) | (((val as u8) & 0x07) << 3usize);
            }
            #[doc = "CRC Calculation Switching"]
            #[inline(always)]
            pub const fn lms(&self) -> super::vals::Lms {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lms::from_bits(val as u8)
            }
            #[doc = "CRC Calculation Switching"]
            #[inline(always)]
            pub fn set_lms(&mut self, val: super::vals::Lms) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "CRCDOR Register Clear"]
            #[inline(always)]
            pub const fn dorclr(&self) -> super::vals::Dorclr {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dorclr::from_bits(val as u8)
            }
            #[doc = "CRCDOR Register Clear"]
            #[inline(always)]
            pub fn set_dorclr(&mut self, val: super::vals::Dorclr) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Crccr0 {
            #[inline(always)]
            fn default() -> Crccr0 {
                Crccr0(0)
            }
        }
        impl core::fmt::Debug for Crccr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccr0")
                    .field("gps", &self.gps())
                    .field("reserved_3_5", &self.reserved_3_5())
                    .field("lms", &self.lms())
                    .field("dorclr", &self.dorclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crccr0 {{ gps: {:?}, reserved_3_5: {=u8:?}, lms: {:?}, dorclr: {:?} }}",
                    self.gps(),
                    self.reserved_3_5(),
                    self.lms(),
                    self.dorclr()
                )
            }
        }
        #[doc = "CRC Control Register1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccr1(pub u8);
        impl Crccr1 {
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_0_5(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_0_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "Snoop,on,write/read switch bit"]
            #[inline(always)]
            pub const fn crcswr(&self) -> super::vals::Crcswr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Crcswr::from_bits(val as u8)
            }
            #[doc = "Snoop,on,write/read switch bit"]
            #[inline(always)]
            pub fn set_crcswr(&mut self, val: super::vals::Crcswr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Snoop enable bit"]
            #[inline(always)]
            pub const fn crcsen(&self) -> super::vals::Crcsen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Crcsen::from_bits(val as u8)
            }
            #[doc = "Snoop enable bit"]
            #[inline(always)]
            pub fn set_crcsen(&mut self, val: super::vals::Crcsen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Crccr1 {
            #[inline(always)]
            fn default() -> Crccr1 {
                Crccr1(0)
            }
        }
        impl core::fmt::Debug for Crccr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccr1")
                    .field("reserved_0_5", &self.reserved_0_5())
                    .field("crcswr", &self.crcswr())
                    .field("crcsen", &self.crcsen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crccr1 {{ reserved_0_5: {=u8:?}, crcswr: {:?}, crcsen: {:?} }}",
                    self.reserved_0_5(),
                    self.crcswr(),
                    self.crcsen()
                )
            }
        }
        #[doc = "CRC Data Input Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcdir(pub u32);
        impl Crcdir {
            #[doc = "Calculation input Data (Case of CRC-32, CRC-32C )"]
            #[inline(always)]
            pub const fn crcdir(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Calculation input Data (Case of CRC-32, CRC-32C )"]
            #[inline(always)]
            pub fn set_crcdir(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Crcdir {
            #[inline(always)]
            fn default() -> Crcdir {
                Crcdir(0)
            }
        }
        impl core::fmt::Debug for Crcdir {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcdir")
                    .field("crcdir", &self.crcdir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcdir {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcdir {{ crcdir: {=u32:?} }}", self.crcdir())
            }
        }
        #[doc = "CRC Data Input Register (byte access)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcdirBy(pub u8);
        impl CrcdirBy {
            #[doc = "Calculation input Data ( Case of CRC-8, CRC-16 or CRC,CCITT )"]
            #[inline(always)]
            pub const fn crcdir_by(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Calculation input Data ( Case of CRC-8, CRC-16 or CRC,CCITT )"]
            #[inline(always)]
            pub fn set_crcdir_by(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for CrcdirBy {
            #[inline(always)]
            fn default() -> CrcdirBy {
                CrcdirBy(0)
            }
        }
        impl core::fmt::Debug for CrcdirBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcdirBy")
                    .field("crcdir_by", &self.crcdir_by())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcdirBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CrcdirBy {{ crcdir_by: {=u8:?} }}", self.crcdir_by())
            }
        }
        #[doc = "CRC Data Output Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcdor(pub u32);
        impl Crcdor {
            #[doc = "Calculation output Data (Case of CRC-32, CRC-32C )"]
            #[inline(always)]
            pub const fn crcdor(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Calculation output Data (Case of CRC-32, CRC-32C )"]
            #[inline(always)]
            pub fn set_crcdor(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Crcdor {
            #[inline(always)]
            fn default() -> Crcdor {
                Crcdor(0)
            }
        }
        impl core::fmt::Debug for Crcdor {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcdor")
                    .field("crcdor", &self.crcdor())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcdor {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcdor {{ crcdor: {=u32:?} }}", self.crcdor())
            }
        }
        #[doc = "CRC Data Output Register(byte access)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcdorBy(pub u8);
        impl CrcdorBy {
            #[doc = "Calculation output Data (Case of CRC-8 )"]
            #[inline(always)]
            pub const fn crcdor_by(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Calculation output Data (Case of CRC-8 )"]
            #[inline(always)]
            pub fn set_crcdor_by(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for CrcdorBy {
            #[inline(always)]
            fn default() -> CrcdorBy {
                CrcdorBy(0)
            }
        }
        impl core::fmt::Debug for CrcdorBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcdorBy")
                    .field("crcdor_by", &self.crcdor_by())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcdorBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CrcdorBy {{ crcdor_by: {=u8:?} }}", self.crcdor_by())
            }
        }
        #[doc = "CRC Data Output Register (halfword access)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcdorHa(pub u16);
        impl CrcdorHa {
            #[doc = "Calculation output Data (Case of CRC-16 or CRC,CCITT )"]
            #[inline(always)]
            pub const fn crcdor_ha(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Calculation output Data (Case of CRC-16 or CRC,CCITT )"]
            #[inline(always)]
            pub fn set_crcdor_ha(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for CrcdorHa {
            #[inline(always)]
            fn default() -> CrcdorHa {
                CrcdorHa(0)
            }
        }
        impl core::fmt::Debug for CrcdorHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcdorHa")
                    .field("crcdor_ha", &self.crcdor_ha())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcdorHa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CrcdorHa {{ crcdor_ha: {=u16:?} }}", self.crcdor_ha())
            }
        }
        #[doc = "Snoop Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcsar(pub u16);
        impl Crcsar {
            #[doc = "snoop address bitSet the I/O register address to snoop"]
            #[inline(always)]
            pub const fn crcsa(&self) -> super::vals::Crcsa {
                let val = (self.0 >> 0usize) & 0x3fff;
                super::vals::Crcsa::from_bits(val as u16)
            }
            #[doc = "snoop address bitSet the I/O register address to snoop"]
            #[inline(always)]
            pub fn set_crcsa(&mut self, val: super::vals::Crcsa) {
                self.0 =
                    (self.0 & !(0x3fff << 0usize)) | (((val.to_bits() as u16) & 0x3fff) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_14_15(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_14_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 14usize)) | (((val as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Crcsar {
            #[inline(always)]
            fn default() -> Crcsar {
                Crcsar(0)
            }
        }
        impl core::fmt::Debug for Crcsar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcsar")
                    .field("crcsa", &self.crcsa())
                    .field("reserved_14_15", &self.reserved_14_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcsar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crcsar {{ crcsa: {:?}, reserved_14_15: {=u8:?} }}",
                    self.crcsa(),
                    self.reserved_14_15()
                )
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Crcsa(u16);
        impl Crcsa {}
        impl Crcsa {
            pub const fn from_bits(val: u16) -> Crcsa {
                Self(val & 0x3fff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Crcsa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcsa {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Crcsa {
            #[inline(always)]
            fn from(val: u16) -> Crcsa {
                Crcsa::from_bits(val)
            }
        }
        impl From<Crcsa> for u16 {
            #[inline(always)]
            fn from(val: Crcsa) -> u16 {
                Crcsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcsen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Crcsen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcsen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcsen {
            #[inline(always)]
            fn from(val: u8) -> Crcsen {
                Crcsen::from_bits(val)
            }
        }
        impl From<Crcsen> for u8 {
            #[inline(always)]
            fn from(val: Crcsen) -> u8 {
                Crcsen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcswr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Crcswr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcswr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcswr {
            #[inline(always)]
            fn from(val: u8) -> Crcswr {
                Crcswr::from_bits(val)
            }
        }
        impl From<Crcswr> for u8 {
            #[inline(always)]
            fn from(val: Crcswr) -> u8 {
                Crcswr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dorclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dorclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dorclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dorclr {
            #[inline(always)]
            fn from(val: u8) -> Dorclr {
                Dorclr::from_bits(val)
            }
        }
        impl From<Dorclr> for u8 {
            #[inline(always)]
            fn from(val: Dorclr) -> u8 {
                Dorclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gps {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gps {
            #[inline(always)]
            fn from(val: u8) -> Gps {
                Gps::from_bits(val)
            }
        }
        impl From<Gps> for u8 {
            #[inline(always)]
            fn from(val: Gps) -> u8 {
                Gps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lms {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lms {
            #[inline(always)]
            fn from(val: u8) -> Lms {
                Lms::from_bits(val)
            }
        }
        impl From<Lms> for u8 {
            #[inline(always)]
            fn from(val: Lms) -> u8 {
                Lms::to_bits(val)
            }
        }
    }
}
pub mod ctsu {
    #[doc = "Capacitive Touch Sensing Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctsu {
        ptr: *mut u8,
    }
    unsafe impl Send for Ctsu {}
    unsafe impl Sync for Ctsu {}
    impl Ctsu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CTSU Control Register 0"]
        #[inline(always)]
        pub const fn ctsucr0(self) -> crate::common::Reg<regs::Ctsucr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CTSU Control Register 1"]
        #[inline(always)]
        pub const fn ctsucr1(self) -> crate::common::Reg<regs::Ctsucr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "CTSU Synchronous Noise Reduction Setting Register"]
        #[inline(always)]
        pub const fn ctsusdprs(self) -> crate::common::Reg<regs::Ctsusdprs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "CTSU Sensor Stabilization Wait Control Register"]
        #[inline(always)]
        pub const fn ctsusst(self) -> crate::common::Reg<regs::Ctsusst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "CTSU Measurement Channel Register 0"]
        #[inline(always)]
        pub const fn ctsumch0(self) -> crate::common::Reg<regs::Ctsumch0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CTSU Measurement Channel Register 1"]
        #[inline(always)]
        pub const fn ctsumch1(self) -> crate::common::Reg<regs::Ctsumch1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "CTSU Channel Enable Control Register 0"]
        #[inline(always)]
        pub const fn ctsuchac0(self) -> crate::common::Reg<regs::Ctsuchac0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "CTSU Channel Enable Control Register 1"]
        #[inline(always)]
        pub const fn ctsuchac1(self) -> crate::common::Reg<regs::Ctsuchac1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "CTSU Channel Enable Control Register 2"]
        #[inline(always)]
        pub const fn ctsuchac2(self) -> crate::common::Reg<regs::Ctsuchac2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CTSU Channel Enable Control Register 3"]
        #[inline(always)]
        pub const fn ctsuchac3(self) -> crate::common::Reg<regs::Ctsuchac3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "CTSU Channel Transmit/Receive Control Register 0"]
        #[inline(always)]
        pub const fn ctsuchtrc0(self) -> crate::common::Reg<regs::Ctsuchtrc0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "CTSU Channel Transmit/Receive Control Register 1"]
        #[inline(always)]
        pub const fn ctsuchtrc1(self) -> crate::common::Reg<regs::Ctsuchtrc1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "CTSU Channel Transmit/Receive Control Register 2"]
        #[inline(always)]
        pub const fn ctsuchtrc2(self) -> crate::common::Reg<regs::Ctsuchtrc2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "CTSU Channel Transmit/Receive Control Register 3"]
        #[inline(always)]
        pub const fn ctsuchtrc3(self) -> crate::common::Reg<regs::Ctsuchtrc3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "CTSU High,Pass Noise Reduction Control Register"]
        #[inline(always)]
        pub const fn ctsudclkc(self) -> crate::common::Reg<regs::Ctsudclkc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "CTSU Status Register"]
        #[inline(always)]
        pub const fn ctsust(self) -> crate::common::Reg<regs::Ctsust, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
        #[doc = "CTSU High,Pass Noise Reduction Spectrum Diffusion Control Register"]
        #[inline(always)]
        pub const fn ctsussc(self) -> crate::common::Reg<regs::Ctsussc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "CTSU Sensor Offset Register 0"]
        #[inline(always)]
        pub const fn ctsuso0(self) -> crate::common::Reg<regs::Ctsuso0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "CTSU Sensor Offset Register 1"]
        #[inline(always)]
        pub const fn ctsuso1(self) -> crate::common::Reg<regs::Ctsuso1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "CTSU Sensor Counter"]
        #[inline(always)]
        pub const fn ctsusc(self) -> crate::common::Reg<regs::Ctsusc, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "CTSU Reference Counter"]
        #[inline(always)]
        pub const fn ctsurc(self) -> crate::common::Reg<regs::Ctsurc, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "CTSU Error Status Register"]
        #[inline(always)]
        pub const fn ctsuerrs(self) -> crate::common::Reg<regs::Ctsuerrs, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CTSU Channel Enable Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuchac0(pub u8);
        impl Ctsuchac0 {
            #[doc = "CTSU Channel Enable Control 0.0: Not measurement target1: Measurement targetNote: CTSUCHAC0\\[0\\] corresponds to TS00 and CTSUCHAC0\\[7\\] corresponds to TS07."]
            #[inline(always)]
            pub const fn ctsuchac0(&self) -> super::vals::Ctsuchac0 {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Ctsuchac0::from_bits(val as u8)
            }
            #[doc = "CTSU Channel Enable Control 0.0: Not measurement target1: Measurement targetNote: CTSUCHAC0\\[0\\] corresponds to TS00 and CTSUCHAC0\\[7\\] corresponds to TS07."]
            #[inline(always)]
            pub fn set_ctsuchac0(&mut self, val: super::vals::Ctsuchac0) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ctsuchac0 {
            #[inline(always)]
            fn default() -> Ctsuchac0 {
                Ctsuchac0(0)
            }
        }
        impl core::fmt::Debug for Ctsuchac0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuchac0")
                    .field("ctsuchac0", &self.ctsuchac0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchac0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsuchac0 {{ ctsuchac0: {:?} }}", self.ctsuchac0())
            }
        }
        #[doc = "CTSU Channel Enable Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuchac1(pub u8);
        impl Ctsuchac1 {
            #[doc = "CTSU Channel Enable Control 1.0: Not measurement target1: Measurement targetNote: CTSUCHAC1\\[0\\] corresponds to TS08 and CTSUCHAC1\\[7\\] corresponds to TS15."]
            #[inline(always)]
            pub const fn ctsuchac1(&self) -> super::vals::Ctsuchac1 {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Ctsuchac1::from_bits(val as u8)
            }
            #[doc = "CTSU Channel Enable Control 1.0: Not measurement target1: Measurement targetNote: CTSUCHAC1\\[0\\] corresponds to TS08 and CTSUCHAC1\\[7\\] corresponds to TS15."]
            #[inline(always)]
            pub fn set_ctsuchac1(&mut self, val: super::vals::Ctsuchac1) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ctsuchac1 {
            #[inline(always)]
            fn default() -> Ctsuchac1 {
                Ctsuchac1(0)
            }
        }
        impl core::fmt::Debug for Ctsuchac1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuchac1")
                    .field("ctsuchac1", &self.ctsuchac1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchac1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsuchac1 {{ ctsuchac1: {:?} }}", self.ctsuchac1())
            }
        }
        #[doc = "CTSU Channel Enable Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuchac2(pub u8);
        impl Ctsuchac2 {
            #[doc = "CTSU Channel Enable Control 2.0: Not measurement target1: Measurement targetNote: CTSUCHAC2\\[0\\] corresponds to TS16 and CTSUCHAC2\\[7\\] corresponds to TS23."]
            #[inline(always)]
            pub const fn ctsuchac2(&self) -> super::vals::Ctsuchac2 {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Ctsuchac2::from_bits(val as u8)
            }
            #[doc = "CTSU Channel Enable Control 2.0: Not measurement target1: Measurement targetNote: CTSUCHAC2\\[0\\] corresponds to TS16 and CTSUCHAC2\\[7\\] corresponds to TS23."]
            #[inline(always)]
            pub fn set_ctsuchac2(&mut self, val: super::vals::Ctsuchac2) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ctsuchac2 {
            #[inline(always)]
            fn default() -> Ctsuchac2 {
                Ctsuchac2(0)
            }
        }
        impl core::fmt::Debug for Ctsuchac2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuchac2")
                    .field("ctsuchac2", &self.ctsuchac2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchac2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsuchac2 {{ ctsuchac2: {:?} }}", self.ctsuchac2())
            }
        }
        #[doc = "CTSU Channel Enable Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuchac3(pub u8);
        impl Ctsuchac3 {
            #[doc = "CTSU Channel Enable Control 3.0: Not measurement target1: Measurement targetNote: CTSUCHAC3\\[0\\] corresponds to TS24 and CTSUCHAC3\\[3\\] corresponds to TS27."]
            #[inline(always)]
            pub const fn ctsuchac3(&self) -> super::vals::Ctsuchac3 {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Ctsuchac3::from_bits(val as u8)
            }
            #[doc = "CTSU Channel Enable Control 3.0: Not measurement target1: Measurement targetNote: CTSUCHAC3\\[0\\] corresponds to TS24 and CTSUCHAC3\\[3\\] corresponds to TS27."]
            #[inline(always)]
            pub fn set_ctsuchac3(&mut self, val: super::vals::Ctsuchac3) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ctsuchac3 {
            #[inline(always)]
            fn default() -> Ctsuchac3 {
                Ctsuchac3(0)
            }
        }
        impl core::fmt::Debug for Ctsuchac3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuchac3")
                    .field("ctsuchac3", &self.ctsuchac3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchac3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsuchac3 {{ ctsuchac3: {:?} }}", self.ctsuchac3())
            }
        }
        #[doc = "CTSU Channel Transmit/Receive Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuchtrc0(pub u8);
        impl Ctsuchtrc0 {
            #[doc = "CTSU Channel Transmit/Receive Control 0"]
            #[inline(always)]
            pub const fn ctsuchtrc0(&self) -> super::vals::Ctsuchtrc0 {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Ctsuchtrc0::from_bits(val as u8)
            }
            #[doc = "CTSU Channel Transmit/Receive Control 0"]
            #[inline(always)]
            pub fn set_ctsuchtrc0(&mut self, val: super::vals::Ctsuchtrc0) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ctsuchtrc0 {
            #[inline(always)]
            fn default() -> Ctsuchtrc0 {
                Ctsuchtrc0(0)
            }
        }
        impl core::fmt::Debug for Ctsuchtrc0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuchtrc0")
                    .field("ctsuchtrc0", &self.ctsuchtrc0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchtrc0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsuchtrc0 {{ ctsuchtrc0: {:?} }}", self.ctsuchtrc0())
            }
        }
        #[doc = "CTSU Channel Transmit/Receive Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuchtrc1(pub u8);
        impl Ctsuchtrc1 {
            #[doc = "CTSU Channel Transmit/Receive Control 1"]
            #[inline(always)]
            pub const fn ctsuchtrc1(&self) -> super::vals::Ctsuchtrc1 {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Ctsuchtrc1::from_bits(val as u8)
            }
            #[doc = "CTSU Channel Transmit/Receive Control 1"]
            #[inline(always)]
            pub fn set_ctsuchtrc1(&mut self, val: super::vals::Ctsuchtrc1) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ctsuchtrc1 {
            #[inline(always)]
            fn default() -> Ctsuchtrc1 {
                Ctsuchtrc1(0)
            }
        }
        impl core::fmt::Debug for Ctsuchtrc1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuchtrc1")
                    .field("ctsuchtrc1", &self.ctsuchtrc1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchtrc1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsuchtrc1 {{ ctsuchtrc1: {:?} }}", self.ctsuchtrc1())
            }
        }
        #[doc = "CTSU Channel Transmit/Receive Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuchtrc2(pub u8);
        impl Ctsuchtrc2 {
            #[doc = "CTSU Channel Transmit/Receive Control 2"]
            #[inline(always)]
            pub const fn ctsuchrc2(&self) -> super::vals::Ctsuchrc2 {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Ctsuchrc2::from_bits(val as u8)
            }
            #[doc = "CTSU Channel Transmit/Receive Control 2"]
            #[inline(always)]
            pub fn set_ctsuchrc2(&mut self, val: super::vals::Ctsuchrc2) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ctsuchtrc2 {
            #[inline(always)]
            fn default() -> Ctsuchtrc2 {
                Ctsuchtrc2(0)
            }
        }
        impl core::fmt::Debug for Ctsuchtrc2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuchtrc2")
                    .field("ctsuchrc2", &self.ctsuchrc2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchtrc2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsuchtrc2 {{ ctsuchrc2: {:?} }}", self.ctsuchrc2())
            }
        }
        #[doc = "CTSU Channel Transmit/Receive Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuchtrc3(pub u8);
        impl Ctsuchtrc3 {
            #[doc = "CTSU Channel Transmit/Receive Control 3"]
            #[inline(always)]
            pub const fn ctsuchrc3(&self) -> super::vals::Ctsuchrc3 {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Ctsuchrc3::from_bits(val as u8)
            }
            #[doc = "CTSU Channel Transmit/Receive Control 3"]
            #[inline(always)]
            pub fn set_ctsuchrc3(&mut self, val: super::vals::Ctsuchrc3) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ctsuchtrc3 {
            #[inline(always)]
            fn default() -> Ctsuchtrc3 {
                Ctsuchtrc3(0)
            }
        }
        impl core::fmt::Debug for Ctsuchtrc3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuchtrc3")
                    .field("ctsuchrc3", &self.ctsuchrc3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchtrc3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsuchtrc3 {{ ctsuchrc3: {:?} }}", self.ctsuchrc3())
            }
        }
        #[doc = "CTSU Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsucr0(pub u8);
        impl Ctsucr0 {
            #[doc = "CTSU Measurement Operation Start"]
            #[inline(always)]
            pub const fn ctsustrt(&self) -> super::vals::Ctsustrt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ctsustrt::from_bits(val as u8)
            }
            #[doc = "CTSU Measurement Operation Start"]
            #[inline(always)]
            pub fn set_ctsustrt(&mut self, val: super::vals::Ctsustrt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "CTSU Measurement Operation Start Trigger Select"]
            #[inline(always)]
            pub const fn ctsucap(&self) -> super::vals::Ctsucap {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ctsucap::from_bits(val as u8)
            }
            #[doc = "CTSU Measurement Operation Start Trigger Select"]
            #[inline(always)]
            pub fn set_ctsucap(&mut self, val: super::vals::Ctsucap) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "CTSU Wait State Power,Saving Enable"]
            #[inline(always)]
            pub const fn ctsusnz(&self) -> super::vals::Ctsusnz {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ctsusnz::from_bits(val as u8)
            }
            #[doc = "CTSU Wait State Power,Saving Enable"]
            #[inline(always)]
            pub fn set_ctsusnz(&mut self, val: super::vals::Ctsusnz) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "CTSU Control Block Initialization"]
            #[inline(always)]
            pub const fn ctsuinit(&self) -> super::vals::Ctsuinit {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ctsuinit::from_bits(val as u8)
            }
            #[doc = "CTSU Control Block Initialization"]
            #[inline(always)]
            pub fn set_ctsuinit(&mut self, val: super::vals::Ctsuinit) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Ctsucr0 {
            #[inline(always)]
            fn default() -> Ctsucr0 {
                Ctsucr0(0)
            }
        }
        impl core::fmt::Debug for Ctsucr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsucr0")
                    .field("ctsustrt", &self.ctsustrt())
                    .field("ctsucap", &self.ctsucap())
                    .field("ctsusnz", &self.ctsusnz())
                    .field("ctsuinit", &self.ctsuinit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsucr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctsucr0 {{ ctsustrt: {:?}, ctsucap: {:?}, ctsusnz: {:?}, ctsuinit: {:?} }}",
                    self.ctsustrt(),
                    self.ctsucap(),
                    self.ctsusnz(),
                    self.ctsuinit()
                )
            }
        }
        #[doc = "CTSU Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsucr1(pub u8);
        impl Ctsucr1 {
            #[doc = "CTSU Power Supply Enable"]
            #[inline(always)]
            pub const fn ctsupon(&self) -> super::vals::Ctsupon {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ctsupon::from_bits(val as u8)
            }
            #[doc = "CTSU Power Supply Enable"]
            #[inline(always)]
            pub fn set_ctsupon(&mut self, val: super::vals::Ctsupon) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "CTSU LPF Capacitance Charging Control"]
            #[inline(always)]
            pub const fn ctsucsw(&self) -> super::vals::Ctsucsw {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ctsucsw::from_bits(val as u8)
            }
            #[doc = "CTSU LPF Capacitance Charging Control"]
            #[inline(always)]
            pub fn set_ctsucsw(&mut self, val: super::vals::Ctsucsw) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "CTSU Power Supply Operating Mode Setting"]
            #[inline(always)]
            pub const fn ctsuatune0(&self) -> super::vals::Ctsuatune0 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ctsuatune0::from_bits(val as u8)
            }
            #[doc = "CTSU Power Supply Operating Mode Setting"]
            #[inline(always)]
            pub fn set_ctsuatune0(&mut self, val: super::vals::Ctsuatune0) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "CTSU Power Supply Capacity Adjustment"]
            #[inline(always)]
            pub const fn ctsuatune1(&self) -> super::vals::Ctsuatune1 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ctsuatune1::from_bits(val as u8)
            }
            #[doc = "CTSU Power Supply Capacity Adjustment"]
            #[inline(always)]
            pub fn set_ctsuatune1(&mut self, val: super::vals::Ctsuatune1) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "CTSU Operating Clock Select"]
            #[inline(always)]
            pub const fn ctsuclk(&self) -> super::vals::Ctsuclk {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Ctsuclk::from_bits(val as u8)
            }
            #[doc = "CTSU Operating Clock Select"]
            #[inline(always)]
            pub fn set_ctsuclk(&mut self, val: super::vals::Ctsuclk) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "CTSU Measurement Mode Select"]
            #[inline(always)]
            pub const fn ctsumd(&self) -> super::vals::Ctsumd {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Ctsumd::from_bits(val as u8)
            }
            #[doc = "CTSU Measurement Mode Select"]
            #[inline(always)]
            pub fn set_ctsumd(&mut self, val: super::vals::Ctsumd) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Ctsucr1 {
            #[inline(always)]
            fn default() -> Ctsucr1 {
                Ctsucr1(0)
            }
        }
        impl core::fmt::Debug for Ctsucr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsucr1")
                    .field("ctsupon", &self.ctsupon())
                    .field("ctsucsw", &self.ctsucsw())
                    .field("ctsuatune0", &self.ctsuatune0())
                    .field("ctsuatune1", &self.ctsuatune1())
                    .field("ctsuclk", &self.ctsuclk())
                    .field("ctsumd", &self.ctsumd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsucr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctsucr1 {{ ctsupon: {:?}, ctsucsw: {:?}, ctsuatune0: {:?}, ctsuatune1: {:?}, ctsuclk: {:?}, ctsumd: {:?} }}" , self . ctsupon () , self . ctsucsw () , self . ctsuatune0 () , self . ctsuatune1 () , self . ctsuclk () , self . ctsumd ())
            }
        }
        #[doc = "CTSU High,Pass Noise Reduction Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsudclkc(pub u8);
        impl Ctsudclkc {
            #[doc = "CTSU Diffusion Clock Mode SelectNOTE: This bit should be set to 00b."]
            #[inline(always)]
            pub const fn ctsussmod(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "CTSU Diffusion Clock Mode SelectNOTE: This bit should be set to 00b."]
            #[inline(always)]
            pub fn set_ctsussmod(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_2_3(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_2_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "CTSU Diffusion Clock Mode ControlNOTE: This bit should be set to 11b."]
            #[inline(always)]
            pub const fn ctsusscnt(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "CTSU Diffusion Clock Mode ControlNOTE: This bit should be set to 11b."]
            #[inline(always)]
            pub fn set_ctsusscnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Ctsudclkc {
            #[inline(always)]
            fn default() -> Ctsudclkc {
                Ctsudclkc(0)
            }
        }
        impl core::fmt::Debug for Ctsudclkc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsudclkc")
                    .field("ctsussmod", &self.ctsussmod())
                    .field("reserved_2_3", &self.reserved_2_3())
                    .field("ctsusscnt", &self.ctsusscnt())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsudclkc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctsudclkc {{ ctsussmod: {=u8:?}, reserved_2_3: {=u8:?}, ctsusscnt: {=u8:?}, reserved_6_7: {=u8:?} }}" , self . ctsussmod () , self . reserved_2_3 () , self . ctsusscnt () , self . reserved_6_7 ())
            }
        }
        #[doc = "CTSU Error Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuerrs(pub u16);
        impl Ctsuerrs {
            #[doc = "These bits are read as 000000000000000."]
            #[inline(always)]
            pub const fn reserved_0_14(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_0_14(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u16) & 0x7fff) << 0usize);
            }
            #[doc = "TSCAP Voltage Error Monitor"]
            #[inline(always)]
            pub const fn ctsuicomp(&self) -> super::vals::Ctsuicomp {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ctsuicomp::from_bits(val as u8)
            }
            #[doc = "TSCAP Voltage Error Monitor"]
            #[inline(always)]
            pub fn set_ctsuicomp(&mut self, val: super::vals::Ctsuicomp) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Ctsuerrs {
            #[inline(always)]
            fn default() -> Ctsuerrs {
                Ctsuerrs(0)
            }
        }
        impl core::fmt::Debug for Ctsuerrs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuerrs")
                    .field("reserved_0_14", &self.reserved_0_14())
                    .field("ctsuicomp", &self.ctsuicomp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuerrs {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctsuerrs {{ reserved_0_14: {=u16:?}, ctsuicomp: {:?} }}",
                    self.reserved_0_14(),
                    self.ctsuicomp()
                )
            }
        }
        #[doc = "CTSU Measurement Channel Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsumch0(pub u8);
        impl Ctsumch0 {
            #[doc = "CTSU Measurement Channel 0.Note1: Writing to these bits is enabled only in self,capacitance single scan mode (CTSUCR1.CTSUMD\\[1:0\\] bits = 00b).Note2: If the value of CTSUMCH0 was set to b'111111 in mode other than self,capacitor single scan mode, the measurement is stopped."]
            #[inline(always)]
            pub const fn ctsumch0(&self) -> super::vals::Ctsumch0 {
                let val = (self.0 >> 0usize) & 0x3f;
                super::vals::Ctsumch0::from_bits(val as u8)
            }
            #[doc = "CTSU Measurement Channel 0.Note1: Writing to these bits is enabled only in self,capacitance single scan mode (CTSUCR1.CTSUMD\\[1:0\\] bits = 00b).Note2: If the value of CTSUMCH0 was set to b'111111 in mode other than self,capacitor single scan mode, the measurement is stopped."]
            #[inline(always)]
            pub fn set_ctsumch0(&mut self, val: super::vals::Ctsumch0) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val.to_bits() as u8) & 0x3f) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Ctsumch0 {
            #[inline(always)]
            fn default() -> Ctsumch0 {
                Ctsumch0(0)
            }
        }
        impl core::fmt::Debug for Ctsumch0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsumch0")
                    .field("ctsumch0", &self.ctsumch0())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsumch0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctsumch0 {{ ctsumch0: {:?}, reserved_6_7: {=u8:?} }}",
                    self.ctsumch0(),
                    self.reserved_6_7()
                )
            }
        }
        #[doc = "CTSU Measurement Channel Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsumch1(pub u8);
        impl Ctsumch1 {
            #[doc = "CTSU Measurement Channel 1Note1: If the value of CTSUMCH1 was set to b'111111, the measurement is stopped."]
            #[inline(always)]
            pub const fn ctsumch1(&self) -> super::vals::Ctsumch1 {
                let val = (self.0 >> 0usize) & 0x3f;
                super::vals::Ctsumch1::from_bits(val as u8)
            }
            #[doc = "CTSU Measurement Channel 1Note1: If the value of CTSUMCH1 was set to b'111111, the measurement is stopped."]
            #[inline(always)]
            pub fn set_ctsumch1(&mut self, val: super::vals::Ctsumch1) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val.to_bits() as u8) & 0x3f) << 0usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Ctsumch1 {
            #[inline(always)]
            fn default() -> Ctsumch1 {
                Ctsumch1(0)
            }
        }
        impl core::fmt::Debug for Ctsumch1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsumch1")
                    .field("ctsumch1", &self.ctsumch1())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsumch1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctsumch1 {{ ctsumch1: {:?}, reserved_6_7: {=u8:?} }}",
                    self.ctsumch1(),
                    self.reserved_6_7()
                )
            }
        }
        #[doc = "CTSU Reference Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsurc(pub u16);
        impl Ctsurc {
            #[doc = "CTSU Reference Counter"]
            #[inline(always)]
            pub const fn ctsurc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "CTSU Reference Counter"]
            #[inline(always)]
            pub fn set_ctsurc(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ctsurc {
            #[inline(always)]
            fn default() -> Ctsurc {
                Ctsurc(0)
            }
        }
        impl core::fmt::Debug for Ctsurc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsurc")
                    .field("ctsurc", &self.ctsurc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsurc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsurc {{ ctsurc: {=u16:?} }}", self.ctsurc())
            }
        }
        #[doc = "CTSU Sensor Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsusc(pub u16);
        impl Ctsusc {
            #[doc = "CTSU Sensor CounterThese bits indicate the measurement result of the CTSU. These bits indicate FFFFh when an overflow occurs."]
            #[inline(always)]
            pub const fn ctsusc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "CTSU Sensor CounterThese bits indicate the measurement result of the CTSU. These bits indicate FFFFh when an overflow occurs."]
            #[inline(always)]
            pub fn set_ctsusc(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ctsusc {
            #[inline(always)]
            fn default() -> Ctsusc {
                Ctsusc(0)
            }
        }
        impl core::fmt::Debug for Ctsusc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsusc")
                    .field("ctsusc", &self.ctsusc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsusc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsusc {{ ctsusc: {=u16:?} }}", self.ctsusc())
            }
        }
        #[doc = "CTSU Synchronous Noise Reduction Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsusdprs(pub u8);
        impl Ctsusdprs {
            #[doc = "CTSU Measurement Time and Pulse Count AdjustmentRecommended setting: 3 (0011b)"]
            #[inline(always)]
            pub const fn ctsuprratio(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "CTSU Measurement Time and Pulse Count AdjustmentRecommended setting: 3 (0011b)"]
            #[inline(always)]
            pub fn set_ctsuprratio(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "CTSU Base Period and Pulse Count Setting"]
            #[inline(always)]
            pub const fn ctsuprmode(&self) -> super::vals::Ctsuprmode {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Ctsuprmode::from_bits(val as u8)
            }
            #[doc = "CTSU Base Period and Pulse Count Setting"]
            #[inline(always)]
            pub fn set_ctsuprmode(&mut self, val: super::vals::Ctsuprmode) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "CTSU High,Pass Noise Reduction Function Off Setting"]
            #[inline(always)]
            pub const fn ctsusoff(&self) -> super::vals::Ctsusoff {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ctsusoff::from_bits(val as u8)
            }
            #[doc = "CTSU High,Pass Noise Reduction Function Off Setting"]
            #[inline(always)]
            pub fn set_ctsusoff(&mut self, val: super::vals::Ctsusoff) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ctsusdprs {
            #[inline(always)]
            fn default() -> Ctsusdprs {
                Ctsusdprs(0)
            }
        }
        impl core::fmt::Debug for Ctsusdprs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsusdprs")
                    .field("ctsuprratio", &self.ctsuprratio())
                    .field("ctsuprmode", &self.ctsuprmode())
                    .field("ctsusoff", &self.ctsusoff())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsusdprs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctsusdprs {{ ctsuprratio: {=u8:?}, ctsuprmode: {:?}, ctsusoff: {:?}, reserved_7_7: {=bool:?} }}" , self . ctsuprratio () , self . ctsuprmode () , self . ctsusoff () , self . reserved_7_7 ())
            }
        }
        #[doc = "CTSU Sensor Offset Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuso0(pub u16);
        impl Ctsuso0 {
            #[doc = "CTSU Sensor Offset AdjustmentCurrent offset amount is CTSUSO ( 0 to 1023 )"]
            #[inline(always)]
            pub const fn ctsuso(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "CTSU Sensor Offset AdjustmentCurrent offset amount is CTSUSO ( 0 to 1023 )"]
            #[inline(always)]
            pub fn set_ctsuso(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u16) & 0x03ff) << 0usize);
            }
            #[doc = "CTSU Measurement Count Setting"]
            #[inline(always)]
            pub const fn ctsusnum(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "CTSU Measurement Count Setting"]
            #[inline(always)]
            pub fn set_ctsusnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Ctsuso0 {
            #[inline(always)]
            fn default() -> Ctsuso0 {
                Ctsuso0(0)
            }
        }
        impl core::fmt::Debug for Ctsuso0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuso0")
                    .field("ctsuso", &self.ctsuso())
                    .field("ctsusnum", &self.ctsusnum())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuso0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctsuso0 {{ ctsuso: {=u16:?}, ctsusnum: {=u8:?} }}",
                    self.ctsuso(),
                    self.ctsusnum()
                )
            }
        }
        #[doc = "CTSU Sensor Offset Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsuso1(pub u16);
        impl Ctsuso1 {
            #[doc = "CTSU Reference ICO Current AdjustmentCurrent offset amount is CTSUSO ( 0 to 255 )"]
            #[inline(always)]
            pub const fn ctsuricoa(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "CTSU Reference ICO Current AdjustmentCurrent offset amount is CTSUSO ( 0 to 255 )"]
            #[inline(always)]
            pub fn set_ctsuricoa(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "CTSU Base Clock SettingOperating clock divided by ( CTSUSDPA + 1 ) x 2"]
            #[inline(always)]
            pub const fn ctsusdpa(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "CTSU Base Clock SettingOperating clock divided by ( CTSUSDPA + 1 ) x 2"]
            #[inline(always)]
            pub fn set_ctsusdpa(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u16) & 0x1f) << 8usize);
            }
            #[doc = "CTSU ICO Gain Adjustment"]
            #[inline(always)]
            pub const fn ctsuicog(&self) -> super::vals::Ctsuicog {
                let val = (self.0 >> 13usize) & 0x03;
                super::vals::Ctsuicog::from_bits(val as u8)
            }
            #[doc = "CTSU ICO Gain Adjustment"]
            #[inline(always)]
            pub fn set_ctsuicog(&mut self, val: super::vals::Ctsuicog) {
                self.0 =
                    (self.0 & !(0x03 << 13usize)) | (((val.to_bits() as u16) & 0x03) << 13usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_15_15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_15_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Ctsuso1 {
            #[inline(always)]
            fn default() -> Ctsuso1 {
                Ctsuso1(0)
            }
        }
        impl core::fmt::Debug for Ctsuso1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsuso1")
                    .field("ctsuricoa", &self.ctsuricoa())
                    .field("ctsusdpa", &self.ctsusdpa())
                    .field("ctsuicog", &self.ctsuicog())
                    .field("reserved_15_15", &self.reserved_15_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuso1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctsuso1 {{ ctsuricoa: {=u8:?}, ctsusdpa: {=u8:?}, ctsuicog: {:?}, reserved_15_15: {=bool:?} }}" , self . ctsuricoa () , self . ctsusdpa () , self . ctsuicog () , self . reserved_15_15 ())
            }
        }
        #[doc = "CTSU High,Pass Noise Reduction Spectrum Diffusion Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsussc(pub u16);
        impl Ctsussc {
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_0_7(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_0_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "CTSU Spectrum Diffusion Frequency Division Setting"]
            #[inline(always)]
            pub const fn ctsussdiv(&self) -> super::vals::Ctsussdiv {
                let val = (self.0 >> 8usize) & 0x0f;
                super::vals::Ctsussdiv::from_bits(val as u8)
            }
            #[doc = "CTSU Spectrum Diffusion Frequency Division Setting"]
            #[inline(always)]
            pub fn set_ctsussdiv(&mut self, val: super::vals::Ctsussdiv) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u16) & 0x0f) << 8usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_12_15(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_12_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u16) & 0x0f) << 12usize);
            }
        }
        impl Default for Ctsussc {
            #[inline(always)]
            fn default() -> Ctsussc {
                Ctsussc(0)
            }
        }
        impl core::fmt::Debug for Ctsussc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsussc")
                    .field("reserved_0_7", &self.reserved_0_7())
                    .field("ctsussdiv", &self.ctsussdiv())
                    .field("reserved_12_15", &self.reserved_12_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsussc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctsussc {{ reserved_0_7: {=u8:?}, ctsussdiv: {:?}, reserved_12_15: {=u8:?} }}",
                    self.reserved_0_7(),
                    self.ctsussdiv(),
                    self.reserved_12_15()
                )
            }
        }
        #[doc = "CTSU Sensor Stabilization Wait Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsusst(pub u8);
        impl Ctsusst {
            #[doc = "CTSU Sensor Stabilization Wait ControlNOTE: The value of these bits should be fixed to 00010000b."]
            #[inline(always)]
            pub const fn ctsusst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "CTSU Sensor Stabilization Wait ControlNOTE: The value of these bits should be fixed to 00010000b."]
            #[inline(always)]
            pub fn set_ctsusst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ctsusst {
            #[inline(always)]
            fn default() -> Ctsusst {
                Ctsusst(0)
            }
        }
        impl core::fmt::Debug for Ctsusst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsusst")
                    .field("ctsusst", &self.ctsusst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsusst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctsusst {{ ctsusst: {=u8:?} }}", self.ctsusst())
            }
        }
        #[doc = "CTSU Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctsust(pub u8);
        impl Ctsust {
            #[doc = "CTSU Measurement Status Counter"]
            #[inline(always)]
            pub const fn ctsustc(&self) -> super::vals::Ctsustc {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ctsustc::from_bits(val as u8)
            }
            #[doc = "CTSU Measurement Status Counter"]
            #[inline(always)]
            pub fn set_ctsustc(&mut self, val: super::vals::Ctsustc) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "CTSU Data Transfer Status Flag"]
            #[inline(always)]
            pub const fn ctsudtsr(&self) -> super::vals::Ctsudtsr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ctsudtsr::from_bits(val as u8)
            }
            #[doc = "CTSU Data Transfer Status Flag"]
            #[inline(always)]
            pub fn set_ctsudtsr(&mut self, val: super::vals::Ctsudtsr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "CTSU Sensor Counter Overflow Flag"]
            #[inline(always)]
            pub const fn ctsusovf(&self) -> super::vals::Ctsusovf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ctsusovf::from_bits(val as u8)
            }
            #[doc = "CTSU Sensor Counter Overflow Flag"]
            #[inline(always)]
            pub fn set_ctsusovf(&mut self, val: super::vals::Ctsusovf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "CTSU Reference Counter Overflow Flag"]
            #[inline(always)]
            pub const fn ctsurovf(&self) -> super::vals::Ctsurovf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ctsurovf::from_bits(val as u8)
            }
            #[doc = "CTSU Reference Counter Overflow Flag"]
            #[inline(always)]
            pub fn set_ctsurovf(&mut self, val: super::vals::Ctsurovf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "CTSU Mutual Capacitance Status Flag"]
            #[inline(always)]
            pub const fn ctsups(&self) -> super::vals::Ctsups {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ctsups::from_bits(val as u8)
            }
            #[doc = "CTSU Mutual Capacitance Status Flag"]
            #[inline(always)]
            pub fn set_ctsups(&mut self, val: super::vals::Ctsups) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ctsust {
            #[inline(always)]
            fn default() -> Ctsust {
                Ctsust(0)
            }
        }
        impl core::fmt::Debug for Ctsust {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctsust")
                    .field("ctsustc", &self.ctsustc())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("ctsudtsr", &self.ctsudtsr())
                    .field("ctsusovf", &self.ctsusovf())
                    .field("ctsurovf", &self.ctsurovf())
                    .field("ctsups", &self.ctsups())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsust {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctsust {{ ctsustc: {:?}, reserved_3_3: {=bool:?}, ctsudtsr: {:?}, ctsusovf: {:?}, ctsurovf: {:?}, ctsups: {:?} }}" , self . ctsustc () , self . reserved_3_3 () , self . ctsudtsr () , self . ctsusovf () , self . ctsurovf () , self . ctsups ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsuatune0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsuatune0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsuatune0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsuatune0 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuatune0 {
                Ctsuatune0::from_bits(val)
            }
        }
        impl From<Ctsuatune0> for u8 {
            #[inline(always)]
            fn from(val: Ctsuatune0) -> u8 {
                Ctsuatune0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsuatune1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsuatune1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsuatune1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsuatune1 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuatune1 {
                Ctsuatune1::from_bits(val)
            }
        }
        impl From<Ctsuatune1> for u8 {
            #[inline(always)]
            fn from(val: Ctsuatune1) -> u8 {
                Ctsuatune1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsucap {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsucap {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsucap {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsucap {
            #[inline(always)]
            fn from(val: u8) -> Ctsucap {
                Ctsucap::from_bits(val)
            }
        }
        impl From<Ctsucap> for u8 {
            #[inline(always)]
            fn from(val: Ctsucap) -> u8 {
                Ctsucap::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ctsuchac0(u8);
        impl Ctsuchac0 {}
        impl Ctsuchac0 {
            pub const fn from_bits(val: u8) -> Ctsuchac0 {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ctsuchac0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchac0 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ctsuchac0 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuchac0 {
                Ctsuchac0::from_bits(val)
            }
        }
        impl From<Ctsuchac0> for u8 {
            #[inline(always)]
            fn from(val: Ctsuchac0) -> u8 {
                Ctsuchac0::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ctsuchac1(u8);
        impl Ctsuchac1 {}
        impl Ctsuchac1 {
            pub const fn from_bits(val: u8) -> Ctsuchac1 {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ctsuchac1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchac1 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ctsuchac1 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuchac1 {
                Ctsuchac1::from_bits(val)
            }
        }
        impl From<Ctsuchac1> for u8 {
            #[inline(always)]
            fn from(val: Ctsuchac1) -> u8 {
                Ctsuchac1::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ctsuchac2(u8);
        impl Ctsuchac2 {}
        impl Ctsuchac2 {
            pub const fn from_bits(val: u8) -> Ctsuchac2 {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ctsuchac2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchac2 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ctsuchac2 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuchac2 {
                Ctsuchac2::from_bits(val)
            }
        }
        impl From<Ctsuchac2> for u8 {
            #[inline(always)]
            fn from(val: Ctsuchac2) -> u8 {
                Ctsuchac2::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ctsuchac3(u8);
        impl Ctsuchac3 {}
        impl Ctsuchac3 {
            pub const fn from_bits(val: u8) -> Ctsuchac3 {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ctsuchac3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchac3 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ctsuchac3 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuchac3 {
                Ctsuchac3::from_bits(val)
            }
        }
        impl From<Ctsuchac3> for u8 {
            #[inline(always)]
            fn from(val: Ctsuchac3) -> u8 {
                Ctsuchac3::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ctsuchrc2(u8);
        impl Ctsuchrc2 {}
        impl Ctsuchrc2 {
            pub const fn from_bits(val: u8) -> Ctsuchrc2 {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ctsuchrc2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchrc2 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ctsuchrc2 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuchrc2 {
                Ctsuchrc2::from_bits(val)
            }
        }
        impl From<Ctsuchrc2> for u8 {
            #[inline(always)]
            fn from(val: Ctsuchrc2) -> u8 {
                Ctsuchrc2::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ctsuchrc3(u8);
        impl Ctsuchrc3 {}
        impl Ctsuchrc3 {
            pub const fn from_bits(val: u8) -> Ctsuchrc3 {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ctsuchrc3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchrc3 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ctsuchrc3 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuchrc3 {
                Ctsuchrc3::from_bits(val)
            }
        }
        impl From<Ctsuchrc3> for u8 {
            #[inline(always)]
            fn from(val: Ctsuchrc3) -> u8 {
                Ctsuchrc3::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ctsuchtrc0(u8);
        impl Ctsuchtrc0 {}
        impl Ctsuchtrc0 {
            pub const fn from_bits(val: u8) -> Ctsuchtrc0 {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ctsuchtrc0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchtrc0 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ctsuchtrc0 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuchtrc0 {
                Ctsuchtrc0::from_bits(val)
            }
        }
        impl From<Ctsuchtrc0> for u8 {
            #[inline(always)]
            fn from(val: Ctsuchtrc0) -> u8 {
                Ctsuchtrc0::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ctsuchtrc1(u8);
        impl Ctsuchtrc1 {}
        impl Ctsuchtrc1 {
            pub const fn from_bits(val: u8) -> Ctsuchtrc1 {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ctsuchtrc1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctsuchtrc1 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ctsuchtrc1 {
            #[inline(always)]
            fn from(val: u8) -> Ctsuchtrc1 {
                Ctsuchtrc1::from_bits(val)
            }
        }
        impl From<Ctsuchtrc1> for u8 {
            #[inline(always)]
            fn from(val: Ctsuchtrc1) -> u8 {
                Ctsuchtrc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsuclk {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ctsuclk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsuclk {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsuclk {
            #[inline(always)]
            fn from(val: u8) -> Ctsuclk {
                Ctsuclk::from_bits(val)
            }
        }
        impl From<Ctsuclk> for u8 {
            #[inline(always)]
            fn from(val: Ctsuclk) -> u8 {
                Ctsuclk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsucsw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsucsw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsucsw {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsucsw {
            #[inline(always)]
            fn from(val: u8) -> Ctsucsw {
                Ctsucsw::from_bits(val)
            }
        }
        impl From<Ctsucsw> for u8 {
            #[inline(always)]
            fn from(val: Ctsucsw) -> u8 {
                Ctsucsw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsudtsr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsudtsr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsudtsr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsudtsr {
            #[inline(always)]
            fn from(val: u8) -> Ctsudtsr {
                Ctsudtsr::from_bits(val)
            }
        }
        impl From<Ctsudtsr> for u8 {
            #[inline(always)]
            fn from(val: Ctsudtsr) -> u8 {
                Ctsudtsr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsuicog {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ctsuicog {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsuicog {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsuicog {
            #[inline(always)]
            fn from(val: u8) -> Ctsuicog {
                Ctsuicog::from_bits(val)
            }
        }
        impl From<Ctsuicog> for u8 {
            #[inline(always)]
            fn from(val: Ctsuicog) -> u8 {
                Ctsuicog::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsuicomp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsuicomp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsuicomp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsuicomp {
            #[inline(always)]
            fn from(val: u8) -> Ctsuicomp {
                Ctsuicomp::from_bits(val)
            }
        }
        impl From<Ctsuicomp> for u8 {
            #[inline(always)]
            fn from(val: Ctsuicomp) -> u8 {
                Ctsuicomp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsuinit {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsuinit {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsuinit {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsuinit {
            #[inline(always)]
            fn from(val: u8) -> Ctsuinit {
                Ctsuinit::from_bits(val)
            }
        }
        impl From<Ctsuinit> for u8 {
            #[inline(always)]
            fn from(val: Ctsuinit) -> u8 {
                Ctsuinit::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsumch0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
            _RESERVED_20 = 0x20,
            _RESERVED_21 = 0x21,
            _RESERVED_22 = 0x22,
            _RESERVED_23 = 0x23,
            _RESERVED_24 = 0x24,
            _RESERVED_25 = 0x25,
            _RESERVED_26 = 0x26,
            _RESERVED_27 = 0x27,
            _RESERVED_28 = 0x28,
            _RESERVED_29 = 0x29,
            _RESERVED_2a = 0x2a,
            _RESERVED_2b = 0x2b,
            _RESERVED_2c = 0x2c,
            _RESERVED_2d = 0x2d,
            _RESERVED_2e = 0x2e,
            _RESERVED_2f = 0x2f,
            _RESERVED_30 = 0x30,
            _RESERVED_31 = 0x31,
            _RESERVED_32 = 0x32,
            _RESERVED_33 = 0x33,
            _RESERVED_34 = 0x34,
            _RESERVED_35 = 0x35,
            _RESERVED_36 = 0x36,
            _RESERVED_37 = 0x37,
            _RESERVED_38 = 0x38,
            _RESERVED_39 = 0x39,
            _RESERVED_3a = 0x3a,
            _RESERVED_3b = 0x3b,
            _RESERVED_3c = 0x3c,
            _RESERVED_3d = 0x3d,
            _RESERVED_3e = 0x3e,
            _RESERVED_3f = 0x3f,
        }
        impl Ctsumch0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsumch0 {
                unsafe { core::mem::transmute(val & 0x3f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsumch0 {
            #[inline(always)]
            fn from(val: u8) -> Ctsumch0 {
                Ctsumch0::from_bits(val)
            }
        }
        impl From<Ctsumch0> for u8 {
            #[inline(always)]
            fn from(val: Ctsumch0) -> u8 {
                Ctsumch0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsumch1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
            _RESERVED_20 = 0x20,
            _RESERVED_21 = 0x21,
            _RESERVED_22 = 0x22,
            _RESERVED_23 = 0x23,
            _RESERVED_24 = 0x24,
            _RESERVED_25 = 0x25,
            _RESERVED_26 = 0x26,
            _RESERVED_27 = 0x27,
            _RESERVED_28 = 0x28,
            _RESERVED_29 = 0x29,
            _RESERVED_2a = 0x2a,
            _RESERVED_2b = 0x2b,
            _RESERVED_2c = 0x2c,
            _RESERVED_2d = 0x2d,
            _RESERVED_2e = 0x2e,
            _RESERVED_2f = 0x2f,
            _RESERVED_30 = 0x30,
            _RESERVED_31 = 0x31,
            _RESERVED_32 = 0x32,
            _RESERVED_33 = 0x33,
            _RESERVED_34 = 0x34,
            _RESERVED_35 = 0x35,
            _RESERVED_36 = 0x36,
            _RESERVED_37 = 0x37,
            _RESERVED_38 = 0x38,
            _RESERVED_39 = 0x39,
            _RESERVED_3a = 0x3a,
            _RESERVED_3b = 0x3b,
            _RESERVED_3c = 0x3c,
            _RESERVED_3d = 0x3d,
            _RESERVED_3e = 0x3e,
            _RESERVED_3f = 0x3f,
        }
        impl Ctsumch1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsumch1 {
                unsafe { core::mem::transmute(val & 0x3f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsumch1 {
            #[inline(always)]
            fn from(val: u8) -> Ctsumch1 {
                Ctsumch1::from_bits(val)
            }
        }
        impl From<Ctsumch1> for u8 {
            #[inline(always)]
            fn from(val: Ctsumch1) -> u8 {
                Ctsumch1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsumd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ctsumd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsumd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsumd {
            #[inline(always)]
            fn from(val: u8) -> Ctsumd {
                Ctsumd::from_bits(val)
            }
        }
        impl From<Ctsumd> for u8 {
            #[inline(always)]
            fn from(val: Ctsumd) -> u8 {
                Ctsumd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsupon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsupon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsupon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsupon {
            #[inline(always)]
            fn from(val: u8) -> Ctsupon {
                Ctsupon::from_bits(val)
            }
        }
        impl From<Ctsupon> for u8 {
            #[inline(always)]
            fn from(val: Ctsupon) -> u8 {
                Ctsupon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsuprmode {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ctsuprmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsuprmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsuprmode {
            #[inline(always)]
            fn from(val: u8) -> Ctsuprmode {
                Ctsuprmode::from_bits(val)
            }
        }
        impl From<Ctsuprmode> for u8 {
            #[inline(always)]
            fn from(val: Ctsuprmode) -> u8 {
                Ctsuprmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsups {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsups {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsups {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsups {
            #[inline(always)]
            fn from(val: u8) -> Ctsups {
                Ctsups::from_bits(val)
            }
        }
        impl From<Ctsups> for u8 {
            #[inline(always)]
            fn from(val: Ctsups) -> u8 {
                Ctsups::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsurovf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsurovf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsurovf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsurovf {
            #[inline(always)]
            fn from(val: u8) -> Ctsurovf {
                Ctsurovf::from_bits(val)
            }
        }
        impl From<Ctsurovf> for u8 {
            #[inline(always)]
            fn from(val: Ctsurovf) -> u8 {
                Ctsurovf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsusnz {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsusnz {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsusnz {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsusnz {
            #[inline(always)]
            fn from(val: u8) -> Ctsusnz {
                Ctsusnz::from_bits(val)
            }
        }
        impl From<Ctsusnz> for u8 {
            #[inline(always)]
            fn from(val: Ctsusnz) -> u8 {
                Ctsusnz::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsusoff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsusoff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsusoff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsusoff {
            #[inline(always)]
            fn from(val: u8) -> Ctsusoff {
                Ctsusoff::from_bits(val)
            }
        }
        impl From<Ctsusoff> for u8 {
            #[inline(always)]
            fn from(val: Ctsusoff) -> u8 {
                Ctsusoff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsusovf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsusovf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsusovf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsusovf {
            #[inline(always)]
            fn from(val: u8) -> Ctsusovf {
                Ctsusovf::from_bits(val)
            }
        }
        impl From<Ctsusovf> for u8 {
            #[inline(always)]
            fn from(val: Ctsusovf) -> u8 {
                Ctsusovf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsussdiv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Ctsussdiv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsussdiv {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsussdiv {
            #[inline(always)]
            fn from(val: u8) -> Ctsussdiv {
                Ctsussdiv::from_bits(val)
            }
        }
        impl From<Ctsussdiv> for u8 {
            #[inline(always)]
            fn from(val: Ctsussdiv) -> u8 {
                Ctsussdiv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsustc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctsustc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsustc {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsustc {
            #[inline(always)]
            fn from(val: u8) -> Ctsustc {
                Ctsustc::from_bits(val)
            }
        }
        impl From<Ctsustc> for u8 {
            #[inline(always)]
            fn from(val: Ctsustc) -> u8 {
                Ctsustc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsustrt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctsustrt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsustrt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsustrt {
            #[inline(always)]
            fn from(val: u8) -> Ctsustrt {
                Ctsustrt::from_bits(val)
            }
        }
        impl From<Ctsustrt> for u8 {
            #[inline(always)]
            fn from(val: Ctsustrt) -> u8 {
                Ctsustrt::to_bits(val)
            }
        }
    }
}
pub mod dac12 {
    #[doc = "12-bit D/A converter"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dac12 {
        ptr: *mut u8,
    }
    unsafe impl Send for Dac12 {}
    unsafe impl Sync for Dac12 {}
    impl Dac12 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "D/A Data Register 0"]
        #[inline(always)]
        pub const fn dadr0(self) -> crate::common::Reg<regs::Dadr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "D/A Control Register"]
        #[inline(always)]
        pub const fn dacr(self) -> crate::common::Reg<regs::Dacr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "DADR0 Format Select Register"]
        #[inline(always)]
        pub const fn dadpr(self) -> crate::common::Reg<regs::Dadpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "D/A,A/D Synchronous Start Control Register"]
        #[inline(always)]
        pub const fn daadscr(self) -> crate::common::Reg<regs::Daadscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "D/A VREF Control Register"]
        #[inline(always)]
        pub const fn davrefcr(self) -> crate::common::Reg<regs::Davrefcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "D/A Switch Charge Pump Control Register"]
        #[inline(always)]
        pub const fn dapc(self) -> crate::common::Reg<regs::Dapc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "D/A,A/D Synchronous Start Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Daadscr(pub u8);
        impl Daadscr {
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_0_6(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_0_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u8) & 0x7f) << 0usize);
            }
            #[doc = "D/A,A/D Synchronous Conversion"]
            #[inline(always)]
            pub const fn daadst(&self) -> super::vals::Daadst {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Daadst::from_bits(val as u8)
            }
            #[doc = "D/A,A/D Synchronous Conversion"]
            #[inline(always)]
            pub fn set_daadst(&mut self, val: super::vals::Daadst) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Daadscr {
            #[inline(always)]
            fn default() -> Daadscr {
                Daadscr(0)
            }
        }
        impl core::fmt::Debug for Daadscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Daadscr")
                    .field("reserved_0_6", &self.reserved_0_6())
                    .field("daadst", &self.daadst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Daadscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Daadscr {{ reserved_0_6: {=u8:?}, daadst: {:?} }}",
                    self.reserved_0_6(),
                    self.daadst()
                )
            }
        }
        #[doc = "D/A Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dacr(pub u8);
        impl Dacr {
            #[doc = "These bits are read as 11111. The write value should be 11111."]
            #[inline(always)]
            pub const fn reserved_0_4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 11111. The write value should be 11111."]
            #[inline(always)]
            pub fn set_reserved_0_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "D/A Output Enable 0"]
            #[inline(always)]
            pub const fn daoe0(&self) -> super::vals::Daoe0 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Daoe0::from_bits(val as u8)
            }
            #[doc = "D/A Output Enable 0"]
            #[inline(always)]
            pub fn set_daoe0(&mut self, val: super::vals::Daoe0) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Dacr {
            #[inline(always)]
            fn default() -> Dacr {
                Dacr(0)
            }
        }
        impl core::fmt::Debug for Dacr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dacr")
                    .field("reserved_0_4", &self.reserved_0_4())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("daoe0", &self.daoe0())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dacr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dacr {{ reserved_0_4: {=u8:?}, reserved_5_5: {=bool:?}, daoe0: {:?}, reserved_7_7: {=bool:?} }}" , self . reserved_0_4 () , self . reserved_5_5 () , self . daoe0 () , self . reserved_7_7 ())
            }
        }
        #[doc = "DADR0 Format Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dadpr(pub u8);
        impl Dadpr {
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_0_6(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_0_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u8) & 0x7f) << 0usize);
            }
            #[doc = "DADRm Format Select"]
            #[inline(always)]
            pub const fn dpsel(&self) -> super::vals::Dpsel {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dpsel::from_bits(val as u8)
            }
            #[doc = "DADRm Format Select"]
            #[inline(always)]
            pub fn set_dpsel(&mut self, val: super::vals::Dpsel) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Dadpr {
            #[inline(always)]
            fn default() -> Dadpr {
                Dadpr(0)
            }
        }
        impl core::fmt::Debug for Dadpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dadpr")
                    .field("reserved_0_6", &self.reserved_0_6())
                    .field("dpsel", &self.dpsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dadpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dadpr {{ reserved_0_6: {=u8:?}, dpsel: {:?} }}",
                    self.reserved_0_6(),
                    self.dpsel()
                )
            }
        }
        #[doc = "D/A Data Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dadr0(pub u16);
        impl Dadr0 {
            #[doc = "D/A Data RegisterNOTE: When DADPR.DPSEL = 0, the high,order 4 bits are fixed to 0: right justified format. When DADPR.DPSEL = 1, the low,order 4 bits are fixed to 0: left justified format."]
            #[inline(always)]
            pub const fn dadr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "D/A Data RegisterNOTE: When DADPR.DPSEL = 0, the high,order 4 bits are fixed to 0: right justified format. When DADPR.DPSEL = 1, the low,order 4 bits are fixed to 0: left justified format."]
            #[inline(always)]
            pub fn set_dadr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Dadr0 {
            #[inline(always)]
            fn default() -> Dadr0 {
                Dadr0(0)
            }
        }
        impl core::fmt::Debug for Dadr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dadr0").field("dadr", &self.dadr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dadr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dadr0 {{ dadr: {=u16:?} }}", self.dadr())
            }
        }
        #[doc = "D/A Switch Charge Pump Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dapc(pub u8);
        impl Dapc {
            #[doc = "Charge Pump Enable"]
            #[inline(always)]
            pub const fn pumpen(&self) -> super::vals::Pumpen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pumpen::from_bits(val as u8)
            }
            #[doc = "Charge Pump Enable"]
            #[inline(always)]
            pub fn set_pumpen(&mut self, val: super::vals::Pumpen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Dapc {
            #[inline(always)]
            fn default() -> Dapc {
                Dapc(0)
            }
        }
        impl core::fmt::Debug for Dapc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dapc")
                    .field("pumpen", &self.pumpen())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dapc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dapc {{ pumpen: {:?}, reserved_1_7: {=u8:?} }}",
                    self.pumpen(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "D/A VREF Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Davrefcr(pub u8);
        impl Davrefcr {
            #[doc = "D/A Reference Voltage Select"]
            #[inline(always)]
            pub const fn ref_(&self) -> super::vals::Ref {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ref::from_bits(val as u8)
            }
            #[doc = "D/A Reference Voltage Select"]
            #[inline(always)]
            pub fn set_ref_(&mut self, val: super::vals::Ref) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Davrefcr {
            #[inline(always)]
            fn default() -> Davrefcr {
                Davrefcr(0)
            }
        }
        impl core::fmt::Debug for Davrefcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Davrefcr")
                    .field("ref_", &self.ref_())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Davrefcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Davrefcr {{ ref_: {:?}, reserved_3_7: {=u8:?} }}",
                    self.ref_(),
                    self.reserved_3_7()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Daadst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Daadst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Daadst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Daadst {
            #[inline(always)]
            fn from(val: u8) -> Daadst {
                Daadst::from_bits(val)
            }
        }
        impl From<Daadst> for u8 {
            #[inline(always)]
            fn from(val: Daadst) -> u8 {
                Daadst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Daoe0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Daoe0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Daoe0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Daoe0 {
            #[inline(always)]
            fn from(val: u8) -> Daoe0 {
                Daoe0::from_bits(val)
            }
        }
        impl From<Daoe0> for u8 {
            #[inline(always)]
            fn from(val: Daoe0) -> u8 {
                Daoe0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dpsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dpsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dpsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dpsel {
            #[inline(always)]
            fn from(val: u8) -> Dpsel {
                Dpsel::from_bits(val)
            }
        }
        impl From<Dpsel> for u8 {
            #[inline(always)]
            fn from(val: Dpsel) -> u8 {
                Dpsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pumpen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pumpen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pumpen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pumpen {
            #[inline(always)]
            fn from(val: u8) -> Pumpen {
                Pumpen::from_bits(val)
            }
        }
        impl From<Pumpen> for u8 {
            #[inline(always)]
            fn from(val: Pumpen) -> u8 {
                Pumpen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ref {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ref {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ref {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ref {
            #[inline(always)]
            fn from(val: u8) -> Ref {
                Ref::from_bits(val)
            }
        }
        impl From<Ref> for u8 {
            #[inline(always)]
            fn from(val: Ref) -> u8 {
                Ref::to_bits(val)
            }
        }
    }
}
pub mod dac8 {
    #[doc = "8-bit D/A converter"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dac8 {
        ptr: *mut u8,
    }
    unsafe impl Send for Dac8 {}
    unsafe impl Sync for Dac8 {}
    impl Dac8 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "D/A Conversion Value Setting Register %s"]
        #[inline(always)]
        pub const fn dacs(self, n: usize) -> crate::common::Reg<regs::Dacs, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 1usize) as _) }
        }
        #[doc = "D/A Converter Mode Register"]
        #[inline(always)]
        pub const fn dam(self) -> crate::common::Reg<regs::Dam, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "D/A A/D Synchronous Start Control Register"]
        #[inline(always)]
        pub const fn dacadscr(self) -> crate::common::Reg<regs::Dacadscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "D/A SW Charge Pump Control Register"]
        #[inline(always)]
        pub const fn dacpc(self) -> crate::common::Reg<regs::Dacpc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "D/A A/D Synchronous Start Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dacadscr(pub u8);
        impl Dacadscr {
            #[doc = "D/A A/D Synchronous Conversion"]
            #[inline(always)]
            pub const fn dacadst(&self) -> super::vals::Dacadst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dacadst::from_bits(val as u8)
            }
            #[doc = "D/A A/D Synchronous Conversion"]
            #[inline(always)]
            pub fn set_dacadst(&mut self, val: super::vals::Dacadst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Dacadscr {
            #[inline(always)]
            fn default() -> Dacadscr {
                Dacadscr(0)
            }
        }
        impl core::fmt::Debug for Dacadscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dacadscr")
                    .field("dacadst", &self.dacadst())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dacadscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dacadscr {{ dacadst: {:?}, reserved_1_7: {=u8:?} }}",
                    self.dacadst(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "D/A SW Charge Pump Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dacpc(pub u8);
        impl Dacpc {
            #[doc = "Charge pump enable"]
            #[inline(always)]
            pub const fn pumpen(&self) -> super::vals::Pumpen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pumpen::from_bits(val as u8)
            }
            #[doc = "Charge pump enable"]
            #[inline(always)]
            pub fn set_pumpen(&mut self, val: super::vals::Pumpen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Dacpc {
            #[inline(always)]
            fn default() -> Dacpc {
                Dacpc(0)
            }
        }
        impl core::fmt::Debug for Dacpc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dacpc")
                    .field("pumpen", &self.pumpen())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dacpc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dacpc {{ pumpen: {:?}, reserved_1_7: {=u8:?} }}",
                    self.pumpen(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "D/A Conversion Value Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dacs(pub u8);
        impl Dacs {
            #[doc = "DACS D/A conversion store data"]
            #[inline(always)]
            pub const fn dacs(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DACS D/A conversion store data"]
            #[inline(always)]
            pub fn set_dacs(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Dacs {
            #[inline(always)]
            fn default() -> Dacs {
                Dacs(0)
            }
        }
        impl core::fmt::Debug for Dacs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dacs").field("dacs", &self.dacs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dacs {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dacs {{ dacs: {=u8:?} }}", self.dacs())
            }
        }
        #[doc = "D/A Converter Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dam(pub u8);
        impl Dam {
            #[doc = "D/A operation mode select 0"]
            #[inline(always)]
            pub const fn damd0(&self) -> super::vals::Damd0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Damd0::from_bits(val as u8)
            }
            #[doc = "D/A operation mode select 0"]
            #[inline(always)]
            pub fn set_damd0(&mut self, val: super::vals::Damd0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "D/A operation mode select 1"]
            #[inline(always)]
            pub const fn damd1(&self) -> super::vals::Damd1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Damd1::from_bits(val as u8)
            }
            #[doc = "D/A operation mode select 1"]
            #[inline(always)]
            pub fn set_damd1(&mut self, val: super::vals::Damd1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_2_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_2_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "D/A operation enable 0"]
            #[inline(always)]
            pub const fn dace0(&self) -> super::vals::Dace0 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dace0::from_bits(val as u8)
            }
            #[doc = "D/A operation enable 0"]
            #[inline(always)]
            pub fn set_dace0(&mut self, val: super::vals::Dace0) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "D/A operation enable 1"]
            #[inline(always)]
            pub const fn dace1(&self) -> super::vals::Dace1 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Dace1::from_bits(val as u8)
            }
            #[doc = "D/A operation enable 1"]
            #[inline(always)]
            pub fn set_dace1(&mut self, val: super::vals::Dace1) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Dam {
            #[inline(always)]
            fn default() -> Dam {
                Dam(0)
            }
        }
        impl core::fmt::Debug for Dam {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dam")
                    .field("damd0", &self.damd0())
                    .field("damd1", &self.damd1())
                    .field("reserved_2_2", &self.reserved_2_2())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("dace0", &self.dace0())
                    .field("dace1", &self.dace1())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dam {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dam {{ damd0: {:?}, damd1: {:?}, reserved_2_2: {=bool:?}, reserved_3_3: {=bool:?}, dace0: {:?}, dace1: {:?}, reserved_6_6: {=bool:?}, reserved_7_7: {=bool:?} }}" , self . damd0 () , self . damd1 () , self . reserved_2_2 () , self . reserved_3_3 () , self . dace0 () , self . dace1 () , self . reserved_6_6 () , self . reserved_7_7 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dacadst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dacadst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dacadst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dacadst {
            #[inline(always)]
            fn from(val: u8) -> Dacadst {
                Dacadst::from_bits(val)
            }
        }
        impl From<Dacadst> for u8 {
            #[inline(always)]
            fn from(val: Dacadst) -> u8 {
                Dacadst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dace0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dace0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dace0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dace0 {
            #[inline(always)]
            fn from(val: u8) -> Dace0 {
                Dace0::from_bits(val)
            }
        }
        impl From<Dace0> for u8 {
            #[inline(always)]
            fn from(val: Dace0) -> u8 {
                Dace0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dace1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dace1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dace1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dace1 {
            #[inline(always)]
            fn from(val: u8) -> Dace1 {
                Dace1::from_bits(val)
            }
        }
        impl From<Dace1> for u8 {
            #[inline(always)]
            fn from(val: Dace1) -> u8 {
                Dace1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Damd0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Damd0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Damd0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Damd0 {
            #[inline(always)]
            fn from(val: u8) -> Damd0 {
                Damd0::from_bits(val)
            }
        }
        impl From<Damd0> for u8 {
            #[inline(always)]
            fn from(val: Damd0) -> u8 {
                Damd0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Damd1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Damd1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Damd1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Damd1 {
            #[inline(always)]
            fn from(val: u8) -> Damd1 {
                Damd1::from_bits(val)
            }
        }
        impl From<Damd1> for u8 {
            #[inline(always)]
            fn from(val: Damd1) -> u8 {
                Damd1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pumpen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pumpen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pumpen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pumpen {
            #[inline(always)]
            fn from(val: u8) -> Pumpen {
                Pumpen::from_bits(val)
            }
        }
        impl From<Pumpen> for u8 {
            #[inline(always)]
            fn from(val: Pumpen) -> u8 {
                Pumpen::to_bits(val)
            }
        }
    }
}
pub mod dbg {
    #[doc = "Debug Function"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dbg {
        ptr: *mut u8,
    }
    unsafe impl Send for Dbg {}
    unsafe impl Sync for Dbg {}
    impl Dbg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Debug Status Register"]
        #[inline(always)]
        pub const fn dbgstr(self) -> crate::common::Reg<regs::Dbgstr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug Stop Control Register"]
        #[inline(always)]
        pub const fn dbgstopcr(self) -> crate::common::Reg<regs::Dbgstopcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug Stop Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgstopcr(pub u32);
        impl Dbgstopcr {
            #[doc = "Mask bit for IWDT reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_iwdt(&self) -> super::vals::DbgstopIwdt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DbgstopIwdt::from_bits(val as u8)
            }
            #[doc = "Mask bit for IWDT reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_iwdt(&mut self, val: super::vals::DbgstopIwdt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Mask bit for WDT reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_wdt(&self) -> super::vals::DbgstopWdt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::DbgstopWdt::from_bits(val as u8)
            }
            #[doc = "Mask bit for WDT reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_wdt(&mut self, val: super::vals::DbgstopWdt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 00000000000000. The write value should be 00000000000000."]
            #[inline(always)]
            pub const fn reserved_2_15(&self) -> u16 {
                let val = (self.0 >> 2usize) & 0x3fff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000000. The write value should be 00000000000000."]
            #[inline(always)]
            pub fn set_reserved_2_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 2usize)) | (((val as u32) & 0x3fff) << 2usize);
            }
            #[doc = "b18: Mask bit for LVD2 reset/interrupt (0:enable / 1:Mask)b17: Mask bit for LVD1 reset/interrupt (0:enable / 1:Mask)b16: Mask bit for LVD0 reset (0:enable / 1:Mask)"]
            #[inline(always)]
            pub const fn dbgstop_lvd(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "b18: Mask bit for LVD2 reset/interrupt (0:enable / 1:Mask)b17: Mask bit for LVD1 reset/interrupt (0:enable / 1:Mask)b16: Mask bit for LVD0 reset (0:enable / 1:Mask)"]
            #[inline(always)]
            pub fn set_dbgstop_lvd(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_19_23(&self) -> u8 {
                let val = (self.0 >> 19usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_19_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 19usize)) | (((val as u32) & 0x1f) << 19usize);
            }
            #[doc = "Mask bit for RAM parity error reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_rper(&self) -> super::vals::DbgstopRper {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::DbgstopRper::from_bits(val as u8)
            }
            #[doc = "Mask bit for RAM parity error reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_rper(&mut self, val: super::vals::DbgstopRper) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Mask bit for SRAM ECC error reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_reccr(&self) -> super::vals::DbgstopReccr {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::DbgstopReccr::from_bits(val as u8)
            }
            #[doc = "Mask bit for SRAM ECC error reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_reccr(&mut self, val: super::vals::DbgstopReccr) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_26_31(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_26_31(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 26usize)) | (((val as u32) & 0x3f) << 26usize);
            }
        }
        impl Default for Dbgstopcr {
            #[inline(always)]
            fn default() -> Dbgstopcr {
                Dbgstopcr(0)
            }
        }
        impl core::fmt::Debug for Dbgstopcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgstopcr")
                    .field("dbgstop_iwdt", &self.dbgstop_iwdt())
                    .field("dbgstop_wdt", &self.dbgstop_wdt())
                    .field("reserved_2_15", &self.reserved_2_15())
                    .field("dbgstop_lvd", &self.dbgstop_lvd())
                    .field("reserved_19_23", &self.reserved_19_23())
                    .field("dbgstop_rper", &self.dbgstop_rper())
                    .field("dbgstop_reccr", &self.dbgstop_reccr())
                    .field("reserved_26_31", &self.reserved_26_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgstopcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dbgstopcr {{ dbgstop_iwdt: {:?}, dbgstop_wdt: {:?}, reserved_2_15: {=u16:?}, dbgstop_lvd: {=u8:?}, reserved_19_23: {=u8:?}, dbgstop_rper: {:?}, dbgstop_reccr: {:?}, reserved_26_31: {=u8:?} }}" , self . dbgstop_iwdt () , self . dbgstop_wdt () , self . reserved_2_15 () , self . dbgstop_lvd () , self . reserved_19_23 () , self . dbgstop_rper () , self . dbgstop_reccr () , self . reserved_26_31 ())
            }
        }
        #[doc = "Debug Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgstr(pub u32);
        impl Dbgstr {
            #[doc = "These bits are read as 0000000000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_0_27(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[doc = "These bits are read as 0000000000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_0_27(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
            #[doc = "Debug power,up request"]
            #[inline(always)]
            pub const fn cdbgpwrupreq(&self) -> super::vals::Cdbgpwrupreq {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Cdbgpwrupreq::from_bits(val as u8)
            }
            #[doc = "Debug power,up request"]
            #[inline(always)]
            pub fn set_cdbgpwrupreq(&mut self, val: super::vals::Cdbgpwrupreq) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Debug power,up acknowledge"]
            #[inline(always)]
            pub const fn cdbgpwrupack(&self) -> super::vals::Cdbgpwrupack {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Cdbgpwrupack::from_bits(val as u8)
            }
            #[doc = "Debug power,up acknowledge"]
            #[inline(always)]
            pub fn set_cdbgpwrupack(&mut self, val: super::vals::Cdbgpwrupack) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_30_31(&self) -> u8 {
                let val = (self.0 >> 30usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_30_31(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 30usize)) | (((val as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Dbgstr {
            #[inline(always)]
            fn default() -> Dbgstr {
                Dbgstr(0)
            }
        }
        impl core::fmt::Debug for Dbgstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgstr")
                    .field("reserved_0_27", &self.reserved_0_27())
                    .field("cdbgpwrupreq", &self.cdbgpwrupreq())
                    .field("cdbgpwrupack", &self.cdbgpwrupack())
                    .field("reserved_30_31", &self.reserved_30_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgstr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dbgstr {{ reserved_0_27: {=u32:?}, cdbgpwrupreq: {:?}, cdbgpwrupack: {:?}, reserved_30_31: {=u8:?} }}" , self . reserved_0_27 () , self . cdbgpwrupreq () , self . cdbgpwrupack () , self . reserved_30_31 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdbgpwrupack {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdbgpwrupack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdbgpwrupack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdbgpwrupack {
            #[inline(always)]
            fn from(val: u8) -> Cdbgpwrupack {
                Cdbgpwrupack::from_bits(val)
            }
        }
        impl From<Cdbgpwrupack> for u8 {
            #[inline(always)]
            fn from(val: Cdbgpwrupack) -> u8 {
                Cdbgpwrupack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdbgpwrupreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdbgpwrupreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdbgpwrupreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdbgpwrupreq {
            #[inline(always)]
            fn from(val: u8) -> Cdbgpwrupreq {
                Cdbgpwrupreq::from_bits(val)
            }
        }
        impl From<Cdbgpwrupreq> for u8 {
            #[inline(always)]
            fn from(val: Cdbgpwrupreq) -> u8 {
                Cdbgpwrupreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopIwdt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopIwdt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopIwdt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopIwdt {
            #[inline(always)]
            fn from(val: u8) -> DbgstopIwdt {
                DbgstopIwdt::from_bits(val)
            }
        }
        impl From<DbgstopIwdt> for u8 {
            #[inline(always)]
            fn from(val: DbgstopIwdt) -> u8 {
                DbgstopIwdt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopReccr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopReccr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopReccr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopReccr {
            #[inline(always)]
            fn from(val: u8) -> DbgstopReccr {
                DbgstopReccr::from_bits(val)
            }
        }
        impl From<DbgstopReccr> for u8 {
            #[inline(always)]
            fn from(val: DbgstopReccr) -> u8 {
                DbgstopReccr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopRper {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopRper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopRper {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopRper {
            #[inline(always)]
            fn from(val: u8) -> DbgstopRper {
                DbgstopRper::from_bits(val)
            }
        }
        impl From<DbgstopRper> for u8 {
            #[inline(always)]
            fn from(val: DbgstopRper) -> u8 {
                DbgstopRper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopWdt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopWdt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopWdt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopWdt {
            #[inline(always)]
            fn from(val: u8) -> DbgstopWdt {
                DbgstopWdt::from_bits(val)
            }
        }
        impl From<DbgstopWdt> for u8 {
            #[inline(always)]
            fn from(val: DbgstopWdt) -> u8 {
                DbgstopWdt::to_bits(val)
            }
        }
    }
}
pub mod doc {
    #[doc = "Data Operation Circuit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Doc {
        ptr: *mut u8,
    }
    unsafe impl Send for Doc {}
    unsafe impl Sync for Doc {}
    impl Doc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "DOC Control Register"]
        #[inline(always)]
        pub const fn docr(self) -> crate::common::Reg<regs::Docr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "DOC Data Input Register"]
        #[inline(always)]
        pub const fn dodir(self) -> crate::common::Reg<regs::Dodir, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "DOC Data Setting Register"]
        #[inline(always)]
        pub const fn dodsr(self) -> crate::common::Reg<regs::Dodsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "DOC Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Docr(pub u8);
        impl Docr {
            #[doc = "Operating Mode Select"]
            #[inline(always)]
            pub const fn oms(&self) -> super::vals::Oms {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Oms::from_bits(val as u8)
            }
            #[doc = "Operating Mode Select"]
            #[inline(always)]
            pub fn set_oms(&mut self, val: super::vals::Oms) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Detection Condition Select"]
            #[inline(always)]
            pub const fn dcsel(&self) -> super::vals::Dcsel {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dcsel::from_bits(val as u8)
            }
            #[doc = "Detection Condition Select"]
            #[inline(always)]
            pub fn set_dcsel(&mut self, val: super::vals::Dcsel) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_3_4(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_3_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val as u8) & 0x03) << 3usize);
            }
            #[doc = "Data Operation Circuit FlagIndicates the result of an operation."]
            #[inline(always)]
            pub const fn dopcf(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Data Operation Circuit FlagIndicates the result of an operation."]
            #[inline(always)]
            pub fn set_dopcf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "DOPCF Clear"]
            #[inline(always)]
            pub const fn dopcfcl(&self) -> super::vals::Dopcfcl {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Dopcfcl::from_bits(val as u8)
            }
            #[doc = "DOPCF Clear"]
            #[inline(always)]
            pub fn set_dopcfcl(&mut self, val: super::vals::Dopcfcl) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Docr {
            #[inline(always)]
            fn default() -> Docr {
                Docr(0)
            }
        }
        impl core::fmt::Debug for Docr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Docr")
                    .field("oms", &self.oms())
                    .field("dcsel", &self.dcsel())
                    .field("reserved_3_4", &self.reserved_3_4())
                    .field("dopcf", &self.dopcf())
                    .field("dopcfcl", &self.dopcfcl())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Docr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Docr {{ oms: {:?}, dcsel: {:?}, reserved_3_4: {=u8:?}, dopcf: {=bool:?}, dopcfcl: {:?}, reserved_7_7: {=bool:?} }}" , self . oms () , self . dcsel () , self . reserved_3_4 () , self . dopcf () , self . dopcfcl () , self . reserved_7_7 ())
            }
        }
        #[doc = "DOC Data Input Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dodir(pub u16);
        impl Dodir {
            #[doc = "16-bit read,write register in which 16-bit data for use in the operations are stored."]
            #[inline(always)]
            pub const fn dodir(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "16-bit read,write register in which 16-bit data for use in the operations are stored."]
            #[inline(always)]
            pub fn set_dodir(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Dodir {
            #[inline(always)]
            fn default() -> Dodir {
                Dodir(0)
            }
        }
        impl core::fmt::Debug for Dodir {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dodir")
                    .field("dodir", &self.dodir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dodir {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dodir {{ dodir: {=u16:?} }}", self.dodir())
            }
        }
        #[doc = "DOC Data Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dodsr(pub u16);
        impl Dodsr {
            #[doc = "This register stores 16-bit data for use as a reference in data comparison mode. This register also stores the results of operations in data addition and data subtraction modes."]
            #[inline(always)]
            pub const fn dodsr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This register stores 16-bit data for use as a reference in data comparison mode. This register also stores the results of operations in data addition and data subtraction modes."]
            #[inline(always)]
            pub fn set_dodsr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Dodsr {
            #[inline(always)]
            fn default() -> Dodsr {
                Dodsr(0)
            }
        }
        impl core::fmt::Debug for Dodsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dodsr")
                    .field("dodsr", &self.dodsr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dodsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dodsr {{ dodsr: {=u16:?} }}", self.dodsr())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcsel {
            #[inline(always)]
            fn from(val: u8) -> Dcsel {
                Dcsel::from_bits(val)
            }
        }
        impl From<Dcsel> for u8 {
            #[inline(always)]
            fn from(val: Dcsel) -> u8 {
                Dcsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dopcfcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dopcfcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dopcfcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dopcfcl {
            #[inline(always)]
            fn from(val: u8) -> Dopcfcl {
                Dopcfcl::from_bits(val)
            }
        }
        impl From<Dopcfcl> for u8 {
            #[inline(always)]
            fn from(val: Dopcfcl) -> u8 {
                Dopcfcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oms {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oms {
            #[inline(always)]
            fn from(val: u8) -> Oms {
                Oms::from_bits(val)
            }
        }
        impl From<Oms> for u8 {
            #[inline(always)]
            fn from(val: Oms) -> u8 {
                Oms::to_bits(val)
            }
        }
    }
}
pub mod dtc {
    #[doc = "Data Transfer Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Dtc {}
    unsafe impl Sync for Dtc {}
    impl Dtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "DTC Control Register"]
        #[inline(always)]
        pub const fn dtccr(self) -> crate::common::Reg<regs::Dtccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "DTC Vector Base Register"]
        #[inline(always)]
        pub const fn dtcvbr(self) -> crate::common::Reg<regs::Dtcvbr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "DTC Module Start Register"]
        #[inline(always)]
        pub const fn dtcst(self) -> crate::common::Reg<regs::Dtcst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DTC Status Register"]
        #[inline(always)]
        pub const fn dtcsts(self) -> crate::common::Reg<regs::Dtcsts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "DTC Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtccr(pub u8);
        impl Dtccr {
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_0_2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_0_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u8) & 0x07) << 0usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "DTC Transfer Information Read Skip Enable."]
            #[inline(always)]
            pub const fn rrs(&self) -> super::vals::Rrs {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rrs::from_bits(val as u8)
            }
            #[doc = "DTC Transfer Information Read Skip Enable."]
            #[inline(always)]
            pub fn set_rrs(&mut self, val: super::vals::Rrs) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Dtccr {
            #[inline(always)]
            fn default() -> Dtccr {
                Dtccr(0)
            }
        }
        impl core::fmt::Debug for Dtccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtccr")
                    .field("reserved_0_2", &self.reserved_0_2())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("rrs", &self.rrs())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtccr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dtccr {{ reserved_0_2: {=u8:?}, reserved_3_3: {=bool:?}, rrs: {:?}, reserved_5_7: {=u8:?} }}" , self . reserved_0_2 () , self . reserved_3_3 () , self . rrs () , self . reserved_5_7 ())
            }
        }
        #[doc = "DTC Module Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcst(pub u8);
        impl Dtcst {
            #[doc = "DTC Module Start"]
            #[inline(always)]
            pub const fn dtcst(&self) -> super::vals::Dtcst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dtcst::from_bits(val as u8)
            }
            #[doc = "DTC Module Start"]
            #[inline(always)]
            pub fn set_dtcst(&mut self, val: super::vals::Dtcst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Dtcst {
            #[inline(always)]
            fn default() -> Dtcst {
                Dtcst(0)
            }
        }
        impl core::fmt::Debug for Dtcst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcst")
                    .field("dtcst", &self.dtcst())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtcst {{ dtcst: {:?}, reserved_1_7: {=u8:?} }}",
                    self.dtcst(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "DTC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcsts(pub u16);
        impl Dtcsts {
            #[doc = "DTC,Activating Vector Number MonitoringThese bits indicate the vector number for the activating source when DTC transfer is in progress.The value is only valid if DTC transfer is in progress (the value of the ACT flag is 1)"]
            #[inline(always)]
            pub const fn vecn(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DTC,Activating Vector Number MonitoringThese bits indicate the vector number for the activating source when DTC transfer is in progress.The value is only valid if DTC transfer is in progress (the value of the ACT flag is 1)"]
            #[inline(always)]
            pub fn set_vecn(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 0000000."]
            #[inline(always)]
            pub const fn reserved_8_14(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000."]
            #[inline(always)]
            pub fn set_reserved_8_14(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 8usize)) | (((val as u16) & 0x7f) << 8usize);
            }
            #[doc = "DTC Active Flag"]
            #[inline(always)]
            pub const fn act(&self) -> super::vals::Act {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Act::from_bits(val as u8)
            }
            #[doc = "DTC Active Flag"]
            #[inline(always)]
            pub fn set_act(&mut self, val: super::vals::Act) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Dtcsts {
            #[inline(always)]
            fn default() -> Dtcsts {
                Dtcsts(0)
            }
        }
        impl core::fmt::Debug for Dtcsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcsts")
                    .field("vecn", &self.vecn())
                    .field("reserved_8_14", &self.reserved_8_14())
                    .field("act", &self.act())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtcsts {{ vecn: {=u8:?}, reserved_8_14: {=u8:?}, act: {:?} }}",
                    self.vecn(),
                    self.reserved_8_14(),
                    self.act()
                )
            }
        }
        #[doc = "DTC Vector Base Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcvbr(pub u32);
        impl Dtcvbr {
            #[doc = "DTC Vector Base Address.Note: A value cannot be set in the lower,order 10 bits. These bits are fixed to 0."]
            #[inline(always)]
            pub const fn dtcvbr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "DTC Vector Base Address.Note: A value cannot be set in the lower,order 10 bits. These bits are fixed to 0."]
            #[inline(always)]
            pub fn set_dtcvbr(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Dtcvbr {
            #[inline(always)]
            fn default() -> Dtcvbr {
                Dtcvbr(0)
            }
        }
        impl core::fmt::Debug for Dtcvbr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcvbr")
                    .field("dtcvbr", &self.dtcvbr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcvbr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dtcvbr {{ dtcvbr: {=u32:?} }}", self.dtcvbr())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Act {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Act {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Act {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Act {
            #[inline(always)]
            fn from(val: u8) -> Act {
                Act::from_bits(val)
            }
        }
        impl From<Act> for u8 {
            #[inline(always)]
            fn from(val: Act) -> u8 {
                Act::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtcst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtcst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtcst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtcst {
            #[inline(always)]
            fn from(val: u8) -> Dtcst {
                Dtcst::from_bits(val)
            }
        }
        impl From<Dtcst> for u8 {
            #[inline(always)]
            fn from(val: Dtcst) -> u8 {
                Dtcst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rrs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rrs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rrs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rrs {
            #[inline(always)]
            fn from(val: u8) -> Rrs {
                Rrs::from_bits(val)
            }
        }
        impl From<Rrs> for u8 {
            #[inline(always)]
            fn from(val: Rrs) -> u8 {
                Rrs::to_bits(val)
            }
        }
    }
}
pub mod elc {
    #[doc = "Event Link Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Elc {
        ptr: *mut u8,
    }
    unsafe impl Send for Elc {}
    unsafe impl Sync for Elc {}
    impl Elc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Event Link Controller Register"]
        #[inline(always)]
        pub const fn elcr(self) -> crate::common::Reg<regs::Elcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Event Link Software Event Generation Register %s"]
        #[inline(always)]
        pub const fn elsegr(self, n: usize) -> crate::common::Reg<regs::Elsegr, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize + n * 2usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr(self, n: usize) -> crate::common::Reg<regs::Elsr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr_1(self, n: usize) -> crate::common::Reg<regs::Elsr1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize + n * 4usize) as _) }
        }
        #[doc = "Event Link Setting Register 12"]
        #[inline(always)]
        pub const fn elsr12(self) -> crate::common::Reg<regs::Elsr12, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr_2(self, n: usize) -> crate::common::Reg<regs::Elsr2, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize + n * 4usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr_3(self, n: usize) -> crate::common::Reg<regs::Elsr3, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize + n * 4usize) as _) }
        }
        #[doc = "Event Link Setting Register 22"]
        #[inline(always)]
        pub const fn elsr22(self) -> crate::common::Reg<regs::Elsr22, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Event Link Controller Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elcr(pub u8);
        impl Elcr {
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_0_6(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_0_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u8) & 0x7f) << 0usize);
            }
            #[doc = "All Event Link Enable"]
            #[inline(always)]
            pub const fn elcon(&self) -> super::vals::Elcon {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Elcon::from_bits(val as u8)
            }
            #[doc = "All Event Link Enable"]
            #[inline(always)]
            pub fn set_elcon(&mut self, val: super::vals::Elcon) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Elcr {
            #[inline(always)]
            fn default() -> Elcr {
                Elcr(0)
            }
        }
        impl core::fmt::Debug for Elcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elcr")
                    .field("reserved_0_6", &self.reserved_0_6())
                    .field("elcon", &self.elcon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elcr {{ reserved_0_6: {=u8:?}, elcon: {:?} }}",
                    self.reserved_0_6(),
                    self.elcon()
                )
            }
        }
        #[doc = "Event Link Software Event Generation Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsegr(pub u8);
        impl Elsegr {
            #[doc = "Software Event Generation"]
            #[inline(always)]
            pub const fn seg(&self) -> super::vals::Seg {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Seg::from_bits(val as u8)
            }
            #[doc = "Software Event Generation"]
            #[inline(always)]
            pub fn set_seg(&mut self, val: super::vals::Seg) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_1_5(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_1_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 1usize)) | (((val as u8) & 0x1f) << 1usize);
            }
            #[doc = "SEG Bit Write Enable"]
            #[inline(always)]
            pub const fn we(&self) -> super::vals::We {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::We::from_bits(val as u8)
            }
            #[doc = "SEG Bit Write Enable"]
            #[inline(always)]
            pub fn set_we(&mut self, val: super::vals::We) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "ELSEGR Register Write Disable"]
            #[inline(always)]
            pub const fn wi(&self) -> super::vals::Wi {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wi::from_bits(val as u8)
            }
            #[doc = "ELSEGR Register Write Disable"]
            #[inline(always)]
            pub fn set_wi(&mut self, val: super::vals::Wi) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Elsegr {
            #[inline(always)]
            fn default() -> Elsegr {
                Elsegr(0)
            }
        }
        impl core::fmt::Debug for Elsegr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsegr")
                    .field("seg", &self.seg())
                    .field("reserved_1_5", &self.reserved_1_5())
                    .field("we", &self.we())
                    .field("wi", &self.wi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsegr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsegr {{ seg: {:?}, reserved_1_5: {=u8:?}, we: {:?}, wi: {:?} }}",
                    self.seg(),
                    self.reserved_1_5(),
                    self.we(),
                    self.wi()
                )
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr(pub u16);
        impl Elsr {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> super::vals::ElsrEls {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::ElsrEls::from_bits(val as u8)
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: super::vals::ElsrEls) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Elsr {
            #[inline(always)]
            fn default() -> Elsr {
                Elsr(0)
            }
        }
        impl core::fmt::Debug for Elsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr")
                    .field("els", &self.els())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsr {{ els: {:?}, reserved_8_15: {=u8:?} }}",
                    self.els(),
                    self.reserved_8_15()
                )
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr1(pub u16);
        impl Elsr1 {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> super::vals::Elsr1Els {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Elsr1Els::from_bits(val as u8)
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: super::vals::Elsr1Els) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Elsr1 {
            #[inline(always)]
            fn default() -> Elsr1 {
                Elsr1(0)
            }
        }
        impl core::fmt::Debug for Elsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr1")
                    .field("els", &self.els())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsr1 {{ els: {:?}, reserved_8_15: {=u8:?} }}",
                    self.els(),
                    self.reserved_8_15()
                )
            }
        }
        #[doc = "Event Link Setting Register 12"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr12(pub u16);
        impl Elsr12 {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> super::vals::Elsr12Els {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Elsr12Els::from_bits(val as u8)
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: super::vals::Elsr12Els) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Elsr12 {
            #[inline(always)]
            fn default() -> Elsr12 {
                Elsr12(0)
            }
        }
        impl core::fmt::Debug for Elsr12 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr12")
                    .field("els", &self.els())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr12 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsr12 {{ els: {:?}, reserved_8_15: {=u8:?} }}",
                    self.els(),
                    self.reserved_8_15()
                )
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr2(pub u16);
        impl Elsr2 {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> super::vals::Elsr2Els {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Elsr2Els::from_bits(val as u8)
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: super::vals::Elsr2Els) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Elsr2 {
            #[inline(always)]
            fn default() -> Elsr2 {
                Elsr2(0)
            }
        }
        impl core::fmt::Debug for Elsr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr2")
                    .field("els", &self.els())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsr2 {{ els: {:?}, reserved_8_15: {=u8:?} }}",
                    self.els(),
                    self.reserved_8_15()
                )
            }
        }
        #[doc = "Event Link Setting Register 22"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr22(pub u16);
        impl Elsr22 {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> super::vals::Elsr22Els {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Elsr22Els::from_bits(val as u8)
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: super::vals::Elsr22Els) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Elsr22 {
            #[inline(always)]
            fn default() -> Elsr22 {
                Elsr22(0)
            }
        }
        impl core::fmt::Debug for Elsr22 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr22")
                    .field("els", &self.els())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr22 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsr22 {{ els: {:?}, reserved_8_15: {=u8:?} }}",
                    self.els(),
                    self.reserved_8_15()
                )
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr3(pub u16);
        impl Elsr3 {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> super::vals::Elsr3Els {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Elsr3Els::from_bits(val as u8)
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: super::vals::Elsr3Els) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Elsr3 {
            #[inline(always)]
            fn default() -> Elsr3 {
                Elsr3(0)
            }
        }
        impl core::fmt::Debug for Elsr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr3")
                    .field("els", &self.els())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsr3 {{ els: {:?}, reserved_8_15: {=u8:?} }}",
                    self.els(),
                    self.reserved_8_15()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Elcon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Elcon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Elcon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Elcon {
            #[inline(always)]
            fn from(val: u8) -> Elcon {
                Elcon::from_bits(val)
            }
        }
        impl From<Elcon> for u8 {
            #[inline(always)]
            fn from(val: Elcon) -> u8 {
                Elcon::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Elsr12Els(u8);
        impl Elsr12Els {}
        impl Elsr12Els {
            pub const fn from_bits(val: u8) -> Elsr12Els {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Elsr12Els {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr12Els {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Elsr12Els {
            #[inline(always)]
            fn from(val: u8) -> Elsr12Els {
                Elsr12Els::from_bits(val)
            }
        }
        impl From<Elsr12Els> for u8 {
            #[inline(always)]
            fn from(val: Elsr12Els) -> u8 {
                Elsr12Els::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Elsr1Els(u8);
        impl Elsr1Els {}
        impl Elsr1Els {
            pub const fn from_bits(val: u8) -> Elsr1Els {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Elsr1Els {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr1Els {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Elsr1Els {
            #[inline(always)]
            fn from(val: u8) -> Elsr1Els {
                Elsr1Els::from_bits(val)
            }
        }
        impl From<Elsr1Els> for u8 {
            #[inline(always)]
            fn from(val: Elsr1Els) -> u8 {
                Elsr1Els::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Elsr22Els(u8);
        impl Elsr22Els {}
        impl Elsr22Els {
            pub const fn from_bits(val: u8) -> Elsr22Els {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Elsr22Els {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr22Els {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Elsr22Els {
            #[inline(always)]
            fn from(val: u8) -> Elsr22Els {
                Elsr22Els::from_bits(val)
            }
        }
        impl From<Elsr22Els> for u8 {
            #[inline(always)]
            fn from(val: Elsr22Els) -> u8 {
                Elsr22Els::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Elsr2Els(u8);
        impl Elsr2Els {}
        impl Elsr2Els {
            pub const fn from_bits(val: u8) -> Elsr2Els {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Elsr2Els {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr2Els {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Elsr2Els {
            #[inline(always)]
            fn from(val: u8) -> Elsr2Els {
                Elsr2Els::from_bits(val)
            }
        }
        impl From<Elsr2Els> for u8 {
            #[inline(always)]
            fn from(val: Elsr2Els) -> u8 {
                Elsr2Els::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Elsr3Els(u8);
        impl Elsr3Els {}
        impl Elsr3Els {
            pub const fn from_bits(val: u8) -> Elsr3Els {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Elsr3Els {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr3Els {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Elsr3Els {
            #[inline(always)]
            fn from(val: u8) -> Elsr3Els {
                Elsr3Els::from_bits(val)
            }
        }
        impl From<Elsr3Els> for u8 {
            #[inline(always)]
            fn from(val: Elsr3Els) -> u8 {
                Elsr3Els::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ElsrEls(u8);
        impl ElsrEls {}
        impl ElsrEls {
            pub const fn from_bits(val: u8) -> ElsrEls {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for ElsrEls {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ElsrEls {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for ElsrEls {
            #[inline(always)]
            fn from(val: u8) -> ElsrEls {
                ElsrEls::from_bits(val)
            }
        }
        impl From<ElsrEls> for u8 {
            #[inline(always)]
            fn from(val: ElsrEls) -> u8 {
                ElsrEls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Seg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Seg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Seg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Seg {
            #[inline(always)]
            fn from(val: u8) -> Seg {
                Seg::from_bits(val)
            }
        }
        impl From<Seg> for u8 {
            #[inline(always)]
            fn from(val: Seg) -> u8 {
                Seg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum We {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl We {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> We {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for We {
            #[inline(always)]
            fn from(val: u8) -> We {
                We::from_bits(val)
            }
        }
        impl From<We> for u8 {
            #[inline(always)]
            fn from(val: We) -> u8 {
                We::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wi {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wi {
            #[inline(always)]
            fn from(val: u8) -> Wi {
                Wi::from_bits(val)
            }
        }
        impl From<Wi> for u8 {
            #[inline(always)]
            fn from(val: Wi) -> u8 {
                Wi::to_bits(val)
            }
        }
    }
}
pub mod fcache {
    #[doc = "Flash Cache"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fcache {
        ptr: *mut u8,
    }
    unsafe impl Send for Fcache {}
    unsafe impl Sync for Fcache {}
    impl Fcache {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Flash Cache Enable Register"]
        #[inline(always)]
        pub const fn fcachee(self) -> crate::common::Reg<regs::Fcachee, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Flash Cache Invalidate Register"]
        #[inline(always)]
        pub const fn fcacheiv(self) -> crate::common::Reg<regs::Fcacheiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Flash Cache Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fcachee(pub u16);
        impl Fcachee {
            #[doc = "FCACHE Enable"]
            #[inline(always)]
            pub const fn fcacheen(&self) -> super::vals::Fcacheen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fcacheen::from_bits(val as u8)
            }
            #[doc = "FCACHE Enable"]
            #[inline(always)]
            pub fn set_fcacheen(&mut self, val: super::vals::Fcacheen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub const fn reserved_1_15(&self) -> u16 {
                let val = (self.0 >> 1usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_1_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 1usize)) | (((val as u16) & 0x7fff) << 1usize);
            }
        }
        impl Default for Fcachee {
            #[inline(always)]
            fn default() -> Fcachee {
                Fcachee(0)
            }
        }
        impl core::fmt::Debug for Fcachee {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fcachee")
                    .field("fcacheen", &self.fcacheen())
                    .field("reserved_1_15", &self.reserved_1_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fcachee {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fcachee {{ fcacheen: {:?}, reserved_1_15: {=u16:?} }}",
                    self.fcacheen(),
                    self.reserved_1_15()
                )
            }
        }
        #[doc = "Flash Cache Invalidate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fcacheiv(pub u16);
        impl Fcacheiv {
            #[doc = "FCACHE Invalidation"]
            #[inline(always)]
            pub const fn fcacheiv(&self) -> super::vals::Fcacheiv {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fcacheiv::from_bits(val as u8)
            }
            #[doc = "FCACHE Invalidation"]
            #[inline(always)]
            pub fn set_fcacheiv(&mut self, val: super::vals::Fcacheiv) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub const fn reserved_1_15(&self) -> u16 {
                let val = (self.0 >> 1usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_1_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 1usize)) | (((val as u16) & 0x7fff) << 1usize);
            }
        }
        impl Default for Fcacheiv {
            #[inline(always)]
            fn default() -> Fcacheiv {
                Fcacheiv(0)
            }
        }
        impl core::fmt::Debug for Fcacheiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fcacheiv")
                    .field("fcacheiv", &self.fcacheiv())
                    .field("reserved_1_15", &self.reserved_1_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fcacheiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fcacheiv {{ fcacheiv: {:?}, reserved_1_15: {=u16:?} }}",
                    self.fcacheiv(),
                    self.reserved_1_15()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fcacheen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fcacheen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fcacheen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fcacheen {
            #[inline(always)]
            fn from(val: u8) -> Fcacheen {
                Fcacheen::from_bits(val)
            }
        }
        impl From<Fcacheen> for u8 {
            #[inline(always)]
            fn from(val: Fcacheen) -> u8 {
                Fcacheen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fcacheiv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fcacheiv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fcacheiv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fcacheiv {
            #[inline(always)]
            fn from(val: u8) -> Fcacheiv {
                Fcacheiv::from_bits(val)
            }
        }
        impl From<Fcacheiv> for u8 {
            #[inline(always)]
            fn from(val: Fcacheiv) -> u8 {
                Fcacheiv::to_bits(val)
            }
        }
    }
}
pub mod gpt161 {
    #[doc = "General PWM Timer 1 (16-bit)"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpt161 {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpt161 {}
    unsafe impl Sync for Gpt161 {}
    impl Gpt161 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "General PWM Timer Write,Protection Register"]
        #[inline(always)]
        pub const fn gtwp(self) -> crate::common::Reg<regs::Gtwp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "General PWM Timer Software Start Register"]
        #[inline(always)]
        pub const fn gtstr(self) -> crate::common::Reg<regs::Gtstr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "General PWM Timer Software Stop Register"]
        #[inline(always)]
        pub const fn gtstp(self) -> crate::common::Reg<regs::Gtstp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "General PWM Timer Software Clear Register"]
        #[inline(always)]
        pub const fn gtclr(self) -> crate::common::Reg<regs::Gtclr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "General PWM Timer Start Source Select Register"]
        #[inline(always)]
        pub const fn gtssr(self) -> crate::common::Reg<regs::Gtssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "General PWM Timer Stop Source Select Register"]
        #[inline(always)]
        pub const fn gtpsr(self) -> crate::common::Reg<regs::Gtpsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "General PWM Timer Clear Source Select Register"]
        #[inline(always)]
        pub const fn gtcsr(self) -> crate::common::Reg<regs::Gtcsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "General PWM Timer Up Count Source Select Register"]
        #[inline(always)]
        pub const fn gtupsr(self) -> crate::common::Reg<regs::Gtupsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "General PWM Timer Down Count Source Select Register"]
        #[inline(always)]
        pub const fn gtdnsr(self) -> crate::common::Reg<regs::Gtdnsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register A"]
        #[inline(always)]
        pub const fn gticasr(self) -> crate::common::Reg<regs::Gticasr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register B"]
        #[inline(always)]
        pub const fn gticbsr(self) -> crate::common::Reg<regs::Gticbsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "General PWM Timer Control Register"]
        #[inline(always)]
        pub const fn gtcr(self) -> crate::common::Reg<regs::Gtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "General PWM Timer Count Direction and Duty Setting Register"]
        #[inline(always)]
        pub const fn gtuddtyc(self) -> crate::common::Reg<regs::Gtuddtyc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "General PWM Timer I/O Control Register"]
        #[inline(always)]
        pub const fn gtior(self) -> crate::common::Reg<regs::Gtior, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "General PWM Timer Interrupt Output Setting Register"]
        #[inline(always)]
        pub const fn gtintad(self) -> crate::common::Reg<regs::Gtintad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "General PWM Timer Status Register"]
        #[inline(always)]
        pub const fn gtst(self) -> crate::common::Reg<regs::Gtst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "General PWM Timer Buffer Enable Register"]
        #[inline(always)]
        pub const fn gtber(self) -> crate::common::Reg<regs::Gtber, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "General PWM Timer Counter"]
        #[inline(always)]
        pub const fn gtcnt(self) -> crate::common::Reg<regs::Gtcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register A"]
        #[inline(always)]
        pub const fn gtccra(self) -> crate::common::Reg<regs::Gtccra, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register B"]
        #[inline(always)]
        pub const fn gtccrb(self) -> crate::common::Reg<regs::Gtccrb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register C"]
        #[inline(always)]
        pub const fn gtccrc(self) -> crate::common::Reg<regs::Gtccrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register E"]
        #[inline(always)]
        pub const fn gtccre(self) -> crate::common::Reg<regs::Gtccre, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register D"]
        #[inline(always)]
        pub const fn gtccrd(self) -> crate::common::Reg<regs::Gtccrd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register F"]
        #[inline(always)]
        pub const fn gtccrf(self) -> crate::common::Reg<regs::Gtccrf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "General PWM Timer Cycle Setting Register"]
        #[inline(always)]
        pub const fn gtpr(self) -> crate::common::Reg<regs::Gtpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "General PWM Timer Cycle Setting Buffer Register"]
        #[inline(always)]
        pub const fn gtpbr(self) -> crate::common::Reg<regs::Gtpbr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "General PWM Timer Dead Time Control Register"]
        #[inline(always)]
        pub const fn gtdtcr(self) -> crate::common::Reg<regs::Gtdtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "General PWM Timer Dead Time Value Register U"]
        #[inline(always)]
        pub const fn gtdvu(self) -> crate::common::Reg<regs::Gtdvu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "General PWM Timer Buffer Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtber(pub u32);
        impl Gtber {
            #[doc = "BD\\[1\\]: GTPR Buffer Operation DisableBD\\[0\\]: GTCCR Buffer Operation Disable"]
            #[inline(always)]
            pub const fn bd(&self) -> super::vals::Bd {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Bd::from_bits(val as u8)
            }
            #[doc = "BD\\[1\\]: GTPR Buffer Operation DisableBD\\[0\\]: GTCCR Buffer Operation Disable"]
            #[inline(always)]
            pub fn set_bd(&mut self, val: super::vals::Bd) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "GTCCRA Buffer Operation"]
            #[inline(always)]
            pub const fn ccra(&self) -> super::vals::Ccra {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Ccra::from_bits(val as u8)
            }
            #[doc = "GTCCRA Buffer Operation"]
            #[inline(always)]
            pub fn set_ccra(&mut self, val: super::vals::Ccra) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "GTCCRB Buffer Operation"]
            #[inline(always)]
            pub const fn ccrb(&self) -> super::vals::Ccrb {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Ccrb::from_bits(val as u8)
            }
            #[doc = "GTCCRB Buffer Operation"]
            #[inline(always)]
            pub fn set_ccrb(&mut self, val: super::vals::Ccrb) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "GTPR Buffer Operation"]
            #[inline(always)]
            pub const fn pr(&self) -> super::vals::Pr {
                let val = (self.0 >> 20usize) & 0x03;
                super::vals::Pr::from_bits(val as u8)
            }
            #[doc = "GTPR Buffer Operation"]
            #[inline(always)]
            pub fn set_pr(&mut self, val: super::vals::Pr) {
                self.0 =
                    (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
            }
            #[doc = "GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0."]
            #[inline(always)]
            pub const fn ccrswt(&self) -> super::vals::Ccrswt {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Ccrswt::from_bits(val as u8)
            }
            #[doc = "GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0."]
            #[inline(always)]
            pub fn set_ccrswt(&mut self, val: super::vals::Ccrswt) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Gtber {
            #[inline(always)]
            fn default() -> Gtber {
                Gtber(0)
            }
        }
        impl core::fmt::Debug for Gtber {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtber")
                    .field("bd", &self.bd())
                    .field("ccra", &self.ccra())
                    .field("ccrb", &self.ccrb())
                    .field("pr", &self.pr())
                    .field("ccrswt", &self.ccrswt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtber {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtber {{ bd: {:?}, ccra: {:?}, ccrb: {:?}, pr: {:?}, ccrswt: {:?} }}",
                    self.bd(),
                    self.ccra(),
                    self.ccrb(),
                    self.pr(),
                    self.ccrswt()
                )
            }
        }
        #[doc = "General PWM Timer Compare Capture Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccra(pub u32);
        impl Gtccra {
            #[doc = "Compare Capture Register A"]
            #[inline(always)]
            pub const fn gtccra(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Compare Capture Register A"]
            #[inline(always)]
            pub fn set_gtccra(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtccra {
            #[inline(always)]
            fn default() -> Gtccra {
                Gtccra(0)
            }
        }
        impl core::fmt::Debug for Gtccra {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccra")
                    .field("gtccra", &self.gtccra())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccra {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtccra {{ gtccra: {=u16:?}, reserved_16_31: {=u16:?} }}",
                    self.gtccra(),
                    self.reserved_16_31()
                )
            }
        }
        #[doc = "General PWM Timer Compare Capture Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccrb(pub u32);
        impl Gtccrb {
            #[doc = "Compare Capture Register B"]
            #[inline(always)]
            pub const fn gtccrb(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Compare Capture Register B"]
            #[inline(always)]
            pub fn set_gtccrb(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtccrb {
            #[inline(always)]
            fn default() -> Gtccrb {
                Gtccrb(0)
            }
        }
        impl core::fmt::Debug for Gtccrb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccrb")
                    .field("gtccrb", &self.gtccrb())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccrb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtccrb {{ gtccrb: {=u16:?}, reserved_16_31: {=u16:?} }}",
                    self.gtccrb(),
                    self.reserved_16_31()
                )
            }
        }
        #[doc = "General PWM Timer Compare Capture Register C"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccrc(pub u32);
        impl Gtccrc {
            #[doc = "Compare Capture Register C"]
            #[inline(always)]
            pub const fn gtccrc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Compare Capture Register C"]
            #[inline(always)]
            pub fn set_gtccrc(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtccrc {
            #[inline(always)]
            fn default() -> Gtccrc {
                Gtccrc(0)
            }
        }
        impl core::fmt::Debug for Gtccrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccrc")
                    .field("gtccrc", &self.gtccrc())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtccrc {{ gtccrc: {=u16:?}, reserved_16_31: {=u16:?} }}",
                    self.gtccrc(),
                    self.reserved_16_31()
                )
            }
        }
        #[doc = "General PWM Timer Compare Capture Register D"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccrd(pub u32);
        impl Gtccrd {
            #[doc = "Compare Capture Register D"]
            #[inline(always)]
            pub const fn gtccrd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Compare Capture Register D"]
            #[inline(always)]
            pub fn set_gtccrd(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtccrd {
            #[inline(always)]
            fn default() -> Gtccrd {
                Gtccrd(0)
            }
        }
        impl core::fmt::Debug for Gtccrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccrd")
                    .field("gtccrd", &self.gtccrd())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccrd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtccrd {{ gtccrd: {=u16:?}, reserved_16_31: {=u16:?} }}",
                    self.gtccrd(),
                    self.reserved_16_31()
                )
            }
        }
        #[doc = "General PWM Timer Compare Capture Register E"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccre(pub u32);
        impl Gtccre {
            #[doc = "Compare Capture Register E"]
            #[inline(always)]
            pub const fn gtccre(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Compare Capture Register E"]
            #[inline(always)]
            pub fn set_gtccre(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtccre {
            #[inline(always)]
            fn default() -> Gtccre {
                Gtccre(0)
            }
        }
        impl core::fmt::Debug for Gtccre {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccre")
                    .field("gtccre", &self.gtccre())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccre {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtccre {{ gtccre: {=u16:?}, reserved_16_31: {=u16:?} }}",
                    self.gtccre(),
                    self.reserved_16_31()
                )
            }
        }
        #[doc = "General PWM Timer Compare Capture Register F"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccrf(pub u32);
        impl Gtccrf {
            #[doc = "Compare Capture Register F"]
            #[inline(always)]
            pub const fn gtccrf(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Compare Capture Register F"]
            #[inline(always)]
            pub fn set_gtccrf(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtccrf {
            #[inline(always)]
            fn default() -> Gtccrf {
                Gtccrf(0)
            }
        }
        impl core::fmt::Debug for Gtccrf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccrf")
                    .field("gtccrf", &self.gtccrf())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccrf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtccrf {{ gtccrf: {=u16:?}, reserved_16_31: {=u16:?} }}",
                    self.gtccrf(),
                    self.reserved_16_31()
                )
            }
        }
        #[doc = "General PWM Timer Software Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtclr(pub u32);
        impl Gtclr {
            #[doc = "Channel 0 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr0(&self) -> super::vals::Cclr0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cclr0::from_bits(val as u8)
            }
            #[doc = "Channel 0 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr0(&mut self, val: super::vals::Cclr0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel 1 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr1(&self) -> super::vals::Cclr1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cclr1::from_bits(val as u8)
            }
            #[doc = "Channel 1 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr1(&mut self, val: super::vals::Cclr1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Channel 2 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr2(&self) -> super::vals::Cclr2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cclr2::from_bits(val as u8)
            }
            #[doc = "Channel 2 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr2(&mut self, val: super::vals::Cclr2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Channel 3 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr3(&self) -> super::vals::Cclr3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cclr3::from_bits(val as u8)
            }
            #[doc = "Channel 3 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr3(&mut self, val: super::vals::Cclr3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Channel 4 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr4(&self) -> super::vals::Cclr4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cclr4::from_bits(val as u8)
            }
            #[doc = "Channel 4 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr4(&mut self, val: super::vals::Cclr4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel 5 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr5(&self) -> super::vals::Cclr5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cclr5::from_bits(val as u8)
            }
            #[doc = "Channel 5 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr5(&mut self, val: super::vals::Cclr5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel 6 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr6(&self) -> super::vals::Cclr6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cclr6::from_bits(val as u8)
            }
            #[doc = "Channel 6 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr6(&mut self, val: super::vals::Cclr6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "The write value should be 0000000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_7_31(&self) -> u32 {
                let val = (self.0 >> 7usize) & 0x01ff_ffff;
                val as u32
            }
            #[doc = "The write value should be 0000000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_7_31(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x01ff_ffff << 7usize)) | (((val as u32) & 0x01ff_ffff) << 7usize);
            }
        }
        impl Default for Gtclr {
            #[inline(always)]
            fn default() -> Gtclr {
                Gtclr(0)
            }
        }
        impl core::fmt::Debug for Gtclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtclr")
                    .field("cclr0", &self.cclr0())
                    .field("cclr1", &self.cclr1())
                    .field("cclr2", &self.cclr2())
                    .field("cclr3", &self.cclr3())
                    .field("cclr4", &self.cclr4())
                    .field("cclr5", &self.cclr5())
                    .field("cclr6", &self.cclr6())
                    .field("reserved_7_31", &self.reserved_7_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtclr {{ cclr0: {:?}, cclr1: {:?}, cclr2: {:?}, cclr3: {:?}, cclr4: {:?}, cclr5: {:?}, cclr6: {:?}, reserved_7_31: {=u32:?} }}" , self . cclr0 () , self . cclr1 () , self . cclr2 () , self . cclr3 () , self . cclr4 () , self . cclr5 () , self . cclr6 () , self . reserved_7_31 ())
            }
        }
        #[doc = "General PWM Timer Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcnt(pub u32);
        impl Gtcnt {
            #[doc = "Counter"]
            #[inline(always)]
            pub const fn gtcnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Counter"]
            #[inline(always)]
            pub fn set_gtcnt(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtcnt {
            #[inline(always)]
            fn default() -> Gtcnt {
                Gtcnt(0)
            }
        }
        impl core::fmt::Debug for Gtcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcnt")
                    .field("gtcnt", &self.gtcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtcnt {{ gtcnt: {=u32:?} }}", self.gtcnt())
            }
        }
        #[doc = "General PWM Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcr(pub u32);
        impl Gtcr {
            #[doc = "Count Start"]
            #[inline(always)]
            pub const fn cst(&self) -> super::vals::Cst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cst::from_bits(val as u8)
            }
            #[doc = "Count Start"]
            #[inline(always)]
            pub fn set_cst(&mut self, val: super::vals::Cst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub const fn reserved_1_15(&self) -> u16 {
                let val = (self.0 >> 1usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_1_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 1usize)) | (((val as u32) & 0x7fff) << 1usize);
            }
            #[doc = "Mode Select"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Md {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Md::from_bits(val as u8)
            }
            #[doc = "Mode Select"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Md) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_19_23(&self) -> u8 {
                let val = (self.0 >> 19usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_19_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 19usize)) | (((val as u32) & 0x1f) << 19usize);
            }
            #[doc = "Timer Prescaler Select"]
            #[inline(always)]
            pub const fn tpcs(&self) -> super::vals::Tpcs {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Tpcs::from_bits(val as u8)
            }
            #[doc = "Timer Prescaler Select"]
            #[inline(always)]
            pub fn set_tpcs(&mut self, val: super::vals::Tpcs) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Gtcr {
            #[inline(always)]
            fn default() -> Gtcr {
                Gtcr(0)
            }
        }
        impl core::fmt::Debug for Gtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcr")
                    .field("cst", &self.cst())
                    .field("reserved_1_15", &self.reserved_1_15())
                    .field("md", &self.md())
                    .field("reserved_19_23", &self.reserved_19_23())
                    .field("tpcs", &self.tpcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtcr {{ cst: {:?}, reserved_1_15: {=u16:?}, md: {:?}, reserved_19_23: {=u8:?}, tpcs: {:?} }}" , self . cst () , self . reserved_1_15 () , self . md () , self . reserved_19_23 () , self . tpcs ())
            }
        }
        #[doc = "General PWM Timer Clear Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcsr(pub u32);
        impl Gtcsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgar(&self) -> super::vals::Csgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Csgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgar(&mut self, val: super::vals::Csgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgaf(&self) -> super::vals::Csgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Csgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgaf(&mut self, val: super::vals::Csgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgbr(&self) -> super::vals::Csgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Csgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgbr(&mut self, val: super::vals::Csgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgbf(&self) -> super::vals::Csgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Csgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgbf(&mut self, val: super::vals::Csgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscarbl(&self) -> super::vals::Cscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscarbl(&mut self, val: super::vals::Cscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscarbh(&self) -> super::vals::Cscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscarbh(&mut self, val: super::vals::Cscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscafbl(&self) -> super::vals::Cscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscafbl(&mut self, val: super::vals::Cscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscafbh(&self) -> super::vals::Cscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscafbh(&mut self, val: super::vals::Cscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbral(&self) -> super::vals::Cscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbral(&mut self, val: super::vals::Cscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbrah(&self) -> super::vals::Cscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbrah(&mut self, val: super::vals::Cscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbfal(&self) -> super::vals::Cscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbfal(&mut self, val: super::vals::Cscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbfah(&self) -> super::vals::Cscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbfah(&mut self, val: super::vals::Cscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselca(&self) -> super::vals::Cselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Cselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselca(&mut self, val: super::vals::Cselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcb(&self) -> super::vals::Cselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Cselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcb(&mut self, val: super::vals::Cselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcc(&self) -> super::vals::Cselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Cselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcc(&mut self, val: super::vals::Cselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcd(&self) -> super::vals::Cselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Cselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcd(&mut self, val: super::vals::Cselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub const fn reserved_20_30(&self) -> u16 {
                let val = (self.0 >> 20usize) & 0x07ff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub fn set_reserved_20_30(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 20usize)) | (((val as u32) & 0x07ff) << 20usize);
            }
            #[doc = "Software Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cclr(&self) -> super::vals::Cclr {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cclr::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cclr(&mut self, val: super::vals::Cclr) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtcsr {
            #[inline(always)]
            fn default() -> Gtcsr {
                Gtcsr(0)
            }
        }
        impl core::fmt::Debug for Gtcsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcsr")
                    .field("csgtrgar", &self.csgtrgar())
                    .field("csgtrgaf", &self.csgtrgaf())
                    .field("csgtrgbr", &self.csgtrgbr())
                    .field("csgtrgbf", &self.csgtrgbf())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .field("cscarbl", &self.cscarbl())
                    .field("cscarbh", &self.cscarbh())
                    .field("cscafbl", &self.cscafbl())
                    .field("cscafbh", &self.cscafbh())
                    .field("cscbral", &self.cscbral())
                    .field("cscbrah", &self.cscbrah())
                    .field("cscbfal", &self.cscbfal())
                    .field("cscbfah", &self.cscbfah())
                    .field("cselca", &self.cselca())
                    .field("cselcb", &self.cselcb())
                    .field("cselcc", &self.cselcc())
                    .field("cselcd", &self.cselcd())
                    .field("reserved_20_30", &self.reserved_20_30())
                    .field("cclr", &self.cclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtcsr {{ csgtrgar: {:?}, csgtrgaf: {:?}, csgtrgbr: {:?}, csgtrgbf: {:?}, reserved_4_7: {=u8:?}, cscarbl: {:?}, cscarbh: {:?}, cscafbl: {:?}, cscafbh: {:?}, cscbral: {:?}, cscbrah: {:?}, cscbfal: {:?}, cscbfah: {:?}, cselca: {:?}, cselcb: {:?}, cselcc: {:?}, cselcd: {:?}, reserved_20_30: {=u16:?}, cclr: {:?} }}" , self . csgtrgar () , self . csgtrgaf () , self . csgtrgbr () , self . csgtrgbf () , self . reserved_4_7 () , self . cscarbl () , self . cscarbh () , self . cscafbl () , self . cscafbh () , self . cscbral () , self . cscbrah () , self . cscbfal () , self . cscbfah () , self . cselca () , self . cselcb () , self . cselcc () , self . cselcd () , self . reserved_20_30 () , self . cclr ())
            }
        }
        #[doc = "General PWM Timer Down Count Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdnsr(pub u32);
        impl Gtdnsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgar(&self) -> super::vals::Dsgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dsgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgar(&mut self, val: super::vals::Dsgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgaf(&self) -> super::vals::Dsgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Dsgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgaf(&mut self, val: super::vals::Dsgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgbr(&self) -> super::vals::Dsgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dsgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgbr(&mut self, val: super::vals::Dsgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgbf(&self) -> super::vals::Dsgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dsgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgbf(&mut self, val: super::vals::Dsgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscarbl(&self) -> super::vals::Dscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Dscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscarbl(&mut self, val: super::vals::Dscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscarbh(&self) -> super::vals::Dscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Dscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscarbh(&mut self, val: super::vals::Dscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscafbl(&self) -> super::vals::Dscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Dscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscafbl(&mut self, val: super::vals::Dscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscafbh(&self) -> super::vals::Dscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Dscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscafbh(&mut self, val: super::vals::Dscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbral(&self) -> super::vals::Dscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Dscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbral(&mut self, val: super::vals::Dscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbrah(&self) -> super::vals::Dscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Dscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbrah(&mut self, val: super::vals::Dscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbfal(&self) -> super::vals::Dscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Dscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbfal(&mut self, val: super::vals::Dscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbfah(&self) -> super::vals::Dscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Dscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbfah(&mut self, val: super::vals::Dscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselca(&self) -> super::vals::Dselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Dselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselca(&mut self, val: super::vals::Dselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcb(&self) -> super::vals::Dselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Dselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcb(&mut self, val: super::vals::Dselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcc(&self) -> super::vals::Dselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Dselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcc(&mut self, val: super::vals::Dselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcd(&self) -> super::vals::Dselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Dselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcd(&mut self, val: super::vals::Dselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gtdnsr {
            #[inline(always)]
            fn default() -> Gtdnsr {
                Gtdnsr(0)
            }
        }
        impl core::fmt::Debug for Gtdnsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdnsr")
                    .field("dsgtrgar", &self.dsgtrgar())
                    .field("dsgtrgaf", &self.dsgtrgaf())
                    .field("dsgtrgbr", &self.dsgtrgbr())
                    .field("dsgtrgbf", &self.dsgtrgbf())
                    .field("dscarbl", &self.dscarbl())
                    .field("dscarbh", &self.dscarbh())
                    .field("dscafbl", &self.dscafbl())
                    .field("dscafbh", &self.dscafbh())
                    .field("dscbral", &self.dscbral())
                    .field("dscbrah", &self.dscbrah())
                    .field("dscbfal", &self.dscbfal())
                    .field("dscbfah", &self.dscbfah())
                    .field("dselca", &self.dselca())
                    .field("dselcb", &self.dselcb())
                    .field("dselcc", &self.dselcc())
                    .field("dselcd", &self.dselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdnsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtdnsr {{ dsgtrgar: {:?}, dsgtrgaf: {:?}, dsgtrgbr: {:?}, dsgtrgbf: {:?}, dscarbl: {:?}, dscarbh: {:?}, dscafbl: {:?}, dscafbh: {:?}, dscbral: {:?}, dscbrah: {:?}, dscbfal: {:?}, dscbfah: {:?}, dselca: {:?}, dselcb: {:?}, dselcc: {:?}, dselcd: {:?} }}" , self . dsgtrgar () , self . dsgtrgaf () , self . dsgtrgbr () , self . dsgtrgbf () , self . dscarbl () , self . dscarbh () , self . dscafbl () , self . dscafbh () , self . dscbral () , self . dscbrah () , self . dscbfal () , self . dscbfah () , self . dselca () , self . dselcb () , self . dselcc () , self . dselcd ())
            }
        }
        #[doc = "General PWM Timer Dead Time Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdtcr(pub u32);
        impl Gtdtcr {
            #[doc = "Negative,Phase Waveform Setting"]
            #[inline(always)]
            pub const fn tde(&self) -> super::vals::Tde {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tde::from_bits(val as u8)
            }
            #[doc = "Negative,Phase Waveform Setting"]
            #[inline(always)]
            pub fn set_tde(&mut self, val: super::vals::Tde) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000000000000000000. The write value should be 0000000000000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_1_31(&self) -> u32 {
                let val = (self.0 >> 1usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "These bits are read as 0000000000000000000000000000000. The write value should be 0000000000000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_1_31(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x7fff_ffff << 1usize)) | (((val as u32) & 0x7fff_ffff) << 1usize);
            }
        }
        impl Default for Gtdtcr {
            #[inline(always)]
            fn default() -> Gtdtcr {
                Gtdtcr(0)
            }
        }
        impl core::fmt::Debug for Gtdtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdtcr")
                    .field("tde", &self.tde())
                    .field("reserved_1_31", &self.reserved_1_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtdtcr {{ tde: {:?}, reserved_1_31: {=u32:?} }}",
                    self.tde(),
                    self.reserved_1_31()
                )
            }
        }
        #[doc = "General PWM Timer Dead Time Value Register U"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdvu(pub u32);
        impl Gtdvu {
            #[doc = "Dead Time Value Register U"]
            #[inline(always)]
            pub const fn gtdvu(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Dead Time Value Register U"]
            #[inline(always)]
            pub fn set_gtdvu(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtdvu {
            #[inline(always)]
            fn default() -> Gtdvu {
                Gtdvu(0)
            }
        }
        impl core::fmt::Debug for Gtdvu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdvu")
                    .field("gtdvu", &self.gtdvu())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdvu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtdvu {{ gtdvu: {=u16:?}, reserved_16_31: {=u16:?} }}",
                    self.gtdvu(),
                    self.reserved_16_31()
                )
            }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gticasr(pub u32);
        impl Gticasr {
            #[doc = "GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgar(&self) -> super::vals::Asgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Asgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgar(&mut self, val: super::vals::Asgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgaf(&self) -> super::vals::Asgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Asgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgaf(&mut self, val: super::vals::Asgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgbr(&self) -> super::vals::Asgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Asgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgbr(&mut self, val: super::vals::Asgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgbf(&self) -> super::vals::Asgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Asgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgbf(&mut self, val: super::vals::Asgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascarbl(&self) -> super::vals::Ascarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ascarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascarbl(&mut self, val: super::vals::Ascarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascarbh(&self) -> super::vals::Ascarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ascarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascarbh(&mut self, val: super::vals::Ascarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascafbl(&self) -> super::vals::Ascafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ascafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascafbl(&mut self, val: super::vals::Ascafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascafbh(&self) -> super::vals::Ascafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ascafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascafbh(&mut self, val: super::vals::Ascafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbral(&self) -> super::vals::Ascbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ascbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbral(&mut self, val: super::vals::Ascbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbrah(&self) -> super::vals::Ascbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ascbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbrah(&mut self, val: super::vals::Ascbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbfal(&self) -> super::vals::Ascbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ascbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbfal(&mut self, val: super::vals::Ascbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbfah(&self) -> super::vals::Ascbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ascbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbfah(&mut self, val: super::vals::Ascbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselca(&self) -> super::vals::Aselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Aselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselca(&mut self, val: super::vals::Aselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcb(&self) -> super::vals::Aselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Aselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcb(&mut self, val: super::vals::Aselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcc(&self) -> super::vals::Aselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Aselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcc(&mut self, val: super::vals::Aselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcd(&self) -> super::vals::Aselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Aselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcd(&mut self, val: super::vals::Aselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gticasr {
            #[inline(always)]
            fn default() -> Gticasr {
                Gticasr(0)
            }
        }
        impl core::fmt::Debug for Gticasr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gticasr")
                    .field("asgtrgar", &self.asgtrgar())
                    .field("asgtrgaf", &self.asgtrgaf())
                    .field("asgtrgbr", &self.asgtrgbr())
                    .field("asgtrgbf", &self.asgtrgbf())
                    .field("ascarbl", &self.ascarbl())
                    .field("ascarbh", &self.ascarbh())
                    .field("ascafbl", &self.ascafbl())
                    .field("ascafbh", &self.ascafbh())
                    .field("ascbral", &self.ascbral())
                    .field("ascbrah", &self.ascbrah())
                    .field("ascbfal", &self.ascbfal())
                    .field("ascbfah", &self.ascbfah())
                    .field("aselca", &self.aselca())
                    .field("aselcb", &self.aselcb())
                    .field("aselcc", &self.aselcc())
                    .field("aselcd", &self.aselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gticasr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gticasr {{ asgtrgar: {:?}, asgtrgaf: {:?}, asgtrgbr: {:?}, asgtrgbf: {:?}, ascarbl: {:?}, ascarbh: {:?}, ascafbl: {:?}, ascafbh: {:?}, ascbral: {:?}, ascbrah: {:?}, ascbfal: {:?}, ascbfah: {:?}, aselca: {:?}, aselcb: {:?}, aselcc: {:?}, aselcd: {:?} }}" , self . asgtrgar () , self . asgtrgaf () , self . asgtrgbr () , self . asgtrgbf () , self . ascarbl () , self . ascarbh () , self . ascafbl () , self . ascafbh () , self . ascbral () , self . ascbrah () , self . ascbfal () , self . ascbfah () , self . aselca () , self . aselcb () , self . aselcc () , self . aselcd ())
            }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gticbsr(pub u32);
        impl Gticbsr {
            #[doc = "GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgar(&self) -> super::vals::Bsgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bsgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgar(&mut self, val: super::vals::Bsgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgaf(&self) -> super::vals::Bsgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Bsgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgaf(&mut self, val: super::vals::Bsgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgbr(&self) -> super::vals::Bsgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Bsgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgbr(&mut self, val: super::vals::Bsgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgbf(&self) -> super::vals::Bsgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bsgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgbf(&mut self, val: super::vals::Bsgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscarbl(&self) -> super::vals::Bscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Bscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscarbl(&mut self, val: super::vals::Bscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscarbh(&self) -> super::vals::Bscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Bscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscarbh(&mut self, val: super::vals::Bscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscafbl(&self) -> super::vals::Bscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscafbl(&mut self, val: super::vals::Bscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscafbh(&self) -> super::vals::Bscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Bscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscafbh(&mut self, val: super::vals::Bscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbral(&self) -> super::vals::Bscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Bscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbral(&mut self, val: super::vals::Bscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbrah(&self) -> super::vals::Bscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Bscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbrah(&mut self, val: super::vals::Bscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbfal(&self) -> super::vals::Bscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Bscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbfal(&mut self, val: super::vals::Bscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbfah(&self) -> super::vals::Bscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Bscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbfah(&mut self, val: super::vals::Bscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselca(&self) -> super::vals::Bselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Bselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselca(&mut self, val: super::vals::Bselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcb(&self) -> super::vals::Bselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Bselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcb(&mut self, val: super::vals::Bselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcc(&self) -> super::vals::Bselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Bselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcc(&mut self, val: super::vals::Bselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcd(&self) -> super::vals::Bselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Bselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcd(&mut self, val: super::vals::Bselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gticbsr {
            #[inline(always)]
            fn default() -> Gticbsr {
                Gticbsr(0)
            }
        }
        impl core::fmt::Debug for Gticbsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gticbsr")
                    .field("bsgtrgar", &self.bsgtrgar())
                    .field("bsgtrgaf", &self.bsgtrgaf())
                    .field("bsgtrgbr", &self.bsgtrgbr())
                    .field("bsgtrgbf", &self.bsgtrgbf())
                    .field("bscarbl", &self.bscarbl())
                    .field("bscarbh", &self.bscarbh())
                    .field("bscafbl", &self.bscafbl())
                    .field("bscafbh", &self.bscafbh())
                    .field("bscbral", &self.bscbral())
                    .field("bscbrah", &self.bscbrah())
                    .field("bscbfal", &self.bscbfal())
                    .field("bscbfah", &self.bscbfah())
                    .field("bselca", &self.bselca())
                    .field("bselcb", &self.bselcb())
                    .field("bselcc", &self.bselcc())
                    .field("bselcd", &self.bselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gticbsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gticbsr {{ bsgtrgar: {:?}, bsgtrgaf: {:?}, bsgtrgbr: {:?}, bsgtrgbf: {:?}, bscarbl: {:?}, bscarbh: {:?}, bscafbl: {:?}, bscafbh: {:?}, bscbral: {:?}, bscbrah: {:?}, bscbfal: {:?}, bscbfah: {:?}, bselca: {:?}, bselcb: {:?}, bselcc: {:?}, bselcd: {:?} }}" , self . bsgtrgar () , self . bsgtrgaf () , self . bsgtrgbr () , self . bsgtrgbf () , self . bscarbl () , self . bscarbh () , self . bscafbl () , self . bscafbh () , self . bscbral () , self . bscbrah () , self . bscbfal () , self . bscbfah () , self . bselca () , self . bselcb () , self . bselcc () , self . bselcd ())
            }
        }
        #[doc = "General PWM Timer Interrupt Output Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtintad(pub u32);
        impl Gtintad {
            #[doc = "These bits are read as 000000000000000000000000. The write value should be 000000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_0_23(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "These bits are read as 000000000000000000000000. The write value should be 000000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_0_23(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "Output Disable Source Select"]
            #[inline(always)]
            pub const fn grp(&self) -> super::vals::Grp {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Grp::from_bits(val as u8)
            }
            #[doc = "Output Disable Source Select"]
            #[inline(always)]
            pub fn set_grp(&mut self, val: super::vals::Grp) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_26_28(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_26_28(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 26usize)) | (((val as u32) & 0x07) << 26usize);
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub const fn grpabh(&self) -> super::vals::Grpabh {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Grpabh::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub fn set_grpabh(&mut self, val: super::vals::Grpabh) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub const fn grpabl(&self) -> super::vals::Grpabl {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Grpabl::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub fn set_grpabl(&mut self, val: super::vals::Grpabl) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Gtintad {
            #[inline(always)]
            fn default() -> Gtintad {
                Gtintad(0)
            }
        }
        impl core::fmt::Debug for Gtintad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtintad")
                    .field("reserved_0_23", &self.reserved_0_23())
                    .field("grp", &self.grp())
                    .field("reserved_26_28", &self.reserved_26_28())
                    .field("grpabh", &self.grpabh())
                    .field("grpabl", &self.grpabl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtintad {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtintad {{ reserved_0_23: {=u32:?}, grp: {:?}, reserved_26_28: {=u8:?}, grpabh: {:?}, grpabl: {:?} }}" , self . reserved_0_23 () , self . grp () , self . reserved_26_28 () , self . grpabh () , self . grpabl ())
            }
        }
        #[doc = "General PWM Timer I/O Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtior(pub u32);
        impl Gtior {
            #[doc = "GTIOCA Pin Function Select"]
            #[inline(always)]
            pub const fn gtioa(&self) -> super::vals::Gtioa {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Gtioa::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Function Select"]
            #[inline(always)]
            pub fn set_gtioa(&mut self, val: super::vals::Gtioa) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GTIOCA Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub const fn oadflt(&self) -> super::vals::Oadflt {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Oadflt::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub fn set_oadflt(&mut self, val: super::vals::Oadflt) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "GTIOCA Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub const fn oahld(&self) -> super::vals::Oahld {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Oahld::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub fn set_oahld(&mut self, val: super::vals::Oahld) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "GTIOCA Pin Output Enable"]
            #[inline(always)]
            pub const fn oae(&self) -> super::vals::Oae {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Oae::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Output Enable"]
            #[inline(always)]
            pub fn set_oae(&mut self, val: super::vals::Oae) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Disable Value Setting"]
            #[inline(always)]
            pub const fn oadf(&self) -> super::vals::Oadf {
                let val = (self.0 >> 9usize) & 0x03;
                super::vals::Oadf::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Disable Value Setting"]
            #[inline(always)]
            pub fn set_oadf(&mut self, val: super::vals::Oadf) {
                self.0 = (self.0 & !(0x03 << 9usize)) | (((val.to_bits() as u32) & 0x03) << 9usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_11_12(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_11_12(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 11usize)) | (((val as u32) & 0x03) << 11usize);
            }
            #[doc = "Noise Filter A Enable"]
            #[inline(always)]
            pub const fn nfaen(&self) -> super::vals::Nfaen {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Nfaen::from_bits(val as u8)
            }
            #[doc = "Noise Filter A Enable"]
            #[inline(always)]
            pub fn set_nfaen(&mut self, val: super::vals::Nfaen) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Noise Filter A Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfcsa(&self) -> super::vals::Nfcsa {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Nfcsa::from_bits(val as u8)
            }
            #[doc = "Noise Filter A Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfcsa(&mut self, val: super::vals::Nfcsa) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u32) & 0x03) << 14usize);
            }
            #[doc = "GTIOCB Pin Function Select"]
            #[inline(always)]
            pub const fn gtiob(&self) -> super::vals::Gtiob {
                let val = (self.0 >> 16usize) & 0x1f;
                super::vals::Gtiob::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Function Select"]
            #[inline(always)]
            pub fn set_gtiob(&mut self, val: super::vals::Gtiob) {
                self.0 =
                    (self.0 & !(0x1f << 16usize)) | (((val.to_bits() as u32) & 0x1f) << 16usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_21_21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_21_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GTIOCB Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub const fn obdflt(&self) -> super::vals::Obdflt {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Obdflt::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub fn set_obdflt(&mut self, val: super::vals::Obdflt) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "GTIOCB Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub const fn obhld(&self) -> super::vals::Obhld {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Obhld::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub fn set_obhld(&mut self, val: super::vals::Obhld) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "GTIOCB Pin Output Enable"]
            #[inline(always)]
            pub const fn obe(&self) -> super::vals::Obe {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Obe::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Output Enable"]
            #[inline(always)]
            pub fn set_obe(&mut self, val: super::vals::Obe) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "GTIOCB Pin Disable Value Setting"]
            #[inline(always)]
            pub const fn obdf(&self) -> super::vals::Obdf {
                let val = (self.0 >> 25usize) & 0x03;
                super::vals::Obdf::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Disable Value Setting"]
            #[inline(always)]
            pub fn set_obdf(&mut self, val: super::vals::Obdf) {
                self.0 =
                    (self.0 & !(0x03 << 25usize)) | (((val.to_bits() as u32) & 0x03) << 25usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_27_28(&self) -> u8 {
                let val = (self.0 >> 27usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_27_28(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 27usize)) | (((val as u32) & 0x03) << 27usize);
            }
            #[doc = "Noise Filter B Enable"]
            #[inline(always)]
            pub const fn nfben(&self) -> super::vals::Nfben {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Nfben::from_bits(val as u8)
            }
            #[doc = "Noise Filter B Enable"]
            #[inline(always)]
            pub fn set_nfben(&mut self, val: super::vals::Nfben) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Noise Filter B Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfcsb(&self) -> super::vals::Nfcsb {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::Nfcsb::from_bits(val as u8)
            }
            #[doc = "Noise Filter B Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfcsb(&mut self, val: super::vals::Nfcsb) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Gtior {
            #[inline(always)]
            fn default() -> Gtior {
                Gtior(0)
            }
        }
        impl core::fmt::Debug for Gtior {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtior")
                    .field("gtioa", &self.gtioa())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("oadflt", &self.oadflt())
                    .field("oahld", &self.oahld())
                    .field("oae", &self.oae())
                    .field("oadf", &self.oadf())
                    .field("reserved_11_12", &self.reserved_11_12())
                    .field("nfaen", &self.nfaen())
                    .field("nfcsa", &self.nfcsa())
                    .field("gtiob", &self.gtiob())
                    .field("reserved_21_21", &self.reserved_21_21())
                    .field("obdflt", &self.obdflt())
                    .field("obhld", &self.obhld())
                    .field("obe", &self.obe())
                    .field("obdf", &self.obdf())
                    .field("reserved_27_28", &self.reserved_27_28())
                    .field("nfben", &self.nfben())
                    .field("nfcsb", &self.nfcsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtior {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtior {{ gtioa: {:?}, reserved_5_5: {=bool:?}, oadflt: {:?}, oahld: {:?}, oae: {:?}, oadf: {:?}, reserved_11_12: {=u8:?}, nfaen: {:?}, nfcsa: {:?}, gtiob: {:?}, reserved_21_21: {=bool:?}, obdflt: {:?}, obhld: {:?}, obe: {:?}, obdf: {:?}, reserved_27_28: {=u8:?}, nfben: {:?}, nfcsb: {:?} }}" , self . gtioa () , self . reserved_5_5 () , self . oadflt () , self . oahld () , self . oae () , self . oadf () , self . reserved_11_12 () , self . nfaen () , self . nfcsa () , self . gtiob () , self . reserved_21_21 () , self . obdflt () , self . obhld () , self . obe () , self . obdf () , self . reserved_27_28 () , self . nfben () , self . nfcsb ())
            }
        }
        #[doc = "General PWM Timer Cycle Setting Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtpbr(pub u32);
        impl Gtpbr {
            #[doc = "Cycle Setting Buffer Register"]
            #[inline(always)]
            pub const fn gtpbr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Cycle Setting Buffer Register"]
            #[inline(always)]
            pub fn set_gtpbr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtpbr {
            #[inline(always)]
            fn default() -> Gtpbr {
                Gtpbr(0)
            }
        }
        impl core::fmt::Debug for Gtpbr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtpbr")
                    .field("gtpbr", &self.gtpbr())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtpbr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtpbr {{ gtpbr: {=u16:?}, reserved_16_31: {=u16:?} }}",
                    self.gtpbr(),
                    self.reserved_16_31()
                )
            }
        }
        #[doc = "General PWM Timer Cycle Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtpr(pub u32);
        impl Gtpr {
            #[doc = "Cycle Setting Register"]
            #[inline(always)]
            pub const fn gtpr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Cycle Setting Register"]
            #[inline(always)]
            pub fn set_gtpr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtpr {
            #[inline(always)]
            fn default() -> Gtpr {
                Gtpr(0)
            }
        }
        impl core::fmt::Debug for Gtpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtpr")
                    .field("gtpr", &self.gtpr())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtpr {{ gtpr: {=u16:?}, reserved_16_31: {=u16:?} }}",
                    self.gtpr(),
                    self.reserved_16_31()
                )
            }
        }
        #[doc = "General PWM Timer Stop Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtpsr(pub u32);
        impl Gtpsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgar(&self) -> super::vals::Psgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Psgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgar(&mut self, val: super::vals::Psgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgaf(&self) -> super::vals::Psgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Psgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgaf(&mut self, val: super::vals::Psgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgbr(&self) -> super::vals::Psgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Psgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgbr(&mut self, val: super::vals::Psgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgbf(&self) -> super::vals::Psgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Psgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgbf(&mut self, val: super::vals::Psgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscarbl(&self) -> super::vals::Pscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscarbl(&mut self, val: super::vals::Pscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscarbh(&self) -> super::vals::Pscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscarbh(&mut self, val: super::vals::Pscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscafbl(&self) -> super::vals::Pscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscafbl(&mut self, val: super::vals::Pscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscafbh(&self) -> super::vals::Pscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscafbh(&mut self, val: super::vals::Pscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbral(&self) -> super::vals::Pscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbral(&mut self, val: super::vals::Pscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbrah(&self) -> super::vals::Pscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbrah(&mut self, val: super::vals::Pscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbfal(&self) -> super::vals::Pscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbfal(&mut self, val: super::vals::Pscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbfah(&self) -> super::vals::Pscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbfah(&mut self, val: super::vals::Pscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselca(&self) -> super::vals::Pselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselca(&mut self, val: super::vals::Pselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcb(&self) -> super::vals::Pselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcb(&mut self, val: super::vals::Pselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcc(&self) -> super::vals::Pselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcc(&mut self, val: super::vals::Pselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcd(&self) -> super::vals::Pselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcd(&mut self, val: super::vals::Pselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub const fn reserved_20_30(&self) -> u16 {
                let val = (self.0 >> 20usize) & 0x07ff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub fn set_reserved_20_30(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 20usize)) | (((val as u32) & 0x07ff) << 20usize);
            }
            #[doc = "Software Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn cstop(&self) -> super::vals::Cstop {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cstop::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_cstop(&mut self, val: super::vals::Cstop) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtpsr {
            #[inline(always)]
            fn default() -> Gtpsr {
                Gtpsr(0)
            }
        }
        impl core::fmt::Debug for Gtpsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtpsr")
                    .field("psgtrgar", &self.psgtrgar())
                    .field("psgtrgaf", &self.psgtrgaf())
                    .field("psgtrgbr", &self.psgtrgbr())
                    .field("psgtrgbf", &self.psgtrgbf())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .field("pscarbl", &self.pscarbl())
                    .field("pscarbh", &self.pscarbh())
                    .field("pscafbl", &self.pscafbl())
                    .field("pscafbh", &self.pscafbh())
                    .field("pscbral", &self.pscbral())
                    .field("pscbrah", &self.pscbrah())
                    .field("pscbfal", &self.pscbfal())
                    .field("pscbfah", &self.pscbfah())
                    .field("pselca", &self.pselca())
                    .field("pselcb", &self.pselcb())
                    .field("pselcc", &self.pselcc())
                    .field("pselcd", &self.pselcd())
                    .field("reserved_20_30", &self.reserved_20_30())
                    .field("cstop", &self.cstop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtpsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtpsr {{ psgtrgar: {:?}, psgtrgaf: {:?}, psgtrgbr: {:?}, psgtrgbf: {:?}, reserved_4_7: {=u8:?}, pscarbl: {:?}, pscarbh: {:?}, pscafbl: {:?}, pscafbh: {:?}, pscbral: {:?}, pscbrah: {:?}, pscbfal: {:?}, pscbfah: {:?}, pselca: {:?}, pselcb: {:?}, pselcc: {:?}, pselcd: {:?}, reserved_20_30: {=u16:?}, cstop: {:?} }}" , self . psgtrgar () , self . psgtrgaf () , self . psgtrgbr () , self . psgtrgbf () , self . reserved_4_7 () , self . pscarbl () , self . pscarbh () , self . pscafbl () , self . pscafbh () , self . pscbral () , self . pscbrah () , self . pscbfal () , self . pscbfah () , self . pselca () , self . pselcb () , self . pselcc () , self . pselcd () , self . reserved_20_30 () , self . cstop ())
            }
        }
        #[doc = "General PWM Timer Start Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtssr(pub u32);
        impl Gtssr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgar(&self) -> super::vals::Ssgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgar(&mut self, val: super::vals::Ssgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgaf(&self) -> super::vals::Ssgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgaf(&mut self, val: super::vals::Ssgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgbr(&self) -> super::vals::Ssgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ssgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgbr(&mut self, val: super::vals::Ssgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgbf(&self) -> super::vals::Ssgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ssgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgbf(&mut self, val: super::vals::Ssgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscarbl(&self) -> super::vals::Sscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Sscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscarbl(&mut self, val: super::vals::Sscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscarbh(&self) -> super::vals::Sscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Sscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscarbh(&mut self, val: super::vals::Sscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscafbl(&self) -> super::vals::Sscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Sscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscafbl(&mut self, val: super::vals::Sscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscafbh(&self) -> super::vals::Sscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Sscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscafbh(&mut self, val: super::vals::Sscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbral(&self) -> super::vals::Sscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Sscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbral(&mut self, val: super::vals::Sscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbrah(&self) -> super::vals::Sscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Sscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbrah(&mut self, val: super::vals::Sscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbfal(&self) -> super::vals::Sscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Sscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbfal(&mut self, val: super::vals::Sscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbfah(&self) -> super::vals::Sscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbfah(&mut self, val: super::vals::Sscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselca(&self) -> super::vals::Sselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Sselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselca(&mut self, val: super::vals::Sselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcb(&self) -> super::vals::Sselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Sselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcb(&mut self, val: super::vals::Sselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcc(&self) -> super::vals::Sselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Sselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcc(&mut self, val: super::vals::Sselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcd(&self) -> super::vals::Sselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Sselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcd(&mut self, val: super::vals::Sselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub const fn reserved_20_30(&self) -> u16 {
                let val = (self.0 >> 20usize) & 0x07ff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub fn set_reserved_20_30(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 20usize)) | (((val as u32) & 0x07ff) << 20usize);
            }
            #[doc = "Software Source Counter Start Enable"]
            #[inline(always)]
            pub const fn cstrt(&self) -> super::vals::Cstrt {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cstrt::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_cstrt(&mut self, val: super::vals::Cstrt) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtssr {
            #[inline(always)]
            fn default() -> Gtssr {
                Gtssr(0)
            }
        }
        impl core::fmt::Debug for Gtssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtssr")
                    .field("ssgtrgar", &self.ssgtrgar())
                    .field("ssgtrgaf", &self.ssgtrgaf())
                    .field("ssgtrgbr", &self.ssgtrgbr())
                    .field("ssgtrgbf", &self.ssgtrgbf())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .field("sscarbl", &self.sscarbl())
                    .field("sscarbh", &self.sscarbh())
                    .field("sscafbl", &self.sscafbl())
                    .field("sscafbh", &self.sscafbh())
                    .field("sscbral", &self.sscbral())
                    .field("sscbrah", &self.sscbrah())
                    .field("sscbfal", &self.sscbfal())
                    .field("sscbfah", &self.sscbfah())
                    .field("sselca", &self.sselca())
                    .field("sselcb", &self.sselcb())
                    .field("sselcc", &self.sselcc())
                    .field("sselcd", &self.sselcd())
                    .field("reserved_20_30", &self.reserved_20_30())
                    .field("cstrt", &self.cstrt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtssr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtssr {{ ssgtrgar: {:?}, ssgtrgaf: {:?}, ssgtrgbr: {:?}, ssgtrgbf: {:?}, reserved_4_7: {=u8:?}, sscarbl: {:?}, sscarbh: {:?}, sscafbl: {:?}, sscafbh: {:?}, sscbral: {:?}, sscbrah: {:?}, sscbfal: {:?}, sscbfah: {:?}, sselca: {:?}, sselcb: {:?}, sselcc: {:?}, sselcd: {:?}, reserved_20_30: {=u16:?}, cstrt: {:?} }}" , self . ssgtrgar () , self . ssgtrgaf () , self . ssgtrgbr () , self . ssgtrgbf () , self . reserved_4_7 () , self . sscarbl () , self . sscarbh () , self . sscafbl () , self . sscafbh () , self . sscbral () , self . sscbrah () , self . sscbfal () , self . sscbfah () , self . sselca () , self . sselcb () , self . sselcc () , self . sselcd () , self . reserved_20_30 () , self . cstrt ())
            }
        }
        #[doc = "General PWM Timer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtst(pub u32);
        impl Gtst {
            #[doc = "Input Capture/Compare Match Flag A"]
            #[inline(always)]
            pub const fn tcfa(&self) -> super::vals::Tcfa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tcfa::from_bits(val as u8)
            }
            #[doc = "Input Capture/Compare Match Flag A"]
            #[inline(always)]
            pub fn set_tcfa(&mut self, val: super::vals::Tcfa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Input Capture/Compare Match Flag B"]
            #[inline(always)]
            pub const fn tcfb(&self) -> super::vals::Tcfb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tcfb::from_bits(val as u8)
            }
            #[doc = "Input Capture/Compare Match Flag B"]
            #[inline(always)]
            pub fn set_tcfb(&mut self, val: super::vals::Tcfb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Input Compare Match Flag C"]
            #[inline(always)]
            pub const fn tcfc(&self) -> super::vals::Tcfc {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tcfc::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag C"]
            #[inline(always)]
            pub fn set_tcfc(&mut self, val: super::vals::Tcfc) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Input Compare Match Flag D"]
            #[inline(always)]
            pub const fn tcfd(&self) -> super::vals::Tcfd {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tcfd::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag D"]
            #[inline(always)]
            pub fn set_tcfd(&mut self, val: super::vals::Tcfd) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Input Compare Match Flag E"]
            #[inline(always)]
            pub const fn tcfe(&self) -> super::vals::Tcfe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tcfe::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag E"]
            #[inline(always)]
            pub fn set_tcfe(&mut self, val: super::vals::Tcfe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Input Compare Match Flag F"]
            #[inline(always)]
            pub const fn tcff(&self) -> super::vals::Tcff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tcff::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag F"]
            #[inline(always)]
            pub fn set_tcff(&mut self, val: super::vals::Tcff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub const fn tcpfo(&self) -> super::vals::Tcpfo {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tcpfo::from_bits(val as u8)
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub fn set_tcpfo(&mut self, val: super::vals::Tcpfo) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn tcfpu(&self) -> super::vals::Tcfpu {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tcfpu::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_tcfpu(&mut self, val: super::vals::Tcfpu) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_8_14(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_8_14(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 8usize)) | (((val as u32) & 0x7f) << 8usize);
            }
            #[doc = "Count Direction Flag"]
            #[inline(always)]
            pub const fn gtcf(&self) -> super::vals::Gtcf {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Gtcf::from_bits(val as u8)
            }
            #[doc = "Count Direction Flag"]
            #[inline(always)]
            pub fn set_gtcf(&mut self, val: super::vals::Gtcf) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_16_23(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_16_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Output Disable Flag"]
            #[inline(always)]
            pub const fn odf(&self) -> super::vals::Odf {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Odf::from_bits(val as u8)
            }
            #[doc = "Output Disable Flag"]
            #[inline(always)]
            pub fn set_odf(&mut self, val: super::vals::Odf) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_25_28(&self) -> u8 {
                let val = (self.0 >> 25usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_25_28(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 25usize)) | (((val as u32) & 0x0f) << 25usize);
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub const fn oabhf(&self) -> super::vals::Oabhf {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Oabhf::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub fn set_oabhf(&mut self, val: super::vals::Oabhf) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub const fn oablf(&self) -> super::vals::Oablf {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Oablf::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub fn set_oablf(&mut self, val: super::vals::Oablf) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Gtst {
            #[inline(always)]
            fn default() -> Gtst {
                Gtst(0)
            }
        }
        impl core::fmt::Debug for Gtst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtst")
                    .field("tcfa", &self.tcfa())
                    .field("tcfb", &self.tcfb())
                    .field("tcfc", &self.tcfc())
                    .field("tcfd", &self.tcfd())
                    .field("tcfe", &self.tcfe())
                    .field("tcff", &self.tcff())
                    .field("tcpfo", &self.tcpfo())
                    .field("tcfpu", &self.tcfpu())
                    .field("reserved_8_14", &self.reserved_8_14())
                    .field("gtcf", &self.gtcf())
                    .field("reserved_16_23", &self.reserved_16_23())
                    .field("odf", &self.odf())
                    .field("reserved_25_28", &self.reserved_25_28())
                    .field("oabhf", &self.oabhf())
                    .field("oablf", &self.oablf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtst {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtst {{ tcfa: {:?}, tcfb: {:?}, tcfc: {:?}, tcfd: {:?}, tcfe: {:?}, tcff: {:?}, tcpfo: {:?}, tcfpu: {:?}, reserved_8_14: {=u8:?}, gtcf: {:?}, reserved_16_23: {=u8:?}, odf: {:?}, reserved_25_28: {=u8:?}, oabhf: {:?}, oablf: {:?} }}" , self . tcfa () , self . tcfb () , self . tcfc () , self . tcfd () , self . tcfe () , self . tcff () , self . tcpfo () , self . tcfpu () , self . reserved_8_14 () , self . gtcf () , self . reserved_16_23 () , self . odf () , self . reserved_25_28 () , self . oabhf () , self . oablf ())
            }
        }
        #[doc = "General PWM Timer Software Stop Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtstp(pub u32);
        impl Gtstp {
            #[doc = "Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop0(&self) -> super::vals::Cstop0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cstop0::from_bits(val as u8)
            }
            #[doc = "Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop0(&mut self, val: super::vals::Cstop0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop1(&self) -> super::vals::Cstop1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cstop1::from_bits(val as u8)
            }
            #[doc = "Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop1(&mut self, val: super::vals::Cstop1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop2(&self) -> super::vals::Cstop2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cstop2::from_bits(val as u8)
            }
            #[doc = "Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop2(&mut self, val: super::vals::Cstop2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop3(&self) -> super::vals::Cstop3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cstop3::from_bits(val as u8)
            }
            #[doc = "Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop3(&mut self, val: super::vals::Cstop3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop4(&self) -> super::vals::Cstop4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cstop4::from_bits(val as u8)
            }
            #[doc = "Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop4(&mut self, val: super::vals::Cstop4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop5(&self) -> super::vals::Cstop5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cstop5::from_bits(val as u8)
            }
            #[doc = "Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop5(&mut self, val: super::vals::Cstop5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop6(&self) -> super::vals::Cstop6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cstop6::from_bits(val as u8)
            }
            #[doc = "Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop6(&mut self, val: super::vals::Cstop6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 1111111111111111111111111. The write value should be 1111111111111111111111111."]
            #[inline(always)]
            pub const fn reserved_7_31(&self) -> u32 {
                let val = (self.0 >> 7usize) & 0x01ff_ffff;
                val as u32
            }
            #[doc = "These bits are read as 1111111111111111111111111. The write value should be 1111111111111111111111111."]
            #[inline(always)]
            pub fn set_reserved_7_31(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x01ff_ffff << 7usize)) | (((val as u32) & 0x01ff_ffff) << 7usize);
            }
        }
        impl Default for Gtstp {
            #[inline(always)]
            fn default() -> Gtstp {
                Gtstp(0)
            }
        }
        impl core::fmt::Debug for Gtstp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtstp")
                    .field("cstop0", &self.cstop0())
                    .field("cstop1", &self.cstop1())
                    .field("cstop2", &self.cstop2())
                    .field("cstop3", &self.cstop3())
                    .field("cstop4", &self.cstop4())
                    .field("cstop5", &self.cstop5())
                    .field("cstop6", &self.cstop6())
                    .field("reserved_7_31", &self.reserved_7_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtstp {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtstp {{ cstop0: {:?}, cstop1: {:?}, cstop2: {:?}, cstop3: {:?}, cstop4: {:?}, cstop5: {:?}, cstop6: {:?}, reserved_7_31: {=u32:?} }}" , self . cstop0 () , self . cstop1 () , self . cstop2 () , self . cstop3 () , self . cstop4 () , self . cstop5 () , self . cstop6 () , self . reserved_7_31 ())
            }
        }
        #[doc = "General PWM Timer Software Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtstr(pub u32);
        impl Gtstr {
            #[doc = "Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt0(&self) -> super::vals::Cstrt0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cstrt0::from_bits(val as u8)
            }
            #[doc = "Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt0(&mut self, val: super::vals::Cstrt0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt1(&self) -> super::vals::Cstrt1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cstrt1::from_bits(val as u8)
            }
            #[doc = "Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt1(&mut self, val: super::vals::Cstrt1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt2(&self) -> super::vals::Cstrt2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cstrt2::from_bits(val as u8)
            }
            #[doc = "Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt2(&mut self, val: super::vals::Cstrt2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt3(&self) -> super::vals::Cstrt3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cstrt3::from_bits(val as u8)
            }
            #[doc = "Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt3(&mut self, val: super::vals::Cstrt3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt4(&self) -> super::vals::Cstrt4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cstrt4::from_bits(val as u8)
            }
            #[doc = "Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt4(&mut self, val: super::vals::Cstrt4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt5(&self) -> super::vals::Cstrt5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cstrt5::from_bits(val as u8)
            }
            #[doc = "Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt5(&mut self, val: super::vals::Cstrt5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt6(&self) -> super::vals::Cstrt6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cstrt6::from_bits(val as u8)
            }
            #[doc = "Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt6(&mut self, val: super::vals::Cstrt6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 0000000000000000000000000. The write value should be 0000000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_7_31(&self) -> u32 {
                let val = (self.0 >> 7usize) & 0x01ff_ffff;
                val as u32
            }
            #[doc = "These bits are read as 0000000000000000000000000. The write value should be 0000000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_7_31(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x01ff_ffff << 7usize)) | (((val as u32) & 0x01ff_ffff) << 7usize);
            }
        }
        impl Default for Gtstr {
            #[inline(always)]
            fn default() -> Gtstr {
                Gtstr(0)
            }
        }
        impl core::fmt::Debug for Gtstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtstr")
                    .field("cstrt0", &self.cstrt0())
                    .field("cstrt1", &self.cstrt1())
                    .field("cstrt2", &self.cstrt2())
                    .field("cstrt3", &self.cstrt3())
                    .field("cstrt4", &self.cstrt4())
                    .field("cstrt5", &self.cstrt5())
                    .field("cstrt6", &self.cstrt6())
                    .field("reserved_7_31", &self.reserved_7_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtstr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtstr {{ cstrt0: {:?}, cstrt1: {:?}, cstrt2: {:?}, cstrt3: {:?}, cstrt4: {:?}, cstrt5: {:?}, cstrt6: {:?}, reserved_7_31: {=u32:?} }}" , self . cstrt0 () , self . cstrt1 () , self . cstrt2 () , self . cstrt3 () , self . cstrt4 () , self . cstrt5 () , self . cstrt6 () , self . reserved_7_31 ())
            }
        }
        #[doc = "General PWM Timer Count Direction and Duty Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtuddtyc(pub u32);
        impl Gtuddtyc {
            #[doc = "Count Direction Setting"]
            #[inline(always)]
            pub const fn ud(&self) -> super::vals::Ud {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ud::from_bits(val as u8)
            }
            #[doc = "Count Direction Setting"]
            #[inline(always)]
            pub fn set_ud(&mut self, val: super::vals::Ud) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Forcible Count Direction Setting"]
            #[inline(always)]
            pub const fn udf(&self) -> super::vals::Udf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Udf::from_bits(val as u8)
            }
            #[doc = "Forcible Count Direction Setting"]
            #[inline(always)]
            pub fn set_udf(&mut self, val: super::vals::Udf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTIOCA Output Duty Setting"]
            #[inline(always)]
            pub const fn oadty(&self) -> super::vals::Oadty {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Oadty::from_bits(val as u8)
            }
            #[doc = "GTIOCA Output Duty Setting"]
            #[inline(always)]
            pub fn set_oadty(&mut self, val: super::vals::Oadty) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "Forcible GTIOCA Output Duty Setting"]
            #[inline(always)]
            pub const fn oadtyf(&self) -> super::vals::Oadtyf {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oadtyf::from_bits(val as u8)
            }
            #[doc = "Forcible GTIOCA Output Duty Setting"]
            #[inline(always)]
            pub fn set_oadtyf(&mut self, val: super::vals::Oadtyf) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting"]
            #[inline(always)]
            pub const fn oadtyr(&self) -> super::vals::Oadtyr {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oadtyr::from_bits(val as u8)
            }
            #[doc = "GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting"]
            #[inline(always)]
            pub fn set_oadtyr(&mut self, val: super::vals::Oadtyr) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_20_23(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_20_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "GTIOCB Output Duty Setting"]
            #[inline(always)]
            pub const fn obdty(&self) -> super::vals::Obdty {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Obdty::from_bits(val as u8)
            }
            #[doc = "GTIOCB Output Duty Setting"]
            #[inline(always)]
            pub fn set_obdty(&mut self, val: super::vals::Obdty) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Forcible GTIOCB Output Duty Setting"]
            #[inline(always)]
            pub const fn obdtyf(&self) -> super::vals::Obdtyf {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Obdtyf::from_bits(val as u8)
            }
            #[doc = "Forcible GTIOCB Output Duty Setting"]
            #[inline(always)]
            pub fn set_obdtyf(&mut self, val: super::vals::Obdtyf) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting"]
            #[inline(always)]
            pub const fn obdtyr(&self) -> super::vals::Obdtyr {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Obdtyr::from_bits(val as u8)
            }
            #[doc = "GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting"]
            #[inline(always)]
            pub fn set_obdtyr(&mut self, val: super::vals::Obdtyr) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Gtuddtyc {
            #[inline(always)]
            fn default() -> Gtuddtyc {
                Gtuddtyc(0)
            }
        }
        impl core::fmt::Debug for Gtuddtyc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtuddtyc")
                    .field("ud", &self.ud())
                    .field("udf", &self.udf())
                    .field("oadty", &self.oadty())
                    .field("oadtyf", &self.oadtyf())
                    .field("oadtyr", &self.oadtyr())
                    .field("reserved_20_23", &self.reserved_20_23())
                    .field("obdty", &self.obdty())
                    .field("obdtyf", &self.obdtyf())
                    .field("obdtyr", &self.obdtyr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtuddtyc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtuddtyc {{ ud: {:?}, udf: {:?}, oadty: {:?}, oadtyf: {:?}, oadtyr: {:?}, reserved_20_23: {=u8:?}, obdty: {:?}, obdtyf: {:?}, obdtyr: {:?} }}" , self . ud () , self . udf () , self . oadty () , self . oadtyf () , self . oadtyr () , self . reserved_20_23 () , self . obdty () , self . obdtyf () , self . obdtyr ())
            }
        }
        #[doc = "General PWM Timer Up Count Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtupsr(pub u32);
        impl Gtupsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgar(&self) -> super::vals::Usgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Usgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgar(&mut self, val: super::vals::Usgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgaf(&self) -> super::vals::Usgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Usgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgaf(&mut self, val: super::vals::Usgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgbr(&self) -> super::vals::Usgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Usgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgbr(&mut self, val: super::vals::Usgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgbf(&self) -> super::vals::Usgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Usgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgbf(&mut self, val: super::vals::Usgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscarbl(&self) -> super::vals::Uscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Uscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscarbl(&mut self, val: super::vals::Uscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscarbh(&self) -> super::vals::Uscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Uscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscarbh(&mut self, val: super::vals::Uscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscafbl(&self) -> super::vals::Uscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Uscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscafbl(&mut self, val: super::vals::Uscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscafbh(&self) -> super::vals::Uscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Uscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscafbh(&mut self, val: super::vals::Uscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbral(&self) -> super::vals::Uscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Uscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbral(&mut self, val: super::vals::Uscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbrah(&self) -> super::vals::Uscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Uscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbrah(&mut self, val: super::vals::Uscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbfal(&self) -> super::vals::Uscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Uscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbfal(&mut self, val: super::vals::Uscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbfah(&self) -> super::vals::Uscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Uscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbfah(&mut self, val: super::vals::Uscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselca(&self) -> super::vals::Uselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Uselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselca(&mut self, val: super::vals::Uselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcb(&self) -> super::vals::Uselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Uselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcb(&mut self, val: super::vals::Uselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcc(&self) -> super::vals::Uselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Uselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcc(&mut self, val: super::vals::Uselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcd(&self) -> super::vals::Uselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Uselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcd(&mut self, val: super::vals::Uselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gtupsr {
            #[inline(always)]
            fn default() -> Gtupsr {
                Gtupsr(0)
            }
        }
        impl core::fmt::Debug for Gtupsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtupsr")
                    .field("usgtrgar", &self.usgtrgar())
                    .field("usgtrgaf", &self.usgtrgaf())
                    .field("usgtrgbr", &self.usgtrgbr())
                    .field("usgtrgbf", &self.usgtrgbf())
                    .field("uscarbl", &self.uscarbl())
                    .field("uscarbh", &self.uscarbh())
                    .field("uscafbl", &self.uscafbl())
                    .field("uscafbh", &self.uscafbh())
                    .field("uscbral", &self.uscbral())
                    .field("uscbrah", &self.uscbrah())
                    .field("uscbfal", &self.uscbfal())
                    .field("uscbfah", &self.uscbfah())
                    .field("uselca", &self.uselca())
                    .field("uselcb", &self.uselcb())
                    .field("uselcc", &self.uselcc())
                    .field("uselcd", &self.uselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtupsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtupsr {{ usgtrgar: {:?}, usgtrgaf: {:?}, usgtrgbr: {:?}, usgtrgbf: {:?}, uscarbl: {:?}, uscarbh: {:?}, uscafbl: {:?}, uscafbh: {:?}, uscbral: {:?}, uscbrah: {:?}, uscbfal: {:?}, uscbfah: {:?}, uselca: {:?}, uselcb: {:?}, uselcc: {:?}, uselcd: {:?} }}" , self . usgtrgar () , self . usgtrgaf () , self . usgtrgbr () , self . usgtrgbf () , self . uscarbl () , self . uscarbh () , self . uscafbl () , self . uscafbh () , self . uscbral () , self . uscbrah () , self . uscbfal () , self . uscbfah () , self . uselca () , self . uselcb () , self . uselcc () , self . uselcd ())
            }
        }
        #[doc = "General PWM Timer Write,Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtwp(pub u32);
        impl Gtwp {
            #[doc = "Register Write Disable"]
            #[inline(always)]
            pub const fn wp(&self) -> super::vals::Wp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Wp::from_bits(val as u8)
            }
            #[doc = "Register Write Disable"]
            #[inline(always)]
            pub fn set_wp(&mut self, val: super::vals::Wp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u32) & 0x7f) << 1usize);
            }
            #[doc = "GTWP Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> super::vals::Prkey {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::Prkey::from_bits(val as u8)
            }
            #[doc = "GTWP Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: super::vals::Prkey) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u32) & 0xff) << 8usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtwp {
            #[inline(always)]
            fn default() -> Gtwp {
                Gtwp(0)
            }
        }
        impl core::fmt::Debug for Gtwp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtwp")
                    .field("wp", &self.wp())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("prkey", &self.prkey())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtwp {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtwp {{ wp: {:?}, reserved_1_7: {=u8:?}, prkey: {:?}, reserved_16_31: {=u16:?} }}" , self . wp () , self . reserved_1_7 () , self . prkey () , self . reserved_16_31 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascafbh {
            #[inline(always)]
            fn from(val: u8) -> Ascafbh {
                Ascafbh::from_bits(val)
            }
        }
        impl From<Ascafbh> for u8 {
            #[inline(always)]
            fn from(val: Ascafbh) -> u8 {
                Ascafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascafbl {
            #[inline(always)]
            fn from(val: u8) -> Ascafbl {
                Ascafbl::from_bits(val)
            }
        }
        impl From<Ascafbl> for u8 {
            #[inline(always)]
            fn from(val: Ascafbl) -> u8 {
                Ascafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascarbh {
            #[inline(always)]
            fn from(val: u8) -> Ascarbh {
                Ascarbh::from_bits(val)
            }
        }
        impl From<Ascarbh> for u8 {
            #[inline(always)]
            fn from(val: Ascarbh) -> u8 {
                Ascarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascarbl {
            #[inline(always)]
            fn from(val: u8) -> Ascarbl {
                Ascarbl::from_bits(val)
            }
        }
        impl From<Ascarbl> for u8 {
            #[inline(always)]
            fn from(val: Ascarbl) -> u8 {
                Ascarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbfah {
            #[inline(always)]
            fn from(val: u8) -> Ascbfah {
                Ascbfah::from_bits(val)
            }
        }
        impl From<Ascbfah> for u8 {
            #[inline(always)]
            fn from(val: Ascbfah) -> u8 {
                Ascbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbfal {
            #[inline(always)]
            fn from(val: u8) -> Ascbfal {
                Ascbfal::from_bits(val)
            }
        }
        impl From<Ascbfal> for u8 {
            #[inline(always)]
            fn from(val: Ascbfal) -> u8 {
                Ascbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbrah {
            #[inline(always)]
            fn from(val: u8) -> Ascbrah {
                Ascbrah::from_bits(val)
            }
        }
        impl From<Ascbrah> for u8 {
            #[inline(always)]
            fn from(val: Ascbrah) -> u8 {
                Ascbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbral {
            #[inline(always)]
            fn from(val: u8) -> Ascbral {
                Ascbral::from_bits(val)
            }
        }
        impl From<Ascbral> for u8 {
            #[inline(always)]
            fn from(val: Ascbral) -> u8 {
                Ascbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselca {
            #[inline(always)]
            fn from(val: u8) -> Aselca {
                Aselca::from_bits(val)
            }
        }
        impl From<Aselca> for u8 {
            #[inline(always)]
            fn from(val: Aselca) -> u8 {
                Aselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcb {
            #[inline(always)]
            fn from(val: u8) -> Aselcb {
                Aselcb::from_bits(val)
            }
        }
        impl From<Aselcb> for u8 {
            #[inline(always)]
            fn from(val: Aselcb) -> u8 {
                Aselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcc {
            #[inline(always)]
            fn from(val: u8) -> Aselcc {
                Aselcc::from_bits(val)
            }
        }
        impl From<Aselcc> for u8 {
            #[inline(always)]
            fn from(val: Aselcc) -> u8 {
                Aselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcd {
            #[inline(always)]
            fn from(val: u8) -> Aselcd {
                Aselcd::from_bits(val)
            }
        }
        impl From<Aselcd> for u8 {
            #[inline(always)]
            fn from(val: Aselcd) -> u8 {
                Aselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgaf {
                Asgtrgaf::from_bits(val)
            }
        }
        impl From<Asgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgaf) -> u8 {
                Asgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgar {
                Asgtrgar::from_bits(val)
            }
        }
        impl From<Asgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgar) -> u8 {
                Asgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgbf {
                Asgtrgbf::from_bits(val)
            }
        }
        impl From<Asgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgbf) -> u8 {
                Asgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgbr {
                Asgtrgbr::from_bits(val)
            }
        }
        impl From<Asgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgbr) -> u8 {
                Asgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Bd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bd {
            #[inline(always)]
            fn from(val: u8) -> Bd {
                Bd::from_bits(val)
            }
        }
        impl From<Bd> for u8 {
            #[inline(always)]
            fn from(val: Bd) -> u8 {
                Bd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscafbh {
            #[inline(always)]
            fn from(val: u8) -> Bscafbh {
                Bscafbh::from_bits(val)
            }
        }
        impl From<Bscafbh> for u8 {
            #[inline(always)]
            fn from(val: Bscafbh) -> u8 {
                Bscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscafbl {
            #[inline(always)]
            fn from(val: u8) -> Bscafbl {
                Bscafbl::from_bits(val)
            }
        }
        impl From<Bscafbl> for u8 {
            #[inline(always)]
            fn from(val: Bscafbl) -> u8 {
                Bscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscarbh {
            #[inline(always)]
            fn from(val: u8) -> Bscarbh {
                Bscarbh::from_bits(val)
            }
        }
        impl From<Bscarbh> for u8 {
            #[inline(always)]
            fn from(val: Bscarbh) -> u8 {
                Bscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscarbl {
            #[inline(always)]
            fn from(val: u8) -> Bscarbl {
                Bscarbl::from_bits(val)
            }
        }
        impl From<Bscarbl> for u8 {
            #[inline(always)]
            fn from(val: Bscarbl) -> u8 {
                Bscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbfah {
            #[inline(always)]
            fn from(val: u8) -> Bscbfah {
                Bscbfah::from_bits(val)
            }
        }
        impl From<Bscbfah> for u8 {
            #[inline(always)]
            fn from(val: Bscbfah) -> u8 {
                Bscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbfal {
            #[inline(always)]
            fn from(val: u8) -> Bscbfal {
                Bscbfal::from_bits(val)
            }
        }
        impl From<Bscbfal> for u8 {
            #[inline(always)]
            fn from(val: Bscbfal) -> u8 {
                Bscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbrah {
            #[inline(always)]
            fn from(val: u8) -> Bscbrah {
                Bscbrah::from_bits(val)
            }
        }
        impl From<Bscbrah> for u8 {
            #[inline(always)]
            fn from(val: Bscbrah) -> u8 {
                Bscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbral {
            #[inline(always)]
            fn from(val: u8) -> Bscbral {
                Bscbral::from_bits(val)
            }
        }
        impl From<Bscbral> for u8 {
            #[inline(always)]
            fn from(val: Bscbral) -> u8 {
                Bscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselca {
            #[inline(always)]
            fn from(val: u8) -> Bselca {
                Bselca::from_bits(val)
            }
        }
        impl From<Bselca> for u8 {
            #[inline(always)]
            fn from(val: Bselca) -> u8 {
                Bselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcb {
            #[inline(always)]
            fn from(val: u8) -> Bselcb {
                Bselcb::from_bits(val)
            }
        }
        impl From<Bselcb> for u8 {
            #[inline(always)]
            fn from(val: Bselcb) -> u8 {
                Bselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcc {
            #[inline(always)]
            fn from(val: u8) -> Bselcc {
                Bselcc::from_bits(val)
            }
        }
        impl From<Bselcc> for u8 {
            #[inline(always)]
            fn from(val: Bselcc) -> u8 {
                Bselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcd {
            #[inline(always)]
            fn from(val: u8) -> Bselcd {
                Bselcd::from_bits(val)
            }
        }
        impl From<Bselcd> for u8 {
            #[inline(always)]
            fn from(val: Bselcd) -> u8 {
                Bselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgaf {
                Bsgtrgaf::from_bits(val)
            }
        }
        impl From<Bsgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgaf) -> u8 {
                Bsgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgar {
                Bsgtrgar::from_bits(val)
            }
        }
        impl From<Bsgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgar) -> u8 {
                Bsgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgbf {
                Bsgtrgbf::from_bits(val)
            }
        }
        impl From<Bsgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgbf) -> u8 {
                Bsgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgbr {
                Bsgtrgbr::from_bits(val)
            }
        }
        impl From<Bsgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgbr) -> u8 {
                Bsgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr {
            #[inline(always)]
            fn from(val: u8) -> Cclr {
                Cclr::from_bits(val)
            }
        }
        impl From<Cclr> for u8 {
            #[inline(always)]
            fn from(val: Cclr) -> u8 {
                Cclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr0 {
            #[inline(always)]
            fn from(val: u8) -> Cclr0 {
                Cclr0::from_bits(val)
            }
        }
        impl From<Cclr0> for u8 {
            #[inline(always)]
            fn from(val: Cclr0) -> u8 {
                Cclr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr1 {
            #[inline(always)]
            fn from(val: u8) -> Cclr1 {
                Cclr1::from_bits(val)
            }
        }
        impl From<Cclr1> for u8 {
            #[inline(always)]
            fn from(val: Cclr1) -> u8 {
                Cclr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr2 {
            #[inline(always)]
            fn from(val: u8) -> Cclr2 {
                Cclr2::from_bits(val)
            }
        }
        impl From<Cclr2> for u8 {
            #[inline(always)]
            fn from(val: Cclr2) -> u8 {
                Cclr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr3 {
            #[inline(always)]
            fn from(val: u8) -> Cclr3 {
                Cclr3::from_bits(val)
            }
        }
        impl From<Cclr3> for u8 {
            #[inline(always)]
            fn from(val: Cclr3) -> u8 {
                Cclr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr4 {
            #[inline(always)]
            fn from(val: u8) -> Cclr4 {
                Cclr4::from_bits(val)
            }
        }
        impl From<Cclr4> for u8 {
            #[inline(always)]
            fn from(val: Cclr4) -> u8 {
                Cclr4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr5 {
            #[inline(always)]
            fn from(val: u8) -> Cclr5 {
                Cclr5::from_bits(val)
            }
        }
        impl From<Cclr5> for u8 {
            #[inline(always)]
            fn from(val: Cclr5) -> u8 {
                Cclr5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr6 {
            #[inline(always)]
            fn from(val: u8) -> Cclr6 {
                Cclr6::from_bits(val)
            }
        }
        impl From<Cclr6> for u8 {
            #[inline(always)]
            fn from(val: Cclr6) -> u8 {
                Cclr6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccra {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ccra {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccra {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccra {
            #[inline(always)]
            fn from(val: u8) -> Ccra {
                Ccra::from_bits(val)
            }
        }
        impl From<Ccra> for u8 {
            #[inline(always)]
            fn from(val: Ccra) -> u8 {
                Ccra::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccrb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ccrb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccrb {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccrb {
            #[inline(always)]
            fn from(val: u8) -> Ccrb {
                Ccrb::from_bits(val)
            }
        }
        impl From<Ccrb> for u8 {
            #[inline(always)]
            fn from(val: Ccrb) -> u8 {
                Ccrb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccrswt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ccrswt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccrswt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccrswt {
            #[inline(always)]
            fn from(val: u8) -> Ccrswt {
                Ccrswt::from_bits(val)
            }
        }
        impl From<Ccrswt> for u8 {
            #[inline(always)]
            fn from(val: Ccrswt) -> u8 {
                Ccrswt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscafbh {
            #[inline(always)]
            fn from(val: u8) -> Cscafbh {
                Cscafbh::from_bits(val)
            }
        }
        impl From<Cscafbh> for u8 {
            #[inline(always)]
            fn from(val: Cscafbh) -> u8 {
                Cscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscafbl {
            #[inline(always)]
            fn from(val: u8) -> Cscafbl {
                Cscafbl::from_bits(val)
            }
        }
        impl From<Cscafbl> for u8 {
            #[inline(always)]
            fn from(val: Cscafbl) -> u8 {
                Cscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscarbh {
            #[inline(always)]
            fn from(val: u8) -> Cscarbh {
                Cscarbh::from_bits(val)
            }
        }
        impl From<Cscarbh> for u8 {
            #[inline(always)]
            fn from(val: Cscarbh) -> u8 {
                Cscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscarbl {
            #[inline(always)]
            fn from(val: u8) -> Cscarbl {
                Cscarbl::from_bits(val)
            }
        }
        impl From<Cscarbl> for u8 {
            #[inline(always)]
            fn from(val: Cscarbl) -> u8 {
                Cscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbfah {
            #[inline(always)]
            fn from(val: u8) -> Cscbfah {
                Cscbfah::from_bits(val)
            }
        }
        impl From<Cscbfah> for u8 {
            #[inline(always)]
            fn from(val: Cscbfah) -> u8 {
                Cscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbfal {
            #[inline(always)]
            fn from(val: u8) -> Cscbfal {
                Cscbfal::from_bits(val)
            }
        }
        impl From<Cscbfal> for u8 {
            #[inline(always)]
            fn from(val: Cscbfal) -> u8 {
                Cscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbrah {
            #[inline(always)]
            fn from(val: u8) -> Cscbrah {
                Cscbrah::from_bits(val)
            }
        }
        impl From<Cscbrah> for u8 {
            #[inline(always)]
            fn from(val: Cscbrah) -> u8 {
                Cscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbral {
            #[inline(always)]
            fn from(val: u8) -> Cscbral {
                Cscbral::from_bits(val)
            }
        }
        impl From<Cscbral> for u8 {
            #[inline(always)]
            fn from(val: Cscbral) -> u8 {
                Cscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselca {
            #[inline(always)]
            fn from(val: u8) -> Cselca {
                Cselca::from_bits(val)
            }
        }
        impl From<Cselca> for u8 {
            #[inline(always)]
            fn from(val: Cselca) -> u8 {
                Cselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcb {
            #[inline(always)]
            fn from(val: u8) -> Cselcb {
                Cselcb::from_bits(val)
            }
        }
        impl From<Cselcb> for u8 {
            #[inline(always)]
            fn from(val: Cselcb) -> u8 {
                Cselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcc {
            #[inline(always)]
            fn from(val: u8) -> Cselcc {
                Cselcc::from_bits(val)
            }
        }
        impl From<Cselcc> for u8 {
            #[inline(always)]
            fn from(val: Cselcc) -> u8 {
                Cselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcd {
            #[inline(always)]
            fn from(val: u8) -> Cselcd {
                Cselcd::from_bits(val)
            }
        }
        impl From<Cselcd> for u8 {
            #[inline(always)]
            fn from(val: Cselcd) -> u8 {
                Cselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgaf {
                Csgtrgaf::from_bits(val)
            }
        }
        impl From<Csgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgaf) -> u8 {
                Csgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgar {
                Csgtrgar::from_bits(val)
            }
        }
        impl From<Csgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgar) -> u8 {
                Csgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgbf {
                Csgtrgbf::from_bits(val)
            }
        }
        impl From<Csgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgbf) -> u8 {
                Csgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgbr {
                Csgtrgbr::from_bits(val)
            }
        }
        impl From<Csgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgbr) -> u8 {
                Csgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cst {
            #[inline(always)]
            fn from(val: u8) -> Cst {
                Cst::from_bits(val)
            }
        }
        impl From<Cst> for u8 {
            #[inline(always)]
            fn from(val: Cst) -> u8 {
                Cst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop {
            #[inline(always)]
            fn from(val: u8) -> Cstop {
                Cstop::from_bits(val)
            }
        }
        impl From<Cstop> for u8 {
            #[inline(always)]
            fn from(val: Cstop) -> u8 {
                Cstop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop0 {
            #[inline(always)]
            fn from(val: u8) -> Cstop0 {
                Cstop0::from_bits(val)
            }
        }
        impl From<Cstop0> for u8 {
            #[inline(always)]
            fn from(val: Cstop0) -> u8 {
                Cstop0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop1 {
            #[inline(always)]
            fn from(val: u8) -> Cstop1 {
                Cstop1::from_bits(val)
            }
        }
        impl From<Cstop1> for u8 {
            #[inline(always)]
            fn from(val: Cstop1) -> u8 {
                Cstop1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop2 {
            #[inline(always)]
            fn from(val: u8) -> Cstop2 {
                Cstop2::from_bits(val)
            }
        }
        impl From<Cstop2> for u8 {
            #[inline(always)]
            fn from(val: Cstop2) -> u8 {
                Cstop2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop3 {
            #[inline(always)]
            fn from(val: u8) -> Cstop3 {
                Cstop3::from_bits(val)
            }
        }
        impl From<Cstop3> for u8 {
            #[inline(always)]
            fn from(val: Cstop3) -> u8 {
                Cstop3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop4 {
            #[inline(always)]
            fn from(val: u8) -> Cstop4 {
                Cstop4::from_bits(val)
            }
        }
        impl From<Cstop4> for u8 {
            #[inline(always)]
            fn from(val: Cstop4) -> u8 {
                Cstop4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop5 {
            #[inline(always)]
            fn from(val: u8) -> Cstop5 {
                Cstop5::from_bits(val)
            }
        }
        impl From<Cstop5> for u8 {
            #[inline(always)]
            fn from(val: Cstop5) -> u8 {
                Cstop5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop6 {
            #[inline(always)]
            fn from(val: u8) -> Cstop6 {
                Cstop6::from_bits(val)
            }
        }
        impl From<Cstop6> for u8 {
            #[inline(always)]
            fn from(val: Cstop6) -> u8 {
                Cstop6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt {
            #[inline(always)]
            fn from(val: u8) -> Cstrt {
                Cstrt::from_bits(val)
            }
        }
        impl From<Cstrt> for u8 {
            #[inline(always)]
            fn from(val: Cstrt) -> u8 {
                Cstrt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt0 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt0 {
                Cstrt0::from_bits(val)
            }
        }
        impl From<Cstrt0> for u8 {
            #[inline(always)]
            fn from(val: Cstrt0) -> u8 {
                Cstrt0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt1 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt1 {
                Cstrt1::from_bits(val)
            }
        }
        impl From<Cstrt1> for u8 {
            #[inline(always)]
            fn from(val: Cstrt1) -> u8 {
                Cstrt1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt2 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt2 {
                Cstrt2::from_bits(val)
            }
        }
        impl From<Cstrt2> for u8 {
            #[inline(always)]
            fn from(val: Cstrt2) -> u8 {
                Cstrt2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt3 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt3 {
                Cstrt3::from_bits(val)
            }
        }
        impl From<Cstrt3> for u8 {
            #[inline(always)]
            fn from(val: Cstrt3) -> u8 {
                Cstrt3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt4 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt4 {
                Cstrt4::from_bits(val)
            }
        }
        impl From<Cstrt4> for u8 {
            #[inline(always)]
            fn from(val: Cstrt4) -> u8 {
                Cstrt4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt5 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt5 {
                Cstrt5::from_bits(val)
            }
        }
        impl From<Cstrt5> for u8 {
            #[inline(always)]
            fn from(val: Cstrt5) -> u8 {
                Cstrt5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt6 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt6 {
                Cstrt6::from_bits(val)
            }
        }
        impl From<Cstrt6> for u8 {
            #[inline(always)]
            fn from(val: Cstrt6) -> u8 {
                Cstrt6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscafbh {
            #[inline(always)]
            fn from(val: u8) -> Dscafbh {
                Dscafbh::from_bits(val)
            }
        }
        impl From<Dscafbh> for u8 {
            #[inline(always)]
            fn from(val: Dscafbh) -> u8 {
                Dscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscafbl {
            #[inline(always)]
            fn from(val: u8) -> Dscafbl {
                Dscafbl::from_bits(val)
            }
        }
        impl From<Dscafbl> for u8 {
            #[inline(always)]
            fn from(val: Dscafbl) -> u8 {
                Dscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscarbh {
            #[inline(always)]
            fn from(val: u8) -> Dscarbh {
                Dscarbh::from_bits(val)
            }
        }
        impl From<Dscarbh> for u8 {
            #[inline(always)]
            fn from(val: Dscarbh) -> u8 {
                Dscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscarbl {
            #[inline(always)]
            fn from(val: u8) -> Dscarbl {
                Dscarbl::from_bits(val)
            }
        }
        impl From<Dscarbl> for u8 {
            #[inline(always)]
            fn from(val: Dscarbl) -> u8 {
                Dscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbfah {
            #[inline(always)]
            fn from(val: u8) -> Dscbfah {
                Dscbfah::from_bits(val)
            }
        }
        impl From<Dscbfah> for u8 {
            #[inline(always)]
            fn from(val: Dscbfah) -> u8 {
                Dscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbfal {
            #[inline(always)]
            fn from(val: u8) -> Dscbfal {
                Dscbfal::from_bits(val)
            }
        }
        impl From<Dscbfal> for u8 {
            #[inline(always)]
            fn from(val: Dscbfal) -> u8 {
                Dscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbrah {
            #[inline(always)]
            fn from(val: u8) -> Dscbrah {
                Dscbrah::from_bits(val)
            }
        }
        impl From<Dscbrah> for u8 {
            #[inline(always)]
            fn from(val: Dscbrah) -> u8 {
                Dscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbral {
            #[inline(always)]
            fn from(val: u8) -> Dscbral {
                Dscbral::from_bits(val)
            }
        }
        impl From<Dscbral> for u8 {
            #[inline(always)]
            fn from(val: Dscbral) -> u8 {
                Dscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselca {
            #[inline(always)]
            fn from(val: u8) -> Dselca {
                Dselca::from_bits(val)
            }
        }
        impl From<Dselca> for u8 {
            #[inline(always)]
            fn from(val: Dselca) -> u8 {
                Dselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcb {
            #[inline(always)]
            fn from(val: u8) -> Dselcb {
                Dselcb::from_bits(val)
            }
        }
        impl From<Dselcb> for u8 {
            #[inline(always)]
            fn from(val: Dselcb) -> u8 {
                Dselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcc {
            #[inline(always)]
            fn from(val: u8) -> Dselcc {
                Dselcc::from_bits(val)
            }
        }
        impl From<Dselcc> for u8 {
            #[inline(always)]
            fn from(val: Dselcc) -> u8 {
                Dselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcd {
            #[inline(always)]
            fn from(val: u8) -> Dselcd {
                Dselcd::from_bits(val)
            }
        }
        impl From<Dselcd> for u8 {
            #[inline(always)]
            fn from(val: Dselcd) -> u8 {
                Dselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgaf {
                Dsgtrgaf::from_bits(val)
            }
        }
        impl From<Dsgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgaf) -> u8 {
                Dsgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgar {
                Dsgtrgar::from_bits(val)
            }
        }
        impl From<Dsgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgar) -> u8 {
                Dsgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgbf {
                Dsgtrgbf::from_bits(val)
            }
        }
        impl From<Dsgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgbf) -> u8 {
                Dsgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgbr {
                Dsgtrgbr::from_bits(val)
            }
        }
        impl From<Dsgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgbr) -> u8 {
                Dsgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Grp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grp {
            #[inline(always)]
            fn from(val: u8) -> Grp {
                Grp::from_bits(val)
            }
        }
        impl From<Grp> for u8 {
            #[inline(always)]
            fn from(val: Grp) -> u8 {
                Grp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grpabh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Grpabh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grpabh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grpabh {
            #[inline(always)]
            fn from(val: u8) -> Grpabh {
                Grpabh::from_bits(val)
            }
        }
        impl From<Grpabh> for u8 {
            #[inline(always)]
            fn from(val: Grpabh) -> u8 {
                Grpabh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grpabl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Grpabl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grpabl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grpabl {
            #[inline(always)]
            fn from(val: u8) -> Grpabl {
                Grpabl::from_bits(val)
            }
        }
        impl From<Grpabl> for u8 {
            #[inline(always)]
            fn from(val: Grpabl) -> u8 {
                Grpabl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gtcf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gtcf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gtcf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gtcf {
            #[inline(always)]
            fn from(val: u8) -> Gtcf {
                Gtcf::from_bits(val)
            }
        }
        impl From<Gtcf> for u8 {
            #[inline(always)]
            fn from(val: Gtcf) -> u8 {
                Gtcf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gtioa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Gtioa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gtioa {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gtioa {
            #[inline(always)]
            fn from(val: u8) -> Gtioa {
                Gtioa::from_bits(val)
            }
        }
        impl From<Gtioa> for u8 {
            #[inline(always)]
            fn from(val: Gtioa) -> u8 {
                Gtioa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gtiob {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Gtiob {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gtiob {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gtiob {
            #[inline(always)]
            fn from(val: u8) -> Gtiob {
                Gtiob::from_bits(val)
            }
        }
        impl From<Gtiob> for u8 {
            #[inline(always)]
            fn from(val: Gtiob) -> u8 {
                Gtiob::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Md {
            #[inline(always)]
            fn from(val: u8) -> Md {
                Md::from_bits(val)
            }
        }
        impl From<Md> for u8 {
            #[inline(always)]
            fn from(val: Md) -> u8 {
                Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfaen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfaen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfaen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfaen {
            #[inline(always)]
            fn from(val: u8) -> Nfaen {
                Nfaen::from_bits(val)
            }
        }
        impl From<Nfaen> for u8 {
            #[inline(always)]
            fn from(val: Nfaen) -> u8 {
                Nfaen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfben {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfben {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfben {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfben {
            #[inline(always)]
            fn from(val: u8) -> Nfben {
                Nfben::from_bits(val)
            }
        }
        impl From<Nfben> for u8 {
            #[inline(always)]
            fn from(val: Nfben) -> u8 {
                Nfben::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcsa {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcsa {
            #[inline(always)]
            fn from(val: u8) -> Nfcsa {
                Nfcsa::from_bits(val)
            }
        }
        impl From<Nfcsa> for u8 {
            #[inline(always)]
            fn from(val: Nfcsa) -> u8 {
                Nfcsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcsb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcsb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcsb {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcsb {
            #[inline(always)]
            fn from(val: u8) -> Nfcsb {
                Nfcsb::from_bits(val)
            }
        }
        impl From<Nfcsb> for u8 {
            #[inline(always)]
            fn from(val: Nfcsb) -> u8 {
                Nfcsb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oabhf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oabhf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oabhf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oabhf {
            #[inline(always)]
            fn from(val: u8) -> Oabhf {
                Oabhf::from_bits(val)
            }
        }
        impl From<Oabhf> for u8 {
            #[inline(always)]
            fn from(val: Oabhf) -> u8 {
                Oabhf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oablf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oablf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oablf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oablf {
            #[inline(always)]
            fn from(val: u8) -> Oablf {
                Oablf::from_bits(val)
            }
        }
        impl From<Oablf> for u8 {
            #[inline(always)]
            fn from(val: Oablf) -> u8 {
                Oablf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oadf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadf {
            #[inline(always)]
            fn from(val: u8) -> Oadf {
                Oadf::from_bits(val)
            }
        }
        impl From<Oadf> for u8 {
            #[inline(always)]
            fn from(val: Oadf) -> u8 {
                Oadf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadflt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadflt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadflt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadflt {
            #[inline(always)]
            fn from(val: u8) -> Oadflt {
                Oadflt::from_bits(val)
            }
        }
        impl From<Oadflt> for u8 {
            #[inline(always)]
            fn from(val: Oadflt) -> u8 {
                Oadflt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadty {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oadty {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadty {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadty {
            #[inline(always)]
            fn from(val: u8) -> Oadty {
                Oadty::from_bits(val)
            }
        }
        impl From<Oadty> for u8 {
            #[inline(always)]
            fn from(val: Oadty) -> u8 {
                Oadty::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadtyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadtyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadtyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadtyf {
            #[inline(always)]
            fn from(val: u8) -> Oadtyf {
                Oadtyf::from_bits(val)
            }
        }
        impl From<Oadtyf> for u8 {
            #[inline(always)]
            fn from(val: Oadtyf) -> u8 {
                Oadtyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadtyr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadtyr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadtyr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadtyr {
            #[inline(always)]
            fn from(val: u8) -> Oadtyr {
                Oadtyr::from_bits(val)
            }
        }
        impl From<Oadtyr> for u8 {
            #[inline(always)]
            fn from(val: Oadtyr) -> u8 {
                Oadtyr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oae {
            #[inline(always)]
            fn from(val: u8) -> Oae {
                Oae::from_bits(val)
            }
        }
        impl From<Oae> for u8 {
            #[inline(always)]
            fn from(val: Oae) -> u8 {
                Oae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oahld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oahld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oahld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oahld {
            #[inline(always)]
            fn from(val: u8) -> Oahld {
                Oahld::from_bits(val)
            }
        }
        impl From<Oahld> for u8 {
            #[inline(always)]
            fn from(val: Oahld) -> u8 {
                Oahld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Obdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdf {
            #[inline(always)]
            fn from(val: u8) -> Obdf {
                Obdf::from_bits(val)
            }
        }
        impl From<Obdf> for u8 {
            #[inline(always)]
            fn from(val: Obdf) -> u8 {
                Obdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdflt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdflt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdflt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdflt {
            #[inline(always)]
            fn from(val: u8) -> Obdflt {
                Obdflt::from_bits(val)
            }
        }
        impl From<Obdflt> for u8 {
            #[inline(always)]
            fn from(val: Obdflt) -> u8 {
                Obdflt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdty {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Obdty {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdty {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdty {
            #[inline(always)]
            fn from(val: u8) -> Obdty {
                Obdty::from_bits(val)
            }
        }
        impl From<Obdty> for u8 {
            #[inline(always)]
            fn from(val: Obdty) -> u8 {
                Obdty::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdtyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdtyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdtyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdtyf {
            #[inline(always)]
            fn from(val: u8) -> Obdtyf {
                Obdtyf::from_bits(val)
            }
        }
        impl From<Obdtyf> for u8 {
            #[inline(always)]
            fn from(val: Obdtyf) -> u8 {
                Obdtyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdtyr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdtyr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdtyr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdtyr {
            #[inline(always)]
            fn from(val: u8) -> Obdtyr {
                Obdtyr::from_bits(val)
            }
        }
        impl From<Obdtyr> for u8 {
            #[inline(always)]
            fn from(val: Obdtyr) -> u8 {
                Obdtyr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obe {
            #[inline(always)]
            fn from(val: u8) -> Obe {
                Obe::from_bits(val)
            }
        }
        impl From<Obe> for u8 {
            #[inline(always)]
            fn from(val: Obe) -> u8 {
                Obe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obhld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obhld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obhld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obhld {
            #[inline(always)]
            fn from(val: u8) -> Obhld {
                Obhld::from_bits(val)
            }
        }
        impl From<Obhld> for u8 {
            #[inline(always)]
            fn from(val: Obhld) -> u8 {
                Obhld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Odf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Odf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Odf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Odf {
            #[inline(always)]
            fn from(val: u8) -> Odf {
                Odf::from_bits(val)
            }
        }
        impl From<Odf> for u8 {
            #[inline(always)]
            fn from(val: Odf) -> u8 {
                Odf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Pr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pr {
            #[inline(always)]
            fn from(val: u8) -> Pr {
                Pr::from_bits(val)
            }
        }
        impl From<Pr> for u8 {
            #[inline(always)]
            fn from(val: Pr) -> u8 {
                Pr::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Prkey(u8);
        impl Prkey {}
        impl Prkey {
            pub const fn from_bits(val: u8) -> Prkey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Prkey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prkey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Prkey {
            #[inline(always)]
            fn from(val: u8) -> Prkey {
                Prkey::from_bits(val)
            }
        }
        impl From<Prkey> for u8 {
            #[inline(always)]
            fn from(val: Prkey) -> u8 {
                Prkey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscafbh {
            #[inline(always)]
            fn from(val: u8) -> Pscafbh {
                Pscafbh::from_bits(val)
            }
        }
        impl From<Pscafbh> for u8 {
            #[inline(always)]
            fn from(val: Pscafbh) -> u8 {
                Pscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscafbl {
            #[inline(always)]
            fn from(val: u8) -> Pscafbl {
                Pscafbl::from_bits(val)
            }
        }
        impl From<Pscafbl> for u8 {
            #[inline(always)]
            fn from(val: Pscafbl) -> u8 {
                Pscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscarbh {
            #[inline(always)]
            fn from(val: u8) -> Pscarbh {
                Pscarbh::from_bits(val)
            }
        }
        impl From<Pscarbh> for u8 {
            #[inline(always)]
            fn from(val: Pscarbh) -> u8 {
                Pscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscarbl {
            #[inline(always)]
            fn from(val: u8) -> Pscarbl {
                Pscarbl::from_bits(val)
            }
        }
        impl From<Pscarbl> for u8 {
            #[inline(always)]
            fn from(val: Pscarbl) -> u8 {
                Pscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbfah {
            #[inline(always)]
            fn from(val: u8) -> Pscbfah {
                Pscbfah::from_bits(val)
            }
        }
        impl From<Pscbfah> for u8 {
            #[inline(always)]
            fn from(val: Pscbfah) -> u8 {
                Pscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbfal {
            #[inline(always)]
            fn from(val: u8) -> Pscbfal {
                Pscbfal::from_bits(val)
            }
        }
        impl From<Pscbfal> for u8 {
            #[inline(always)]
            fn from(val: Pscbfal) -> u8 {
                Pscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbrah {
            #[inline(always)]
            fn from(val: u8) -> Pscbrah {
                Pscbrah::from_bits(val)
            }
        }
        impl From<Pscbrah> for u8 {
            #[inline(always)]
            fn from(val: Pscbrah) -> u8 {
                Pscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbral {
            #[inline(always)]
            fn from(val: u8) -> Pscbral {
                Pscbral::from_bits(val)
            }
        }
        impl From<Pscbral> for u8 {
            #[inline(always)]
            fn from(val: Pscbral) -> u8 {
                Pscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselca {
            #[inline(always)]
            fn from(val: u8) -> Pselca {
                Pselca::from_bits(val)
            }
        }
        impl From<Pselca> for u8 {
            #[inline(always)]
            fn from(val: Pselca) -> u8 {
                Pselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcb {
            #[inline(always)]
            fn from(val: u8) -> Pselcb {
                Pselcb::from_bits(val)
            }
        }
        impl From<Pselcb> for u8 {
            #[inline(always)]
            fn from(val: Pselcb) -> u8 {
                Pselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcc {
            #[inline(always)]
            fn from(val: u8) -> Pselcc {
                Pselcc::from_bits(val)
            }
        }
        impl From<Pselcc> for u8 {
            #[inline(always)]
            fn from(val: Pselcc) -> u8 {
                Pselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcd {
            #[inline(always)]
            fn from(val: u8) -> Pselcd {
                Pselcd::from_bits(val)
            }
        }
        impl From<Pselcd> for u8 {
            #[inline(always)]
            fn from(val: Pselcd) -> u8 {
                Pselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgaf {
                Psgtrgaf::from_bits(val)
            }
        }
        impl From<Psgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgaf) -> u8 {
                Psgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgar {
                Psgtrgar::from_bits(val)
            }
        }
        impl From<Psgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgar) -> u8 {
                Psgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgbf {
                Psgtrgbf::from_bits(val)
            }
        }
        impl From<Psgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgbf) -> u8 {
                Psgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgbr {
                Psgtrgbr::from_bits(val)
            }
        }
        impl From<Psgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgbr) -> u8 {
                Psgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscafbh {
            #[inline(always)]
            fn from(val: u8) -> Sscafbh {
                Sscafbh::from_bits(val)
            }
        }
        impl From<Sscafbh> for u8 {
            #[inline(always)]
            fn from(val: Sscafbh) -> u8 {
                Sscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscafbl {
            #[inline(always)]
            fn from(val: u8) -> Sscafbl {
                Sscafbl::from_bits(val)
            }
        }
        impl From<Sscafbl> for u8 {
            #[inline(always)]
            fn from(val: Sscafbl) -> u8 {
                Sscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscarbh {
            #[inline(always)]
            fn from(val: u8) -> Sscarbh {
                Sscarbh::from_bits(val)
            }
        }
        impl From<Sscarbh> for u8 {
            #[inline(always)]
            fn from(val: Sscarbh) -> u8 {
                Sscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscarbl {
            #[inline(always)]
            fn from(val: u8) -> Sscarbl {
                Sscarbl::from_bits(val)
            }
        }
        impl From<Sscarbl> for u8 {
            #[inline(always)]
            fn from(val: Sscarbl) -> u8 {
                Sscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbfah {
            #[inline(always)]
            fn from(val: u8) -> Sscbfah {
                Sscbfah::from_bits(val)
            }
        }
        impl From<Sscbfah> for u8 {
            #[inline(always)]
            fn from(val: Sscbfah) -> u8 {
                Sscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbfal {
            #[inline(always)]
            fn from(val: u8) -> Sscbfal {
                Sscbfal::from_bits(val)
            }
        }
        impl From<Sscbfal> for u8 {
            #[inline(always)]
            fn from(val: Sscbfal) -> u8 {
                Sscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbrah {
            #[inline(always)]
            fn from(val: u8) -> Sscbrah {
                Sscbrah::from_bits(val)
            }
        }
        impl From<Sscbrah> for u8 {
            #[inline(always)]
            fn from(val: Sscbrah) -> u8 {
                Sscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbral {
            #[inline(always)]
            fn from(val: u8) -> Sscbral {
                Sscbral::from_bits(val)
            }
        }
        impl From<Sscbral> for u8 {
            #[inline(always)]
            fn from(val: Sscbral) -> u8 {
                Sscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselca {
            #[inline(always)]
            fn from(val: u8) -> Sselca {
                Sselca::from_bits(val)
            }
        }
        impl From<Sselca> for u8 {
            #[inline(always)]
            fn from(val: Sselca) -> u8 {
                Sselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcb {
            #[inline(always)]
            fn from(val: u8) -> Sselcb {
                Sselcb::from_bits(val)
            }
        }
        impl From<Sselcb> for u8 {
            #[inline(always)]
            fn from(val: Sselcb) -> u8 {
                Sselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcc {
            #[inline(always)]
            fn from(val: u8) -> Sselcc {
                Sselcc::from_bits(val)
            }
        }
        impl From<Sselcc> for u8 {
            #[inline(always)]
            fn from(val: Sselcc) -> u8 {
                Sselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcd {
            #[inline(always)]
            fn from(val: u8) -> Sselcd {
                Sselcd::from_bits(val)
            }
        }
        impl From<Sselcd> for u8 {
            #[inline(always)]
            fn from(val: Sselcd) -> u8 {
                Sselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgaf {
                Ssgtrgaf::from_bits(val)
            }
        }
        impl From<Ssgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgaf) -> u8 {
                Ssgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgar {
                Ssgtrgar::from_bits(val)
            }
        }
        impl From<Ssgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgar) -> u8 {
                Ssgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgbf {
                Ssgtrgbf::from_bits(val)
            }
        }
        impl From<Ssgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgbf) -> u8 {
                Ssgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgbr {
                Ssgtrgbr::from_bits(val)
            }
        }
        impl From<Ssgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgbr) -> u8 {
                Ssgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfa {
            #[inline(always)]
            fn from(val: u8) -> Tcfa {
                Tcfa::from_bits(val)
            }
        }
        impl From<Tcfa> for u8 {
            #[inline(always)]
            fn from(val: Tcfa) -> u8 {
                Tcfa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfb {
            #[inline(always)]
            fn from(val: u8) -> Tcfb {
                Tcfb::from_bits(val)
            }
        }
        impl From<Tcfb> for u8 {
            #[inline(always)]
            fn from(val: Tcfb) -> u8 {
                Tcfb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfc {
            #[inline(always)]
            fn from(val: u8) -> Tcfc {
                Tcfc::from_bits(val)
            }
        }
        impl From<Tcfc> for u8 {
            #[inline(always)]
            fn from(val: Tcfc) -> u8 {
                Tcfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfd {
            #[inline(always)]
            fn from(val: u8) -> Tcfd {
                Tcfd::from_bits(val)
            }
        }
        impl From<Tcfd> for u8 {
            #[inline(always)]
            fn from(val: Tcfd) -> u8 {
                Tcfd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfe {
            #[inline(always)]
            fn from(val: u8) -> Tcfe {
                Tcfe::from_bits(val)
            }
        }
        impl From<Tcfe> for u8 {
            #[inline(always)]
            fn from(val: Tcfe) -> u8 {
                Tcfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcff {
            #[inline(always)]
            fn from(val: u8) -> Tcff {
                Tcff::from_bits(val)
            }
        }
        impl From<Tcff> for u8 {
            #[inline(always)]
            fn from(val: Tcff) -> u8 {
                Tcff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfpu {
            #[inline(always)]
            fn from(val: u8) -> Tcfpu {
                Tcfpu::from_bits(val)
            }
        }
        impl From<Tcfpu> for u8 {
            #[inline(always)]
            fn from(val: Tcfpu) -> u8 {
                Tcfpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcpfo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcpfo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcpfo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcpfo {
            #[inline(always)]
            fn from(val: u8) -> Tcpfo {
                Tcpfo::from_bits(val)
            }
        }
        impl From<Tcpfo> for u8 {
            #[inline(always)]
            fn from(val: Tcpfo) -> u8 {
                Tcpfo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tde {
            #[inline(always)]
            fn from(val: u8) -> Tde {
                Tde::from_bits(val)
            }
        }
        impl From<Tde> for u8 {
            #[inline(always)]
            fn from(val: Tde) -> u8 {
                Tde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tpcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tpcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tpcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tpcs {
            #[inline(always)]
            fn from(val: u8) -> Tpcs {
                Tpcs::from_bits(val)
            }
        }
        impl From<Tpcs> for u8 {
            #[inline(always)]
            fn from(val: Tpcs) -> u8 {
                Tpcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ud {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ud {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ud {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ud {
            #[inline(always)]
            fn from(val: u8) -> Ud {
                Ud::from_bits(val)
            }
        }
        impl From<Ud> for u8 {
            #[inline(always)]
            fn from(val: Ud) -> u8 {
                Ud::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Udf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Udf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Udf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Udf {
            #[inline(always)]
            fn from(val: u8) -> Udf {
                Udf::from_bits(val)
            }
        }
        impl From<Udf> for u8 {
            #[inline(always)]
            fn from(val: Udf) -> u8 {
                Udf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscafbh {
            #[inline(always)]
            fn from(val: u8) -> Uscafbh {
                Uscafbh::from_bits(val)
            }
        }
        impl From<Uscafbh> for u8 {
            #[inline(always)]
            fn from(val: Uscafbh) -> u8 {
                Uscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscafbl {
            #[inline(always)]
            fn from(val: u8) -> Uscafbl {
                Uscafbl::from_bits(val)
            }
        }
        impl From<Uscafbl> for u8 {
            #[inline(always)]
            fn from(val: Uscafbl) -> u8 {
                Uscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscarbh {
            #[inline(always)]
            fn from(val: u8) -> Uscarbh {
                Uscarbh::from_bits(val)
            }
        }
        impl From<Uscarbh> for u8 {
            #[inline(always)]
            fn from(val: Uscarbh) -> u8 {
                Uscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscarbl {
            #[inline(always)]
            fn from(val: u8) -> Uscarbl {
                Uscarbl::from_bits(val)
            }
        }
        impl From<Uscarbl> for u8 {
            #[inline(always)]
            fn from(val: Uscarbl) -> u8 {
                Uscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbfah {
            #[inline(always)]
            fn from(val: u8) -> Uscbfah {
                Uscbfah::from_bits(val)
            }
        }
        impl From<Uscbfah> for u8 {
            #[inline(always)]
            fn from(val: Uscbfah) -> u8 {
                Uscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbfal {
            #[inline(always)]
            fn from(val: u8) -> Uscbfal {
                Uscbfal::from_bits(val)
            }
        }
        impl From<Uscbfal> for u8 {
            #[inline(always)]
            fn from(val: Uscbfal) -> u8 {
                Uscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbrah {
            #[inline(always)]
            fn from(val: u8) -> Uscbrah {
                Uscbrah::from_bits(val)
            }
        }
        impl From<Uscbrah> for u8 {
            #[inline(always)]
            fn from(val: Uscbrah) -> u8 {
                Uscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbral {
            #[inline(always)]
            fn from(val: u8) -> Uscbral {
                Uscbral::from_bits(val)
            }
        }
        impl From<Uscbral> for u8 {
            #[inline(always)]
            fn from(val: Uscbral) -> u8 {
                Uscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselca {
            #[inline(always)]
            fn from(val: u8) -> Uselca {
                Uselca::from_bits(val)
            }
        }
        impl From<Uselca> for u8 {
            #[inline(always)]
            fn from(val: Uselca) -> u8 {
                Uselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcb {
            #[inline(always)]
            fn from(val: u8) -> Uselcb {
                Uselcb::from_bits(val)
            }
        }
        impl From<Uselcb> for u8 {
            #[inline(always)]
            fn from(val: Uselcb) -> u8 {
                Uselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcc {
            #[inline(always)]
            fn from(val: u8) -> Uselcc {
                Uselcc::from_bits(val)
            }
        }
        impl From<Uselcc> for u8 {
            #[inline(always)]
            fn from(val: Uselcc) -> u8 {
                Uselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcd {
            #[inline(always)]
            fn from(val: u8) -> Uselcd {
                Uselcd::from_bits(val)
            }
        }
        impl From<Uselcd> for u8 {
            #[inline(always)]
            fn from(val: Uselcd) -> u8 {
                Uselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgaf {
                Usgtrgaf::from_bits(val)
            }
        }
        impl From<Usgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgaf) -> u8 {
                Usgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgar {
                Usgtrgar::from_bits(val)
            }
        }
        impl From<Usgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgar) -> u8 {
                Usgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgbf {
                Usgtrgbf::from_bits(val)
            }
        }
        impl From<Usgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgbf) -> u8 {
                Usgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgbr {
                Usgtrgbr::from_bits(val)
            }
        }
        impl From<Usgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgbr) -> u8 {
                Usgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wp {
            #[inline(always)]
            fn from(val: u8) -> Wp {
                Wp::from_bits(val)
            }
        }
        impl From<Wp> for u8 {
            #[inline(always)]
            fn from(val: Wp) -> u8 {
                Wp::to_bits(val)
            }
        }
    }
}
pub mod gpt320 {
    #[doc = "General PWM Timer 0 (32-bit)"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpt320 {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpt320 {}
    unsafe impl Sync for Gpt320 {}
    impl Gpt320 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "General PWM Timer Write,Protection Register"]
        #[inline(always)]
        pub const fn gtwp(self) -> crate::common::Reg<regs::Gtwp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "General PWM Timer Software Start Register"]
        #[inline(always)]
        pub const fn gtstr(self) -> crate::common::Reg<regs::Gtstr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "General PWM Timer Software Stop Register"]
        #[inline(always)]
        pub const fn gtstp(self) -> crate::common::Reg<regs::Gtstp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "General PWM Timer Software Clear Register"]
        #[inline(always)]
        pub const fn gtclr(self) -> crate::common::Reg<regs::Gtclr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "General PWM Timer Start Source Select Register"]
        #[inline(always)]
        pub const fn gtssr(self) -> crate::common::Reg<regs::Gtssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "General PWM Timer Stop Source Select Register"]
        #[inline(always)]
        pub const fn gtpsr(self) -> crate::common::Reg<regs::Gtpsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "General PWM Timer Clear Source Select Register"]
        #[inline(always)]
        pub const fn gtcsr(self) -> crate::common::Reg<regs::Gtcsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "General PWM Timer Up Count Source Select Register"]
        #[inline(always)]
        pub const fn gtupsr(self) -> crate::common::Reg<regs::Gtupsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "General PWM Timer Down Count Source Select Register"]
        #[inline(always)]
        pub const fn gtdnsr(self) -> crate::common::Reg<regs::Gtdnsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register A"]
        #[inline(always)]
        pub const fn gticasr(self) -> crate::common::Reg<regs::Gticasr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register B"]
        #[inline(always)]
        pub const fn gticbsr(self) -> crate::common::Reg<regs::Gticbsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "General PWM Timer Control Register"]
        #[inline(always)]
        pub const fn gtcr(self) -> crate::common::Reg<regs::Gtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "General PWM Timer Count Direction and Duty Setting Register"]
        #[inline(always)]
        pub const fn gtuddtyc(self) -> crate::common::Reg<regs::Gtuddtyc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "General PWM Timer I/O Control Register"]
        #[inline(always)]
        pub const fn gtior(self) -> crate::common::Reg<regs::Gtior, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "General PWM Timer Interrupt Output Setting Register"]
        #[inline(always)]
        pub const fn gtintad(self) -> crate::common::Reg<regs::Gtintad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "General PWM Timer Status Register"]
        #[inline(always)]
        pub const fn gtst(self) -> crate::common::Reg<regs::Gtst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "General PWM Timer Buffer Enable Register"]
        #[inline(always)]
        pub const fn gtber(self) -> crate::common::Reg<regs::Gtber, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "General PWM Timer Counter"]
        #[inline(always)]
        pub const fn gtcnt(self) -> crate::common::Reg<regs::Gtcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register A"]
        #[inline(always)]
        pub const fn gtccra(self) -> crate::common::Reg<regs::Gtccra, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register B"]
        #[inline(always)]
        pub const fn gtccrb(self) -> crate::common::Reg<regs::Gtccrb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register C"]
        #[inline(always)]
        pub const fn gtccrc(self) -> crate::common::Reg<regs::Gtccrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register E"]
        #[inline(always)]
        pub const fn gtccre(self) -> crate::common::Reg<regs::Gtccre, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register D"]
        #[inline(always)]
        pub const fn gtccrd(self) -> crate::common::Reg<regs::Gtccrd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register F"]
        #[inline(always)]
        pub const fn gtccrf(self) -> crate::common::Reg<regs::Gtccrf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "General PWM Timer Cycle Setting Register"]
        #[inline(always)]
        pub const fn gtpr(self) -> crate::common::Reg<regs::Gtpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "General PWM Timer Cycle Setting Buffer Register"]
        #[inline(always)]
        pub const fn gtpbr(self) -> crate::common::Reg<regs::Gtpbr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "General PWM Timer Dead Time Control Register"]
        #[inline(always)]
        pub const fn gtdtcr(self) -> crate::common::Reg<regs::Gtdtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "General PWM Timer Dead Time Value Register U"]
        #[inline(always)]
        pub const fn gtdvu(self) -> crate::common::Reg<regs::Gtdvu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "General PWM Timer Buffer Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtber(pub u32);
        impl Gtber {
            #[doc = "BD\\[1\\]: GTPR Buffer Operation DisableBD\\[0\\]: GTCCR Buffer Operation Disable"]
            #[inline(always)]
            pub const fn bd(&self) -> super::vals::Bd {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Bd::from_bits(val as u8)
            }
            #[doc = "BD\\[1\\]: GTPR Buffer Operation DisableBD\\[0\\]: GTCCR Buffer Operation Disable"]
            #[inline(always)]
            pub fn set_bd(&mut self, val: super::vals::Bd) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "GTCCRA Buffer Operation"]
            #[inline(always)]
            pub const fn ccra(&self) -> super::vals::Ccra {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Ccra::from_bits(val as u8)
            }
            #[doc = "GTCCRA Buffer Operation"]
            #[inline(always)]
            pub fn set_ccra(&mut self, val: super::vals::Ccra) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "GTCCRB Buffer Operation"]
            #[inline(always)]
            pub const fn ccrb(&self) -> super::vals::Ccrb {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Ccrb::from_bits(val as u8)
            }
            #[doc = "GTCCRB Buffer Operation"]
            #[inline(always)]
            pub fn set_ccrb(&mut self, val: super::vals::Ccrb) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "GTPR Buffer Operation"]
            #[inline(always)]
            pub const fn pr(&self) -> super::vals::Pr {
                let val = (self.0 >> 20usize) & 0x03;
                super::vals::Pr::from_bits(val as u8)
            }
            #[doc = "GTPR Buffer Operation"]
            #[inline(always)]
            pub fn set_pr(&mut self, val: super::vals::Pr) {
                self.0 =
                    (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
            }
            #[doc = "GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0."]
            #[inline(always)]
            pub const fn ccrswt(&self) -> super::vals::Ccrswt {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Ccrswt::from_bits(val as u8)
            }
            #[doc = "GTCCRA and GTCCRB Forcible Buffer OperationThis bit is read as 0."]
            #[inline(always)]
            pub fn set_ccrswt(&mut self, val: super::vals::Ccrswt) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Gtber {
            #[inline(always)]
            fn default() -> Gtber {
                Gtber(0)
            }
        }
        impl core::fmt::Debug for Gtber {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtber")
                    .field("bd", &self.bd())
                    .field("ccra", &self.ccra())
                    .field("ccrb", &self.ccrb())
                    .field("pr", &self.pr())
                    .field("ccrswt", &self.ccrswt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtber {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtber {{ bd: {:?}, ccra: {:?}, ccrb: {:?}, pr: {:?}, ccrswt: {:?} }}",
                    self.bd(),
                    self.ccra(),
                    self.ccrb(),
                    self.pr(),
                    self.ccrswt()
                )
            }
        }
        #[doc = "General PWM Timer Compare Capture Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccra(pub u32);
        impl Gtccra {
            #[doc = "Compare Capture Register A"]
            #[inline(always)]
            pub const fn gtccra(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Compare Capture Register A"]
            #[inline(always)]
            pub fn set_gtccra(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtccra {
            #[inline(always)]
            fn default() -> Gtccra {
                Gtccra(0)
            }
        }
        impl core::fmt::Debug for Gtccra {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccra")
                    .field("gtccra", &self.gtccra())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccra {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtccra {{ gtccra: {=u32:?} }}", self.gtccra())
            }
        }
        #[doc = "General PWM Timer Compare Capture Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccrb(pub u32);
        impl Gtccrb {
            #[doc = "Compare Capture Register B"]
            #[inline(always)]
            pub const fn gtccrb(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Compare Capture Register B"]
            #[inline(always)]
            pub fn set_gtccrb(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtccrb {
            #[inline(always)]
            fn default() -> Gtccrb {
                Gtccrb(0)
            }
        }
        impl core::fmt::Debug for Gtccrb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccrb")
                    .field("gtccrb", &self.gtccrb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccrb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtccrb {{ gtccrb: {=u32:?} }}", self.gtccrb())
            }
        }
        #[doc = "General PWM Timer Compare Capture Register C"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccrc(pub u32);
        impl Gtccrc {
            #[doc = "Compare Capture Register C"]
            #[inline(always)]
            pub const fn gtccrc(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Compare Capture Register C"]
            #[inline(always)]
            pub fn set_gtccrc(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtccrc {
            #[inline(always)]
            fn default() -> Gtccrc {
                Gtccrc(0)
            }
        }
        impl core::fmt::Debug for Gtccrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccrc")
                    .field("gtccrc", &self.gtccrc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtccrc {{ gtccrc: {=u32:?} }}", self.gtccrc())
            }
        }
        #[doc = "General PWM Timer Compare Capture Register D"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccrd(pub u32);
        impl Gtccrd {
            #[doc = "Compare Capture Register D"]
            #[inline(always)]
            pub const fn gtccrd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Compare Capture Register D"]
            #[inline(always)]
            pub fn set_gtccrd(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtccrd {
            #[inline(always)]
            fn default() -> Gtccrd {
                Gtccrd(0)
            }
        }
        impl core::fmt::Debug for Gtccrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccrd")
                    .field("gtccrd", &self.gtccrd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccrd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtccrd {{ gtccrd: {=u32:?} }}", self.gtccrd())
            }
        }
        #[doc = "General PWM Timer Compare Capture Register E"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccre(pub u32);
        impl Gtccre {
            #[doc = "Compare Capture Register E"]
            #[inline(always)]
            pub const fn gtccre(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Compare Capture Register E"]
            #[inline(always)]
            pub fn set_gtccre(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtccre {
            #[inline(always)]
            fn default() -> Gtccre {
                Gtccre(0)
            }
        }
        impl core::fmt::Debug for Gtccre {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccre")
                    .field("gtccre", &self.gtccre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccre {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtccre {{ gtccre: {=u32:?} }}", self.gtccre())
            }
        }
        #[doc = "General PWM Timer Compare Capture Register F"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtccrf(pub u32);
        impl Gtccrf {
            #[doc = "Compare Capture Register F"]
            #[inline(always)]
            pub const fn gtccrf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Compare Capture Register F"]
            #[inline(always)]
            pub fn set_gtccrf(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtccrf {
            #[inline(always)]
            fn default() -> Gtccrf {
                Gtccrf(0)
            }
        }
        impl core::fmt::Debug for Gtccrf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtccrf")
                    .field("gtccrf", &self.gtccrf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtccrf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtccrf {{ gtccrf: {=u32:?} }}", self.gtccrf())
            }
        }
        #[doc = "General PWM Timer Software Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtclr(pub u32);
        impl Gtclr {
            #[doc = "Channel 0 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr0(&self) -> super::vals::Cclr0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cclr0::from_bits(val as u8)
            }
            #[doc = "Channel 0 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr0(&mut self, val: super::vals::Cclr0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel 1 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr1(&self) -> super::vals::Cclr1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cclr1::from_bits(val as u8)
            }
            #[doc = "Channel 1 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr1(&mut self, val: super::vals::Cclr1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Channel 2 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr2(&self) -> super::vals::Cclr2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cclr2::from_bits(val as u8)
            }
            #[doc = "Channel 2 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr2(&mut self, val: super::vals::Cclr2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Channel 3 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr3(&self) -> super::vals::Cclr3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cclr3::from_bits(val as u8)
            }
            #[doc = "Channel 3 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr3(&mut self, val: super::vals::Cclr3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Channel 4 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr4(&self) -> super::vals::Cclr4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cclr4::from_bits(val as u8)
            }
            #[doc = "Channel 4 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr4(&mut self, val: super::vals::Cclr4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel 5 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr5(&self) -> super::vals::Cclr5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cclr5::from_bits(val as u8)
            }
            #[doc = "Channel 5 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr5(&mut self, val: super::vals::Cclr5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel 6 GTCNT Count Clear"]
            #[inline(always)]
            pub const fn cclr6(&self) -> super::vals::Cclr6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cclr6::from_bits(val as u8)
            }
            #[doc = "Channel 6 GTCNT Count Clear"]
            #[inline(always)]
            pub fn set_cclr6(&mut self, val: super::vals::Cclr6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "The write value should be 0000000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_7_31(&self) -> u32 {
                let val = (self.0 >> 7usize) & 0x01ff_ffff;
                val as u32
            }
            #[doc = "The write value should be 0000000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_7_31(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x01ff_ffff << 7usize)) | (((val as u32) & 0x01ff_ffff) << 7usize);
            }
        }
        impl Default for Gtclr {
            #[inline(always)]
            fn default() -> Gtclr {
                Gtclr(0)
            }
        }
        impl core::fmt::Debug for Gtclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtclr")
                    .field("cclr0", &self.cclr0())
                    .field("cclr1", &self.cclr1())
                    .field("cclr2", &self.cclr2())
                    .field("cclr3", &self.cclr3())
                    .field("cclr4", &self.cclr4())
                    .field("cclr5", &self.cclr5())
                    .field("cclr6", &self.cclr6())
                    .field("reserved_7_31", &self.reserved_7_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtclr {{ cclr0: {:?}, cclr1: {:?}, cclr2: {:?}, cclr3: {:?}, cclr4: {:?}, cclr5: {:?}, cclr6: {:?}, reserved_7_31: {=u32:?} }}" , self . cclr0 () , self . cclr1 () , self . cclr2 () , self . cclr3 () , self . cclr4 () , self . cclr5 () , self . cclr6 () , self . reserved_7_31 ())
            }
        }
        #[doc = "General PWM Timer Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcnt(pub u32);
        impl Gtcnt {
            #[doc = "Counter"]
            #[inline(always)]
            pub const fn gtcnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Counter"]
            #[inline(always)]
            pub fn set_gtcnt(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtcnt {
            #[inline(always)]
            fn default() -> Gtcnt {
                Gtcnt(0)
            }
        }
        impl core::fmt::Debug for Gtcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcnt")
                    .field("gtcnt", &self.gtcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtcnt {{ gtcnt: {=u32:?} }}", self.gtcnt())
            }
        }
        #[doc = "General PWM Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcr(pub u32);
        impl Gtcr {
            #[doc = "Count Start"]
            #[inline(always)]
            pub const fn cst(&self) -> super::vals::Cst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cst::from_bits(val as u8)
            }
            #[doc = "Count Start"]
            #[inline(always)]
            pub fn set_cst(&mut self, val: super::vals::Cst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub const fn reserved_1_15(&self) -> u16 {
                let val = (self.0 >> 1usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_1_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 1usize)) | (((val as u32) & 0x7fff) << 1usize);
            }
            #[doc = "Mode Select"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Md {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Md::from_bits(val as u8)
            }
            #[doc = "Mode Select"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Md) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_19_23(&self) -> u8 {
                let val = (self.0 >> 19usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_19_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 19usize)) | (((val as u32) & 0x1f) << 19usize);
            }
            #[doc = "Timer Prescaler Select"]
            #[inline(always)]
            pub const fn tpcs(&self) -> super::vals::Tpcs {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Tpcs::from_bits(val as u8)
            }
            #[doc = "Timer Prescaler Select"]
            #[inline(always)]
            pub fn set_tpcs(&mut self, val: super::vals::Tpcs) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Gtcr {
            #[inline(always)]
            fn default() -> Gtcr {
                Gtcr(0)
            }
        }
        impl core::fmt::Debug for Gtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcr")
                    .field("cst", &self.cst())
                    .field("reserved_1_15", &self.reserved_1_15())
                    .field("md", &self.md())
                    .field("reserved_19_23", &self.reserved_19_23())
                    .field("tpcs", &self.tpcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtcr {{ cst: {:?}, reserved_1_15: {=u16:?}, md: {:?}, reserved_19_23: {=u8:?}, tpcs: {:?} }}" , self . cst () , self . reserved_1_15 () , self . md () , self . reserved_19_23 () , self . tpcs ())
            }
        }
        #[doc = "General PWM Timer Clear Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcsr(pub u32);
        impl Gtcsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgar(&self) -> super::vals::Csgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Csgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgar(&mut self, val: super::vals::Csgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgaf(&self) -> super::vals::Csgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Csgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgaf(&mut self, val: super::vals::Csgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgbr(&self) -> super::vals::Csgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Csgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgbr(&mut self, val: super::vals::Csgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgbf(&self) -> super::vals::Csgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Csgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgbf(&mut self, val: super::vals::Csgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscarbl(&self) -> super::vals::Cscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscarbl(&mut self, val: super::vals::Cscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscarbh(&self) -> super::vals::Cscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscarbh(&mut self, val: super::vals::Cscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscafbl(&self) -> super::vals::Cscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscafbl(&mut self, val: super::vals::Cscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscafbh(&self) -> super::vals::Cscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscafbh(&mut self, val: super::vals::Cscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbral(&self) -> super::vals::Cscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbral(&mut self, val: super::vals::Cscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbrah(&self) -> super::vals::Cscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbrah(&mut self, val: super::vals::Cscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbfal(&self) -> super::vals::Cscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbfal(&mut self, val: super::vals::Cscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbfah(&self) -> super::vals::Cscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbfah(&mut self, val: super::vals::Cscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselca(&self) -> super::vals::Cselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Cselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselca(&mut self, val: super::vals::Cselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcb(&self) -> super::vals::Cselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Cselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcb(&mut self, val: super::vals::Cselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcc(&self) -> super::vals::Cselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Cselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcc(&mut self, val: super::vals::Cselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcd(&self) -> super::vals::Cselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Cselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcd(&mut self, val: super::vals::Cselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub const fn reserved_20_30(&self) -> u16 {
                let val = (self.0 >> 20usize) & 0x07ff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub fn set_reserved_20_30(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 20usize)) | (((val as u32) & 0x07ff) << 20usize);
            }
            #[doc = "Software Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cclr(&self) -> super::vals::Cclr {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cclr::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cclr(&mut self, val: super::vals::Cclr) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtcsr {
            #[inline(always)]
            fn default() -> Gtcsr {
                Gtcsr(0)
            }
        }
        impl core::fmt::Debug for Gtcsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcsr")
                    .field("csgtrgar", &self.csgtrgar())
                    .field("csgtrgaf", &self.csgtrgaf())
                    .field("csgtrgbr", &self.csgtrgbr())
                    .field("csgtrgbf", &self.csgtrgbf())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .field("cscarbl", &self.cscarbl())
                    .field("cscarbh", &self.cscarbh())
                    .field("cscafbl", &self.cscafbl())
                    .field("cscafbh", &self.cscafbh())
                    .field("cscbral", &self.cscbral())
                    .field("cscbrah", &self.cscbrah())
                    .field("cscbfal", &self.cscbfal())
                    .field("cscbfah", &self.cscbfah())
                    .field("cselca", &self.cselca())
                    .field("cselcb", &self.cselcb())
                    .field("cselcc", &self.cselcc())
                    .field("cselcd", &self.cselcd())
                    .field("reserved_20_30", &self.reserved_20_30())
                    .field("cclr", &self.cclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtcsr {{ csgtrgar: {:?}, csgtrgaf: {:?}, csgtrgbr: {:?}, csgtrgbf: {:?}, reserved_4_7: {=u8:?}, cscarbl: {:?}, cscarbh: {:?}, cscafbl: {:?}, cscafbh: {:?}, cscbral: {:?}, cscbrah: {:?}, cscbfal: {:?}, cscbfah: {:?}, cselca: {:?}, cselcb: {:?}, cselcc: {:?}, cselcd: {:?}, reserved_20_30: {=u16:?}, cclr: {:?} }}" , self . csgtrgar () , self . csgtrgaf () , self . csgtrgbr () , self . csgtrgbf () , self . reserved_4_7 () , self . cscarbl () , self . cscarbh () , self . cscafbl () , self . cscafbh () , self . cscbral () , self . cscbrah () , self . cscbfal () , self . cscbfah () , self . cselca () , self . cselcb () , self . cselcc () , self . cselcd () , self . reserved_20_30 () , self . cclr ())
            }
        }
        #[doc = "General PWM Timer Down Count Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdnsr(pub u32);
        impl Gtdnsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgar(&self) -> super::vals::Dsgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dsgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgar(&mut self, val: super::vals::Dsgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgaf(&self) -> super::vals::Dsgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Dsgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgaf(&mut self, val: super::vals::Dsgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgbr(&self) -> super::vals::Dsgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dsgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgbr(&mut self, val: super::vals::Dsgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgbf(&self) -> super::vals::Dsgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dsgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgbf(&mut self, val: super::vals::Dsgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscarbl(&self) -> super::vals::Dscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Dscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscarbl(&mut self, val: super::vals::Dscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscarbh(&self) -> super::vals::Dscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Dscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscarbh(&mut self, val: super::vals::Dscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscafbl(&self) -> super::vals::Dscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Dscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscafbl(&mut self, val: super::vals::Dscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscafbh(&self) -> super::vals::Dscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Dscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscafbh(&mut self, val: super::vals::Dscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbral(&self) -> super::vals::Dscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Dscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbral(&mut self, val: super::vals::Dscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbrah(&self) -> super::vals::Dscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Dscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbrah(&mut self, val: super::vals::Dscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbfal(&self) -> super::vals::Dscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Dscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbfal(&mut self, val: super::vals::Dscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbfah(&self) -> super::vals::Dscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Dscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbfah(&mut self, val: super::vals::Dscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselca(&self) -> super::vals::Dselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Dselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselca(&mut self, val: super::vals::Dselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcb(&self) -> super::vals::Dselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Dselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcb(&mut self, val: super::vals::Dselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcc(&self) -> super::vals::Dselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Dselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcc(&mut self, val: super::vals::Dselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcd(&self) -> super::vals::Dselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Dselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcd(&mut self, val: super::vals::Dselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gtdnsr {
            #[inline(always)]
            fn default() -> Gtdnsr {
                Gtdnsr(0)
            }
        }
        impl core::fmt::Debug for Gtdnsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdnsr")
                    .field("dsgtrgar", &self.dsgtrgar())
                    .field("dsgtrgaf", &self.dsgtrgaf())
                    .field("dsgtrgbr", &self.dsgtrgbr())
                    .field("dsgtrgbf", &self.dsgtrgbf())
                    .field("dscarbl", &self.dscarbl())
                    .field("dscarbh", &self.dscarbh())
                    .field("dscafbl", &self.dscafbl())
                    .field("dscafbh", &self.dscafbh())
                    .field("dscbral", &self.dscbral())
                    .field("dscbrah", &self.dscbrah())
                    .field("dscbfal", &self.dscbfal())
                    .field("dscbfah", &self.dscbfah())
                    .field("dselca", &self.dselca())
                    .field("dselcb", &self.dselcb())
                    .field("dselcc", &self.dselcc())
                    .field("dselcd", &self.dselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdnsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtdnsr {{ dsgtrgar: {:?}, dsgtrgaf: {:?}, dsgtrgbr: {:?}, dsgtrgbf: {:?}, dscarbl: {:?}, dscarbh: {:?}, dscafbl: {:?}, dscafbh: {:?}, dscbral: {:?}, dscbrah: {:?}, dscbfal: {:?}, dscbfah: {:?}, dselca: {:?}, dselcb: {:?}, dselcc: {:?}, dselcd: {:?} }}" , self . dsgtrgar () , self . dsgtrgaf () , self . dsgtrgbr () , self . dsgtrgbf () , self . dscarbl () , self . dscarbh () , self . dscafbl () , self . dscafbh () , self . dscbral () , self . dscbrah () , self . dscbfal () , self . dscbfah () , self . dselca () , self . dselcb () , self . dselcc () , self . dselcd ())
            }
        }
        #[doc = "General PWM Timer Dead Time Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdtcr(pub u32);
        impl Gtdtcr {
            #[doc = "Negative,Phase Waveform Setting"]
            #[inline(always)]
            pub const fn tde(&self) -> super::vals::Tde {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tde::from_bits(val as u8)
            }
            #[doc = "Negative,Phase Waveform Setting"]
            #[inline(always)]
            pub fn set_tde(&mut self, val: super::vals::Tde) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000000000000000000000000000. The write value should be 0000000000000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_1_31(&self) -> u32 {
                let val = (self.0 >> 1usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "These bits are read as 0000000000000000000000000000000. The write value should be 0000000000000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_1_31(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x7fff_ffff << 1usize)) | (((val as u32) & 0x7fff_ffff) << 1usize);
            }
        }
        impl Default for Gtdtcr {
            #[inline(always)]
            fn default() -> Gtdtcr {
                Gtdtcr(0)
            }
        }
        impl core::fmt::Debug for Gtdtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdtcr")
                    .field("tde", &self.tde())
                    .field("reserved_1_31", &self.reserved_1_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtdtcr {{ tde: {:?}, reserved_1_31: {=u32:?} }}",
                    self.tde(),
                    self.reserved_1_31()
                )
            }
        }
        #[doc = "General PWM Timer Dead Time Value Register U"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdvu(pub u32);
        impl Gtdvu {
            #[doc = "Dead Time Value Register U"]
            #[inline(always)]
            pub const fn gtdvu(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Dead Time Value Register U"]
            #[inline(always)]
            pub fn set_gtdvu(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtdvu {
            #[inline(always)]
            fn default() -> Gtdvu {
                Gtdvu(0)
            }
        }
        impl core::fmt::Debug for Gtdvu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdvu")
                    .field("gtdvu", &self.gtdvu())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdvu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtdvu {{ gtdvu: {=u32:?} }}", self.gtdvu())
            }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gticasr(pub u32);
        impl Gticasr {
            #[doc = "GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgar(&self) -> super::vals::Asgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Asgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgar(&mut self, val: super::vals::Asgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgaf(&self) -> super::vals::Asgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Asgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgaf(&mut self, val: super::vals::Asgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgbr(&self) -> super::vals::Asgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Asgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgbr(&mut self, val: super::vals::Asgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgbf(&self) -> super::vals::Asgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Asgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgbf(&mut self, val: super::vals::Asgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascarbl(&self) -> super::vals::Ascarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ascarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascarbl(&mut self, val: super::vals::Ascarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascarbh(&self) -> super::vals::Ascarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ascarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascarbh(&mut self, val: super::vals::Ascarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascafbl(&self) -> super::vals::Ascafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ascafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascafbl(&mut self, val: super::vals::Ascafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascafbh(&self) -> super::vals::Ascafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ascafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascafbh(&mut self, val: super::vals::Ascafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbral(&self) -> super::vals::Ascbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ascbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbral(&mut self, val: super::vals::Ascbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbrah(&self) -> super::vals::Ascbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ascbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbrah(&mut self, val: super::vals::Ascbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbfal(&self) -> super::vals::Ascbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ascbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbfal(&mut self, val: super::vals::Ascbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbfah(&self) -> super::vals::Ascbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ascbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbfah(&mut self, val: super::vals::Ascbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselca(&self) -> super::vals::Aselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Aselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselca(&mut self, val: super::vals::Aselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcb(&self) -> super::vals::Aselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Aselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcb(&mut self, val: super::vals::Aselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcc(&self) -> super::vals::Aselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Aselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcc(&mut self, val: super::vals::Aselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcd(&self) -> super::vals::Aselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Aselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcd(&mut self, val: super::vals::Aselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gticasr {
            #[inline(always)]
            fn default() -> Gticasr {
                Gticasr(0)
            }
        }
        impl core::fmt::Debug for Gticasr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gticasr")
                    .field("asgtrgar", &self.asgtrgar())
                    .field("asgtrgaf", &self.asgtrgaf())
                    .field("asgtrgbr", &self.asgtrgbr())
                    .field("asgtrgbf", &self.asgtrgbf())
                    .field("ascarbl", &self.ascarbl())
                    .field("ascarbh", &self.ascarbh())
                    .field("ascafbl", &self.ascafbl())
                    .field("ascafbh", &self.ascafbh())
                    .field("ascbral", &self.ascbral())
                    .field("ascbrah", &self.ascbrah())
                    .field("ascbfal", &self.ascbfal())
                    .field("ascbfah", &self.ascbfah())
                    .field("aselca", &self.aselca())
                    .field("aselcb", &self.aselcb())
                    .field("aselcc", &self.aselcc())
                    .field("aselcd", &self.aselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gticasr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gticasr {{ asgtrgar: {:?}, asgtrgaf: {:?}, asgtrgbr: {:?}, asgtrgbf: {:?}, ascarbl: {:?}, ascarbh: {:?}, ascafbl: {:?}, ascafbh: {:?}, ascbral: {:?}, ascbrah: {:?}, ascbfal: {:?}, ascbfah: {:?}, aselca: {:?}, aselcb: {:?}, aselcc: {:?}, aselcd: {:?} }}" , self . asgtrgar () , self . asgtrgaf () , self . asgtrgbr () , self . asgtrgbf () , self . ascarbl () , self . ascarbh () , self . ascafbl () , self . ascafbh () , self . ascbral () , self . ascbrah () , self . ascbfal () , self . ascbfah () , self . aselca () , self . aselcb () , self . aselcc () , self . aselcd ())
            }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gticbsr(pub u32);
        impl Gticbsr {
            #[doc = "GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgar(&self) -> super::vals::Bsgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bsgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgar(&mut self, val: super::vals::Bsgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgaf(&self) -> super::vals::Bsgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Bsgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgaf(&mut self, val: super::vals::Bsgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgbr(&self) -> super::vals::Bsgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Bsgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgbr(&mut self, val: super::vals::Bsgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgbf(&self) -> super::vals::Bsgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bsgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgbf(&mut self, val: super::vals::Bsgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscarbl(&self) -> super::vals::Bscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Bscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscarbl(&mut self, val: super::vals::Bscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscarbh(&self) -> super::vals::Bscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Bscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscarbh(&mut self, val: super::vals::Bscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscafbl(&self) -> super::vals::Bscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscafbl(&mut self, val: super::vals::Bscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscafbh(&self) -> super::vals::Bscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Bscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscafbh(&mut self, val: super::vals::Bscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbral(&self) -> super::vals::Bscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Bscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbral(&mut self, val: super::vals::Bscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbrah(&self) -> super::vals::Bscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Bscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbrah(&mut self, val: super::vals::Bscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbfal(&self) -> super::vals::Bscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Bscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbfal(&mut self, val: super::vals::Bscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbfah(&self) -> super::vals::Bscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Bscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbfah(&mut self, val: super::vals::Bscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselca(&self) -> super::vals::Bselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Bselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselca(&mut self, val: super::vals::Bselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcb(&self) -> super::vals::Bselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Bselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcb(&mut self, val: super::vals::Bselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcc(&self) -> super::vals::Bselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Bselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcc(&mut self, val: super::vals::Bselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcd(&self) -> super::vals::Bselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Bselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcd(&mut self, val: super::vals::Bselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gticbsr {
            #[inline(always)]
            fn default() -> Gticbsr {
                Gticbsr(0)
            }
        }
        impl core::fmt::Debug for Gticbsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gticbsr")
                    .field("bsgtrgar", &self.bsgtrgar())
                    .field("bsgtrgaf", &self.bsgtrgaf())
                    .field("bsgtrgbr", &self.bsgtrgbr())
                    .field("bsgtrgbf", &self.bsgtrgbf())
                    .field("bscarbl", &self.bscarbl())
                    .field("bscarbh", &self.bscarbh())
                    .field("bscafbl", &self.bscafbl())
                    .field("bscafbh", &self.bscafbh())
                    .field("bscbral", &self.bscbral())
                    .field("bscbrah", &self.bscbrah())
                    .field("bscbfal", &self.bscbfal())
                    .field("bscbfah", &self.bscbfah())
                    .field("bselca", &self.bselca())
                    .field("bselcb", &self.bselcb())
                    .field("bselcc", &self.bselcc())
                    .field("bselcd", &self.bselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gticbsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gticbsr {{ bsgtrgar: {:?}, bsgtrgaf: {:?}, bsgtrgbr: {:?}, bsgtrgbf: {:?}, bscarbl: {:?}, bscarbh: {:?}, bscafbl: {:?}, bscafbh: {:?}, bscbral: {:?}, bscbrah: {:?}, bscbfal: {:?}, bscbfah: {:?}, bselca: {:?}, bselcb: {:?}, bselcc: {:?}, bselcd: {:?} }}" , self . bsgtrgar () , self . bsgtrgaf () , self . bsgtrgbr () , self . bsgtrgbf () , self . bscarbl () , self . bscarbh () , self . bscafbl () , self . bscafbh () , self . bscbral () , self . bscbrah () , self . bscbfal () , self . bscbfah () , self . bselca () , self . bselcb () , self . bselcc () , self . bselcd ())
            }
        }
        #[doc = "General PWM Timer Interrupt Output Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtintad(pub u32);
        impl Gtintad {
            #[doc = "These bits are read as 000000000000000000000000. The write value should be 000000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_0_23(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "These bits are read as 000000000000000000000000. The write value should be 000000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_0_23(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "Output Disable Source Select"]
            #[inline(always)]
            pub const fn grp(&self) -> super::vals::Grp {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Grp::from_bits(val as u8)
            }
            #[doc = "Output Disable Source Select"]
            #[inline(always)]
            pub fn set_grp(&mut self, val: super::vals::Grp) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_26_28(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_26_28(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 26usize)) | (((val as u32) & 0x07) << 26usize);
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub const fn grpabh(&self) -> super::vals::Grpabh {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Grpabh::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub fn set_grpabh(&mut self, val: super::vals::Grpabh) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub const fn grpabl(&self) -> super::vals::Grpabl {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Grpabl::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub fn set_grpabl(&mut self, val: super::vals::Grpabl) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Gtintad {
            #[inline(always)]
            fn default() -> Gtintad {
                Gtintad(0)
            }
        }
        impl core::fmt::Debug for Gtintad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtintad")
                    .field("reserved_0_23", &self.reserved_0_23())
                    .field("grp", &self.grp())
                    .field("reserved_26_28", &self.reserved_26_28())
                    .field("grpabh", &self.grpabh())
                    .field("grpabl", &self.grpabl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtintad {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtintad {{ reserved_0_23: {=u32:?}, grp: {:?}, reserved_26_28: {=u8:?}, grpabh: {:?}, grpabl: {:?} }}" , self . reserved_0_23 () , self . grp () , self . reserved_26_28 () , self . grpabh () , self . grpabl ())
            }
        }
        #[doc = "General PWM Timer I/O Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtior(pub u32);
        impl Gtior {
            #[doc = "GTIOCA Pin Function Select"]
            #[inline(always)]
            pub const fn gtioa(&self) -> super::vals::Gtioa {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Gtioa::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Function Select"]
            #[inline(always)]
            pub fn set_gtioa(&mut self, val: super::vals::Gtioa) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GTIOCA Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub const fn oadflt(&self) -> super::vals::Oadflt {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Oadflt::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub fn set_oadflt(&mut self, val: super::vals::Oadflt) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "GTIOCA Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub const fn oahld(&self) -> super::vals::Oahld {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Oahld::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub fn set_oahld(&mut self, val: super::vals::Oahld) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "GTIOCA Pin Output Enable"]
            #[inline(always)]
            pub const fn oae(&self) -> super::vals::Oae {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Oae::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Output Enable"]
            #[inline(always)]
            pub fn set_oae(&mut self, val: super::vals::Oae) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Disable Value Setting"]
            #[inline(always)]
            pub const fn oadf(&self) -> super::vals::Oadf {
                let val = (self.0 >> 9usize) & 0x03;
                super::vals::Oadf::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Disable Value Setting"]
            #[inline(always)]
            pub fn set_oadf(&mut self, val: super::vals::Oadf) {
                self.0 = (self.0 & !(0x03 << 9usize)) | (((val.to_bits() as u32) & 0x03) << 9usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_11_12(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_11_12(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 11usize)) | (((val as u32) & 0x03) << 11usize);
            }
            #[doc = "Noise Filter A Enable"]
            #[inline(always)]
            pub const fn nfaen(&self) -> super::vals::Nfaen {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Nfaen::from_bits(val as u8)
            }
            #[doc = "Noise Filter A Enable"]
            #[inline(always)]
            pub fn set_nfaen(&mut self, val: super::vals::Nfaen) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Noise Filter A Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfcsa(&self) -> super::vals::Nfcsa {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Nfcsa::from_bits(val as u8)
            }
            #[doc = "Noise Filter A Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfcsa(&mut self, val: super::vals::Nfcsa) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u32) & 0x03) << 14usize);
            }
            #[doc = "GTIOCB Pin Function Select"]
            #[inline(always)]
            pub const fn gtiob(&self) -> super::vals::Gtiob {
                let val = (self.0 >> 16usize) & 0x1f;
                super::vals::Gtiob::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Function Select"]
            #[inline(always)]
            pub fn set_gtiob(&mut self, val: super::vals::Gtiob) {
                self.0 =
                    (self.0 & !(0x1f << 16usize)) | (((val.to_bits() as u32) & 0x1f) << 16usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_21_21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_21_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GTIOCB Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub const fn obdflt(&self) -> super::vals::Obdflt {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Obdflt::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub fn set_obdflt(&mut self, val: super::vals::Obdflt) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "GTIOCB Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub const fn obhld(&self) -> super::vals::Obhld {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Obhld::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub fn set_obhld(&mut self, val: super::vals::Obhld) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "GTIOCB Pin Output Enable"]
            #[inline(always)]
            pub const fn obe(&self) -> super::vals::Obe {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Obe::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Output Enable"]
            #[inline(always)]
            pub fn set_obe(&mut self, val: super::vals::Obe) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "GTIOCB Pin Disable Value Setting"]
            #[inline(always)]
            pub const fn obdf(&self) -> super::vals::Obdf {
                let val = (self.0 >> 25usize) & 0x03;
                super::vals::Obdf::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Disable Value Setting"]
            #[inline(always)]
            pub fn set_obdf(&mut self, val: super::vals::Obdf) {
                self.0 =
                    (self.0 & !(0x03 << 25usize)) | (((val.to_bits() as u32) & 0x03) << 25usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_27_28(&self) -> u8 {
                let val = (self.0 >> 27usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_27_28(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 27usize)) | (((val as u32) & 0x03) << 27usize);
            }
            #[doc = "Noise Filter B Enable"]
            #[inline(always)]
            pub const fn nfben(&self) -> super::vals::Nfben {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Nfben::from_bits(val as u8)
            }
            #[doc = "Noise Filter B Enable"]
            #[inline(always)]
            pub fn set_nfben(&mut self, val: super::vals::Nfben) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Noise Filter B Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfcsb(&self) -> super::vals::Nfcsb {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::Nfcsb::from_bits(val as u8)
            }
            #[doc = "Noise Filter B Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfcsb(&mut self, val: super::vals::Nfcsb) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Gtior {
            #[inline(always)]
            fn default() -> Gtior {
                Gtior(0)
            }
        }
        impl core::fmt::Debug for Gtior {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtior")
                    .field("gtioa", &self.gtioa())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("oadflt", &self.oadflt())
                    .field("oahld", &self.oahld())
                    .field("oae", &self.oae())
                    .field("oadf", &self.oadf())
                    .field("reserved_11_12", &self.reserved_11_12())
                    .field("nfaen", &self.nfaen())
                    .field("nfcsa", &self.nfcsa())
                    .field("gtiob", &self.gtiob())
                    .field("reserved_21_21", &self.reserved_21_21())
                    .field("obdflt", &self.obdflt())
                    .field("obhld", &self.obhld())
                    .field("obe", &self.obe())
                    .field("obdf", &self.obdf())
                    .field("reserved_27_28", &self.reserved_27_28())
                    .field("nfben", &self.nfben())
                    .field("nfcsb", &self.nfcsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtior {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtior {{ gtioa: {:?}, reserved_5_5: {=bool:?}, oadflt: {:?}, oahld: {:?}, oae: {:?}, oadf: {:?}, reserved_11_12: {=u8:?}, nfaen: {:?}, nfcsa: {:?}, gtiob: {:?}, reserved_21_21: {=bool:?}, obdflt: {:?}, obhld: {:?}, obe: {:?}, obdf: {:?}, reserved_27_28: {=u8:?}, nfben: {:?}, nfcsb: {:?} }}" , self . gtioa () , self . reserved_5_5 () , self . oadflt () , self . oahld () , self . oae () , self . oadf () , self . reserved_11_12 () , self . nfaen () , self . nfcsa () , self . gtiob () , self . reserved_21_21 () , self . obdflt () , self . obhld () , self . obe () , self . obdf () , self . reserved_27_28 () , self . nfben () , self . nfcsb ())
            }
        }
        #[doc = "General PWM Timer Cycle Setting Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtpbr(pub u32);
        impl Gtpbr {
            #[doc = "Cycle Setting Buffer Register"]
            #[inline(always)]
            pub const fn gtpbr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Cycle Setting Buffer Register"]
            #[inline(always)]
            pub fn set_gtpbr(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtpbr {
            #[inline(always)]
            fn default() -> Gtpbr {
                Gtpbr(0)
            }
        }
        impl core::fmt::Debug for Gtpbr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtpbr")
                    .field("gtpbr", &self.gtpbr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtpbr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtpbr {{ gtpbr: {=u32:?} }}", self.gtpbr())
            }
        }
        #[doc = "General PWM Timer Cycle Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtpr(pub u32);
        impl Gtpr {
            #[doc = "Cycle Setting Register"]
            #[inline(always)]
            pub const fn gtpr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Cycle Setting Register"]
            #[inline(always)]
            pub fn set_gtpr(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Gtpr {
            #[inline(always)]
            fn default() -> Gtpr {
                Gtpr(0)
            }
        }
        impl core::fmt::Debug for Gtpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtpr").field("gtpr", &self.gtpr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtpr {{ gtpr: {=u32:?} }}", self.gtpr())
            }
        }
        #[doc = "General PWM Timer Stop Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtpsr(pub u32);
        impl Gtpsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgar(&self) -> super::vals::Psgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Psgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgar(&mut self, val: super::vals::Psgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgaf(&self) -> super::vals::Psgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Psgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgaf(&mut self, val: super::vals::Psgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgbr(&self) -> super::vals::Psgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Psgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgbr(&mut self, val: super::vals::Psgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgbf(&self) -> super::vals::Psgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Psgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgbf(&mut self, val: super::vals::Psgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscarbl(&self) -> super::vals::Pscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscarbl(&mut self, val: super::vals::Pscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscarbh(&self) -> super::vals::Pscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscarbh(&mut self, val: super::vals::Pscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscafbl(&self) -> super::vals::Pscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscafbl(&mut self, val: super::vals::Pscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscafbh(&self) -> super::vals::Pscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscafbh(&mut self, val: super::vals::Pscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbral(&self) -> super::vals::Pscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbral(&mut self, val: super::vals::Pscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbrah(&self) -> super::vals::Pscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbrah(&mut self, val: super::vals::Pscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbfal(&self) -> super::vals::Pscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbfal(&mut self, val: super::vals::Pscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbfah(&self) -> super::vals::Pscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbfah(&mut self, val: super::vals::Pscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselca(&self) -> super::vals::Pselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselca(&mut self, val: super::vals::Pselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcb(&self) -> super::vals::Pselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcb(&mut self, val: super::vals::Pselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcc(&self) -> super::vals::Pselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcc(&mut self, val: super::vals::Pselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcd(&self) -> super::vals::Pselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcd(&mut self, val: super::vals::Pselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub const fn reserved_20_30(&self) -> u16 {
                let val = (self.0 >> 20usize) & 0x07ff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub fn set_reserved_20_30(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 20usize)) | (((val as u32) & 0x07ff) << 20usize);
            }
            #[doc = "Software Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn cstop(&self) -> super::vals::Cstop {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cstop::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_cstop(&mut self, val: super::vals::Cstop) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtpsr {
            #[inline(always)]
            fn default() -> Gtpsr {
                Gtpsr(0)
            }
        }
        impl core::fmt::Debug for Gtpsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtpsr")
                    .field("psgtrgar", &self.psgtrgar())
                    .field("psgtrgaf", &self.psgtrgaf())
                    .field("psgtrgbr", &self.psgtrgbr())
                    .field("psgtrgbf", &self.psgtrgbf())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .field("pscarbl", &self.pscarbl())
                    .field("pscarbh", &self.pscarbh())
                    .field("pscafbl", &self.pscafbl())
                    .field("pscafbh", &self.pscafbh())
                    .field("pscbral", &self.pscbral())
                    .field("pscbrah", &self.pscbrah())
                    .field("pscbfal", &self.pscbfal())
                    .field("pscbfah", &self.pscbfah())
                    .field("pselca", &self.pselca())
                    .field("pselcb", &self.pselcb())
                    .field("pselcc", &self.pselcc())
                    .field("pselcd", &self.pselcd())
                    .field("reserved_20_30", &self.reserved_20_30())
                    .field("cstop", &self.cstop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtpsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtpsr {{ psgtrgar: {:?}, psgtrgaf: {:?}, psgtrgbr: {:?}, psgtrgbf: {:?}, reserved_4_7: {=u8:?}, pscarbl: {:?}, pscarbh: {:?}, pscafbl: {:?}, pscafbh: {:?}, pscbral: {:?}, pscbrah: {:?}, pscbfal: {:?}, pscbfah: {:?}, pselca: {:?}, pselcb: {:?}, pselcc: {:?}, pselcd: {:?}, reserved_20_30: {=u16:?}, cstop: {:?} }}" , self . psgtrgar () , self . psgtrgaf () , self . psgtrgbr () , self . psgtrgbf () , self . reserved_4_7 () , self . pscarbl () , self . pscarbh () , self . pscafbl () , self . pscafbh () , self . pscbral () , self . pscbrah () , self . pscbfal () , self . pscbfah () , self . pselca () , self . pselcb () , self . pselcc () , self . pselcd () , self . reserved_20_30 () , self . cstop ())
            }
        }
        #[doc = "General PWM Timer Start Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtssr(pub u32);
        impl Gtssr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgar(&self) -> super::vals::Ssgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgar(&mut self, val: super::vals::Ssgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgaf(&self) -> super::vals::Ssgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgaf(&mut self, val: super::vals::Ssgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgbr(&self) -> super::vals::Ssgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ssgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgbr(&mut self, val: super::vals::Ssgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgbf(&self) -> super::vals::Ssgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ssgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgbf(&mut self, val: super::vals::Ssgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscarbl(&self) -> super::vals::Sscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Sscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscarbl(&mut self, val: super::vals::Sscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscarbh(&self) -> super::vals::Sscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Sscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscarbh(&mut self, val: super::vals::Sscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscafbl(&self) -> super::vals::Sscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Sscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscafbl(&mut self, val: super::vals::Sscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscafbh(&self) -> super::vals::Sscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Sscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscafbh(&mut self, val: super::vals::Sscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbral(&self) -> super::vals::Sscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Sscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbral(&mut self, val: super::vals::Sscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbrah(&self) -> super::vals::Sscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Sscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbrah(&mut self, val: super::vals::Sscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbfal(&self) -> super::vals::Sscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Sscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbfal(&mut self, val: super::vals::Sscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbfah(&self) -> super::vals::Sscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbfah(&mut self, val: super::vals::Sscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselca(&self) -> super::vals::Sselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Sselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselca(&mut self, val: super::vals::Sselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcb(&self) -> super::vals::Sselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Sselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcb(&mut self, val: super::vals::Sselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcc(&self) -> super::vals::Sselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Sselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcc(&mut self, val: super::vals::Sselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcd(&self) -> super::vals::Sselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Sselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcd(&mut self, val: super::vals::Sselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub const fn reserved_20_30(&self) -> u16 {
                let val = (self.0 >> 20usize) & 0x07ff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub fn set_reserved_20_30(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 20usize)) | (((val as u32) & 0x07ff) << 20usize);
            }
            #[doc = "Software Source Counter Start Enable"]
            #[inline(always)]
            pub const fn cstrt(&self) -> super::vals::Cstrt {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cstrt::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_cstrt(&mut self, val: super::vals::Cstrt) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtssr {
            #[inline(always)]
            fn default() -> Gtssr {
                Gtssr(0)
            }
        }
        impl core::fmt::Debug for Gtssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtssr")
                    .field("ssgtrgar", &self.ssgtrgar())
                    .field("ssgtrgaf", &self.ssgtrgaf())
                    .field("ssgtrgbr", &self.ssgtrgbr())
                    .field("ssgtrgbf", &self.ssgtrgbf())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .field("sscarbl", &self.sscarbl())
                    .field("sscarbh", &self.sscarbh())
                    .field("sscafbl", &self.sscafbl())
                    .field("sscafbh", &self.sscafbh())
                    .field("sscbral", &self.sscbral())
                    .field("sscbrah", &self.sscbrah())
                    .field("sscbfal", &self.sscbfal())
                    .field("sscbfah", &self.sscbfah())
                    .field("sselca", &self.sselca())
                    .field("sselcb", &self.sselcb())
                    .field("sselcc", &self.sselcc())
                    .field("sselcd", &self.sselcd())
                    .field("reserved_20_30", &self.reserved_20_30())
                    .field("cstrt", &self.cstrt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtssr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtssr {{ ssgtrgar: {:?}, ssgtrgaf: {:?}, ssgtrgbr: {:?}, ssgtrgbf: {:?}, reserved_4_7: {=u8:?}, sscarbl: {:?}, sscarbh: {:?}, sscafbl: {:?}, sscafbh: {:?}, sscbral: {:?}, sscbrah: {:?}, sscbfal: {:?}, sscbfah: {:?}, sselca: {:?}, sselcb: {:?}, sselcc: {:?}, sselcd: {:?}, reserved_20_30: {=u16:?}, cstrt: {:?} }}" , self . ssgtrgar () , self . ssgtrgaf () , self . ssgtrgbr () , self . ssgtrgbf () , self . reserved_4_7 () , self . sscarbl () , self . sscarbh () , self . sscafbl () , self . sscafbh () , self . sscbral () , self . sscbrah () , self . sscbfal () , self . sscbfah () , self . sselca () , self . sselcb () , self . sselcc () , self . sselcd () , self . reserved_20_30 () , self . cstrt ())
            }
        }
        #[doc = "General PWM Timer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtst(pub u32);
        impl Gtst {
            #[doc = "Input Capture/Compare Match Flag A"]
            #[inline(always)]
            pub const fn tcfa(&self) -> super::vals::Tcfa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tcfa::from_bits(val as u8)
            }
            #[doc = "Input Capture/Compare Match Flag A"]
            #[inline(always)]
            pub fn set_tcfa(&mut self, val: super::vals::Tcfa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Input Capture/Compare Match Flag B"]
            #[inline(always)]
            pub const fn tcfb(&self) -> super::vals::Tcfb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tcfb::from_bits(val as u8)
            }
            #[doc = "Input Capture/Compare Match Flag B"]
            #[inline(always)]
            pub fn set_tcfb(&mut self, val: super::vals::Tcfb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Input Compare Match Flag C"]
            #[inline(always)]
            pub const fn tcfc(&self) -> super::vals::Tcfc {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tcfc::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag C"]
            #[inline(always)]
            pub fn set_tcfc(&mut self, val: super::vals::Tcfc) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Input Compare Match Flag D"]
            #[inline(always)]
            pub const fn tcfd(&self) -> super::vals::Tcfd {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tcfd::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag D"]
            #[inline(always)]
            pub fn set_tcfd(&mut self, val: super::vals::Tcfd) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Input Compare Match Flag E"]
            #[inline(always)]
            pub const fn tcfe(&self) -> super::vals::Tcfe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tcfe::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag E"]
            #[inline(always)]
            pub fn set_tcfe(&mut self, val: super::vals::Tcfe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Input Compare Match Flag F"]
            #[inline(always)]
            pub const fn tcff(&self) -> super::vals::Tcff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tcff::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag F"]
            #[inline(always)]
            pub fn set_tcff(&mut self, val: super::vals::Tcff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub const fn tcpfo(&self) -> super::vals::Tcpfo {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tcpfo::from_bits(val as u8)
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub fn set_tcpfo(&mut self, val: super::vals::Tcpfo) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn tcfpu(&self) -> super::vals::Tcfpu {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tcfpu::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_tcfpu(&mut self, val: super::vals::Tcfpu) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_8_14(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_8_14(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 8usize)) | (((val as u32) & 0x7f) << 8usize);
            }
            #[doc = "Count Direction Flag"]
            #[inline(always)]
            pub const fn gtcf(&self) -> super::vals::Gtcf {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Gtcf::from_bits(val as u8)
            }
            #[doc = "Count Direction Flag"]
            #[inline(always)]
            pub fn set_gtcf(&mut self, val: super::vals::Gtcf) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_16_23(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_16_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Output Disable Flag"]
            #[inline(always)]
            pub const fn odf(&self) -> super::vals::Odf {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Odf::from_bits(val as u8)
            }
            #[doc = "Output Disable Flag"]
            #[inline(always)]
            pub fn set_odf(&mut self, val: super::vals::Odf) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_25_28(&self) -> u8 {
                let val = (self.0 >> 25usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_25_28(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 25usize)) | (((val as u32) & 0x0f) << 25usize);
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub const fn oabhf(&self) -> super::vals::Oabhf {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Oabhf::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub fn set_oabhf(&mut self, val: super::vals::Oabhf) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub const fn oablf(&self) -> super::vals::Oablf {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Oablf::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub fn set_oablf(&mut self, val: super::vals::Oablf) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Gtst {
            #[inline(always)]
            fn default() -> Gtst {
                Gtst(0)
            }
        }
        impl core::fmt::Debug for Gtst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtst")
                    .field("tcfa", &self.tcfa())
                    .field("tcfb", &self.tcfb())
                    .field("tcfc", &self.tcfc())
                    .field("tcfd", &self.tcfd())
                    .field("tcfe", &self.tcfe())
                    .field("tcff", &self.tcff())
                    .field("tcpfo", &self.tcpfo())
                    .field("tcfpu", &self.tcfpu())
                    .field("reserved_8_14", &self.reserved_8_14())
                    .field("gtcf", &self.gtcf())
                    .field("reserved_16_23", &self.reserved_16_23())
                    .field("odf", &self.odf())
                    .field("reserved_25_28", &self.reserved_25_28())
                    .field("oabhf", &self.oabhf())
                    .field("oablf", &self.oablf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtst {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtst {{ tcfa: {:?}, tcfb: {:?}, tcfc: {:?}, tcfd: {:?}, tcfe: {:?}, tcff: {:?}, tcpfo: {:?}, tcfpu: {:?}, reserved_8_14: {=u8:?}, gtcf: {:?}, reserved_16_23: {=u8:?}, odf: {:?}, reserved_25_28: {=u8:?}, oabhf: {:?}, oablf: {:?} }}" , self . tcfa () , self . tcfb () , self . tcfc () , self . tcfd () , self . tcfe () , self . tcff () , self . tcpfo () , self . tcfpu () , self . reserved_8_14 () , self . gtcf () , self . reserved_16_23 () , self . odf () , self . reserved_25_28 () , self . oabhf () , self . oablf ())
            }
        }
        #[doc = "General PWM Timer Software Stop Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtstp(pub u32);
        impl Gtstp {
            #[doc = "Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop0(&self) -> super::vals::Cstop0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cstop0::from_bits(val as u8)
            }
            #[doc = "Channel 0 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop0(&mut self, val: super::vals::Cstop0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop1(&self) -> super::vals::Cstop1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cstop1::from_bits(val as u8)
            }
            #[doc = "Channel 1 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop1(&mut self, val: super::vals::Cstop1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop2(&self) -> super::vals::Cstop2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cstop2::from_bits(val as u8)
            }
            #[doc = "Channel 2 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop2(&mut self, val: super::vals::Cstop2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop3(&self) -> super::vals::Cstop3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cstop3::from_bits(val as u8)
            }
            #[doc = "Channel 3 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop3(&mut self, val: super::vals::Cstop3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop4(&self) -> super::vals::Cstop4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cstop4::from_bits(val as u8)
            }
            #[doc = "Channel 4 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop4(&mut self, val: super::vals::Cstop4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop5(&self) -> super::vals::Cstop5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cstop5::from_bits(val as u8)
            }
            #[doc = "Channel 5 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop5(&mut self, val: super::vals::Cstop5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub const fn cstop6(&self) -> super::vals::Cstop6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cstop6::from_bits(val as u8)
            }
            #[doc = "Channel 6 GTCNT Count StopRead data shows each channel's counter status (GTCR.CST bit). 0 means counter runnning. 1 means counter stop."]
            #[inline(always)]
            pub fn set_cstop6(&mut self, val: super::vals::Cstop6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 1111111111111111111111111. The write value should be 1111111111111111111111111."]
            #[inline(always)]
            pub const fn reserved_7_31(&self) -> u32 {
                let val = (self.0 >> 7usize) & 0x01ff_ffff;
                val as u32
            }
            #[doc = "These bits are read as 1111111111111111111111111. The write value should be 1111111111111111111111111."]
            #[inline(always)]
            pub fn set_reserved_7_31(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x01ff_ffff << 7usize)) | (((val as u32) & 0x01ff_ffff) << 7usize);
            }
        }
        impl Default for Gtstp {
            #[inline(always)]
            fn default() -> Gtstp {
                Gtstp(0)
            }
        }
        impl core::fmt::Debug for Gtstp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtstp")
                    .field("cstop0", &self.cstop0())
                    .field("cstop1", &self.cstop1())
                    .field("cstop2", &self.cstop2())
                    .field("cstop3", &self.cstop3())
                    .field("cstop4", &self.cstop4())
                    .field("cstop5", &self.cstop5())
                    .field("cstop6", &self.cstop6())
                    .field("reserved_7_31", &self.reserved_7_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtstp {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtstp {{ cstop0: {:?}, cstop1: {:?}, cstop2: {:?}, cstop3: {:?}, cstop4: {:?}, cstop5: {:?}, cstop6: {:?}, reserved_7_31: {=u32:?} }}" , self . cstop0 () , self . cstop1 () , self . cstop2 () , self . cstop3 () , self . cstop4 () , self . cstop5 () , self . cstop6 () , self . reserved_7_31 ())
            }
        }
        #[doc = "General PWM Timer Software Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtstr(pub u32);
        impl Gtstr {
            #[doc = "Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt0(&self) -> super::vals::Cstrt0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cstrt0::from_bits(val as u8)
            }
            #[doc = "Channel 0 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt0(&mut self, val: super::vals::Cstrt0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt1(&self) -> super::vals::Cstrt1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cstrt1::from_bits(val as u8)
            }
            #[doc = "Channel 1 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt1(&mut self, val: super::vals::Cstrt1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt2(&self) -> super::vals::Cstrt2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cstrt2::from_bits(val as u8)
            }
            #[doc = "Channel 2 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt2(&mut self, val: super::vals::Cstrt2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt3(&self) -> super::vals::Cstrt3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cstrt3::from_bits(val as u8)
            }
            #[doc = "Channel 3 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt3(&mut self, val: super::vals::Cstrt3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt4(&self) -> super::vals::Cstrt4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cstrt4::from_bits(val as u8)
            }
            #[doc = "Channel 4 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt4(&mut self, val: super::vals::Cstrt4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt5(&self) -> super::vals::Cstrt5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cstrt5::from_bits(val as u8)
            }
            #[doc = "Channel 5 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt5(&mut self, val: super::vals::Cstrt5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub const fn cstrt6(&self) -> super::vals::Cstrt6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cstrt6::from_bits(val as u8)
            }
            #[doc = "Channel 6 GTCNT Count StartRead data shows each channel's counter status (GTCR.CST bit). 0 means counter stop. 1 means counter running."]
            #[inline(always)]
            pub fn set_cstrt6(&mut self, val: super::vals::Cstrt6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 0000000000000000000000000. The write value should be 0000000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_7_31(&self) -> u32 {
                let val = (self.0 >> 7usize) & 0x01ff_ffff;
                val as u32
            }
            #[doc = "These bits are read as 0000000000000000000000000. The write value should be 0000000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_7_31(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x01ff_ffff << 7usize)) | (((val as u32) & 0x01ff_ffff) << 7usize);
            }
        }
        impl Default for Gtstr {
            #[inline(always)]
            fn default() -> Gtstr {
                Gtstr(0)
            }
        }
        impl core::fmt::Debug for Gtstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtstr")
                    .field("cstrt0", &self.cstrt0())
                    .field("cstrt1", &self.cstrt1())
                    .field("cstrt2", &self.cstrt2())
                    .field("cstrt3", &self.cstrt3())
                    .field("cstrt4", &self.cstrt4())
                    .field("cstrt5", &self.cstrt5())
                    .field("cstrt6", &self.cstrt6())
                    .field("reserved_7_31", &self.reserved_7_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtstr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtstr {{ cstrt0: {:?}, cstrt1: {:?}, cstrt2: {:?}, cstrt3: {:?}, cstrt4: {:?}, cstrt5: {:?}, cstrt6: {:?}, reserved_7_31: {=u32:?} }}" , self . cstrt0 () , self . cstrt1 () , self . cstrt2 () , self . cstrt3 () , self . cstrt4 () , self . cstrt5 () , self . cstrt6 () , self . reserved_7_31 ())
            }
        }
        #[doc = "General PWM Timer Count Direction and Duty Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtuddtyc(pub u32);
        impl Gtuddtyc {
            #[doc = "Count Direction Setting"]
            #[inline(always)]
            pub const fn ud(&self) -> super::vals::Ud {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ud::from_bits(val as u8)
            }
            #[doc = "Count Direction Setting"]
            #[inline(always)]
            pub fn set_ud(&mut self, val: super::vals::Ud) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Forcible Count Direction Setting"]
            #[inline(always)]
            pub const fn udf(&self) -> super::vals::Udf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Udf::from_bits(val as u8)
            }
            #[doc = "Forcible Count Direction Setting"]
            #[inline(always)]
            pub fn set_udf(&mut self, val: super::vals::Udf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTIOCA Output Duty Setting"]
            #[inline(always)]
            pub const fn oadty(&self) -> super::vals::Oadty {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Oadty::from_bits(val as u8)
            }
            #[doc = "GTIOCA Output Duty Setting"]
            #[inline(always)]
            pub fn set_oadty(&mut self, val: super::vals::Oadty) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "Forcible GTIOCA Output Duty Setting"]
            #[inline(always)]
            pub const fn oadtyf(&self) -> super::vals::Oadtyf {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oadtyf::from_bits(val as u8)
            }
            #[doc = "Forcible GTIOCA Output Duty Setting"]
            #[inline(always)]
            pub fn set_oadtyf(&mut self, val: super::vals::Oadtyf) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting"]
            #[inline(always)]
            pub const fn oadtyr(&self) -> super::vals::Oadtyr {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oadtyr::from_bits(val as u8)
            }
            #[doc = "GTIOCA Output Value Selecting after Releasing 0 percent/100 percent Duty Setting"]
            #[inline(always)]
            pub fn set_oadtyr(&mut self, val: super::vals::Oadtyr) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_20_23(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_20_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "GTIOCB Output Duty Setting"]
            #[inline(always)]
            pub const fn obdty(&self) -> super::vals::Obdty {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Obdty::from_bits(val as u8)
            }
            #[doc = "GTIOCB Output Duty Setting"]
            #[inline(always)]
            pub fn set_obdty(&mut self, val: super::vals::Obdty) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Forcible GTIOCB Output Duty Setting"]
            #[inline(always)]
            pub const fn obdtyf(&self) -> super::vals::Obdtyf {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Obdtyf::from_bits(val as u8)
            }
            #[doc = "Forcible GTIOCB Output Duty Setting"]
            #[inline(always)]
            pub fn set_obdtyf(&mut self, val: super::vals::Obdtyf) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting"]
            #[inline(always)]
            pub const fn obdtyr(&self) -> super::vals::Obdtyr {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Obdtyr::from_bits(val as u8)
            }
            #[doc = "GTIOCB Output Value Selecting after Releasing 0 percent/100 percent Duty Setting"]
            #[inline(always)]
            pub fn set_obdtyr(&mut self, val: super::vals::Obdtyr) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Gtuddtyc {
            #[inline(always)]
            fn default() -> Gtuddtyc {
                Gtuddtyc(0)
            }
        }
        impl core::fmt::Debug for Gtuddtyc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtuddtyc")
                    .field("ud", &self.ud())
                    .field("udf", &self.udf())
                    .field("oadty", &self.oadty())
                    .field("oadtyf", &self.oadtyf())
                    .field("oadtyr", &self.oadtyr())
                    .field("reserved_20_23", &self.reserved_20_23())
                    .field("obdty", &self.obdty())
                    .field("obdtyf", &self.obdtyf())
                    .field("obdtyr", &self.obdtyr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtuddtyc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtuddtyc {{ ud: {:?}, udf: {:?}, oadty: {:?}, oadtyf: {:?}, oadtyr: {:?}, reserved_20_23: {=u8:?}, obdty: {:?}, obdtyf: {:?}, obdtyr: {:?} }}" , self . ud () , self . udf () , self . oadty () , self . oadtyf () , self . oadtyr () , self . reserved_20_23 () , self . obdty () , self . obdtyf () , self . obdtyr ())
            }
        }
        #[doc = "General PWM Timer Up Count Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtupsr(pub u32);
        impl Gtupsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgar(&self) -> super::vals::Usgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Usgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgar(&mut self, val: super::vals::Usgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgaf(&self) -> super::vals::Usgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Usgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgaf(&mut self, val: super::vals::Usgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgbr(&self) -> super::vals::Usgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Usgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgbr(&mut self, val: super::vals::Usgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgbf(&self) -> super::vals::Usgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Usgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgbf(&mut self, val: super::vals::Usgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscarbl(&self) -> super::vals::Uscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Uscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscarbl(&mut self, val: super::vals::Uscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscarbh(&self) -> super::vals::Uscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Uscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Rising Input during GTIOCB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscarbh(&mut self, val: super::vals::Uscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscafbl(&self) -> super::vals::Uscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Uscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscafbl(&mut self, val: super::vals::Uscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscafbh(&self) -> super::vals::Uscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Uscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCA Pin Falling Input during GTIOCB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscafbh(&mut self, val: super::vals::Uscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbral(&self) -> super::vals::Uscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Uscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbral(&mut self, val: super::vals::Uscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbrah(&self) -> super::vals::Uscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Uscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Rising Input during GTIOCA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbrah(&mut self, val: super::vals::Uscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbfal(&self) -> super::vals::Uscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Uscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbfal(&mut self, val: super::vals::Uscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbfah(&self) -> super::vals::Uscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Uscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCB Pin Falling Input during GTIOCA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbfah(&mut self, val: super::vals::Uscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselca(&self) -> super::vals::Uselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Uselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselca(&mut self, val: super::vals::Uselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcb(&self) -> super::vals::Uselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Uselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcb(&mut self, val: super::vals::Uselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcc(&self) -> super::vals::Uselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Uselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcc(&mut self, val: super::vals::Uselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcd(&self) -> super::vals::Uselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Uselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcd(&mut self, val: super::vals::Uselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gtupsr {
            #[inline(always)]
            fn default() -> Gtupsr {
                Gtupsr(0)
            }
        }
        impl core::fmt::Debug for Gtupsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtupsr")
                    .field("usgtrgar", &self.usgtrgar())
                    .field("usgtrgaf", &self.usgtrgaf())
                    .field("usgtrgbr", &self.usgtrgbr())
                    .field("usgtrgbf", &self.usgtrgbf())
                    .field("uscarbl", &self.uscarbl())
                    .field("uscarbh", &self.uscarbh())
                    .field("uscafbl", &self.uscafbl())
                    .field("uscafbh", &self.uscafbh())
                    .field("uscbral", &self.uscbral())
                    .field("uscbrah", &self.uscbrah())
                    .field("uscbfal", &self.uscbfal())
                    .field("uscbfah", &self.uscbfah())
                    .field("uselca", &self.uselca())
                    .field("uselcb", &self.uselcb())
                    .field("uselcc", &self.uselcc())
                    .field("uselcd", &self.uselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtupsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtupsr {{ usgtrgar: {:?}, usgtrgaf: {:?}, usgtrgbr: {:?}, usgtrgbf: {:?}, uscarbl: {:?}, uscarbh: {:?}, uscafbl: {:?}, uscafbh: {:?}, uscbral: {:?}, uscbrah: {:?}, uscbfal: {:?}, uscbfah: {:?}, uselca: {:?}, uselcb: {:?}, uselcc: {:?}, uselcd: {:?} }}" , self . usgtrgar () , self . usgtrgaf () , self . usgtrgbr () , self . usgtrgbf () , self . uscarbl () , self . uscarbh () , self . uscafbl () , self . uscafbh () , self . uscbral () , self . uscbrah () , self . uscbfal () , self . uscbfah () , self . uselca () , self . uselcb () , self . uselcc () , self . uselcd ())
            }
        }
        #[doc = "General PWM Timer Write,Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtwp(pub u32);
        impl Gtwp {
            #[doc = "Register Write Disable"]
            #[inline(always)]
            pub const fn wp(&self) -> super::vals::Wp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Wp::from_bits(val as u8)
            }
            #[doc = "Register Write Disable"]
            #[inline(always)]
            pub fn set_wp(&mut self, val: super::vals::Wp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u32) & 0x7f) << 1usize);
            }
            #[doc = "GTWP Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> super::vals::Prkey {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::Prkey::from_bits(val as u8)
            }
            #[doc = "GTWP Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: super::vals::Prkey) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u32) & 0xff) << 8usize);
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_16_31(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_16_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gtwp {
            #[inline(always)]
            fn default() -> Gtwp {
                Gtwp(0)
            }
        }
        impl core::fmt::Debug for Gtwp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtwp")
                    .field("wp", &self.wp())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("prkey", &self.prkey())
                    .field("reserved_16_31", &self.reserved_16_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtwp {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtwp {{ wp: {:?}, reserved_1_7: {=u8:?}, prkey: {:?}, reserved_16_31: {=u16:?} }}" , self . wp () , self . reserved_1_7 () , self . prkey () , self . reserved_16_31 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascafbh {
            #[inline(always)]
            fn from(val: u8) -> Ascafbh {
                Ascafbh::from_bits(val)
            }
        }
        impl From<Ascafbh> for u8 {
            #[inline(always)]
            fn from(val: Ascafbh) -> u8 {
                Ascafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascafbl {
            #[inline(always)]
            fn from(val: u8) -> Ascafbl {
                Ascafbl::from_bits(val)
            }
        }
        impl From<Ascafbl> for u8 {
            #[inline(always)]
            fn from(val: Ascafbl) -> u8 {
                Ascafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascarbh {
            #[inline(always)]
            fn from(val: u8) -> Ascarbh {
                Ascarbh::from_bits(val)
            }
        }
        impl From<Ascarbh> for u8 {
            #[inline(always)]
            fn from(val: Ascarbh) -> u8 {
                Ascarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascarbl {
            #[inline(always)]
            fn from(val: u8) -> Ascarbl {
                Ascarbl::from_bits(val)
            }
        }
        impl From<Ascarbl> for u8 {
            #[inline(always)]
            fn from(val: Ascarbl) -> u8 {
                Ascarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbfah {
            #[inline(always)]
            fn from(val: u8) -> Ascbfah {
                Ascbfah::from_bits(val)
            }
        }
        impl From<Ascbfah> for u8 {
            #[inline(always)]
            fn from(val: Ascbfah) -> u8 {
                Ascbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbfal {
            #[inline(always)]
            fn from(val: u8) -> Ascbfal {
                Ascbfal::from_bits(val)
            }
        }
        impl From<Ascbfal> for u8 {
            #[inline(always)]
            fn from(val: Ascbfal) -> u8 {
                Ascbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbrah {
            #[inline(always)]
            fn from(val: u8) -> Ascbrah {
                Ascbrah::from_bits(val)
            }
        }
        impl From<Ascbrah> for u8 {
            #[inline(always)]
            fn from(val: Ascbrah) -> u8 {
                Ascbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbral {
            #[inline(always)]
            fn from(val: u8) -> Ascbral {
                Ascbral::from_bits(val)
            }
        }
        impl From<Ascbral> for u8 {
            #[inline(always)]
            fn from(val: Ascbral) -> u8 {
                Ascbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselca {
            #[inline(always)]
            fn from(val: u8) -> Aselca {
                Aselca::from_bits(val)
            }
        }
        impl From<Aselca> for u8 {
            #[inline(always)]
            fn from(val: Aselca) -> u8 {
                Aselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcb {
            #[inline(always)]
            fn from(val: u8) -> Aselcb {
                Aselcb::from_bits(val)
            }
        }
        impl From<Aselcb> for u8 {
            #[inline(always)]
            fn from(val: Aselcb) -> u8 {
                Aselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcc {
            #[inline(always)]
            fn from(val: u8) -> Aselcc {
                Aselcc::from_bits(val)
            }
        }
        impl From<Aselcc> for u8 {
            #[inline(always)]
            fn from(val: Aselcc) -> u8 {
                Aselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcd {
            #[inline(always)]
            fn from(val: u8) -> Aselcd {
                Aselcd::from_bits(val)
            }
        }
        impl From<Aselcd> for u8 {
            #[inline(always)]
            fn from(val: Aselcd) -> u8 {
                Aselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgaf {
                Asgtrgaf::from_bits(val)
            }
        }
        impl From<Asgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgaf) -> u8 {
                Asgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgar {
                Asgtrgar::from_bits(val)
            }
        }
        impl From<Asgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgar) -> u8 {
                Asgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgbf {
                Asgtrgbf::from_bits(val)
            }
        }
        impl From<Asgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgbf) -> u8 {
                Asgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgbr {
                Asgtrgbr::from_bits(val)
            }
        }
        impl From<Asgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgbr) -> u8 {
                Asgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Bd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bd {
            #[inline(always)]
            fn from(val: u8) -> Bd {
                Bd::from_bits(val)
            }
        }
        impl From<Bd> for u8 {
            #[inline(always)]
            fn from(val: Bd) -> u8 {
                Bd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscafbh {
            #[inline(always)]
            fn from(val: u8) -> Bscafbh {
                Bscafbh::from_bits(val)
            }
        }
        impl From<Bscafbh> for u8 {
            #[inline(always)]
            fn from(val: Bscafbh) -> u8 {
                Bscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscafbl {
            #[inline(always)]
            fn from(val: u8) -> Bscafbl {
                Bscafbl::from_bits(val)
            }
        }
        impl From<Bscafbl> for u8 {
            #[inline(always)]
            fn from(val: Bscafbl) -> u8 {
                Bscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscarbh {
            #[inline(always)]
            fn from(val: u8) -> Bscarbh {
                Bscarbh::from_bits(val)
            }
        }
        impl From<Bscarbh> for u8 {
            #[inline(always)]
            fn from(val: Bscarbh) -> u8 {
                Bscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscarbl {
            #[inline(always)]
            fn from(val: u8) -> Bscarbl {
                Bscarbl::from_bits(val)
            }
        }
        impl From<Bscarbl> for u8 {
            #[inline(always)]
            fn from(val: Bscarbl) -> u8 {
                Bscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbfah {
            #[inline(always)]
            fn from(val: u8) -> Bscbfah {
                Bscbfah::from_bits(val)
            }
        }
        impl From<Bscbfah> for u8 {
            #[inline(always)]
            fn from(val: Bscbfah) -> u8 {
                Bscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbfal {
            #[inline(always)]
            fn from(val: u8) -> Bscbfal {
                Bscbfal::from_bits(val)
            }
        }
        impl From<Bscbfal> for u8 {
            #[inline(always)]
            fn from(val: Bscbfal) -> u8 {
                Bscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbrah {
            #[inline(always)]
            fn from(val: u8) -> Bscbrah {
                Bscbrah::from_bits(val)
            }
        }
        impl From<Bscbrah> for u8 {
            #[inline(always)]
            fn from(val: Bscbrah) -> u8 {
                Bscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbral {
            #[inline(always)]
            fn from(val: u8) -> Bscbral {
                Bscbral::from_bits(val)
            }
        }
        impl From<Bscbral> for u8 {
            #[inline(always)]
            fn from(val: Bscbral) -> u8 {
                Bscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselca {
            #[inline(always)]
            fn from(val: u8) -> Bselca {
                Bselca::from_bits(val)
            }
        }
        impl From<Bselca> for u8 {
            #[inline(always)]
            fn from(val: Bselca) -> u8 {
                Bselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcb {
            #[inline(always)]
            fn from(val: u8) -> Bselcb {
                Bselcb::from_bits(val)
            }
        }
        impl From<Bselcb> for u8 {
            #[inline(always)]
            fn from(val: Bselcb) -> u8 {
                Bselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcc {
            #[inline(always)]
            fn from(val: u8) -> Bselcc {
                Bselcc::from_bits(val)
            }
        }
        impl From<Bselcc> for u8 {
            #[inline(always)]
            fn from(val: Bselcc) -> u8 {
                Bselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcd {
            #[inline(always)]
            fn from(val: u8) -> Bselcd {
                Bselcd::from_bits(val)
            }
        }
        impl From<Bselcd> for u8 {
            #[inline(always)]
            fn from(val: Bselcd) -> u8 {
                Bselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgaf {
                Bsgtrgaf::from_bits(val)
            }
        }
        impl From<Bsgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgaf) -> u8 {
                Bsgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgar {
                Bsgtrgar::from_bits(val)
            }
        }
        impl From<Bsgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgar) -> u8 {
                Bsgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgbf {
                Bsgtrgbf::from_bits(val)
            }
        }
        impl From<Bsgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgbf) -> u8 {
                Bsgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgbr {
                Bsgtrgbr::from_bits(val)
            }
        }
        impl From<Bsgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgbr) -> u8 {
                Bsgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr {
            #[inline(always)]
            fn from(val: u8) -> Cclr {
                Cclr::from_bits(val)
            }
        }
        impl From<Cclr> for u8 {
            #[inline(always)]
            fn from(val: Cclr) -> u8 {
                Cclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr0 {
            #[inline(always)]
            fn from(val: u8) -> Cclr0 {
                Cclr0::from_bits(val)
            }
        }
        impl From<Cclr0> for u8 {
            #[inline(always)]
            fn from(val: Cclr0) -> u8 {
                Cclr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr1 {
            #[inline(always)]
            fn from(val: u8) -> Cclr1 {
                Cclr1::from_bits(val)
            }
        }
        impl From<Cclr1> for u8 {
            #[inline(always)]
            fn from(val: Cclr1) -> u8 {
                Cclr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr2 {
            #[inline(always)]
            fn from(val: u8) -> Cclr2 {
                Cclr2::from_bits(val)
            }
        }
        impl From<Cclr2> for u8 {
            #[inline(always)]
            fn from(val: Cclr2) -> u8 {
                Cclr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr3 {
            #[inline(always)]
            fn from(val: u8) -> Cclr3 {
                Cclr3::from_bits(val)
            }
        }
        impl From<Cclr3> for u8 {
            #[inline(always)]
            fn from(val: Cclr3) -> u8 {
                Cclr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr4 {
            #[inline(always)]
            fn from(val: u8) -> Cclr4 {
                Cclr4::from_bits(val)
            }
        }
        impl From<Cclr4> for u8 {
            #[inline(always)]
            fn from(val: Cclr4) -> u8 {
                Cclr4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr5 {
            #[inline(always)]
            fn from(val: u8) -> Cclr5 {
                Cclr5::from_bits(val)
            }
        }
        impl From<Cclr5> for u8 {
            #[inline(always)]
            fn from(val: Cclr5) -> u8 {
                Cclr5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr6 {
            #[inline(always)]
            fn from(val: u8) -> Cclr6 {
                Cclr6::from_bits(val)
            }
        }
        impl From<Cclr6> for u8 {
            #[inline(always)]
            fn from(val: Cclr6) -> u8 {
                Cclr6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccra {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ccra {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccra {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccra {
            #[inline(always)]
            fn from(val: u8) -> Ccra {
                Ccra::from_bits(val)
            }
        }
        impl From<Ccra> for u8 {
            #[inline(always)]
            fn from(val: Ccra) -> u8 {
                Ccra::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccrb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ccrb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccrb {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccrb {
            #[inline(always)]
            fn from(val: u8) -> Ccrb {
                Ccrb::from_bits(val)
            }
        }
        impl From<Ccrb> for u8 {
            #[inline(always)]
            fn from(val: Ccrb) -> u8 {
                Ccrb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccrswt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ccrswt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccrswt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccrswt {
            #[inline(always)]
            fn from(val: u8) -> Ccrswt {
                Ccrswt::from_bits(val)
            }
        }
        impl From<Ccrswt> for u8 {
            #[inline(always)]
            fn from(val: Ccrswt) -> u8 {
                Ccrswt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscafbh {
            #[inline(always)]
            fn from(val: u8) -> Cscafbh {
                Cscafbh::from_bits(val)
            }
        }
        impl From<Cscafbh> for u8 {
            #[inline(always)]
            fn from(val: Cscafbh) -> u8 {
                Cscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscafbl {
            #[inline(always)]
            fn from(val: u8) -> Cscafbl {
                Cscafbl::from_bits(val)
            }
        }
        impl From<Cscafbl> for u8 {
            #[inline(always)]
            fn from(val: Cscafbl) -> u8 {
                Cscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscarbh {
            #[inline(always)]
            fn from(val: u8) -> Cscarbh {
                Cscarbh::from_bits(val)
            }
        }
        impl From<Cscarbh> for u8 {
            #[inline(always)]
            fn from(val: Cscarbh) -> u8 {
                Cscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscarbl {
            #[inline(always)]
            fn from(val: u8) -> Cscarbl {
                Cscarbl::from_bits(val)
            }
        }
        impl From<Cscarbl> for u8 {
            #[inline(always)]
            fn from(val: Cscarbl) -> u8 {
                Cscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbfah {
            #[inline(always)]
            fn from(val: u8) -> Cscbfah {
                Cscbfah::from_bits(val)
            }
        }
        impl From<Cscbfah> for u8 {
            #[inline(always)]
            fn from(val: Cscbfah) -> u8 {
                Cscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbfal {
            #[inline(always)]
            fn from(val: u8) -> Cscbfal {
                Cscbfal::from_bits(val)
            }
        }
        impl From<Cscbfal> for u8 {
            #[inline(always)]
            fn from(val: Cscbfal) -> u8 {
                Cscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbrah {
            #[inline(always)]
            fn from(val: u8) -> Cscbrah {
                Cscbrah::from_bits(val)
            }
        }
        impl From<Cscbrah> for u8 {
            #[inline(always)]
            fn from(val: Cscbrah) -> u8 {
                Cscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbral {
            #[inline(always)]
            fn from(val: u8) -> Cscbral {
                Cscbral::from_bits(val)
            }
        }
        impl From<Cscbral> for u8 {
            #[inline(always)]
            fn from(val: Cscbral) -> u8 {
                Cscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselca {
            #[inline(always)]
            fn from(val: u8) -> Cselca {
                Cselca::from_bits(val)
            }
        }
        impl From<Cselca> for u8 {
            #[inline(always)]
            fn from(val: Cselca) -> u8 {
                Cselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcb {
            #[inline(always)]
            fn from(val: u8) -> Cselcb {
                Cselcb::from_bits(val)
            }
        }
        impl From<Cselcb> for u8 {
            #[inline(always)]
            fn from(val: Cselcb) -> u8 {
                Cselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcc {
            #[inline(always)]
            fn from(val: u8) -> Cselcc {
                Cselcc::from_bits(val)
            }
        }
        impl From<Cselcc> for u8 {
            #[inline(always)]
            fn from(val: Cselcc) -> u8 {
                Cselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcd {
            #[inline(always)]
            fn from(val: u8) -> Cselcd {
                Cselcd::from_bits(val)
            }
        }
        impl From<Cselcd> for u8 {
            #[inline(always)]
            fn from(val: Cselcd) -> u8 {
                Cselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgaf {
                Csgtrgaf::from_bits(val)
            }
        }
        impl From<Csgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgaf) -> u8 {
                Csgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgar {
                Csgtrgar::from_bits(val)
            }
        }
        impl From<Csgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgar) -> u8 {
                Csgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgbf {
                Csgtrgbf::from_bits(val)
            }
        }
        impl From<Csgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgbf) -> u8 {
                Csgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgbr {
                Csgtrgbr::from_bits(val)
            }
        }
        impl From<Csgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgbr) -> u8 {
                Csgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cst {
            #[inline(always)]
            fn from(val: u8) -> Cst {
                Cst::from_bits(val)
            }
        }
        impl From<Cst> for u8 {
            #[inline(always)]
            fn from(val: Cst) -> u8 {
                Cst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop {
            #[inline(always)]
            fn from(val: u8) -> Cstop {
                Cstop::from_bits(val)
            }
        }
        impl From<Cstop> for u8 {
            #[inline(always)]
            fn from(val: Cstop) -> u8 {
                Cstop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop0 {
            #[inline(always)]
            fn from(val: u8) -> Cstop0 {
                Cstop0::from_bits(val)
            }
        }
        impl From<Cstop0> for u8 {
            #[inline(always)]
            fn from(val: Cstop0) -> u8 {
                Cstop0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop1 {
            #[inline(always)]
            fn from(val: u8) -> Cstop1 {
                Cstop1::from_bits(val)
            }
        }
        impl From<Cstop1> for u8 {
            #[inline(always)]
            fn from(val: Cstop1) -> u8 {
                Cstop1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop2 {
            #[inline(always)]
            fn from(val: u8) -> Cstop2 {
                Cstop2::from_bits(val)
            }
        }
        impl From<Cstop2> for u8 {
            #[inline(always)]
            fn from(val: Cstop2) -> u8 {
                Cstop2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop3 {
            #[inline(always)]
            fn from(val: u8) -> Cstop3 {
                Cstop3::from_bits(val)
            }
        }
        impl From<Cstop3> for u8 {
            #[inline(always)]
            fn from(val: Cstop3) -> u8 {
                Cstop3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop4 {
            #[inline(always)]
            fn from(val: u8) -> Cstop4 {
                Cstop4::from_bits(val)
            }
        }
        impl From<Cstop4> for u8 {
            #[inline(always)]
            fn from(val: Cstop4) -> u8 {
                Cstop4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop5 {
            #[inline(always)]
            fn from(val: u8) -> Cstop5 {
                Cstop5::from_bits(val)
            }
        }
        impl From<Cstop5> for u8 {
            #[inline(always)]
            fn from(val: Cstop5) -> u8 {
                Cstop5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop6 {
            #[inline(always)]
            fn from(val: u8) -> Cstop6 {
                Cstop6::from_bits(val)
            }
        }
        impl From<Cstop6> for u8 {
            #[inline(always)]
            fn from(val: Cstop6) -> u8 {
                Cstop6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt {
            #[inline(always)]
            fn from(val: u8) -> Cstrt {
                Cstrt::from_bits(val)
            }
        }
        impl From<Cstrt> for u8 {
            #[inline(always)]
            fn from(val: Cstrt) -> u8 {
                Cstrt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt0 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt0 {
                Cstrt0::from_bits(val)
            }
        }
        impl From<Cstrt0> for u8 {
            #[inline(always)]
            fn from(val: Cstrt0) -> u8 {
                Cstrt0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt1 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt1 {
                Cstrt1::from_bits(val)
            }
        }
        impl From<Cstrt1> for u8 {
            #[inline(always)]
            fn from(val: Cstrt1) -> u8 {
                Cstrt1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt2 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt2 {
                Cstrt2::from_bits(val)
            }
        }
        impl From<Cstrt2> for u8 {
            #[inline(always)]
            fn from(val: Cstrt2) -> u8 {
                Cstrt2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt3 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt3 {
                Cstrt3::from_bits(val)
            }
        }
        impl From<Cstrt3> for u8 {
            #[inline(always)]
            fn from(val: Cstrt3) -> u8 {
                Cstrt3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt4 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt4 {
                Cstrt4::from_bits(val)
            }
        }
        impl From<Cstrt4> for u8 {
            #[inline(always)]
            fn from(val: Cstrt4) -> u8 {
                Cstrt4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt5 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt5 {
                Cstrt5::from_bits(val)
            }
        }
        impl From<Cstrt5> for u8 {
            #[inline(always)]
            fn from(val: Cstrt5) -> u8 {
                Cstrt5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt6 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt6 {
                Cstrt6::from_bits(val)
            }
        }
        impl From<Cstrt6> for u8 {
            #[inline(always)]
            fn from(val: Cstrt6) -> u8 {
                Cstrt6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscafbh {
            #[inline(always)]
            fn from(val: u8) -> Dscafbh {
                Dscafbh::from_bits(val)
            }
        }
        impl From<Dscafbh> for u8 {
            #[inline(always)]
            fn from(val: Dscafbh) -> u8 {
                Dscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscafbl {
            #[inline(always)]
            fn from(val: u8) -> Dscafbl {
                Dscafbl::from_bits(val)
            }
        }
        impl From<Dscafbl> for u8 {
            #[inline(always)]
            fn from(val: Dscafbl) -> u8 {
                Dscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscarbh {
            #[inline(always)]
            fn from(val: u8) -> Dscarbh {
                Dscarbh::from_bits(val)
            }
        }
        impl From<Dscarbh> for u8 {
            #[inline(always)]
            fn from(val: Dscarbh) -> u8 {
                Dscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscarbl {
            #[inline(always)]
            fn from(val: u8) -> Dscarbl {
                Dscarbl::from_bits(val)
            }
        }
        impl From<Dscarbl> for u8 {
            #[inline(always)]
            fn from(val: Dscarbl) -> u8 {
                Dscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbfah {
            #[inline(always)]
            fn from(val: u8) -> Dscbfah {
                Dscbfah::from_bits(val)
            }
        }
        impl From<Dscbfah> for u8 {
            #[inline(always)]
            fn from(val: Dscbfah) -> u8 {
                Dscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbfal {
            #[inline(always)]
            fn from(val: u8) -> Dscbfal {
                Dscbfal::from_bits(val)
            }
        }
        impl From<Dscbfal> for u8 {
            #[inline(always)]
            fn from(val: Dscbfal) -> u8 {
                Dscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbrah {
            #[inline(always)]
            fn from(val: u8) -> Dscbrah {
                Dscbrah::from_bits(val)
            }
        }
        impl From<Dscbrah> for u8 {
            #[inline(always)]
            fn from(val: Dscbrah) -> u8 {
                Dscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbral {
            #[inline(always)]
            fn from(val: u8) -> Dscbral {
                Dscbral::from_bits(val)
            }
        }
        impl From<Dscbral> for u8 {
            #[inline(always)]
            fn from(val: Dscbral) -> u8 {
                Dscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselca {
            #[inline(always)]
            fn from(val: u8) -> Dselca {
                Dselca::from_bits(val)
            }
        }
        impl From<Dselca> for u8 {
            #[inline(always)]
            fn from(val: Dselca) -> u8 {
                Dselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcb {
            #[inline(always)]
            fn from(val: u8) -> Dselcb {
                Dselcb::from_bits(val)
            }
        }
        impl From<Dselcb> for u8 {
            #[inline(always)]
            fn from(val: Dselcb) -> u8 {
                Dselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcc {
            #[inline(always)]
            fn from(val: u8) -> Dselcc {
                Dselcc::from_bits(val)
            }
        }
        impl From<Dselcc> for u8 {
            #[inline(always)]
            fn from(val: Dselcc) -> u8 {
                Dselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcd {
            #[inline(always)]
            fn from(val: u8) -> Dselcd {
                Dselcd::from_bits(val)
            }
        }
        impl From<Dselcd> for u8 {
            #[inline(always)]
            fn from(val: Dselcd) -> u8 {
                Dselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgaf {
                Dsgtrgaf::from_bits(val)
            }
        }
        impl From<Dsgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgaf) -> u8 {
                Dsgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgar {
                Dsgtrgar::from_bits(val)
            }
        }
        impl From<Dsgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgar) -> u8 {
                Dsgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgbf {
                Dsgtrgbf::from_bits(val)
            }
        }
        impl From<Dsgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgbf) -> u8 {
                Dsgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgbr {
                Dsgtrgbr::from_bits(val)
            }
        }
        impl From<Dsgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgbr) -> u8 {
                Dsgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Grp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grp {
            #[inline(always)]
            fn from(val: u8) -> Grp {
                Grp::from_bits(val)
            }
        }
        impl From<Grp> for u8 {
            #[inline(always)]
            fn from(val: Grp) -> u8 {
                Grp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grpabh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Grpabh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grpabh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grpabh {
            #[inline(always)]
            fn from(val: u8) -> Grpabh {
                Grpabh::from_bits(val)
            }
        }
        impl From<Grpabh> for u8 {
            #[inline(always)]
            fn from(val: Grpabh) -> u8 {
                Grpabh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grpabl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Grpabl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grpabl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grpabl {
            #[inline(always)]
            fn from(val: u8) -> Grpabl {
                Grpabl::from_bits(val)
            }
        }
        impl From<Grpabl> for u8 {
            #[inline(always)]
            fn from(val: Grpabl) -> u8 {
                Grpabl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gtcf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gtcf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gtcf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gtcf {
            #[inline(always)]
            fn from(val: u8) -> Gtcf {
                Gtcf::from_bits(val)
            }
        }
        impl From<Gtcf> for u8 {
            #[inline(always)]
            fn from(val: Gtcf) -> u8 {
                Gtcf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gtioa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Gtioa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gtioa {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gtioa {
            #[inline(always)]
            fn from(val: u8) -> Gtioa {
                Gtioa::from_bits(val)
            }
        }
        impl From<Gtioa> for u8 {
            #[inline(always)]
            fn from(val: Gtioa) -> u8 {
                Gtioa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gtiob {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Gtiob {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gtiob {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gtiob {
            #[inline(always)]
            fn from(val: u8) -> Gtiob {
                Gtiob::from_bits(val)
            }
        }
        impl From<Gtiob> for u8 {
            #[inline(always)]
            fn from(val: Gtiob) -> u8 {
                Gtiob::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Md {
            #[inline(always)]
            fn from(val: u8) -> Md {
                Md::from_bits(val)
            }
        }
        impl From<Md> for u8 {
            #[inline(always)]
            fn from(val: Md) -> u8 {
                Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfaen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfaen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfaen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfaen {
            #[inline(always)]
            fn from(val: u8) -> Nfaen {
                Nfaen::from_bits(val)
            }
        }
        impl From<Nfaen> for u8 {
            #[inline(always)]
            fn from(val: Nfaen) -> u8 {
                Nfaen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfben {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfben {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfben {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfben {
            #[inline(always)]
            fn from(val: u8) -> Nfben {
                Nfben::from_bits(val)
            }
        }
        impl From<Nfben> for u8 {
            #[inline(always)]
            fn from(val: Nfben) -> u8 {
                Nfben::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcsa {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcsa {
            #[inline(always)]
            fn from(val: u8) -> Nfcsa {
                Nfcsa::from_bits(val)
            }
        }
        impl From<Nfcsa> for u8 {
            #[inline(always)]
            fn from(val: Nfcsa) -> u8 {
                Nfcsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcsb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcsb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcsb {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcsb {
            #[inline(always)]
            fn from(val: u8) -> Nfcsb {
                Nfcsb::from_bits(val)
            }
        }
        impl From<Nfcsb> for u8 {
            #[inline(always)]
            fn from(val: Nfcsb) -> u8 {
                Nfcsb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oabhf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oabhf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oabhf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oabhf {
            #[inline(always)]
            fn from(val: u8) -> Oabhf {
                Oabhf::from_bits(val)
            }
        }
        impl From<Oabhf> for u8 {
            #[inline(always)]
            fn from(val: Oabhf) -> u8 {
                Oabhf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oablf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oablf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oablf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oablf {
            #[inline(always)]
            fn from(val: u8) -> Oablf {
                Oablf::from_bits(val)
            }
        }
        impl From<Oablf> for u8 {
            #[inline(always)]
            fn from(val: Oablf) -> u8 {
                Oablf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oadf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadf {
            #[inline(always)]
            fn from(val: u8) -> Oadf {
                Oadf::from_bits(val)
            }
        }
        impl From<Oadf> for u8 {
            #[inline(always)]
            fn from(val: Oadf) -> u8 {
                Oadf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadflt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadflt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadflt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadflt {
            #[inline(always)]
            fn from(val: u8) -> Oadflt {
                Oadflt::from_bits(val)
            }
        }
        impl From<Oadflt> for u8 {
            #[inline(always)]
            fn from(val: Oadflt) -> u8 {
                Oadflt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadty {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oadty {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadty {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadty {
            #[inline(always)]
            fn from(val: u8) -> Oadty {
                Oadty::from_bits(val)
            }
        }
        impl From<Oadty> for u8 {
            #[inline(always)]
            fn from(val: Oadty) -> u8 {
                Oadty::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadtyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadtyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadtyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadtyf {
            #[inline(always)]
            fn from(val: u8) -> Oadtyf {
                Oadtyf::from_bits(val)
            }
        }
        impl From<Oadtyf> for u8 {
            #[inline(always)]
            fn from(val: Oadtyf) -> u8 {
                Oadtyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadtyr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadtyr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadtyr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadtyr {
            #[inline(always)]
            fn from(val: u8) -> Oadtyr {
                Oadtyr::from_bits(val)
            }
        }
        impl From<Oadtyr> for u8 {
            #[inline(always)]
            fn from(val: Oadtyr) -> u8 {
                Oadtyr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oae {
            #[inline(always)]
            fn from(val: u8) -> Oae {
                Oae::from_bits(val)
            }
        }
        impl From<Oae> for u8 {
            #[inline(always)]
            fn from(val: Oae) -> u8 {
                Oae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oahld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oahld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oahld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oahld {
            #[inline(always)]
            fn from(val: u8) -> Oahld {
                Oahld::from_bits(val)
            }
        }
        impl From<Oahld> for u8 {
            #[inline(always)]
            fn from(val: Oahld) -> u8 {
                Oahld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Obdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdf {
            #[inline(always)]
            fn from(val: u8) -> Obdf {
                Obdf::from_bits(val)
            }
        }
        impl From<Obdf> for u8 {
            #[inline(always)]
            fn from(val: Obdf) -> u8 {
                Obdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdflt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdflt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdflt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdflt {
            #[inline(always)]
            fn from(val: u8) -> Obdflt {
                Obdflt::from_bits(val)
            }
        }
        impl From<Obdflt> for u8 {
            #[inline(always)]
            fn from(val: Obdflt) -> u8 {
                Obdflt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdty {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Obdty {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdty {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdty {
            #[inline(always)]
            fn from(val: u8) -> Obdty {
                Obdty::from_bits(val)
            }
        }
        impl From<Obdty> for u8 {
            #[inline(always)]
            fn from(val: Obdty) -> u8 {
                Obdty::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdtyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdtyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdtyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdtyf {
            #[inline(always)]
            fn from(val: u8) -> Obdtyf {
                Obdtyf::from_bits(val)
            }
        }
        impl From<Obdtyf> for u8 {
            #[inline(always)]
            fn from(val: Obdtyf) -> u8 {
                Obdtyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdtyr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdtyr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdtyr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdtyr {
            #[inline(always)]
            fn from(val: u8) -> Obdtyr {
                Obdtyr::from_bits(val)
            }
        }
        impl From<Obdtyr> for u8 {
            #[inline(always)]
            fn from(val: Obdtyr) -> u8 {
                Obdtyr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obe {
            #[inline(always)]
            fn from(val: u8) -> Obe {
                Obe::from_bits(val)
            }
        }
        impl From<Obe> for u8 {
            #[inline(always)]
            fn from(val: Obe) -> u8 {
                Obe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obhld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obhld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obhld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obhld {
            #[inline(always)]
            fn from(val: u8) -> Obhld {
                Obhld::from_bits(val)
            }
        }
        impl From<Obhld> for u8 {
            #[inline(always)]
            fn from(val: Obhld) -> u8 {
                Obhld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Odf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Odf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Odf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Odf {
            #[inline(always)]
            fn from(val: u8) -> Odf {
                Odf::from_bits(val)
            }
        }
        impl From<Odf> for u8 {
            #[inline(always)]
            fn from(val: Odf) -> u8 {
                Odf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Pr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pr {
            #[inline(always)]
            fn from(val: u8) -> Pr {
                Pr::from_bits(val)
            }
        }
        impl From<Pr> for u8 {
            #[inline(always)]
            fn from(val: Pr) -> u8 {
                Pr::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Prkey(u8);
        impl Prkey {}
        impl Prkey {
            pub const fn from_bits(val: u8) -> Prkey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Prkey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prkey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Prkey {
            #[inline(always)]
            fn from(val: u8) -> Prkey {
                Prkey::from_bits(val)
            }
        }
        impl From<Prkey> for u8 {
            #[inline(always)]
            fn from(val: Prkey) -> u8 {
                Prkey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscafbh {
            #[inline(always)]
            fn from(val: u8) -> Pscafbh {
                Pscafbh::from_bits(val)
            }
        }
        impl From<Pscafbh> for u8 {
            #[inline(always)]
            fn from(val: Pscafbh) -> u8 {
                Pscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscafbl {
            #[inline(always)]
            fn from(val: u8) -> Pscafbl {
                Pscafbl::from_bits(val)
            }
        }
        impl From<Pscafbl> for u8 {
            #[inline(always)]
            fn from(val: Pscafbl) -> u8 {
                Pscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscarbh {
            #[inline(always)]
            fn from(val: u8) -> Pscarbh {
                Pscarbh::from_bits(val)
            }
        }
        impl From<Pscarbh> for u8 {
            #[inline(always)]
            fn from(val: Pscarbh) -> u8 {
                Pscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscarbl {
            #[inline(always)]
            fn from(val: u8) -> Pscarbl {
                Pscarbl::from_bits(val)
            }
        }
        impl From<Pscarbl> for u8 {
            #[inline(always)]
            fn from(val: Pscarbl) -> u8 {
                Pscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbfah {
            #[inline(always)]
            fn from(val: u8) -> Pscbfah {
                Pscbfah::from_bits(val)
            }
        }
        impl From<Pscbfah> for u8 {
            #[inline(always)]
            fn from(val: Pscbfah) -> u8 {
                Pscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbfal {
            #[inline(always)]
            fn from(val: u8) -> Pscbfal {
                Pscbfal::from_bits(val)
            }
        }
        impl From<Pscbfal> for u8 {
            #[inline(always)]
            fn from(val: Pscbfal) -> u8 {
                Pscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbrah {
            #[inline(always)]
            fn from(val: u8) -> Pscbrah {
                Pscbrah::from_bits(val)
            }
        }
        impl From<Pscbrah> for u8 {
            #[inline(always)]
            fn from(val: Pscbrah) -> u8 {
                Pscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbral {
            #[inline(always)]
            fn from(val: u8) -> Pscbral {
                Pscbral::from_bits(val)
            }
        }
        impl From<Pscbral> for u8 {
            #[inline(always)]
            fn from(val: Pscbral) -> u8 {
                Pscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselca {
            #[inline(always)]
            fn from(val: u8) -> Pselca {
                Pselca::from_bits(val)
            }
        }
        impl From<Pselca> for u8 {
            #[inline(always)]
            fn from(val: Pselca) -> u8 {
                Pselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcb {
            #[inline(always)]
            fn from(val: u8) -> Pselcb {
                Pselcb::from_bits(val)
            }
        }
        impl From<Pselcb> for u8 {
            #[inline(always)]
            fn from(val: Pselcb) -> u8 {
                Pselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcc {
            #[inline(always)]
            fn from(val: u8) -> Pselcc {
                Pselcc::from_bits(val)
            }
        }
        impl From<Pselcc> for u8 {
            #[inline(always)]
            fn from(val: Pselcc) -> u8 {
                Pselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcd {
            #[inline(always)]
            fn from(val: u8) -> Pselcd {
                Pselcd::from_bits(val)
            }
        }
        impl From<Pselcd> for u8 {
            #[inline(always)]
            fn from(val: Pselcd) -> u8 {
                Pselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgaf {
                Psgtrgaf::from_bits(val)
            }
        }
        impl From<Psgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgaf) -> u8 {
                Psgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgar {
                Psgtrgar::from_bits(val)
            }
        }
        impl From<Psgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgar) -> u8 {
                Psgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgbf {
                Psgtrgbf::from_bits(val)
            }
        }
        impl From<Psgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgbf) -> u8 {
                Psgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgbr {
                Psgtrgbr::from_bits(val)
            }
        }
        impl From<Psgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgbr) -> u8 {
                Psgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscafbh {
            #[inline(always)]
            fn from(val: u8) -> Sscafbh {
                Sscafbh::from_bits(val)
            }
        }
        impl From<Sscafbh> for u8 {
            #[inline(always)]
            fn from(val: Sscafbh) -> u8 {
                Sscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscafbl {
            #[inline(always)]
            fn from(val: u8) -> Sscafbl {
                Sscafbl::from_bits(val)
            }
        }
        impl From<Sscafbl> for u8 {
            #[inline(always)]
            fn from(val: Sscafbl) -> u8 {
                Sscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscarbh {
            #[inline(always)]
            fn from(val: u8) -> Sscarbh {
                Sscarbh::from_bits(val)
            }
        }
        impl From<Sscarbh> for u8 {
            #[inline(always)]
            fn from(val: Sscarbh) -> u8 {
                Sscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscarbl {
            #[inline(always)]
            fn from(val: u8) -> Sscarbl {
                Sscarbl::from_bits(val)
            }
        }
        impl From<Sscarbl> for u8 {
            #[inline(always)]
            fn from(val: Sscarbl) -> u8 {
                Sscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbfah {
            #[inline(always)]
            fn from(val: u8) -> Sscbfah {
                Sscbfah::from_bits(val)
            }
        }
        impl From<Sscbfah> for u8 {
            #[inline(always)]
            fn from(val: Sscbfah) -> u8 {
                Sscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbfal {
            #[inline(always)]
            fn from(val: u8) -> Sscbfal {
                Sscbfal::from_bits(val)
            }
        }
        impl From<Sscbfal> for u8 {
            #[inline(always)]
            fn from(val: Sscbfal) -> u8 {
                Sscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbrah {
            #[inline(always)]
            fn from(val: u8) -> Sscbrah {
                Sscbrah::from_bits(val)
            }
        }
        impl From<Sscbrah> for u8 {
            #[inline(always)]
            fn from(val: Sscbrah) -> u8 {
                Sscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbral {
            #[inline(always)]
            fn from(val: u8) -> Sscbral {
                Sscbral::from_bits(val)
            }
        }
        impl From<Sscbral> for u8 {
            #[inline(always)]
            fn from(val: Sscbral) -> u8 {
                Sscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselca {
            #[inline(always)]
            fn from(val: u8) -> Sselca {
                Sselca::from_bits(val)
            }
        }
        impl From<Sselca> for u8 {
            #[inline(always)]
            fn from(val: Sselca) -> u8 {
                Sselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcb {
            #[inline(always)]
            fn from(val: u8) -> Sselcb {
                Sselcb::from_bits(val)
            }
        }
        impl From<Sselcb> for u8 {
            #[inline(always)]
            fn from(val: Sselcb) -> u8 {
                Sselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcc {
            #[inline(always)]
            fn from(val: u8) -> Sselcc {
                Sselcc::from_bits(val)
            }
        }
        impl From<Sselcc> for u8 {
            #[inline(always)]
            fn from(val: Sselcc) -> u8 {
                Sselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcd {
            #[inline(always)]
            fn from(val: u8) -> Sselcd {
                Sselcd::from_bits(val)
            }
        }
        impl From<Sselcd> for u8 {
            #[inline(always)]
            fn from(val: Sselcd) -> u8 {
                Sselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgaf {
                Ssgtrgaf::from_bits(val)
            }
        }
        impl From<Ssgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgaf) -> u8 {
                Ssgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgar {
                Ssgtrgar::from_bits(val)
            }
        }
        impl From<Ssgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgar) -> u8 {
                Ssgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgbf {
                Ssgtrgbf::from_bits(val)
            }
        }
        impl From<Ssgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgbf) -> u8 {
                Ssgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgbr {
                Ssgtrgbr::from_bits(val)
            }
        }
        impl From<Ssgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgbr) -> u8 {
                Ssgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfa {
            #[inline(always)]
            fn from(val: u8) -> Tcfa {
                Tcfa::from_bits(val)
            }
        }
        impl From<Tcfa> for u8 {
            #[inline(always)]
            fn from(val: Tcfa) -> u8 {
                Tcfa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfb {
            #[inline(always)]
            fn from(val: u8) -> Tcfb {
                Tcfb::from_bits(val)
            }
        }
        impl From<Tcfb> for u8 {
            #[inline(always)]
            fn from(val: Tcfb) -> u8 {
                Tcfb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfc {
            #[inline(always)]
            fn from(val: u8) -> Tcfc {
                Tcfc::from_bits(val)
            }
        }
        impl From<Tcfc> for u8 {
            #[inline(always)]
            fn from(val: Tcfc) -> u8 {
                Tcfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfd {
            #[inline(always)]
            fn from(val: u8) -> Tcfd {
                Tcfd::from_bits(val)
            }
        }
        impl From<Tcfd> for u8 {
            #[inline(always)]
            fn from(val: Tcfd) -> u8 {
                Tcfd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfe {
            #[inline(always)]
            fn from(val: u8) -> Tcfe {
                Tcfe::from_bits(val)
            }
        }
        impl From<Tcfe> for u8 {
            #[inline(always)]
            fn from(val: Tcfe) -> u8 {
                Tcfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcff {
            #[inline(always)]
            fn from(val: u8) -> Tcff {
                Tcff::from_bits(val)
            }
        }
        impl From<Tcff> for u8 {
            #[inline(always)]
            fn from(val: Tcff) -> u8 {
                Tcff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfpu {
            #[inline(always)]
            fn from(val: u8) -> Tcfpu {
                Tcfpu::from_bits(val)
            }
        }
        impl From<Tcfpu> for u8 {
            #[inline(always)]
            fn from(val: Tcfpu) -> u8 {
                Tcfpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcpfo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcpfo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcpfo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcpfo {
            #[inline(always)]
            fn from(val: u8) -> Tcpfo {
                Tcpfo::from_bits(val)
            }
        }
        impl From<Tcpfo> for u8 {
            #[inline(always)]
            fn from(val: Tcpfo) -> u8 {
                Tcpfo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tde {
            #[inline(always)]
            fn from(val: u8) -> Tde {
                Tde::from_bits(val)
            }
        }
        impl From<Tde> for u8 {
            #[inline(always)]
            fn from(val: Tde) -> u8 {
                Tde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tpcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tpcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tpcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tpcs {
            #[inline(always)]
            fn from(val: u8) -> Tpcs {
                Tpcs::from_bits(val)
            }
        }
        impl From<Tpcs> for u8 {
            #[inline(always)]
            fn from(val: Tpcs) -> u8 {
                Tpcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ud {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ud {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ud {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ud {
            #[inline(always)]
            fn from(val: u8) -> Ud {
                Ud::from_bits(val)
            }
        }
        impl From<Ud> for u8 {
            #[inline(always)]
            fn from(val: Ud) -> u8 {
                Ud::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Udf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Udf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Udf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Udf {
            #[inline(always)]
            fn from(val: u8) -> Udf {
                Udf::from_bits(val)
            }
        }
        impl From<Udf> for u8 {
            #[inline(always)]
            fn from(val: Udf) -> u8 {
                Udf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscafbh {
            #[inline(always)]
            fn from(val: u8) -> Uscafbh {
                Uscafbh::from_bits(val)
            }
        }
        impl From<Uscafbh> for u8 {
            #[inline(always)]
            fn from(val: Uscafbh) -> u8 {
                Uscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscafbl {
            #[inline(always)]
            fn from(val: u8) -> Uscafbl {
                Uscafbl::from_bits(val)
            }
        }
        impl From<Uscafbl> for u8 {
            #[inline(always)]
            fn from(val: Uscafbl) -> u8 {
                Uscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscarbh {
            #[inline(always)]
            fn from(val: u8) -> Uscarbh {
                Uscarbh::from_bits(val)
            }
        }
        impl From<Uscarbh> for u8 {
            #[inline(always)]
            fn from(val: Uscarbh) -> u8 {
                Uscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscarbl {
            #[inline(always)]
            fn from(val: u8) -> Uscarbl {
                Uscarbl::from_bits(val)
            }
        }
        impl From<Uscarbl> for u8 {
            #[inline(always)]
            fn from(val: Uscarbl) -> u8 {
                Uscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbfah {
            #[inline(always)]
            fn from(val: u8) -> Uscbfah {
                Uscbfah::from_bits(val)
            }
        }
        impl From<Uscbfah> for u8 {
            #[inline(always)]
            fn from(val: Uscbfah) -> u8 {
                Uscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbfal {
            #[inline(always)]
            fn from(val: u8) -> Uscbfal {
                Uscbfal::from_bits(val)
            }
        }
        impl From<Uscbfal> for u8 {
            #[inline(always)]
            fn from(val: Uscbfal) -> u8 {
                Uscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbrah {
            #[inline(always)]
            fn from(val: u8) -> Uscbrah {
                Uscbrah::from_bits(val)
            }
        }
        impl From<Uscbrah> for u8 {
            #[inline(always)]
            fn from(val: Uscbrah) -> u8 {
                Uscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbral {
            #[inline(always)]
            fn from(val: u8) -> Uscbral {
                Uscbral::from_bits(val)
            }
        }
        impl From<Uscbral> for u8 {
            #[inline(always)]
            fn from(val: Uscbral) -> u8 {
                Uscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselca {
            #[inline(always)]
            fn from(val: u8) -> Uselca {
                Uselca::from_bits(val)
            }
        }
        impl From<Uselca> for u8 {
            #[inline(always)]
            fn from(val: Uselca) -> u8 {
                Uselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcb {
            #[inline(always)]
            fn from(val: u8) -> Uselcb {
                Uselcb::from_bits(val)
            }
        }
        impl From<Uselcb> for u8 {
            #[inline(always)]
            fn from(val: Uselcb) -> u8 {
                Uselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcc {
            #[inline(always)]
            fn from(val: u8) -> Uselcc {
                Uselcc::from_bits(val)
            }
        }
        impl From<Uselcc> for u8 {
            #[inline(always)]
            fn from(val: Uselcc) -> u8 {
                Uselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcd {
            #[inline(always)]
            fn from(val: u8) -> Uselcd {
                Uselcd::from_bits(val)
            }
        }
        impl From<Uselcd> for u8 {
            #[inline(always)]
            fn from(val: Uselcd) -> u8 {
                Uselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgaf {
                Usgtrgaf::from_bits(val)
            }
        }
        impl From<Usgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgaf) -> u8 {
                Usgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgar {
                Usgtrgar::from_bits(val)
            }
        }
        impl From<Usgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgar) -> u8 {
                Usgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgbf {
                Usgtrgbf::from_bits(val)
            }
        }
        impl From<Usgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgbf) -> u8 {
                Usgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgbr {
                Usgtrgbr::from_bits(val)
            }
        }
        impl From<Usgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgbr) -> u8 {
                Usgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wp {
            #[inline(always)]
            fn from(val: u8) -> Wp {
                Wp::from_bits(val)
            }
        }
        impl From<Wp> for u8 {
            #[inline(always)]
            fn from(val: Wp) -> u8 {
                Wp::to_bits(val)
            }
        }
    }
}
pub mod gpt_ops {
    #[doc = "Output Phase Switching Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GptOps {
        ptr: *mut u8,
    }
    unsafe impl Send for GptOps {}
    unsafe impl Sync for GptOps {}
    impl GptOps {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output Phase Switching Control Register"]
        #[inline(always)]
        pub const fn opscr(self) -> crate::common::Reg<regs::Opscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Output Phase Switching Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opscr(pub u32);
        impl Opscr {
            #[doc = "Input Phase Soft Setting WFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1."]
            #[inline(always)]
            pub const fn uf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Input Phase Soft Setting WFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1."]
            #[inline(always)]
            pub fn set_uf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Input Phase Soft Setting VFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1."]
            #[inline(always)]
            pub const fn vf(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Input Phase Soft Setting VFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1."]
            #[inline(always)]
            pub fn set_vf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Input Phase Soft Setting UFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1."]
            #[inline(always)]
            pub const fn wf(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Input Phase Soft Setting UFThis bit sets the input phase by the software settings.This bit setting is valid when the OPSCR.FB bit = 1."]
            #[inline(always)]
            pub fn set_wf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Input U,Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)"]
            #[inline(always)]
            pub const fn u(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Input U,Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)"]
            #[inline(always)]
            pub fn set_u(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Input V,Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)"]
            #[inline(always)]
            pub const fn v(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Input V,Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)"]
            #[inline(always)]
            pub fn set_v(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Input W,Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)"]
            #[inline(always)]
            pub const fn w(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Input W,Phase MonitorThis bit monitors the state of the input phase.OPSCR.FB=0:External input monitoring by PCLKOPSCR.FB=1:Software settings (UF/VF/WF)"]
            #[inline(always)]
            pub fn set_w(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable,Phase Output Control"]
            #[inline(always)]
            pub const fn en(&self) -> super::vals::En {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::En::from_bits(val as u8)
            }
            #[doc = "Enable,Phase Output Control"]
            #[inline(always)]
            pub fn set_en(&mut self, val: super::vals::En) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "External Feedback Signal EnableThis bit selects the input phase from the software settings and external input."]
            #[inline(always)]
            pub const fn fb(&self) -> super::vals::Fb {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Fb::from_bits(val as u8)
            }
            #[doc = "External Feedback Signal EnableThis bit selects the input phase from the software settings and external input."]
            #[inline(always)]
            pub fn set_fb(&mut self, val: super::vals::Fb) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Positive,Phase Output (P) Control"]
            #[inline(always)]
            pub const fn p(&self) -> super::vals::P {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::P::from_bits(val as u8)
            }
            #[doc = "Positive,Phase Output (P) Control"]
            #[inline(always)]
            pub fn set_p(&mut self, val: super::vals::P) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Negative,Phase Output (N) Control"]
            #[inline(always)]
            pub const fn n(&self) -> super::vals::N {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::N::from_bits(val as u8)
            }
            #[doc = "Negative,Phase Output (N) Control"]
            #[inline(always)]
            pub fn set_n(&mut self, val: super::vals::N) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Invert,Phase Output Control"]
            #[inline(always)]
            pub const fn inv(&self) -> super::vals::Inv {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Inv::from_bits(val as u8)
            }
            #[doc = "Invert,Phase Output Control"]
            #[inline(always)]
            pub fn set_inv(&mut self, val: super::vals::Inv) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Output phase rotation direction reversal"]
            #[inline(always)]
            pub const fn rv(&self) -> super::vals::Rv {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Rv::from_bits(val as u8)
            }
            #[doc = "Output phase rotation direction reversal"]
            #[inline(always)]
            pub fn set_rv(&mut self, val: super::vals::Rv) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Input phase alignment"]
            #[inline(always)]
            pub const fn align(&self) -> super::vals::Align {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Align::from_bits(val as u8)
            }
            #[doc = "Input phase alignment"]
            #[inline(always)]
            pub fn set_align(&mut self, val: super::vals::Align) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_22_23(&self) -> u8 {
                let val = (self.0 >> 22usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_22_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize);
            }
            #[doc = "Output disabled source selection"]
            #[inline(always)]
            pub const fn grp(&self) -> super::vals::Grp {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Grp::from_bits(val as u8)
            }
            #[doc = "Output disabled source selection"]
            #[inline(always)]
            pub fn set_grp(&mut self, val: super::vals::Grp) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_25_25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_25_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Group output disable function"]
            #[inline(always)]
            pub const fn godf(&self) -> super::vals::Godf {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Godf::from_bits(val as u8)
            }
            #[doc = "Group output disable function"]
            #[inline(always)]
            pub fn set_godf(&mut self, val: super::vals::Godf) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_27_27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_27_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_28_28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_28_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "External Input Noise Filter Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::Nfen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Nfen::from_bits(val as u8)
            }
            #[doc = "External Input Noise Filter Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::Nfen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "External Input Noise Filter Clock selectionNoise filter sampling clock setting of the external input."]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::Nfcs {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::Nfcs::from_bits(val as u8)
            }
            #[doc = "External Input Noise Filter Clock selectionNoise filter sampling clock setting of the external input."]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::Nfcs) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Opscr {
            #[inline(always)]
            fn default() -> Opscr {
                Opscr(0)
            }
        }
        impl core::fmt::Debug for Opscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opscr")
                    .field("uf", &self.uf())
                    .field("vf", &self.vf())
                    .field("wf", &self.wf())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("u", &self.u())
                    .field("v", &self.v())
                    .field("w", &self.w())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .field("en", &self.en())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .field("fb", &self.fb())
                    .field("p", &self.p())
                    .field("n", &self.n())
                    .field("inv", &self.inv())
                    .field("rv", &self.rv())
                    .field("align", &self.align())
                    .field("reserved_22_23", &self.reserved_22_23())
                    .field("grp", &self.grp())
                    .field("reserved_25_25", &self.reserved_25_25())
                    .field("godf", &self.godf())
                    .field("reserved_27_27", &self.reserved_27_27())
                    .field("reserved_28_28", &self.reserved_28_28())
                    .field("nfen", &self.nfen())
                    .field("nfcs", &self.nfcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opscr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Opscr {{ uf: {=bool:?}, vf: {=bool:?}, wf: {=bool:?}, reserved_3_3: {=bool:?}, u: {=bool:?}, v: {=bool:?}, w: {=bool:?}, reserved_7_7: {=bool:?}, en: {:?}, reserved_9_15: {=u8:?}, fb: {:?}, p: {:?}, n: {:?}, inv: {:?}, rv: {:?}, align: {:?}, reserved_22_23: {=u8:?}, grp: {:?}, reserved_25_25: {=bool:?}, godf: {:?}, reserved_27_27: {=bool:?}, reserved_28_28: {=bool:?}, nfen: {:?}, nfcs: {:?} }}" , self . uf () , self . vf () , self . wf () , self . reserved_3_3 () , self . u () , self . v () , self . w () , self . reserved_7_7 () , self . en () , self . reserved_9_15 () , self . fb () , self . p () , self . n () , self . inv () , self . rv () , self . align () , self . reserved_22_23 () , self . grp () , self . reserved_25_25 () , self . godf () , self . reserved_27_27 () , self . reserved_28_28 () , self . nfen () , self . nfcs ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Align {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Align {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Align {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Align {
            #[inline(always)]
            fn from(val: u8) -> Align {
                Align::from_bits(val)
            }
        }
        impl From<Align> for u8 {
            #[inline(always)]
            fn from(val: Align) -> u8 {
                Align::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En {
            #[inline(always)]
            fn from(val: u8) -> En {
                En::from_bits(val)
            }
        }
        impl From<En> for u8 {
            #[inline(always)]
            fn from(val: En) -> u8 {
                En::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fb {
            #[inline(always)]
            fn from(val: u8) -> Fb {
                Fb::from_bits(val)
            }
        }
        impl From<Fb> for u8 {
            #[inline(always)]
            fn from(val: Fb) -> u8 {
                Fb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Godf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Godf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Godf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Godf {
            #[inline(always)]
            fn from(val: u8) -> Godf {
                Godf::from_bits(val)
            }
        }
        impl From<Godf> for u8 {
            #[inline(always)]
            fn from(val: Godf) -> u8 {
                Godf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Grp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grp {
            #[inline(always)]
            fn from(val: u8) -> Grp {
                Grp::from_bits(val)
            }
        }
        impl From<Grp> for u8 {
            #[inline(always)]
            fn from(val: Grp) -> u8 {
                Grp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Inv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inv {
            #[inline(always)]
            fn from(val: u8) -> Inv {
                Inv::from_bits(val)
            }
        }
        impl From<Inv> for u8 {
            #[inline(always)]
            fn from(val: Inv) -> u8 {
                Inv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum N {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl N {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> N {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for N {
            #[inline(always)]
            fn from(val: u8) -> N {
                N::from_bits(val)
            }
        }
        impl From<N> for u8 {
            #[inline(always)]
            fn from(val: N) -> u8 {
                N::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcs {
            #[inline(always)]
            fn from(val: u8) -> Nfcs {
                Nfcs::from_bits(val)
            }
        }
        impl From<Nfcs> for u8 {
            #[inline(always)]
            fn from(val: Nfcs) -> u8 {
                Nfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfen {
            #[inline(always)]
            fn from(val: u8) -> Nfen {
                Nfen::from_bits(val)
            }
        }
        impl From<Nfen> for u8 {
            #[inline(always)]
            fn from(val: Nfen) -> u8 {
                Nfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P {
            #[inline(always)]
            fn from(val: u8) -> P {
                P::from_bits(val)
            }
        }
        impl From<P> for u8 {
            #[inline(always)]
            fn from(val: P) -> u8 {
                P::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rv {
            #[inline(always)]
            fn from(val: u8) -> Rv {
                Rv::from_bits(val)
            }
        }
        impl From<Rv> for u8 {
            #[inline(always)]
            fn from(val: Rv) -> u8 {
                Rv::to_bits(val)
            }
        }
    }
}
pub mod icu {
    #[doc = "Interrupt Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Icu {
        ptr: *mut u8,
    }
    unsafe impl Send for Icu {}
    unsafe impl Sync for Icu {}
    impl Icu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IRQ Control Register %s"]
        #[inline(always)]
        pub const fn irqcr(self, n: usize) -> crate::common::Reg<regs::Irqcr, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 1usize) as _) }
        }
        #[doc = "NMI Pin Interrupt Control Register"]
        #[inline(always)]
        pub const fn nmicr(self) -> crate::common::Reg<regs::Nmicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Non,Maskable Interrupt Enable Register"]
        #[inline(always)]
        pub const fn nmier(self) -> crate::common::Reg<regs::Nmier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Non,Maskable Interrupt Status Clear Register"]
        #[inline(always)]
        pub const fn nmiclr(self) -> crate::common::Reg<regs::Nmiclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Non,Maskable Interrupt Status Register"]
        #[inline(always)]
        pub const fn nmisr(self) -> crate::common::Reg<regs::Nmisr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "Wake Up Interrupt Enable Register"]
        #[inline(always)]
        pub const fn wupen(self) -> crate::common::Reg<regs::Wupen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a0usize) as _) }
        }
        #[doc = "SYS Event Link Setting Register"]
        #[inline(always)]
        pub const fn selsr0(self) -> crate::common::Reg<regs::Selsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "ICU Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn ielsr(self, n: usize) -> crate::common::Reg<regs::Ielsr, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "ICU Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ielsr(pub u32);
        impl Ielsr {
            #[doc = "ICU Event selection to NVICSet the number for the event signal to be linked ."]
            #[inline(always)]
            pub const fn iels(&self) -> super::vals::Iels {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Iels::from_bits(val as u8)
            }
            #[doc = "ICU Event selection to NVICSet the number for the event signal to be linked ."]
            #[inline(always)]
            pub fn set_iels(&mut self, val: super::vals::Iels) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Interrupt Status Flag"]
            #[inline(always)]
            pub const fn ir(&self) -> super::vals::Ir {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Ir::from_bits(val as u8)
            }
            #[doc = "Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_ir(&mut self, val: super::vals::Ir) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_17_23(&self) -> u8 {
                let val = (self.0 >> 17usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_17_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 17usize)) | (((val as u32) & 0x7f) << 17usize);
            }
            #[doc = "DTC Activation Enable"]
            #[inline(always)]
            pub const fn dtce(&self) -> super::vals::Dtce {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Dtce::from_bits(val as u8)
            }
            #[doc = "DTC Activation Enable"]
            #[inline(always)]
            pub fn set_dtce(&mut self, val: super::vals::Dtce) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_25_31(&self) -> u8 {
                let val = (self.0 >> 25usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_25_31(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 25usize)) | (((val as u32) & 0x7f) << 25usize);
            }
        }
        impl Default for Ielsr {
            #[inline(always)]
            fn default() -> Ielsr {
                Ielsr(0)
            }
        }
        impl core::fmt::Debug for Ielsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ielsr")
                    .field("iels", &self.iels())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .field("ir", &self.ir())
                    .field("reserved_17_23", &self.reserved_17_23())
                    .field("dtce", &self.dtce())
                    .field("reserved_25_31", &self.reserved_25_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ielsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ielsr {{ iels: {:?}, reserved_8_15: {=u8:?}, ir: {:?}, reserved_17_23: {=u8:?}, dtce: {:?}, reserved_25_31: {=u8:?} }}" , self . iels () , self . reserved_8_15 () , self . ir () , self . reserved_17_23 () , self . dtce () , self . reserved_25_31 ())
            }
        }
        #[doc = "IRQ Control Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Irqcr(pub u8);
        impl Irqcr {
            #[doc = "IRQ Detection Sense Select"]
            #[inline(always)]
            pub const fn irqmd(&self) -> super::vals::Irqmd {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Irqmd::from_bits(val as u8)
            }
            #[doc = "IRQ Detection Sense Select"]
            #[inline(always)]
            pub fn set_irqmd(&mut self, val: super::vals::Irqmd) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_2_3(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_2_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "IRQi Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub const fn fclksel(&self) -> super::vals::Fclksel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Fclksel::from_bits(val as u8)
            }
            #[doc = "IRQi Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub fn set_fclksel(&mut self, val: super::vals::Fclksel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "IRQ Digital Filter Enable"]
            #[inline(always)]
            pub const fn flten(&self) -> super::vals::Flten {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Flten::from_bits(val as u8)
            }
            #[doc = "IRQ Digital Filter Enable"]
            #[inline(always)]
            pub fn set_flten(&mut self, val: super::vals::Flten) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Irqcr {
            #[inline(always)]
            fn default() -> Irqcr {
                Irqcr(0)
            }
        }
        impl core::fmt::Debug for Irqcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Irqcr")
                    .field("irqmd", &self.irqmd())
                    .field("reserved_2_3", &self.reserved_2_3())
                    .field("fclksel", &self.fclksel())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("flten", &self.flten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Irqcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Irqcr {{ irqmd: {:?}, reserved_2_3: {=u8:?}, fclksel: {:?}, reserved_6_6: {=bool:?}, flten: {:?} }}" , self . irqmd () , self . reserved_2_3 () , self . fclksel () , self . reserved_6_6 () , self . flten ())
            }
        }
        #[doc = "Non,Maskable Interrupt Status Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmiclr(pub u16);
        impl Nmiclr {
            #[doc = "IWDTST Clear"]
            #[inline(always)]
            pub const fn iwdtclr(&self) -> super::vals::Iwdtclr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtclr::from_bits(val as u8)
            }
            #[doc = "IWDTST Clear"]
            #[inline(always)]
            pub fn set_iwdtclr(&mut self, val: super::vals::Iwdtclr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDTST Clear"]
            #[inline(always)]
            pub const fn wdtclr(&self) -> super::vals::Wdtclr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtclr::from_bits(val as u8)
            }
            #[doc = "WDTST Clear"]
            #[inline(always)]
            pub fn set_wdtclr(&mut self, val: super::vals::Wdtclr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "LVD1ST Clear"]
            #[inline(always)]
            pub const fn lvd1clr(&self) -> super::vals::Lvd1clr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1clr::from_bits(val as u8)
            }
            #[doc = "LVD1ST Clear"]
            #[inline(always)]
            pub fn set_lvd1clr(&mut self, val: super::vals::Lvd1clr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "LVD2ST Clear"]
            #[inline(always)]
            pub const fn lvd2clr(&self) -> super::vals::Lvd2clr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2clr::from_bits(val as u8)
            }
            #[doc = "LVD2ST Clear"]
            #[inline(always)]
            pub fn set_lvd2clr(&mut self, val: super::vals::Lvd2clr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_4_5(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_4_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u16) & 0x03) << 4usize);
            }
            #[doc = "OSTST Clear"]
            #[inline(always)]
            pub const fn ostclr(&self) -> super::vals::Ostclr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ostclr::from_bits(val as u8)
            }
            #[doc = "OSTST Clear"]
            #[inline(always)]
            pub fn set_ostclr(&mut self, val: super::vals::Ostclr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "NMIST Clear"]
            #[inline(always)]
            pub const fn nmiclr(&self) -> super::vals::Nmiclr {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmiclr::from_bits(val as u8)
            }
            #[doc = "NMIST Clear"]
            #[inline(always)]
            pub fn set_nmiclr(&mut self, val: super::vals::Nmiclr) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Clear"]
            #[inline(always)]
            pub const fn rpeclr(&self) -> super::vals::Rpeclr {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpeclr::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Clear"]
            #[inline(always)]
            pub fn set_rpeclr(&mut self, val: super::vals::Rpeclr) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "SRAM ECC Error Interrupt Clear"]
            #[inline(always)]
            pub const fn reccclr(&self) -> super::vals::Reccclr {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Reccclr::from_bits(val as u8)
            }
            #[doc = "SRAM ECC Error Interrupt Clear"]
            #[inline(always)]
            pub fn set_reccclr(&mut self, val: super::vals::Reccclr) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "MPU Bus Slave Error Interrupt Clear"]
            #[inline(always)]
            pub const fn bussclr(&self) -> super::vals::Bussclr {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussclr::from_bits(val as u8)
            }
            #[doc = "MPU Bus Slave Error Interrupt Clear"]
            #[inline(always)]
            pub fn set_bussclr(&mut self, val: super::vals::Bussclr) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "MPU Bus Master Error Interrupt Clear"]
            #[inline(always)]
            pub const fn busmclr(&self) -> super::vals::Busmclr {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmclr::from_bits(val as u8)
            }
            #[doc = "MPU Bus Master Error Interrupt Clear"]
            #[inline(always)]
            pub fn set_busmclr(&mut self, val: super::vals::Busmclr) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Clear"]
            #[inline(always)]
            pub const fn speclr(&self) -> super::vals::Speclr {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Speclr::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Clear"]
            #[inline(always)]
            pub fn set_speclr(&mut self, val: super::vals::Speclr) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_13_15(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_13_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u16) & 0x07) << 13usize);
            }
        }
        impl Default for Nmiclr {
            #[inline(always)]
            fn default() -> Nmiclr {
                Nmiclr(0)
            }
        }
        impl core::fmt::Debug for Nmiclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmiclr")
                    .field("iwdtclr", &self.iwdtclr())
                    .field("wdtclr", &self.wdtclr())
                    .field("lvd1clr", &self.lvd1clr())
                    .field("lvd2clr", &self.lvd2clr())
                    .field("reserved_4_5", &self.reserved_4_5())
                    .field("ostclr", &self.ostclr())
                    .field("nmiclr", &self.nmiclr())
                    .field("rpeclr", &self.rpeclr())
                    .field("reccclr", &self.reccclr())
                    .field("bussclr", &self.bussclr())
                    .field("busmclr", &self.busmclr())
                    .field("speclr", &self.speclr())
                    .field("reserved_13_15", &self.reserved_13_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmiclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmiclr {{ iwdtclr: {:?}, wdtclr: {:?}, lvd1clr: {:?}, lvd2clr: {:?}, reserved_4_5: {=u8:?}, ostclr: {:?}, nmiclr: {:?}, rpeclr: {:?}, reccclr: {:?}, bussclr: {:?}, busmclr: {:?}, speclr: {:?}, reserved_13_15: {=u8:?} }}" , self . iwdtclr () , self . wdtclr () , self . lvd1clr () , self . lvd2clr () , self . reserved_4_5 () , self . ostclr () , self . nmiclr () , self . rpeclr () , self . reccclr () , self . bussclr () , self . busmclr () , self . speclr () , self . reserved_13_15 ())
            }
        }
        #[doc = "NMI Pin Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmicr(pub u8);
        impl Nmicr {
            #[doc = "NMI Detection Set"]
            #[inline(always)]
            pub const fn nmimd(&self) -> super::vals::Nmimd {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Nmimd::from_bits(val as u8)
            }
            #[doc = "NMI Detection Set"]
            #[inline(always)]
            pub fn set_nmimd(&mut self, val: super::vals::Nmimd) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_1_3(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_1_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "NMI Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfclksel(&self) -> super::vals::Nfclksel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Nfclksel::from_bits(val as u8)
            }
            #[doc = "NMI Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfclksel(&mut self, val: super::vals::Nfclksel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "NMI Digital Filter Enable"]
            #[inline(always)]
            pub const fn nflten(&self) -> super::vals::Nflten {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nflten::from_bits(val as u8)
            }
            #[doc = "NMI Digital Filter Enable"]
            #[inline(always)]
            pub fn set_nflten(&mut self, val: super::vals::Nflten) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Nmicr {
            #[inline(always)]
            fn default() -> Nmicr {
                Nmicr(0)
            }
        }
        impl core::fmt::Debug for Nmicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmicr")
                    .field("nmimd", &self.nmimd())
                    .field("reserved_1_3", &self.reserved_1_3())
                    .field("nfclksel", &self.nfclksel())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("nflten", &self.nflten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmicr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmicr {{ nmimd: {:?}, reserved_1_3: {=u8:?}, nfclksel: {:?}, reserved_6_6: {=bool:?}, nflten: {:?} }}" , self . nmimd () , self . reserved_1_3 () , self . nfclksel () , self . reserved_6_6 () , self . nflten ())
            }
        }
        #[doc = "Non,Maskable Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmier(pub u16);
        impl Nmier {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub const fn iwdten(&self) -> super::vals::Iwdten {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdten::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_iwdten(&mut self, val: super::vals::Iwdten) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub const fn wdten(&self) -> super::vals::Wdten {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdten::from_bits(val as u8)
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_wdten(&mut self, val: super::vals::Wdten) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Voltage,Monitoring 1 Interrupt Enable"]
            #[inline(always)]
            pub const fn lvd1en(&self) -> super::vals::Lvd1en {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1en::from_bits(val as u8)
            }
            #[doc = "Voltage,Monitoring 1 Interrupt Enable"]
            #[inline(always)]
            pub fn set_lvd1en(&mut self, val: super::vals::Lvd1en) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Voltage,Monitoring 2 Interrupt Enable"]
            #[inline(always)]
            pub const fn lvd2en(&self) -> super::vals::Lvd2en {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2en::from_bits(val as u8)
            }
            #[doc = "Voltage,Monitoring 2 Interrupt Enable"]
            #[inline(always)]
            pub fn set_lvd2en(&mut self, val: super::vals::Lvd2en) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_4_5(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_4_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u16) & 0x03) << 4usize);
            }
            #[doc = "Oscillation Stop Detection Interrupt Enable"]
            #[inline(always)]
            pub const fn osten(&self) -> super::vals::Osten {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Osten::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Interrupt Enable"]
            #[inline(always)]
            pub fn set_osten(&mut self, val: super::vals::Osten) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "NMI Pin Interrupt Enable"]
            #[inline(always)]
            pub const fn nmien(&self) -> super::vals::Nmien {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmien::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Enable"]
            #[inline(always)]
            pub fn set_nmien(&mut self, val: super::vals::Nmien) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "RAM Parity Error Interrupt Enable"]
            #[inline(always)]
            pub const fn rpeen(&self) -> super::vals::Rpeen {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpeen::from_bits(val as u8)
            }
            #[doc = "RAM Parity Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_rpeen(&mut self, val: super::vals::Rpeen) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "SRAM ECC Error Interrupt Enable"]
            #[inline(always)]
            pub const fn reccen(&self) -> super::vals::Reccen {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Reccen::from_bits(val as u8)
            }
            #[doc = "SRAM ECC Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_reccen(&mut self, val: super::vals::Reccen) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "MPU Bus Slave Error Interrupt Enable"]
            #[inline(always)]
            pub const fn bussen(&self) -> super::vals::Bussen {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussen::from_bits(val as u8)
            }
            #[doc = "MPU Bus Slave Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_bussen(&mut self, val: super::vals::Bussen) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "MPU Bus Master Error Interrupt Enable"]
            #[inline(always)]
            pub const fn busmen(&self) -> super::vals::Busmen {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmen::from_bits(val as u8)
            }
            #[doc = "MPU Bus Master Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_busmen(&mut self, val: super::vals::Busmen) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Enable"]
            #[inline(always)]
            pub const fn speen(&self) -> super::vals::Speen {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Speen::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Enable"]
            #[inline(always)]
            pub fn set_speen(&mut self, val: super::vals::Speen) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_13_15(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_13_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u16) & 0x07) << 13usize);
            }
        }
        impl Default for Nmier {
            #[inline(always)]
            fn default() -> Nmier {
                Nmier(0)
            }
        }
        impl core::fmt::Debug for Nmier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmier")
                    .field("iwdten", &self.iwdten())
                    .field("wdten", &self.wdten())
                    .field("lvd1en", &self.lvd1en())
                    .field("lvd2en", &self.lvd2en())
                    .field("reserved_4_5", &self.reserved_4_5())
                    .field("osten", &self.osten())
                    .field("nmien", &self.nmien())
                    .field("rpeen", &self.rpeen())
                    .field("reccen", &self.reccen())
                    .field("bussen", &self.bussen())
                    .field("busmen", &self.busmen())
                    .field("speen", &self.speen())
                    .field("reserved_13_15", &self.reserved_13_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmier {{ iwdten: {:?}, wdten: {:?}, lvd1en: {:?}, lvd2en: {:?}, reserved_4_5: {=u8:?}, osten: {:?}, nmien: {:?}, rpeen: {:?}, reccen: {:?}, bussen: {:?}, busmen: {:?}, speen: {:?}, reserved_13_15: {=u8:?} }}" , self . iwdten () , self . wdten () , self . lvd1en () , self . lvd2en () , self . reserved_4_5 () , self . osten () , self . nmien () , self . rpeen () , self . reccen () , self . bussen () , self . busmen () , self . speen () , self . reserved_13_15 ())
            }
        }
        #[doc = "Non,Maskable Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmisr(pub u16);
        impl Nmisr {
            #[doc = "IWDT Underflow/Refresh Error Status Flag"]
            #[inline(always)]
            pub const fn iwdtst(&self) -> super::vals::Iwdtst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtst::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Status Flag"]
            #[inline(always)]
            pub fn set_iwdtst(&mut self, val: super::vals::Iwdtst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT Underflow/Refresh Error Status Flag"]
            #[inline(always)]
            pub const fn wdtst(&self) -> super::vals::Wdtst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtst::from_bits(val as u8)
            }
            #[doc = "WDT Underflow/Refresh Error Status Flag"]
            #[inline(always)]
            pub fn set_wdtst(&mut self, val: super::vals::Wdtst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Voltage,Monitoring 1 Interrupt Status Flag"]
            #[inline(always)]
            pub const fn lvd1st(&self) -> super::vals::Lvd1st {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1st::from_bits(val as u8)
            }
            #[doc = "Voltage,Monitoring 1 Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_lvd1st(&mut self, val: super::vals::Lvd1st) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Voltage,Monitoring 2 Interrupt Status Flag"]
            #[inline(always)]
            pub const fn lvd2st(&self) -> super::vals::Lvd2st {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2st::from_bits(val as u8)
            }
            #[doc = "Voltage,Monitoring 2 Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_lvd2st(&mut self, val: super::vals::Lvd2st) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_4_5(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_4_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u16) & 0x03) << 4usize);
            }
            #[doc = "Oscillation Stop Detection Interrupt Status Flag"]
            #[inline(always)]
            pub const fn ostst(&self) -> super::vals::Ostst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ostst::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_ostst(&mut self, val: super::vals::Ostst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "NMI Status Flag"]
            #[inline(always)]
            pub const fn nmist(&self) -> super::vals::Nmist {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmist::from_bits(val as u8)
            }
            #[doc = "NMI Status Flag"]
            #[inline(always)]
            pub fn set_nmist(&mut self, val: super::vals::Nmist) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "RAM Parity Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn rpest(&self) -> super::vals::Rpest {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpest::from_bits(val as u8)
            }
            #[doc = "RAM Parity Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_rpest(&mut self, val: super::vals::Rpest) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "SRAM ECC Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn reccst(&self) -> super::vals::Reccst {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Reccst::from_bits(val as u8)
            }
            #[doc = "SRAM ECC Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_reccst(&mut self, val: super::vals::Reccst) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "MPU Bus Slave Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn bussst(&self) -> super::vals::Bussst {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussst::from_bits(val as u8)
            }
            #[doc = "MPU Bus Slave Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_bussst(&mut self, val: super::vals::Bussst) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "MPU Bus Master Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn busmst(&self) -> super::vals::Busmst {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmst::from_bits(val as u8)
            }
            #[doc = "MPU Bus Master Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_busmst(&mut self, val: super::vals::Busmst) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag"]
            #[inline(always)]
            pub const fn spest(&self) -> super::vals::Spest {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Spest::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_spest(&mut self, val: super::vals::Spest) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub const fn reserved_13_15(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub fn set_reserved_13_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u16) & 0x07) << 13usize);
            }
        }
        impl Default for Nmisr {
            #[inline(always)]
            fn default() -> Nmisr {
                Nmisr(0)
            }
        }
        impl core::fmt::Debug for Nmisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmisr")
                    .field("iwdtst", &self.iwdtst())
                    .field("wdtst", &self.wdtst())
                    .field("lvd1st", &self.lvd1st())
                    .field("lvd2st", &self.lvd2st())
                    .field("reserved_4_5", &self.reserved_4_5())
                    .field("ostst", &self.ostst())
                    .field("nmist", &self.nmist())
                    .field("rpest", &self.rpest())
                    .field("reccst", &self.reccst())
                    .field("bussst", &self.bussst())
                    .field("busmst", &self.busmst())
                    .field("spest", &self.spest())
                    .field("reserved_13_15", &self.reserved_13_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmisr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmisr {{ iwdtst: {:?}, wdtst: {:?}, lvd1st: {:?}, lvd2st: {:?}, reserved_4_5: {=u8:?}, ostst: {:?}, nmist: {:?}, rpest: {:?}, reccst: {:?}, bussst: {:?}, busmst: {:?}, spest: {:?}, reserved_13_15: {=u8:?} }}" , self . iwdtst () , self . wdtst () , self . lvd1st () , self . lvd2st () , self . reserved_4_5 () , self . ostst () , self . nmist () , self . rpest () , self . reccst () , self . bussst () , self . busmst () , self . spest () , self . reserved_13_15 ())
            }
        }
        #[doc = "SYS Event Link Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Selsr0(pub u16);
        impl Selsr0 {
            #[doc = "SYS Event Link Select"]
            #[inline(always)]
            pub const fn sels(&self) -> super::vals::Sels {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Sels::from_bits(val as u8)
            }
            #[doc = "SYS Event Link Select"]
            #[inline(always)]
            pub fn set_sels(&mut self, val: super::vals::Sels) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u16) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Selsr0 {
            #[inline(always)]
            fn default() -> Selsr0 {
                Selsr0(0)
            }
        }
        impl core::fmt::Debug for Selsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Selsr0")
                    .field("sels", &self.sels())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Selsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Selsr0 {{ sels: {:?}, reserved_8_15: {=u8:?} }}",
                    self.sels(),
                    self.reserved_8_15()
                )
            }
        }
        #[doc = "Wake Up Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wupen(pub u32);
        impl Wupen {
            #[doc = "IRQ0 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn irqwupen0(&self) -> super::vals::Irqwupen0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Irqwupen0::from_bits(val as u8)
            }
            #[doc = "IRQ0 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_irqwupen0(&mut self, val: super::vals::Irqwupen0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "IRQ1 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn irqwupen1(&self) -> super::vals::Irqwupen1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Irqwupen1::from_bits(val as u8)
            }
            #[doc = "IRQ1 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_irqwupen1(&mut self, val: super::vals::Irqwupen1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "IRQ2 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn irqwupen2(&self) -> super::vals::Irqwupen2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Irqwupen2::from_bits(val as u8)
            }
            #[doc = "IRQ2 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_irqwupen2(&mut self, val: super::vals::Irqwupen2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "IRQ3 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn irqwupen3(&self) -> super::vals::Irqwupen3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Irqwupen3::from_bits(val as u8)
            }
            #[doc = "IRQ3 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_irqwupen3(&mut self, val: super::vals::Irqwupen3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "IRQ4 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn irqwupen4(&self) -> super::vals::Irqwupen4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Irqwupen4::from_bits(val as u8)
            }
            #[doc = "IRQ4 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_irqwupen4(&mut self, val: super::vals::Irqwupen4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "IRQ5 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn irqwupen5(&self) -> super::vals::Irqwupen5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Irqwupen5::from_bits(val as u8)
            }
            #[doc = "IRQ5 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_irqwupen5(&mut self, val: super::vals::Irqwupen5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "IRQ6 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn irqwupen6(&self) -> super::vals::Irqwupen6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Irqwupen6::from_bits(val as u8)
            }
            #[doc = "IRQ6 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_irqwupen6(&mut self, val: super::vals::Irqwupen6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ7 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn irqwupen7(&self) -> super::vals::Irqwupen7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Irqwupen7::from_bits(val as u8)
            }
            #[doc = "IRQ7 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_irqwupen7(&mut self, val: super::vals::Irqwupen7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "IWDT interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn iwdtwupen(&self) -> super::vals::Iwdtwupen {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Iwdtwupen::from_bits(val as u8)
            }
            #[doc = "IWDT interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_iwdtwupen(&mut self, val: super::vals::Iwdtwupen) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Key interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn keywupen(&self) -> super::vals::Keywupen {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Keywupen::from_bits(val as u8)
            }
            #[doc = "Key interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_keywupen(&mut self, val: super::vals::Keywupen) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "LVD1 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn lvd1wupen(&self) -> super::vals::Lvd1wupen {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Lvd1wupen::from_bits(val as u8)
            }
            #[doc = "LVD1 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_lvd1wupen(&mut self, val: super::vals::Lvd1wupen) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "LVD2 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn lvd2wupen(&self) -> super::vals::Lvd2wupen {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Lvd2wupen::from_bits(val as u8)
            }
            #[doc = "LVD2 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_lvd2wupen(&mut self, val: super::vals::Lvd2wupen) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_20_22(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_20_22(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "ACMPLP0 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn acmplp0wupen(&self) -> super::vals::Acmplp0wupen {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Acmplp0wupen::from_bits(val as u8)
            }
            #[doc = "ACMPLP0 interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_acmplp0wupen(&mut self, val: super::vals::Acmplp0wupen) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "RTC alarm interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn rtcalmwupen(&self) -> super::vals::Rtcalmwupen {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Rtcalmwupen::from_bits(val as u8)
            }
            #[doc = "RTC alarm interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_rtcalmwupen(&mut self, val: super::vals::Rtcalmwupen) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "RCT period interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn rtcprdwupen(&self) -> super::vals::Rtcprdwupen {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Rtcprdwupen::from_bits(val as u8)
            }
            #[doc = "RCT period interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_rtcprdwupen(&mut self, val: super::vals::Rtcprdwupen) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_26_26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_26_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "USBFS interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn usbfswupen(&self) -> super::vals::Usbfswupen {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Usbfswupen::from_bits(val as u8)
            }
            #[doc = "USBFS interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_usbfswupen(&mut self, val: super::vals::Usbfswupen) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "AGT1 underflow interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn agt1udwupen(&self) -> super::vals::Agt1udwupen {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Agt1udwupen::from_bits(val as u8)
            }
            #[doc = "AGT1 underflow interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_agt1udwupen(&mut self, val: super::vals::Agt1udwupen) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "AGT1 compare match A interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn agt1cawupen(&self) -> super::vals::Agt1cawupen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Agt1cawupen::from_bits(val as u8)
            }
            #[doc = "AGT1 compare match A interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_agt1cawupen(&mut self, val: super::vals::Agt1cawupen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "AGT1 compare match B interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn agt1cbwupen(&self) -> super::vals::Agt1cbwupen {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Agt1cbwupen::from_bits(val as u8)
            }
            #[doc = "AGT1 compare match B interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_agt1cbwupen(&mut self, val: super::vals::Agt1cbwupen) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "IIC0 address match interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub const fn iic0wupen(&self) -> super::vals::Iic0wupen {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Iic0wupen::from_bits(val as u8)
            }
            #[doc = "IIC0 address match interrupt S/W standby returns enable bit"]
            #[inline(always)]
            pub fn set_iic0wupen(&mut self, val: super::vals::Iic0wupen) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Wupen {
            #[inline(always)]
            fn default() -> Wupen {
                Wupen(0)
            }
        }
        impl core::fmt::Debug for Wupen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wupen")
                    .field("irqwupen0", &self.irqwupen0())
                    .field("irqwupen1", &self.irqwupen1())
                    .field("irqwupen2", &self.irqwupen2())
                    .field("irqwupen3", &self.irqwupen3())
                    .field("irqwupen4", &self.irqwupen4())
                    .field("irqwupen5", &self.irqwupen5())
                    .field("irqwupen6", &self.irqwupen6())
                    .field("irqwupen7", &self.irqwupen7())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .field("iwdtwupen", &self.iwdtwupen())
                    .field("keywupen", &self.keywupen())
                    .field("lvd1wupen", &self.lvd1wupen())
                    .field("lvd2wupen", &self.lvd2wupen())
                    .field("reserved_20_22", &self.reserved_20_22())
                    .field("acmplp0wupen", &self.acmplp0wupen())
                    .field("rtcalmwupen", &self.rtcalmwupen())
                    .field("rtcprdwupen", &self.rtcprdwupen())
                    .field("reserved_26_26", &self.reserved_26_26())
                    .field("usbfswupen", &self.usbfswupen())
                    .field("agt1udwupen", &self.agt1udwupen())
                    .field("agt1cawupen", &self.agt1cawupen())
                    .field("agt1cbwupen", &self.agt1cbwupen())
                    .field("iic0wupen", &self.iic0wupen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wupen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Wupen {{ irqwupen0: {:?}, irqwupen1: {:?}, irqwupen2: {:?}, irqwupen3: {:?}, irqwupen4: {:?}, irqwupen5: {:?}, irqwupen6: {:?}, irqwupen7: {:?}, reserved_8_15: {=u8:?}, iwdtwupen: {:?}, keywupen: {:?}, lvd1wupen: {:?}, lvd2wupen: {:?}, reserved_20_22: {=u8:?}, acmplp0wupen: {:?}, rtcalmwupen: {:?}, rtcprdwupen: {:?}, reserved_26_26: {=bool:?}, usbfswupen: {:?}, agt1udwupen: {:?}, agt1cawupen: {:?}, agt1cbwupen: {:?}, iic0wupen: {:?} }}" , self . irqwupen0 () , self . irqwupen1 () , self . irqwupen2 () , self . irqwupen3 () , self . irqwupen4 () , self . irqwupen5 () , self . irqwupen6 () , self . irqwupen7 () , self . reserved_8_15 () , self . iwdtwupen () , self . keywupen () , self . lvd1wupen () , self . lvd2wupen () , self . reserved_20_22 () , self . acmplp0wupen () , self . rtcalmwupen () , self . rtcprdwupen () , self . reserved_26_26 () , self . usbfswupen () , self . agt1udwupen () , self . agt1cawupen () , self . agt1cbwupen () , self . iic0wupen ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Acmplp0wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Acmplp0wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Acmplp0wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Acmplp0wupen {
            #[inline(always)]
            fn from(val: u8) -> Acmplp0wupen {
                Acmplp0wupen::from_bits(val)
            }
        }
        impl From<Acmplp0wupen> for u8 {
            #[inline(always)]
            fn from(val: Acmplp0wupen) -> u8 {
                Acmplp0wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt1cawupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt1cawupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt1cawupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt1cawupen {
            #[inline(always)]
            fn from(val: u8) -> Agt1cawupen {
                Agt1cawupen::from_bits(val)
            }
        }
        impl From<Agt1cawupen> for u8 {
            #[inline(always)]
            fn from(val: Agt1cawupen) -> u8 {
                Agt1cawupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt1cbwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt1cbwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt1cbwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt1cbwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt1cbwupen {
                Agt1cbwupen::from_bits(val)
            }
        }
        impl From<Agt1cbwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt1cbwupen) -> u8 {
                Agt1cbwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt1udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt1udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt1udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt1udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt1udwupen {
                Agt1udwupen::from_bits(val)
            }
        }
        impl From<Agt1udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt1udwupen) -> u8 {
                Agt1udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmclr {
            #[inline(always)]
            fn from(val: u8) -> Busmclr {
                Busmclr::from_bits(val)
            }
        }
        impl From<Busmclr> for u8 {
            #[inline(always)]
            fn from(val: Busmclr) -> u8 {
                Busmclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmen {
            #[inline(always)]
            fn from(val: u8) -> Busmen {
                Busmen::from_bits(val)
            }
        }
        impl From<Busmen> for u8 {
            #[inline(always)]
            fn from(val: Busmen) -> u8 {
                Busmen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmst {
            #[inline(always)]
            fn from(val: u8) -> Busmst {
                Busmst::from_bits(val)
            }
        }
        impl From<Busmst> for u8 {
            #[inline(always)]
            fn from(val: Busmst) -> u8 {
                Busmst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussclr {
            #[inline(always)]
            fn from(val: u8) -> Bussclr {
                Bussclr::from_bits(val)
            }
        }
        impl From<Bussclr> for u8 {
            #[inline(always)]
            fn from(val: Bussclr) -> u8 {
                Bussclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussen {
            #[inline(always)]
            fn from(val: u8) -> Bussen {
                Bussen::from_bits(val)
            }
        }
        impl From<Bussen> for u8 {
            #[inline(always)]
            fn from(val: Bussen) -> u8 {
                Bussen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussst {
            #[inline(always)]
            fn from(val: u8) -> Bussst {
                Bussst::from_bits(val)
            }
        }
        impl From<Bussst> for u8 {
            #[inline(always)]
            fn from(val: Bussst) -> u8 {
                Bussst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtce {
            #[inline(always)]
            fn from(val: u8) -> Dtce {
                Dtce::from_bits(val)
            }
        }
        impl From<Dtce> for u8 {
            #[inline(always)]
            fn from(val: Dtce) -> u8 {
                Dtce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fclksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Fclksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fclksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fclksel {
            #[inline(always)]
            fn from(val: u8) -> Fclksel {
                Fclksel::from_bits(val)
            }
        }
        impl From<Fclksel> for u8 {
            #[inline(always)]
            fn from(val: Fclksel) -> u8 {
                Fclksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Flten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flten {
            #[inline(always)]
            fn from(val: u8) -> Flten {
                Flten::from_bits(val)
            }
        }
        impl From<Flten> for u8 {
            #[inline(always)]
            fn from(val: Flten) -> u8 {
                Flten::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Iels(u8);
        impl Iels {}
        impl Iels {
            pub const fn from_bits(val: u8) -> Iels {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Iels {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iels {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Iels {
            #[inline(always)]
            fn from(val: u8) -> Iels {
                Iels::from_bits(val)
            }
        }
        impl From<Iels> for u8 {
            #[inline(always)]
            fn from(val: Iels) -> u8 {
                Iels::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iic0wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iic0wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iic0wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iic0wupen {
            #[inline(always)]
            fn from(val: u8) -> Iic0wupen {
                Iic0wupen::from_bits(val)
            }
        }
        impl From<Iic0wupen> for u8 {
            #[inline(always)]
            fn from(val: Iic0wupen) -> u8 {
                Iic0wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ir {
            #[inline(always)]
            fn from(val: u8) -> Ir {
                Ir::from_bits(val)
            }
        }
        impl From<Ir> for u8 {
            #[inline(always)]
            fn from(val: Ir) -> u8 {
                Ir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Irqmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqmd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqmd {
            #[inline(always)]
            fn from(val: u8) -> Irqmd {
                Irqmd::from_bits(val)
            }
        }
        impl From<Irqmd> for u8 {
            #[inline(always)]
            fn from(val: Irqmd) -> u8 {
                Irqmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqwupen0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irqwupen0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqwupen0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqwupen0 {
            #[inline(always)]
            fn from(val: u8) -> Irqwupen0 {
                Irqwupen0::from_bits(val)
            }
        }
        impl From<Irqwupen0> for u8 {
            #[inline(always)]
            fn from(val: Irqwupen0) -> u8 {
                Irqwupen0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqwupen1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irqwupen1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqwupen1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqwupen1 {
            #[inline(always)]
            fn from(val: u8) -> Irqwupen1 {
                Irqwupen1::from_bits(val)
            }
        }
        impl From<Irqwupen1> for u8 {
            #[inline(always)]
            fn from(val: Irqwupen1) -> u8 {
                Irqwupen1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqwupen2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irqwupen2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqwupen2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqwupen2 {
            #[inline(always)]
            fn from(val: u8) -> Irqwupen2 {
                Irqwupen2::from_bits(val)
            }
        }
        impl From<Irqwupen2> for u8 {
            #[inline(always)]
            fn from(val: Irqwupen2) -> u8 {
                Irqwupen2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqwupen3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irqwupen3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqwupen3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqwupen3 {
            #[inline(always)]
            fn from(val: u8) -> Irqwupen3 {
                Irqwupen3::from_bits(val)
            }
        }
        impl From<Irqwupen3> for u8 {
            #[inline(always)]
            fn from(val: Irqwupen3) -> u8 {
                Irqwupen3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqwupen4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irqwupen4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqwupen4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqwupen4 {
            #[inline(always)]
            fn from(val: u8) -> Irqwupen4 {
                Irqwupen4::from_bits(val)
            }
        }
        impl From<Irqwupen4> for u8 {
            #[inline(always)]
            fn from(val: Irqwupen4) -> u8 {
                Irqwupen4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqwupen5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irqwupen5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqwupen5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqwupen5 {
            #[inline(always)]
            fn from(val: u8) -> Irqwupen5 {
                Irqwupen5::from_bits(val)
            }
        }
        impl From<Irqwupen5> for u8 {
            #[inline(always)]
            fn from(val: Irqwupen5) -> u8 {
                Irqwupen5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqwupen6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irqwupen6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqwupen6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqwupen6 {
            #[inline(always)]
            fn from(val: u8) -> Irqwupen6 {
                Irqwupen6::from_bits(val)
            }
        }
        impl From<Irqwupen6> for u8 {
            #[inline(always)]
            fn from(val: Irqwupen6) -> u8 {
                Irqwupen6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqwupen7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irqwupen7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqwupen7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqwupen7 {
            #[inline(always)]
            fn from(val: u8) -> Irqwupen7 {
                Irqwupen7::from_bits(val)
            }
        }
        impl From<Irqwupen7> for u8 {
            #[inline(always)]
            fn from(val: Irqwupen7) -> u8 {
                Irqwupen7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtclr {
            #[inline(always)]
            fn from(val: u8) -> Iwdtclr {
                Iwdtclr::from_bits(val)
            }
        }
        impl From<Iwdtclr> for u8 {
            #[inline(always)]
            fn from(val: Iwdtclr) -> u8 {
                Iwdtclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdten {
            #[inline(always)]
            fn from(val: u8) -> Iwdten {
                Iwdten::from_bits(val)
            }
        }
        impl From<Iwdten> for u8 {
            #[inline(always)]
            fn from(val: Iwdten) -> u8 {
                Iwdten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtst {
            #[inline(always)]
            fn from(val: u8) -> Iwdtst {
                Iwdtst::from_bits(val)
            }
        }
        impl From<Iwdtst> for u8 {
            #[inline(always)]
            fn from(val: Iwdtst) -> u8 {
                Iwdtst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtwupen {
            #[inline(always)]
            fn from(val: u8) -> Iwdtwupen {
                Iwdtwupen::from_bits(val)
            }
        }
        impl From<Iwdtwupen> for u8 {
            #[inline(always)]
            fn from(val: Iwdtwupen) -> u8 {
                Iwdtwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Keywupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Keywupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Keywupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Keywupen {
            #[inline(always)]
            fn from(val: u8) -> Keywupen {
                Keywupen::from_bits(val)
            }
        }
        impl From<Keywupen> for u8 {
            #[inline(always)]
            fn from(val: Keywupen) -> u8 {
                Keywupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1clr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1clr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1clr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1clr {
            #[inline(always)]
            fn from(val: u8) -> Lvd1clr {
                Lvd1clr::from_bits(val)
            }
        }
        impl From<Lvd1clr> for u8 {
            #[inline(always)]
            fn from(val: Lvd1clr) -> u8 {
                Lvd1clr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1en {
            #[inline(always)]
            fn from(val: u8) -> Lvd1en {
                Lvd1en::from_bits(val)
            }
        }
        impl From<Lvd1en> for u8 {
            #[inline(always)]
            fn from(val: Lvd1en) -> u8 {
                Lvd1en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1st {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1st {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1st {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1st {
            #[inline(always)]
            fn from(val: u8) -> Lvd1st {
                Lvd1st::from_bits(val)
            }
        }
        impl From<Lvd1st> for u8 {
            #[inline(always)]
            fn from(val: Lvd1st) -> u8 {
                Lvd1st::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1wupen {
            #[inline(always)]
            fn from(val: u8) -> Lvd1wupen {
                Lvd1wupen::from_bits(val)
            }
        }
        impl From<Lvd1wupen> for u8 {
            #[inline(always)]
            fn from(val: Lvd1wupen) -> u8 {
                Lvd1wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2clr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2clr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2clr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2clr {
            #[inline(always)]
            fn from(val: u8) -> Lvd2clr {
                Lvd2clr::from_bits(val)
            }
        }
        impl From<Lvd2clr> for u8 {
            #[inline(always)]
            fn from(val: Lvd2clr) -> u8 {
                Lvd2clr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2en {
            #[inline(always)]
            fn from(val: u8) -> Lvd2en {
                Lvd2en::from_bits(val)
            }
        }
        impl From<Lvd2en> for u8 {
            #[inline(always)]
            fn from(val: Lvd2en) -> u8 {
                Lvd2en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2st {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2st {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2st {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2st {
            #[inline(always)]
            fn from(val: u8) -> Lvd2st {
                Lvd2st::from_bits(val)
            }
        }
        impl From<Lvd2st> for u8 {
            #[inline(always)]
            fn from(val: Lvd2st) -> u8 {
                Lvd2st::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2wupen {
            #[inline(always)]
            fn from(val: u8) -> Lvd2wupen {
                Lvd2wupen::from_bits(val)
            }
        }
        impl From<Lvd2wupen> for u8 {
            #[inline(always)]
            fn from(val: Lvd2wupen) -> u8 {
                Lvd2wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfclksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfclksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfclksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfclksel {
            #[inline(always)]
            fn from(val: u8) -> Nfclksel {
                Nfclksel::from_bits(val)
            }
        }
        impl From<Nfclksel> for u8 {
            #[inline(always)]
            fn from(val: Nfclksel) -> u8 {
                Nfclksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nflten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nflten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nflten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nflten {
            #[inline(always)]
            fn from(val: u8) -> Nflten {
                Nflten::from_bits(val)
            }
        }
        impl From<Nflten> for u8 {
            #[inline(always)]
            fn from(val: Nflten) -> u8 {
                Nflten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmiclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmiclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmiclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmiclr {
            #[inline(always)]
            fn from(val: u8) -> Nmiclr {
                Nmiclr::from_bits(val)
            }
        }
        impl From<Nmiclr> for u8 {
            #[inline(always)]
            fn from(val: Nmiclr) -> u8 {
                Nmiclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmien {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmien {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmien {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmien {
            #[inline(always)]
            fn from(val: u8) -> Nmien {
                Nmien::from_bits(val)
            }
        }
        impl From<Nmien> for u8 {
            #[inline(always)]
            fn from(val: Nmien) -> u8 {
                Nmien::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmimd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmimd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmimd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmimd {
            #[inline(always)]
            fn from(val: u8) -> Nmimd {
                Nmimd::from_bits(val)
            }
        }
        impl From<Nmimd> for u8 {
            #[inline(always)]
            fn from(val: Nmimd) -> u8 {
                Nmimd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmist {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmist {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmist {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmist {
            #[inline(always)]
            fn from(val: u8) -> Nmist {
                Nmist::from_bits(val)
            }
        }
        impl From<Nmist> for u8 {
            #[inline(always)]
            fn from(val: Nmist) -> u8 {
                Nmist::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostclr {
            #[inline(always)]
            fn from(val: u8) -> Ostclr {
                Ostclr::from_bits(val)
            }
        }
        impl From<Ostclr> for u8 {
            #[inline(always)]
            fn from(val: Ostclr) -> u8 {
                Ostclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Osten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Osten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Osten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Osten {
            #[inline(always)]
            fn from(val: u8) -> Osten {
                Osten::from_bits(val)
            }
        }
        impl From<Osten> for u8 {
            #[inline(always)]
            fn from(val: Osten) -> u8 {
                Osten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostst {
            #[inline(always)]
            fn from(val: u8) -> Ostst {
                Ostst::from_bits(val)
            }
        }
        impl From<Ostst> for u8 {
            #[inline(always)]
            fn from(val: Ostst) -> u8 {
                Ostst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reccclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Reccclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reccclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reccclr {
            #[inline(always)]
            fn from(val: u8) -> Reccclr {
                Reccclr::from_bits(val)
            }
        }
        impl From<Reccclr> for u8 {
            #[inline(always)]
            fn from(val: Reccclr) -> u8 {
                Reccclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reccen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Reccen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reccen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reccen {
            #[inline(always)]
            fn from(val: u8) -> Reccen {
                Reccen::from_bits(val)
            }
        }
        impl From<Reccen> for u8 {
            #[inline(always)]
            fn from(val: Reccen) -> u8 {
                Reccen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reccst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Reccst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reccst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reccst {
            #[inline(always)]
            fn from(val: u8) -> Reccst {
                Reccst::from_bits(val)
            }
        }
        impl From<Reccst> for u8 {
            #[inline(always)]
            fn from(val: Reccst) -> u8 {
                Reccst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpeclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpeclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpeclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpeclr {
            #[inline(always)]
            fn from(val: u8) -> Rpeclr {
                Rpeclr::from_bits(val)
            }
        }
        impl From<Rpeclr> for u8 {
            #[inline(always)]
            fn from(val: Rpeclr) -> u8 {
                Rpeclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpeen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpeen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpeen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpeen {
            #[inline(always)]
            fn from(val: u8) -> Rpeen {
                Rpeen::from_bits(val)
            }
        }
        impl From<Rpeen> for u8 {
            #[inline(always)]
            fn from(val: Rpeen) -> u8 {
                Rpeen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpest {
            #[inline(always)]
            fn from(val: u8) -> Rpest {
                Rpest::from_bits(val)
            }
        }
        impl From<Rpest> for u8 {
            #[inline(always)]
            fn from(val: Rpest) -> u8 {
                Rpest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcalmwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcalmwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcalmwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcalmwupen {
            #[inline(always)]
            fn from(val: u8) -> Rtcalmwupen {
                Rtcalmwupen::from_bits(val)
            }
        }
        impl From<Rtcalmwupen> for u8 {
            #[inline(always)]
            fn from(val: Rtcalmwupen) -> u8 {
                Rtcalmwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcprdwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcprdwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcprdwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcprdwupen {
            #[inline(always)]
            fn from(val: u8) -> Rtcprdwupen {
                Rtcprdwupen::from_bits(val)
            }
        }
        impl From<Rtcprdwupen> for u8 {
            #[inline(always)]
            fn from(val: Rtcprdwupen) -> u8 {
                Rtcprdwupen::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Sels(u8);
        impl Sels {}
        impl Sels {
            pub const fn from_bits(val: u8) -> Sels {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Sels {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sels {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Sels {
            #[inline(always)]
            fn from(val: u8) -> Sels {
                Sels::from_bits(val)
            }
        }
        impl From<Sels> for u8 {
            #[inline(always)]
            fn from(val: Sels) -> u8 {
                Sels::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Speclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Speclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Speclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Speclr {
            #[inline(always)]
            fn from(val: u8) -> Speclr {
                Speclr::from_bits(val)
            }
        }
        impl From<Speclr> for u8 {
            #[inline(always)]
            fn from(val: Speclr) -> u8 {
                Speclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Speen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Speen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Speen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Speen {
            #[inline(always)]
            fn from(val: u8) -> Speen {
                Speen::from_bits(val)
            }
        }
        impl From<Speen> for u8 {
            #[inline(always)]
            fn from(val: Speen) -> u8 {
                Speen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spest {
            #[inline(always)]
            fn from(val: u8) -> Spest {
                Spest::from_bits(val)
            }
        }
        impl From<Spest> for u8 {
            #[inline(always)]
            fn from(val: Spest) -> u8 {
                Spest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usbfswupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usbfswupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usbfswupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usbfswupen {
            #[inline(always)]
            fn from(val: u8) -> Usbfswupen {
                Usbfswupen::from_bits(val)
            }
        }
        impl From<Usbfswupen> for u8 {
            #[inline(always)]
            fn from(val: Usbfswupen) -> u8 {
                Usbfswupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtclr {
            #[inline(always)]
            fn from(val: u8) -> Wdtclr {
                Wdtclr::from_bits(val)
            }
        }
        impl From<Wdtclr> for u8 {
            #[inline(always)]
            fn from(val: Wdtclr) -> u8 {
                Wdtclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdten {
            #[inline(always)]
            fn from(val: u8) -> Wdten {
                Wdten::from_bits(val)
            }
        }
        impl From<Wdten> for u8 {
            #[inline(always)]
            fn from(val: Wdten) -> u8 {
                Wdten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtst {
            #[inline(always)]
            fn from(val: u8) -> Wdtst {
                Wdtst::from_bits(val)
            }
        }
        impl From<Wdtst> for u8 {
            #[inline(always)]
            fn from(val: Wdtst) -> u8 {
                Wdtst::to_bits(val)
            }
        }
    }
}
pub mod iic0 {
    #[doc = "Inter,Integrated Circuit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iic0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Iic0 {}
    unsafe impl Sync for Iic0 {}
    impl Iic0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "I2C Bus Control Register 1"]
        #[inline(always)]
        pub const fn iccr1(self) -> crate::common::Reg<regs::Iccr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "I2C Bus Control Register 2"]
        #[inline(always)]
        pub const fn iccr2(self) -> crate::common::Reg<regs::Iccr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "I2C Bus Mode Register 1"]
        #[inline(always)]
        pub const fn icmr1(self) -> crate::common::Reg<regs::Icmr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "I2C Bus Mode Register 2"]
        #[inline(always)]
        pub const fn icmr2(self) -> crate::common::Reg<regs::Icmr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "I2C Bus Mode Register 3"]
        #[inline(always)]
        pub const fn icmr3(self) -> crate::common::Reg<regs::Icmr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "I2C Bus Function Enable Register"]
        #[inline(always)]
        pub const fn icfer(self) -> crate::common::Reg<regs::Icfer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "I2C Bus Status Enable Register"]
        #[inline(always)]
        pub const fn icser(self) -> crate::common::Reg<regs::Icser, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "I2C Bus Interrupt Enable Register"]
        #[inline(always)]
        pub const fn icier(self) -> crate::common::Reg<regs::Icier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "I2C Bus Status Register 1"]
        #[inline(always)]
        pub const fn icsr1(self) -> crate::common::Reg<regs::Icsr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "I2C Bus Status Register 2"]
        #[inline(always)]
        pub const fn icsr2(self) -> crate::common::Reg<regs::Icsr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "Slave Address Register L%s"]
        #[inline(always)]
        pub const fn sarl(self, n: usize) -> crate::common::Reg<regs::Sarl, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize + n * 2usize) as _) }
        }
        #[doc = "Slave Address Register U%s"]
        #[inline(always)]
        pub const fn saru(self, n: usize) -> crate::common::Reg<regs::Saru, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize + n * 2usize) as _) }
        }
        #[doc = "I2C Bus Bit Rate Low,Level Register"]
        #[inline(always)]
        pub const fn icbrl(self) -> crate::common::Reg<regs::Icbrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "I2C Bus Bit Rate High,Level Register"]
        #[inline(always)]
        pub const fn icbrh(self) -> crate::common::Reg<regs::Icbrh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
        #[doc = "I2C Bus Transmit Data Register"]
        #[inline(always)]
        pub const fn icdrt(self) -> crate::common::Reg<regs::Icdrt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "I2C Bus Receive Data Register"]
        #[inline(always)]
        pub const fn icdrr(self) -> crate::common::Reg<regs::Icdrr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13usize) as _) }
        }
        #[doc = "I2C Bus Wake Up Unit Register"]
        #[inline(always)]
        pub const fn icwur(self) -> crate::common::Reg<regs::Icwur, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "Reserved"]
        #[inline(always)]
        pub const fn icwur2(self) -> crate::common::Reg<regs::Icwur2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x17usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "I2C Bus Bit Rate High,Level Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icbrh(pub u8);
        impl Icbrh {
            #[doc = "Bit Rate High,Level Period(High,level period of SCL clock)"]
            #[inline(always)]
            pub const fn brh(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Bit Rate High,Level Period(High,level period of SCL clock)"]
            #[inline(always)]
            pub fn set_brh(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 111. The write value should be 111."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 111. The write value should be 111."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Icbrh {
            #[inline(always)]
            fn default() -> Icbrh {
                Icbrh(0)
            }
        }
        impl core::fmt::Debug for Icbrh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icbrh")
                    .field("brh", &self.brh())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icbrh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icbrh {{ brh: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.brh(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "I2C Bus Bit Rate Low,Level Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icbrl(pub u8);
        impl Icbrl {
            #[doc = "Bit Rate Low,Level Period(Low,level period of SCL clock)"]
            #[inline(always)]
            pub const fn brl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Bit Rate Low,Level Period(Low,level period of SCL clock)"]
            #[inline(always)]
            pub fn set_brl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 111. The write value should be 111."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 111. The write value should be 111."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Icbrl {
            #[inline(always)]
            fn default() -> Icbrl {
                Icbrl(0)
            }
        }
        impl core::fmt::Debug for Icbrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icbrl")
                    .field("brl", &self.brl())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icbrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icbrl {{ brl: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.brl(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "I2C Bus Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iccr1(pub u8);
        impl Iccr1 {
            #[doc = "SDA Line Monitor"]
            #[inline(always)]
            pub const fn sdai(&self) -> super::vals::Sdai {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sdai::from_bits(val as u8)
            }
            #[doc = "SDA Line Monitor"]
            #[inline(always)]
            pub fn set_sdai(&mut self, val: super::vals::Sdai) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SCL Line Monitor"]
            #[inline(always)]
            pub const fn scli(&self) -> super::vals::Scli {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Scli::from_bits(val as u8)
            }
            #[doc = "SCL Line Monitor"]
            #[inline(always)]
            pub fn set_scli(&mut self, val: super::vals::Scli) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "SDA Output Control/Monitor"]
            #[inline(always)]
            pub const fn sdao(&self) -> super::vals::Sdao {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sdao::from_bits(val as u8)
            }
            #[doc = "SDA Output Control/Monitor"]
            #[inline(always)]
            pub fn set_sdao(&mut self, val: super::vals::Sdao) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "SCL Output Control/Monitor"]
            #[inline(always)]
            pub const fn sclo(&self) -> super::vals::Sclo {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sclo::from_bits(val as u8)
            }
            #[doc = "SCL Output Control/Monitor"]
            #[inline(always)]
            pub fn set_sclo(&mut self, val: super::vals::Sclo) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SCLO/SDAO Write Protect"]
            #[inline(always)]
            pub const fn sowp(&self) -> super::vals::Sowp {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sowp::from_bits(val as u8)
            }
            #[doc = "SCLO/SDAO Write Protect"]
            #[inline(always)]
            pub fn set_sowp(&mut self, val: super::vals::Sowp) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Extra SCL Clock Cycle Output"]
            #[inline(always)]
            pub const fn clo(&self) -> super::vals::Clo {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Clo::from_bits(val as u8)
            }
            #[doc = "Extra SCL Clock Cycle Output"]
            #[inline(always)]
            pub fn set_clo(&mut self, val: super::vals::Clo) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang,up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information)."]
            #[inline(always)]
            pub const fn iicrst(&self) -> super::vals::Iicrst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Iicrst::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang,up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information)."]
            #[inline(always)]
            pub fn set_iicrst(&mut self, val: super::vals::Iicrst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "I2C Bus Interface Enable"]
            #[inline(always)]
            pub const fn ice(&self) -> super::vals::Ice {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ice::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface Enable"]
            #[inline(always)]
            pub fn set_ice(&mut self, val: super::vals::Ice) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iccr1 {
            #[inline(always)]
            fn default() -> Iccr1 {
                Iccr1(0)
            }
        }
        impl core::fmt::Debug for Iccr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iccr1")
                    .field("sdai", &self.sdai())
                    .field("scli", &self.scli())
                    .field("sdao", &self.sdao())
                    .field("sclo", &self.sclo())
                    .field("sowp", &self.sowp())
                    .field("clo", &self.clo())
                    .field("iicrst", &self.iicrst())
                    .field("ice", &self.ice())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iccr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Iccr1 {{ sdai: {:?}, scli: {:?}, sdao: {:?}, sclo: {:?}, sowp: {:?}, clo: {:?}, iicrst: {:?}, ice: {:?} }}" , self . sdai () , self . scli () , self . sdao () , self . sclo () , self . sowp () , self . clo () , self . iicrst () , self . ice ())
            }
        }
        #[doc = "I2C Bus Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iccr2(pub u8);
        impl Iccr2 {
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_0_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_0_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state)."]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::St {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::St::from_bits(val as u8)
            }
            #[doc = "Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state)."]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::St) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition."]
            #[inline(always)]
            pub const fn rs(&self) -> super::vals::Rs {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Rs::from_bits(val as u8)
            }
            #[doc = "Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition."]
            #[inline(always)]
            pub fn set_rs(&mut self, val: super::vals::Rs) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued."]
            #[inline(always)]
            pub const fn sp(&self) -> super::vals::Sp {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sp::from_bits(val as u8)
            }
            #[doc = "Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued."]
            #[inline(always)]
            pub fn set_sp(&mut self, val: super::vals::Sp) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_4_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_4_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit/Receive Mode"]
            #[inline(always)]
            pub const fn trs(&self) -> super::vals::Trs {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Trs::from_bits(val as u8)
            }
            #[doc = "Transmit/Receive Mode"]
            #[inline(always)]
            pub fn set_trs(&mut self, val: super::vals::Trs) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Master/Slave Mode"]
            #[inline(always)]
            pub const fn mst(&self) -> super::vals::Mst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mst::from_bits(val as u8)
            }
            #[doc = "Master/Slave Mode"]
            #[inline(always)]
            pub fn set_mst(&mut self, val: super::vals::Mst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Bus Busy Detection Flag"]
            #[inline(always)]
            pub const fn bbsy(&self) -> super::vals::Bbsy {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bbsy::from_bits(val as u8)
            }
            #[doc = "Bus Busy Detection Flag"]
            #[inline(always)]
            pub fn set_bbsy(&mut self, val: super::vals::Bbsy) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iccr2 {
            #[inline(always)]
            fn default() -> Iccr2 {
                Iccr2(0)
            }
        }
        impl core::fmt::Debug for Iccr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iccr2")
                    .field("reserved_0_0", &self.reserved_0_0())
                    .field("st", &self.st())
                    .field("rs", &self.rs())
                    .field("sp", &self.sp())
                    .field("reserved_4_4", &self.reserved_4_4())
                    .field("trs", &self.trs())
                    .field("mst", &self.mst())
                    .field("bbsy", &self.bbsy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iccr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Iccr2 {{ reserved_0_0: {=bool:?}, st: {:?}, rs: {:?}, sp: {:?}, reserved_4_4: {=bool:?}, trs: {:?}, mst: {:?}, bbsy: {:?} }}" , self . reserved_0_0 () , self . st () , self . rs () , self . sp () , self . reserved_4_4 () , self . trs () , self . mst () , self . bbsy ())
            }
        }
        #[doc = "I2C Bus Receive Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icdrr(pub u8);
        impl Icdrr {
            #[doc = "8-bit register that stores the received data"]
            #[inline(always)]
            pub const fn icdrr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit register that stores the received data"]
            #[inline(always)]
            pub fn set_icdrr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Icdrr {
            #[inline(always)]
            fn default() -> Icdrr {
                Icdrr(0)
            }
        }
        impl core::fmt::Debug for Icdrr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icdrr")
                    .field("icdrr", &self.icdrr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icdrr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Icdrr {{ icdrr: {=u8:?} }}", self.icdrr())
            }
        }
        #[doc = "I2C Bus Transmit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icdrt(pub u8);
        impl Icdrt {
            #[doc = "8-bit read,write register that stores transmit data."]
            #[inline(always)]
            pub const fn icdrt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit read,write register that stores transmit data."]
            #[inline(always)]
            pub fn set_icdrt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Icdrt {
            #[inline(always)]
            fn default() -> Icdrt {
                Icdrt(0)
            }
        }
        impl core::fmt::Debug for Icdrt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icdrt")
                    .field("icdrt", &self.icdrt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icdrt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Icdrt {{ icdrt: {=u8:?} }}", self.icdrt())
            }
        }
        #[doc = "I2C Bus Function Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icfer(pub u8);
        impl Icfer {
            #[doc = "Timeout Function Enable"]
            #[inline(always)]
            pub const fn tmoe(&self) -> super::vals::Tmoe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmoe::from_bits(val as u8)
            }
            #[doc = "Timeout Function Enable"]
            #[inline(always)]
            pub fn set_tmoe(&mut self, val: super::vals::Tmoe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Master Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn male(&self) -> super::vals::Male {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Male::from_bits(val as u8)
            }
            #[doc = "Master Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_male(&mut self, val: super::vals::Male) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "NACK Transmission Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn nale(&self) -> super::vals::Nale {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Nale::from_bits(val as u8)
            }
            #[doc = "NACK Transmission Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_nale(&mut self, val: super::vals::Nale) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Slave Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn sale(&self) -> super::vals::Sale {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sale::from_bits(val as u8)
            }
            #[doc = "Slave Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_sale(&mut self, val: super::vals::Sale) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "NACK Reception Transfer Suspension Enable"]
            #[inline(always)]
            pub const fn nacke(&self) -> super::vals::Nacke {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nacke::from_bits(val as u8)
            }
            #[doc = "NACK Reception Transfer Suspension Enable"]
            #[inline(always)]
            pub fn set_nacke(&mut self, val: super::vals::Nacke) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Digital Noise Filter Circuit Enable"]
            #[inline(always)]
            pub const fn nfe(&self) -> super::vals::Nfe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Nfe::from_bits(val as u8)
            }
            #[doc = "Digital Noise Filter Circuit Enable"]
            #[inline(always)]
            pub fn set_nfe(&mut self, val: super::vals::Nfe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SCL Synchronous Circuit Enable"]
            #[inline(always)]
            pub const fn scle(&self) -> super::vals::Scle {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Scle::from_bits(val as u8)
            }
            #[doc = "SCL Synchronous Circuit Enable"]
            #[inline(always)]
            pub fn set_scle(&mut self, val: super::vals::Scle) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icfer {
            #[inline(always)]
            fn default() -> Icfer {
                Icfer(0)
            }
        }
        impl core::fmt::Debug for Icfer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icfer")
                    .field("tmoe", &self.tmoe())
                    .field("male", &self.male())
                    .field("nale", &self.nale())
                    .field("sale", &self.sale())
                    .field("nacke", &self.nacke())
                    .field("nfe", &self.nfe())
                    .field("scle", &self.scle())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icfer {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icfer {{ tmoe: {:?}, male: {:?}, nale: {:?}, sale: {:?}, nacke: {:?}, nfe: {:?}, scle: {:?}, reserved_7_7: {=bool:?} }}" , self . tmoe () , self . male () , self . nale () , self . sale () , self . nacke () , self . nfe () , self . scle () , self . reserved_7_7 ())
            }
        }
        #[doc = "I2C Bus Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icier(pub u8);
        impl Icier {
            #[doc = "Timeout Interrupt Request Enable"]
            #[inline(always)]
            pub const fn tmoie(&self) -> super::vals::Tmoie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmoie::from_bits(val as u8)
            }
            #[doc = "Timeout Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_tmoie(&mut self, val: super::vals::Tmoie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Arbitration,Lost Interrupt Request Enable"]
            #[inline(always)]
            pub const fn alie(&self) -> super::vals::Alie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Alie::from_bits(val as u8)
            }
            #[doc = "Arbitration,Lost Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_alie(&mut self, val: super::vals::Alie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Start Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub const fn stie(&self) -> super::vals::Stie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Stie::from_bits(val as u8)
            }
            #[doc = "Start Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_stie(&mut self, val: super::vals::Stie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub const fn spie(&self) -> super::vals::Spie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Spie::from_bits(val as u8)
            }
            #[doc = "Stop Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_spie(&mut self, val: super::vals::Spie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "NACK Reception Interrupt Request Enable"]
            #[inline(always)]
            pub const fn nakie(&self) -> super::vals::Nakie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nakie::from_bits(val as u8)
            }
            #[doc = "NACK Reception Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_nakie(&mut self, val: super::vals::Nakie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Receive Data Full Interrupt Request Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::Rie {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rie::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::Rie) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmit End Interrupt Request Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> super::vals::Teie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Teie::from_bits(val as u8)
            }
            #[doc = "Transmit End Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: super::vals::Teie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Interrupt Request Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::Tie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tie::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::Tie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icier {
            #[inline(always)]
            fn default() -> Icier {
                Icier(0)
            }
        }
        impl core::fmt::Debug for Icier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icier")
                    .field("tmoie", &self.tmoie())
                    .field("alie", &self.alie())
                    .field("stie", &self.stie())
                    .field("spie", &self.spie())
                    .field("nakie", &self.nakie())
                    .field("rie", &self.rie())
                    .field("teie", &self.teie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icier {{ tmoie: {:?}, alie: {:?}, stie: {:?}, spie: {:?}, nakie: {:?}, rie: {:?}, teie: {:?}, tie: {:?} }}" , self . tmoie () , self . alie () , self . stie () , self . spie () , self . nakie () , self . rie () , self . teie () , self . tie ())
            }
        }
        #[doc = "I2C Bus Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icmr1(pub u8);
        impl Icmr1 {
            #[doc = "Bit Counter"]
            #[inline(always)]
            pub const fn bc(&self) -> super::vals::Bc {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Bc::from_bits(val as u8)
            }
            #[doc = "Bit Counter"]
            #[inline(always)]
            pub fn set_bc(&mut self, val: super::vals::Bc) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "BC Write Protect(This bit is read as 1.)"]
            #[inline(always)]
            pub const fn bcwp(&self) -> super::vals::Bcwp {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bcwp::from_bits(val as u8)
            }
            #[doc = "BC Write Protect(This bit is read as 1.)"]
            #[inline(always)]
            pub fn set_bcwp(&mut self, val: super::vals::Bcwp) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Cks {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Cks::from_bits(val as u8)
            }
            #[doc = "Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Cks) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "MST/TRS Write Protect"]
            #[inline(always)]
            pub const fn mtwp(&self) -> super::vals::Mtwp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Mtwp::from_bits(val as u8)
            }
            #[doc = "MST/TRS Write Protect"]
            #[inline(always)]
            pub fn set_mtwp(&mut self, val: super::vals::Mtwp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icmr1 {
            #[inline(always)]
            fn default() -> Icmr1 {
                Icmr1(0)
            }
        }
        impl core::fmt::Debug for Icmr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icmr1")
                    .field("bc", &self.bc())
                    .field("bcwp", &self.bcwp())
                    .field("cks", &self.cks())
                    .field("mtwp", &self.mtwp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icmr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icmr1 {{ bc: {:?}, bcwp: {:?}, cks: {:?}, mtwp: {:?} }}",
                    self.bc(),
                    self.bcwp(),
                    self.cks(),
                    self.mtwp()
                )
            }
        }
        #[doc = "I2C Bus Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icmr2(pub u8);
        impl Icmr2 {
            #[doc = "Timeout Detection Time Selection"]
            #[inline(always)]
            pub const fn tmos(&self) -> super::vals::Tmos {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmos::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Time Selection"]
            #[inline(always)]
            pub fn set_tmos(&mut self, val: super::vals::Tmos) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Timeout L Count Control"]
            #[inline(always)]
            pub const fn tmol(&self) -> super::vals::Tmol {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tmol::from_bits(val as u8)
            }
            #[doc = "Timeout L Count Control"]
            #[inline(always)]
            pub fn set_tmol(&mut self, val: super::vals::Tmol) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Timeout H Count Control"]
            #[inline(always)]
            pub const fn tmoh(&self) -> super::vals::Tmoh {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tmoh::from_bits(val as u8)
            }
            #[doc = "Timeout H Count Control"]
            #[inline(always)]
            pub fn set_tmoh(&mut self, val: super::vals::Tmoh) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "SDA Output Delay Counter"]
            #[inline(always)]
            pub const fn sddl(&self) -> super::vals::Sddl {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Sddl::from_bits(val as u8)
            }
            #[doc = "SDA Output Delay Counter"]
            #[inline(always)]
            pub fn set_sddl(&mut self, val: super::vals::Sddl) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "SDA Output Delay Clock Source Selection"]
            #[inline(always)]
            pub const fn dlcs(&self) -> super::vals::Dlcs {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dlcs::from_bits(val as u8)
            }
            #[doc = "SDA Output Delay Clock Source Selection"]
            #[inline(always)]
            pub fn set_dlcs(&mut self, val: super::vals::Dlcs) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icmr2 {
            #[inline(always)]
            fn default() -> Icmr2 {
                Icmr2(0)
            }
        }
        impl core::fmt::Debug for Icmr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icmr2")
                    .field("tmos", &self.tmos())
                    .field("tmol", &self.tmol())
                    .field("tmoh", &self.tmoh())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("sddl", &self.sddl())
                    .field("dlcs", &self.dlcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icmr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icmr2 {{ tmos: {:?}, tmol: {:?}, tmoh: {:?}, reserved_3_3: {=bool:?}, sddl: {:?}, dlcs: {:?} }}" , self . tmos () , self . tmol () , self . tmoh () , self . reserved_3_3 () , self . sddl () , self . dlcs ())
            }
        }
        #[doc = "I2C Bus Mode Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icmr3(pub u8);
        impl Icmr3 {
            #[doc = "Noise Filter Stage Selection"]
            #[inline(always)]
            pub const fn nf(&self) -> super::vals::Nf {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nf::from_bits(val as u8)
            }
            #[doc = "Noise Filter Stage Selection"]
            #[inline(always)]
            pub fn set_nf(&mut self, val: super::vals::Nf) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Receive Acknowledge"]
            #[inline(always)]
            pub const fn ackbr(&self) -> super::vals::Ackbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ackbr::from_bits(val as u8)
            }
            #[doc = "Receive Acknowledge"]
            #[inline(always)]
            pub fn set_ackbr(&mut self, val: super::vals::Ackbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmit Acknowledge"]
            #[inline(always)]
            pub const fn ackbt(&self) -> super::vals::Ackbt {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ackbt::from_bits(val as u8)
            }
            #[doc = "Transmit Acknowledge"]
            #[inline(always)]
            pub fn set_ackbt(&mut self, val: super::vals::Ackbt) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "ACKBT Write Protect"]
            #[inline(always)]
            pub const fn ackwp(&self) -> super::vals::Ackwp {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ackwp::from_bits(val as u8)
            }
            #[doc = "ACKBT Write Protect"]
            #[inline(always)]
            pub fn set_ackwp(&mut self, val: super::vals::Ackwp) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "RDRF Flag Set Timing Selection"]
            #[inline(always)]
            pub const fn rdrfs(&self) -> super::vals::Rdrfs {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rdrfs::from_bits(val as u8)
            }
            #[doc = "RDRF Flag Set Timing Selection"]
            #[inline(always)]
            pub fn set_rdrfs(&mut self, val: super::vals::Rdrfs) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand."]
            #[inline(always)]
            pub const fn wait(&self) -> super::vals::Wait {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Wait::from_bits(val as u8)
            }
            #[doc = "WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand."]
            #[inline(always)]
            pub fn set_wait(&mut self, val: super::vals::Wait) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "SMBus/I2C Bus Selection"]
            #[inline(always)]
            pub const fn smbs(&self) -> super::vals::Smbs {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Smbs::from_bits(val as u8)
            }
            #[doc = "SMBus/I2C Bus Selection"]
            #[inline(always)]
            pub fn set_smbs(&mut self, val: super::vals::Smbs) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icmr3 {
            #[inline(always)]
            fn default() -> Icmr3 {
                Icmr3(0)
            }
        }
        impl core::fmt::Debug for Icmr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icmr3")
                    .field("nf", &self.nf())
                    .field("ackbr", &self.ackbr())
                    .field("ackbt", &self.ackbt())
                    .field("ackwp", &self.ackwp())
                    .field("rdrfs", &self.rdrfs())
                    .field("wait", &self.wait())
                    .field("smbs", &self.smbs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icmr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icmr3 {{ nf: {:?}, ackbr: {:?}, ackbt: {:?}, ackwp: {:?}, rdrfs: {:?}, wait: {:?}, smbs: {:?} }}" , self . nf () , self . ackbr () , self . ackbt () , self . ackwp () , self . rdrfs () , self . wait () , self . smbs ())
            }
        }
        #[doc = "I2C Bus Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icser(pub u8);
        impl Icser {
            #[doc = "Slave Address Register 0 Enable"]
            #[inline(always)]
            pub const fn sar0e(&self) -> super::vals::Sar0e {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sar0e::from_bits(val as u8)
            }
            #[doc = "Slave Address Register 0 Enable"]
            #[inline(always)]
            pub fn set_sar0e(&mut self, val: super::vals::Sar0e) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Slave Address Register 1 Enable"]
            #[inline(always)]
            pub const fn sar1e(&self) -> super::vals::Sar1e {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sar1e::from_bits(val as u8)
            }
            #[doc = "Slave Address Register 1 Enable"]
            #[inline(always)]
            pub fn set_sar1e(&mut self, val: super::vals::Sar1e) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Slave Address Register 2 Enable"]
            #[inline(always)]
            pub const fn sar2e(&self) -> super::vals::Sar2e {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sar2e::from_bits(val as u8)
            }
            #[doc = "Slave Address Register 2 Enable"]
            #[inline(always)]
            pub fn set_sar2e(&mut self, val: super::vals::Sar2e) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "General Call Address Enable"]
            #[inline(always)]
            pub const fn gcae(&self) -> super::vals::Gcae {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Gcae::from_bits(val as u8)
            }
            #[doc = "General Call Address Enable"]
            #[inline(always)]
            pub fn set_gcae(&mut self, val: super::vals::Gcae) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_4_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_4_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "Device,ID Address Detection Enable"]
            #[inline(always)]
            pub const fn dide(&self) -> super::vals::Dide {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Dide::from_bits(val as u8)
            }
            #[doc = "Device,ID Address Detection Enable"]
            #[inline(always)]
            pub fn set_dide(&mut self, val: super::vals::Dide) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "Host Address Enable"]
            #[inline(always)]
            pub const fn hoae(&self) -> super::vals::Hoae {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Hoae::from_bits(val as u8)
            }
            #[doc = "Host Address Enable"]
            #[inline(always)]
            pub fn set_hoae(&mut self, val: super::vals::Hoae) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icser {
            #[inline(always)]
            fn default() -> Icser {
                Icser(0)
            }
        }
        impl core::fmt::Debug for Icser {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icser")
                    .field("sar0e", &self.sar0e())
                    .field("sar1e", &self.sar1e())
                    .field("sar2e", &self.sar2e())
                    .field("gcae", &self.gcae())
                    .field("reserved_4_4", &self.reserved_4_4())
                    .field("dide", &self.dide())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("hoae", &self.hoae())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icser {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icser {{ sar0e: {:?}, sar1e: {:?}, sar2e: {:?}, gcae: {:?}, reserved_4_4: {=bool:?}, dide: {:?}, reserved_6_6: {=bool:?}, hoae: {:?} }}" , self . sar0e () , self . sar1e () , self . sar2e () , self . gcae () , self . reserved_4_4 () , self . dide () , self . reserved_6_6 () , self . hoae ())
            }
        }
        #[doc = "I2C Bus Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icsr1(pub u8);
        impl Icsr1 {
            #[doc = "Slave Address 0 Detection Flag"]
            #[inline(always)]
            pub const fn aas0(&self) -> super::vals::Aas0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Aas0::from_bits(val as u8)
            }
            #[doc = "Slave Address 0 Detection Flag"]
            #[inline(always)]
            pub fn set_aas0(&mut self, val: super::vals::Aas0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Slave Address 1 Detection Flag"]
            #[inline(always)]
            pub const fn aas1(&self) -> super::vals::Aas1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Aas1::from_bits(val as u8)
            }
            #[doc = "Slave Address 1 Detection Flag"]
            #[inline(always)]
            pub fn set_aas1(&mut self, val: super::vals::Aas1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Slave Address 2 Detection Flag"]
            #[inline(always)]
            pub const fn aas2(&self) -> super::vals::Aas2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Aas2::from_bits(val as u8)
            }
            #[doc = "Slave Address 2 Detection Flag"]
            #[inline(always)]
            pub fn set_aas2(&mut self, val: super::vals::Aas2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "General Call Address Detection Flag"]
            #[inline(always)]
            pub const fn gca(&self) -> super::vals::Gca {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Gca::from_bits(val as u8)
            }
            #[doc = "General Call Address Detection Flag"]
            #[inline(always)]
            pub fn set_gca(&mut self, val: super::vals::Gca) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_4_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_4_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "Device,ID Address Detection Flag"]
            #[inline(always)]
            pub const fn did(&self) -> super::vals::Did {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Did::from_bits(val as u8)
            }
            #[doc = "Device,ID Address Detection Flag"]
            #[inline(always)]
            pub fn set_did(&mut self, val: super::vals::Did) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "Host Address Detection Flag"]
            #[inline(always)]
            pub const fn hoa(&self) -> super::vals::Hoa {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Hoa::from_bits(val as u8)
            }
            #[doc = "Host Address Detection Flag"]
            #[inline(always)]
            pub fn set_hoa(&mut self, val: super::vals::Hoa) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icsr1 {
            #[inline(always)]
            fn default() -> Icsr1 {
                Icsr1(0)
            }
        }
        impl core::fmt::Debug for Icsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icsr1")
                    .field("aas0", &self.aas0())
                    .field("aas1", &self.aas1())
                    .field("aas2", &self.aas2())
                    .field("gca", &self.gca())
                    .field("reserved_4_4", &self.reserved_4_4())
                    .field("did", &self.did())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("hoa", &self.hoa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icsr1 {{ aas0: {:?}, aas1: {:?}, aas2: {:?}, gca: {:?}, reserved_4_4: {=bool:?}, did: {:?}, reserved_6_6: {=bool:?}, hoa: {:?} }}" , self . aas0 () , self . aas1 () , self . aas2 () , self . gca () , self . reserved_4_4 () , self . did () , self . reserved_6_6 () , self . hoa ())
            }
        }
        #[doc = "I2C Bus Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icsr2(pub u8);
        impl Icsr2 {
            #[doc = "Timeout Detection Flag"]
            #[inline(always)]
            pub const fn tmof(&self) -> super::vals::Tmof {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmof::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Flag"]
            #[inline(always)]
            pub fn set_tmof(&mut self, val: super::vals::Tmof) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Arbitration,Lost Flag"]
            #[inline(always)]
            pub const fn al(&self) -> super::vals::Al {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Al::from_bits(val as u8)
            }
            #[doc = "Arbitration,Lost Flag"]
            #[inline(always)]
            pub fn set_al(&mut self, val: super::vals::Al) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Start Condition Detection Flag"]
            #[inline(always)]
            pub const fn start(&self) -> super::vals::Start {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Start::from_bits(val as u8)
            }
            #[doc = "Start Condition Detection Flag"]
            #[inline(always)]
            pub fn set_start(&mut self, val: super::vals::Start) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Condition Detection Flag"]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::Stop {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Stop::from_bits(val as u8)
            }
            #[doc = "Stop Condition Detection Flag"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: super::vals::Stop) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "NACK Detection Flag"]
            #[inline(always)]
            pub const fn nackf(&self) -> super::vals::Nackf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nackf::from_bits(val as u8)
            }
            #[doc = "NACK Detection Flag"]
            #[inline(always)]
            pub fn set_nackf(&mut self, val: super::vals::Nackf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::Rdrf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::Rdrf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::Tend {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::Tend) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::Tdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::Tdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icsr2 {
            #[inline(always)]
            fn default() -> Icsr2 {
                Icsr2(0)
            }
        }
        impl core::fmt::Debug for Icsr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icsr2")
                    .field("tmof", &self.tmof())
                    .field("al", &self.al())
                    .field("start", &self.start())
                    .field("stop", &self.stop())
                    .field("nackf", &self.nackf())
                    .field("rdrf", &self.rdrf())
                    .field("tend", &self.tend())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icsr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icsr2 {{ tmof: {:?}, al: {:?}, start: {:?}, stop: {:?}, nackf: {:?}, rdrf: {:?}, tend: {:?}, tdre: {:?} }}" , self . tmof () , self . al () , self . start () , self . stop () , self . nackf () , self . rdrf () , self . tend () , self . tdre ())
            }
        }
        #[doc = "I2C Bus Wake Up Unit Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icwur(pub u8);
        impl Icwur {
            #[doc = "Wake,Up Analog Filter Additional Selection"]
            #[inline(always)]
            pub const fn wuafa(&self) -> super::vals::Wuafa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Wuafa::from_bits(val as u8)
            }
            #[doc = "Wake,Up Analog Filter Additional Selection"]
            #[inline(always)]
            pub fn set_wuafa(&mut self, val: super::vals::Wuafa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_1_3(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_1_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "Asynchronous/Synchronous Operation State Flag"]
            #[inline(always)]
            pub const fn wuack(&self) -> super::vals::Wuack {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Wuack::from_bits(val as u8)
            }
            #[doc = "Asynchronous/Synchronous Operation State Flag"]
            #[inline(always)]
            pub fn set_wuack(&mut self, val: super::vals::Wuack) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Wake,Up Event Occurrence Flag"]
            #[inline(always)]
            pub const fn wuf(&self) -> super::vals::Wuf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Wuf::from_bits(val as u8)
            }
            #[doc = "Wake,Up Event Occurrence Flag"]
            #[inline(always)]
            pub fn set_wuf(&mut self, val: super::vals::Wuf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Wake Up Interrupt Request Enable"]
            #[inline(always)]
            pub const fn wuie(&self) -> super::vals::Wuie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Wuie::from_bits(val as u8)
            }
            #[doc = "Wake Up Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_wuie(&mut self, val: super::vals::Wuie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Wake Up function Enable"]
            #[inline(always)]
            pub const fn wue(&self) -> super::vals::Wue {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wue::from_bits(val as u8)
            }
            #[doc = "Wake Up function Enable"]
            #[inline(always)]
            pub fn set_wue(&mut self, val: super::vals::Wue) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icwur {
            #[inline(always)]
            fn default() -> Icwur {
                Icwur(0)
            }
        }
        impl core::fmt::Debug for Icwur {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icwur")
                    .field("wuafa", &self.wuafa())
                    .field("reserved_1_3", &self.reserved_1_3())
                    .field("wuack", &self.wuack())
                    .field("wuf", &self.wuf())
                    .field("wuie", &self.wuie())
                    .field("wue", &self.wue())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icwur {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icwur {{ wuafa: {:?}, reserved_1_3: {=u8:?}, wuack: {:?}, wuf: {:?}, wuie: {:?}, wue: {:?} }}" , self . wuafa () , self . reserved_1_3 () , self . wuack () , self . wuf () , self . wuie () , self . wue ())
            }
        }
        #[doc = "Reserved"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icwur2(pub u8);
        impl Icwur2 {
            #[doc = "Wake,Up function Synchronous Enable"]
            #[inline(always)]
            pub const fn wusen(&self) -> super::vals::Wusen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Wusen::from_bits(val as u8)
            }
            #[doc = "Wake,Up function Synchronous Enable"]
            #[inline(always)]
            pub fn set_wusen(&mut self, val: super::vals::Wusen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Wake,Up function Asynchronous operation status Flag"]
            #[inline(always)]
            pub const fn wuasyf(&self) -> super::vals::Wuasyf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wuasyf::from_bits(val as u8)
            }
            #[doc = "Wake,Up function Asynchronous operation status Flag"]
            #[inline(always)]
            pub fn set_wuasyf(&mut self, val: super::vals::Wuasyf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Wake,Up function Synchronous operation status Flag"]
            #[inline(always)]
            pub const fn wusyf(&self) -> super::vals::Wusyf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Wusyf::from_bits(val as u8)
            }
            #[doc = "Wake,Up function Synchronous operation status Flag"]
            #[inline(always)]
            pub fn set_wusyf(&mut self, val: super::vals::Wusyf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 11111. The write value should be 11111."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 11111. The write value should be 11111."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Icwur2 {
            #[inline(always)]
            fn default() -> Icwur2 {
                Icwur2(0)
            }
        }
        impl core::fmt::Debug for Icwur2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icwur2")
                    .field("wusen", &self.wusen())
                    .field("wuasyf", &self.wuasyf())
                    .field("wusyf", &self.wusyf())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icwur2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icwur2 {{ wusen: {:?}, wuasyf: {:?}, wusyf: {:?}, reserved_3_7: {=u8:?} }}",
                    self.wusen(),
                    self.wuasyf(),
                    self.wusyf(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "Slave Address Register L%s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sarl(pub u8);
        impl Sarl {
            #[doc = "A slave address is set.7-Bit Address = SVA\\[7:1\\] 10-Bit Address = { SVA9,SVA8,SVA\\[7:0\\] }"]
            #[inline(always)]
            pub const fn sva(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "A slave address is set.7-Bit Address = SVA\\[7:1\\] 10-Bit Address = { SVA9,SVA8,SVA\\[7:0\\] }"]
            #[inline(always)]
            pub fn set_sva(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Sarl {
            #[inline(always)]
            fn default() -> Sarl {
                Sarl(0)
            }
        }
        impl core::fmt::Debug for Sarl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sarl").field("sva", &self.sva()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sarl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sarl {{ sva: {=u8:?} }}", self.sva())
            }
        }
        #[doc = "Slave Address Register U%s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Saru(pub u8);
        impl Saru {
            #[doc = "7-Bit/10-Bit Address Format Selection"]
            #[inline(always)]
            pub const fn fs(&self) -> super::vals::Fs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fs::from_bits(val as u8)
            }
            #[doc = "7-Bit/10-Bit Address Format Selection"]
            #[inline(always)]
            pub fn set_fs(&mut self, val: super::vals::Fs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "10-Bit Address(bit8)"]
            #[inline(always)]
            pub const fn sva8(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "10-Bit Address(bit8)"]
            #[inline(always)]
            pub fn set_sva8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "10-Bit Address(bit9)"]
            #[inline(always)]
            pub const fn sva9(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "10-Bit Address(bit9)"]
            #[inline(always)]
            pub fn set_sva9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Saru {
            #[inline(always)]
            fn default() -> Saru {
                Saru(0)
            }
        }
        impl core::fmt::Debug for Saru {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Saru")
                    .field("fs", &self.fs())
                    .field("sva8", &self.sva8())
                    .field("sva9", &self.sva9())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Saru {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Saru {{ fs: {:?}, sva8: {=bool:?}, sva9: {=bool:?}, reserved_3_7: {=u8:?} }}",
                    self.fs(),
                    self.sva8(),
                    self.sva9(),
                    self.reserved_3_7()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aas0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aas0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aas0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aas0 {
            #[inline(always)]
            fn from(val: u8) -> Aas0 {
                Aas0::from_bits(val)
            }
        }
        impl From<Aas0> for u8 {
            #[inline(always)]
            fn from(val: Aas0) -> u8 {
                Aas0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aas1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aas1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aas1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aas1 {
            #[inline(always)]
            fn from(val: u8) -> Aas1 {
                Aas1::from_bits(val)
            }
        }
        impl From<Aas1> for u8 {
            #[inline(always)]
            fn from(val: Aas1) -> u8 {
                Aas1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aas2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aas2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aas2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aas2 {
            #[inline(always)]
            fn from(val: u8) -> Aas2 {
                Aas2::from_bits(val)
            }
        }
        impl From<Aas2> for u8 {
            #[inline(always)]
            fn from(val: Aas2) -> u8 {
                Aas2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackbr {
            #[inline(always)]
            fn from(val: u8) -> Ackbr {
                Ackbr::from_bits(val)
            }
        }
        impl From<Ackbr> for u8 {
            #[inline(always)]
            fn from(val: Ackbr) -> u8 {
                Ackbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackbt {
            #[inline(always)]
            fn from(val: u8) -> Ackbt {
                Ackbt::from_bits(val)
            }
        }
        impl From<Ackbt> for u8 {
            #[inline(always)]
            fn from(val: Ackbt) -> u8 {
                Ackbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackwp {
            #[inline(always)]
            fn from(val: u8) -> Ackwp {
                Ackwp::from_bits(val)
            }
        }
        impl From<Ackwp> for u8 {
            #[inline(always)]
            fn from(val: Ackwp) -> u8 {
                Ackwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Al {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Al {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Al {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Al {
            #[inline(always)]
            fn from(val: u8) -> Al {
                Al::from_bits(val)
            }
        }
        impl From<Al> for u8 {
            #[inline(always)]
            fn from(val: Al) -> u8 {
                Al::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Alie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Alie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Alie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Alie {
            #[inline(always)]
            fn from(val: u8) -> Alie {
                Alie::from_bits(val)
            }
        }
        impl From<Alie> for u8 {
            #[inline(always)]
            fn from(val: Alie) -> u8 {
                Alie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bbsy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bbsy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bbsy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bbsy {
            #[inline(always)]
            fn from(val: u8) -> Bbsy {
                Bbsy::from_bits(val)
            }
        }
        impl From<Bbsy> for u8 {
            #[inline(always)]
            fn from(val: Bbsy) -> u8 {
                Bbsy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Bc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bc {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bc {
            #[inline(always)]
            fn from(val: u8) -> Bc {
                Bc::from_bits(val)
            }
        }
        impl From<Bc> for u8 {
            #[inline(always)]
            fn from(val: Bc) -> u8 {
                Bc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bcwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcwp {
            #[inline(always)]
            fn from(val: u8) -> Bcwp {
                Bcwp::from_bits(val)
            }
        }
        impl From<Bcwp> for u8 {
            #[inline(always)]
            fn from(val: Bcwp) -> u8 {
                Bcwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cks {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cks {
            #[inline(always)]
            fn from(val: u8) -> Cks {
                Cks::from_bits(val)
            }
        }
        impl From<Cks> for u8 {
            #[inline(always)]
            fn from(val: Cks) -> u8 {
                Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clo {
            #[inline(always)]
            fn from(val: u8) -> Clo {
                Clo::from_bits(val)
            }
        }
        impl From<Clo> for u8 {
            #[inline(always)]
            fn from(val: Clo) -> u8 {
                Clo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Did {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Did {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Did {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Did {
            #[inline(always)]
            fn from(val: u8) -> Did {
                Did::from_bits(val)
            }
        }
        impl From<Did> for u8 {
            #[inline(always)]
            fn from(val: Did) -> u8 {
                Did::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dide {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dide {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dide {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dide {
            #[inline(always)]
            fn from(val: u8) -> Dide {
                Dide::from_bits(val)
            }
        }
        impl From<Dide> for u8 {
            #[inline(always)]
            fn from(val: Dide) -> u8 {
                Dide::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dlcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dlcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dlcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dlcs {
            #[inline(always)]
            fn from(val: u8) -> Dlcs {
                Dlcs::from_bits(val)
            }
        }
        impl From<Dlcs> for u8 {
            #[inline(always)]
            fn from(val: Dlcs) -> u8 {
                Dlcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fs {
            #[inline(always)]
            fn from(val: u8) -> Fs {
                Fs::from_bits(val)
            }
        }
        impl From<Fs> for u8 {
            #[inline(always)]
            fn from(val: Fs) -> u8 {
                Fs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gca {
            #[inline(always)]
            fn from(val: u8) -> Gca {
                Gca::from_bits(val)
            }
        }
        impl From<Gca> for u8 {
            #[inline(always)]
            fn from(val: Gca) -> u8 {
                Gca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gcae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gcae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gcae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gcae {
            #[inline(always)]
            fn from(val: u8) -> Gcae {
                Gcae::from_bits(val)
            }
        }
        impl From<Gcae> for u8 {
            #[inline(always)]
            fn from(val: Gcae) -> u8 {
                Gcae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hoa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hoa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hoa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hoa {
            #[inline(always)]
            fn from(val: u8) -> Hoa {
                Hoa::from_bits(val)
            }
        }
        impl From<Hoa> for u8 {
            #[inline(always)]
            fn from(val: Hoa) -> u8 {
                Hoa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hoae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hoae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hoae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hoae {
            #[inline(always)]
            fn from(val: u8) -> Hoae {
                Hoae::from_bits(val)
            }
        }
        impl From<Hoae> for u8 {
            #[inline(always)]
            fn from(val: Hoae) -> u8 {
                Hoae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ice {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ice {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ice {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ice {
            #[inline(always)]
            fn from(val: u8) -> Ice {
                Ice::from_bits(val)
            }
        }
        impl From<Ice> for u8 {
            #[inline(always)]
            fn from(val: Ice) -> u8 {
                Ice::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicrst {
            #[inline(always)]
            fn from(val: u8) -> Iicrst {
                Iicrst::from_bits(val)
            }
        }
        impl From<Iicrst> for u8 {
            #[inline(always)]
            fn from(val: Iicrst) -> u8 {
                Iicrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Male {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Male {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Male {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Male {
            #[inline(always)]
            fn from(val: u8) -> Male {
                Male::from_bits(val)
            }
        }
        impl From<Male> for u8 {
            #[inline(always)]
            fn from(val: Male) -> u8 {
                Male::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mst {
            #[inline(always)]
            fn from(val: u8) -> Mst {
                Mst::from_bits(val)
            }
        }
        impl From<Mst> for u8 {
            #[inline(always)]
            fn from(val: Mst) -> u8 {
                Mst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mtwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mtwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mtwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mtwp {
            #[inline(always)]
            fn from(val: u8) -> Mtwp {
                Mtwp::from_bits(val)
            }
        }
        impl From<Mtwp> for u8 {
            #[inline(always)]
            fn from(val: Mtwp) -> u8 {
                Mtwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nacke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nacke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nacke {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nacke {
            #[inline(always)]
            fn from(val: u8) -> Nacke {
                Nacke::from_bits(val)
            }
        }
        impl From<Nacke> for u8 {
            #[inline(always)]
            fn from(val: Nacke) -> u8 {
                Nacke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nackf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nackf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nackf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nackf {
            #[inline(always)]
            fn from(val: u8) -> Nackf {
                Nackf::from_bits(val)
            }
        }
        impl From<Nackf> for u8 {
            #[inline(always)]
            fn from(val: Nackf) -> u8 {
                Nackf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nakie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nakie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nakie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nakie {
            #[inline(always)]
            fn from(val: u8) -> Nakie {
                Nakie::from_bits(val)
            }
        }
        impl From<Nakie> for u8 {
            #[inline(always)]
            fn from(val: Nakie) -> u8 {
                Nakie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nale {
            #[inline(always)]
            fn from(val: u8) -> Nale {
                Nale::from_bits(val)
            }
        }
        impl From<Nale> for u8 {
            #[inline(always)]
            fn from(val: Nale) -> u8 {
                Nale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nf {
            #[inline(always)]
            fn from(val: u8) -> Nf {
                Nf::from_bits(val)
            }
        }
        impl From<Nf> for u8 {
            #[inline(always)]
            fn from(val: Nf) -> u8 {
                Nf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfe {
            #[inline(always)]
            fn from(val: u8) -> Nfe {
                Nfe::from_bits(val)
            }
        }
        impl From<Nfe> for u8 {
            #[inline(always)]
            fn from(val: Nfe) -> u8 {
                Nfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdrf {
            #[inline(always)]
            fn from(val: u8) -> Rdrf {
                Rdrf::from_bits(val)
            }
        }
        impl From<Rdrf> for u8 {
            #[inline(always)]
            fn from(val: Rdrf) -> u8 {
                Rdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdrfs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdrfs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdrfs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdrfs {
            #[inline(always)]
            fn from(val: u8) -> Rdrfs {
                Rdrfs::from_bits(val)
            }
        }
        impl From<Rdrfs> for u8 {
            #[inline(always)]
            fn from(val: Rdrfs) -> u8 {
                Rdrfs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rie {
            #[inline(always)]
            fn from(val: u8) -> Rie {
                Rie::from_bits(val)
            }
        }
        impl From<Rie> for u8 {
            #[inline(always)]
            fn from(val: Rie) -> u8 {
                Rie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rs {
            #[inline(always)]
            fn from(val: u8) -> Rs {
                Rs::from_bits(val)
            }
        }
        impl From<Rs> for u8 {
            #[inline(always)]
            fn from(val: Rs) -> u8 {
                Rs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sale {
            #[inline(always)]
            fn from(val: u8) -> Sale {
                Sale::from_bits(val)
            }
        }
        impl From<Sale> for u8 {
            #[inline(always)]
            fn from(val: Sale) -> u8 {
                Sale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sar0e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sar0e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sar0e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sar0e {
            #[inline(always)]
            fn from(val: u8) -> Sar0e {
                Sar0e::from_bits(val)
            }
        }
        impl From<Sar0e> for u8 {
            #[inline(always)]
            fn from(val: Sar0e) -> u8 {
                Sar0e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sar1e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sar1e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sar1e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sar1e {
            #[inline(always)]
            fn from(val: u8) -> Sar1e {
                Sar1e::from_bits(val)
            }
        }
        impl From<Sar1e> for u8 {
            #[inline(always)]
            fn from(val: Sar1e) -> u8 {
                Sar1e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sar2e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sar2e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sar2e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sar2e {
            #[inline(always)]
            fn from(val: u8) -> Sar2e {
                Sar2e::from_bits(val)
            }
        }
        impl From<Sar2e> for u8 {
            #[inline(always)]
            fn from(val: Sar2e) -> u8 {
                Sar2e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scle {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scle {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scle {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scle {
            #[inline(always)]
            fn from(val: u8) -> Scle {
                Scle::from_bits(val)
            }
        }
        impl From<Scle> for u8 {
            #[inline(always)]
            fn from(val: Scle) -> u8 {
                Scle::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scli {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scli {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scli {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scli {
            #[inline(always)]
            fn from(val: u8) -> Scli {
                Scli::from_bits(val)
            }
        }
        impl From<Scli> for u8 {
            #[inline(always)]
            fn from(val: Scli) -> u8 {
                Scli::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sclo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sclo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sclo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sclo {
            #[inline(always)]
            fn from(val: u8) -> Sclo {
                Sclo::from_bits(val)
            }
        }
        impl From<Sclo> for u8 {
            #[inline(always)]
            fn from(val: Sclo) -> u8 {
                Sclo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdai {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdai {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdai {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdai {
            #[inline(always)]
            fn from(val: u8) -> Sdai {
                Sdai::from_bits(val)
            }
        }
        impl From<Sdai> for u8 {
            #[inline(always)]
            fn from(val: Sdai) -> u8 {
                Sdai::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdao {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdao {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdao {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdao {
            #[inline(always)]
            fn from(val: u8) -> Sdao {
                Sdao::from_bits(val)
            }
        }
        impl From<Sdao> for u8 {
            #[inline(always)]
            fn from(val: Sdao) -> u8 {
                Sdao::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sddl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sddl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sddl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sddl {
            #[inline(always)]
            fn from(val: u8) -> Sddl {
                Sddl::from_bits(val)
            }
        }
        impl From<Sddl> for u8 {
            #[inline(always)]
            fn from(val: Sddl) -> u8 {
                Sddl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smbs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smbs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smbs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smbs {
            #[inline(always)]
            fn from(val: u8) -> Smbs {
                Smbs::from_bits(val)
            }
        }
        impl From<Smbs> for u8 {
            #[inline(always)]
            fn from(val: Smbs) -> u8 {
                Smbs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sowp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sowp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sowp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sowp {
            #[inline(always)]
            fn from(val: u8) -> Sowp {
                Sowp::from_bits(val)
            }
        }
        impl From<Sowp> for u8 {
            #[inline(always)]
            fn from(val: Sowp) -> u8 {
                Sowp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sp {
            #[inline(always)]
            fn from(val: u8) -> Sp {
                Sp::from_bits(val)
            }
        }
        impl From<Sp> for u8 {
            #[inline(always)]
            fn from(val: Sp) -> u8 {
                Sp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spie {
            #[inline(always)]
            fn from(val: u8) -> Spie {
                Spie::from_bits(val)
            }
        }
        impl From<Spie> for u8 {
            #[inline(always)]
            fn from(val: Spie) -> u8 {
                Spie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St {
            #[inline(always)]
            fn from(val: u8) -> St {
                St::from_bits(val)
            }
        }
        impl From<St> for u8 {
            #[inline(always)]
            fn from(val: St) -> u8 {
                St::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Start {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Start {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Start {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Start {
            #[inline(always)]
            fn from(val: u8) -> Start {
                Start::from_bits(val)
            }
        }
        impl From<Start> for u8 {
            #[inline(always)]
            fn from(val: Start) -> u8 {
                Start::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stie {
            #[inline(always)]
            fn from(val: u8) -> Stie {
                Stie::from_bits(val)
            }
        }
        impl From<Stie> for u8 {
            #[inline(always)]
            fn from(val: Stie) -> u8 {
                Stie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stop {
            #[inline(always)]
            fn from(val: u8) -> Stop {
                Stop::from_bits(val)
            }
        }
        impl From<Stop> for u8 {
            #[inline(always)]
            fn from(val: Stop) -> u8 {
                Stop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdre {
            #[inline(always)]
            fn from(val: u8) -> Tdre {
                Tdre::from_bits(val)
            }
        }
        impl From<Tdre> for u8 {
            #[inline(always)]
            fn from(val: Tdre) -> u8 {
                Tdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teie {
            #[inline(always)]
            fn from(val: u8) -> Teie {
                Teie::from_bits(val)
            }
        }
        impl From<Teie> for u8 {
            #[inline(always)]
            fn from(val: Teie) -> u8 {
                Teie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tend {
            #[inline(always)]
            fn from(val: u8) -> Tend {
                Tend::from_bits(val)
            }
        }
        impl From<Tend> for u8 {
            #[inline(always)]
            fn from(val: Tend) -> u8 {
                Tend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tie {
            #[inline(always)]
            fn from(val: u8) -> Tie {
                Tie::from_bits(val)
            }
        }
        impl From<Tie> for u8 {
            #[inline(always)]
            fn from(val: Tie) -> u8 {
                Tie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmoe {
            #[inline(always)]
            fn from(val: u8) -> Tmoe {
                Tmoe::from_bits(val)
            }
        }
        impl From<Tmoe> for u8 {
            #[inline(always)]
            fn from(val: Tmoe) -> u8 {
                Tmoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmof {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmof {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmof {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmof {
            #[inline(always)]
            fn from(val: u8) -> Tmof {
                Tmof::from_bits(val)
            }
        }
        impl From<Tmof> for u8 {
            #[inline(always)]
            fn from(val: Tmof) -> u8 {
                Tmof::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmoh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmoh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmoh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmoh {
            #[inline(always)]
            fn from(val: u8) -> Tmoh {
                Tmoh::from_bits(val)
            }
        }
        impl From<Tmoh> for u8 {
            #[inline(always)]
            fn from(val: Tmoh) -> u8 {
                Tmoh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmoie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmoie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmoie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmoie {
            #[inline(always)]
            fn from(val: u8) -> Tmoie {
                Tmoie::from_bits(val)
            }
        }
        impl From<Tmoie> for u8 {
            #[inline(always)]
            fn from(val: Tmoie) -> u8 {
                Tmoie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmol {
            #[inline(always)]
            fn from(val: u8) -> Tmol {
                Tmol::from_bits(val)
            }
        }
        impl From<Tmol> for u8 {
            #[inline(always)]
            fn from(val: Tmol) -> u8 {
                Tmol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmos {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmos {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmos {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmos {
            #[inline(always)]
            fn from(val: u8) -> Tmos {
                Tmos::from_bits(val)
            }
        }
        impl From<Tmos> for u8 {
            #[inline(always)]
            fn from(val: Tmos) -> u8 {
                Tmos::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trs {
            #[inline(always)]
            fn from(val: u8) -> Trs {
                Trs::from_bits(val)
            }
        }
        impl From<Trs> for u8 {
            #[inline(always)]
            fn from(val: Trs) -> u8 {
                Trs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wait {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wait {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wait {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wait {
            #[inline(always)]
            fn from(val: u8) -> Wait {
                Wait::from_bits(val)
            }
        }
        impl From<Wait> for u8 {
            #[inline(always)]
            fn from(val: Wait) -> u8 {
                Wait::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wuack {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wuack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wuack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wuack {
            #[inline(always)]
            fn from(val: u8) -> Wuack {
                Wuack::from_bits(val)
            }
        }
        impl From<Wuack> for u8 {
            #[inline(always)]
            fn from(val: Wuack) -> u8 {
                Wuack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wuafa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wuafa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wuafa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wuafa {
            #[inline(always)]
            fn from(val: u8) -> Wuafa {
                Wuafa::from_bits(val)
            }
        }
        impl From<Wuafa> for u8 {
            #[inline(always)]
            fn from(val: Wuafa) -> u8 {
                Wuafa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wuasyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wuasyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wuasyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wuasyf {
            #[inline(always)]
            fn from(val: u8) -> Wuasyf {
                Wuasyf::from_bits(val)
            }
        }
        impl From<Wuasyf> for u8 {
            #[inline(always)]
            fn from(val: Wuasyf) -> u8 {
                Wuasyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wue {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wue {
            #[inline(always)]
            fn from(val: u8) -> Wue {
                Wue::from_bits(val)
            }
        }
        impl From<Wue> for u8 {
            #[inline(always)]
            fn from(val: Wue) -> u8 {
                Wue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wuf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wuf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wuf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wuf {
            #[inline(always)]
            fn from(val: u8) -> Wuf {
                Wuf::from_bits(val)
            }
        }
        impl From<Wuf> for u8 {
            #[inline(always)]
            fn from(val: Wuf) -> u8 {
                Wuf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wuie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wuie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wuie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wuie {
            #[inline(always)]
            fn from(val: u8) -> Wuie {
                Wuie::from_bits(val)
            }
        }
        impl From<Wuie> for u8 {
            #[inline(always)]
            fn from(val: Wuie) -> u8 {
                Wuie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wusen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wusen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wusen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wusen {
            #[inline(always)]
            fn from(val: u8) -> Wusen {
                Wusen::from_bits(val)
            }
        }
        impl From<Wusen> for u8 {
            #[inline(always)]
            fn from(val: Wusen) -> u8 {
                Wusen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wusyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wusyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wusyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wusyf {
            #[inline(always)]
            fn from(val: u8) -> Wusyf {
                Wusyf::from_bits(val)
            }
        }
        impl From<Wusyf> for u8 {
            #[inline(always)]
            fn from(val: Wusyf) -> u8 {
                Wusyf::to_bits(val)
            }
        }
    }
}
pub mod iic1 {
    #[doc = "Inter,Integrated Circuit 1"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iic1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Iic1 {}
    unsafe impl Sync for Iic1 {}
    impl Iic1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "I2C Bus Control Register 1"]
        #[inline(always)]
        pub const fn iccr1(self) -> crate::common::Reg<regs::Iccr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "I2C Bus Control Register 2"]
        #[inline(always)]
        pub const fn iccr2(self) -> crate::common::Reg<regs::Iccr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "I2C Bus Mode Register 1"]
        #[inline(always)]
        pub const fn icmr1(self) -> crate::common::Reg<regs::Icmr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "I2C Bus Mode Register 2"]
        #[inline(always)]
        pub const fn icmr2(self) -> crate::common::Reg<regs::Icmr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "I2C Bus Mode Register 3"]
        #[inline(always)]
        pub const fn icmr3(self) -> crate::common::Reg<regs::Icmr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "I2C Bus Function Enable Register"]
        #[inline(always)]
        pub const fn icfer(self) -> crate::common::Reg<regs::Icfer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "I2C Bus Status Enable Register"]
        #[inline(always)]
        pub const fn icser(self) -> crate::common::Reg<regs::Icser, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "I2C Bus Interrupt Enable Register"]
        #[inline(always)]
        pub const fn icier(self) -> crate::common::Reg<regs::Icier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "I2C Bus Status Register 1"]
        #[inline(always)]
        pub const fn icsr1(self) -> crate::common::Reg<regs::Icsr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "I2C Bus Status Register 2"]
        #[inline(always)]
        pub const fn icsr2(self) -> crate::common::Reg<regs::Icsr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "Slave Address Register L%s"]
        #[inline(always)]
        pub const fn sarl(self, n: usize) -> crate::common::Reg<regs::Sarl, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize + n * 2usize) as _) }
        }
        #[doc = "Slave Address Register U%s"]
        #[inline(always)]
        pub const fn saru(self, n: usize) -> crate::common::Reg<regs::Saru, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize + n * 2usize) as _) }
        }
        #[doc = "I2C Bus Bit Rate Low,Level Register"]
        #[inline(always)]
        pub const fn icbrl(self) -> crate::common::Reg<regs::Icbrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "I2C Bus Bit Rate High,Level Register"]
        #[inline(always)]
        pub const fn icbrh(self) -> crate::common::Reg<regs::Icbrh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
        #[doc = "I2C Bus Transmit Data Register"]
        #[inline(always)]
        pub const fn icdrt(self) -> crate::common::Reg<regs::Icdrt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "I2C Bus Receive Data Register"]
        #[inline(always)]
        pub const fn icdrr(self) -> crate::common::Reg<regs::Icdrr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "I2C Bus Bit Rate High,Level Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icbrh(pub u8);
        impl Icbrh {
            #[doc = "Bit Rate High,Level Period(High,level period of SCL clock)"]
            #[inline(always)]
            pub const fn brh(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Bit Rate High,Level Period(High,level period of SCL clock)"]
            #[inline(always)]
            pub fn set_brh(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 111. The write value should be 111."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 111. The write value should be 111."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Icbrh {
            #[inline(always)]
            fn default() -> Icbrh {
                Icbrh(0)
            }
        }
        impl core::fmt::Debug for Icbrh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icbrh")
                    .field("brh", &self.brh())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icbrh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icbrh {{ brh: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.brh(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "I2C Bus Bit Rate Low,Level Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icbrl(pub u8);
        impl Icbrl {
            #[doc = "Bit Rate Low,Level Period(Low,level period of SCL clock)"]
            #[inline(always)]
            pub const fn brl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Bit Rate Low,Level Period(Low,level period of SCL clock)"]
            #[inline(always)]
            pub fn set_brl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 111. The write value should be 111."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 111. The write value should be 111."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Icbrl {
            #[inline(always)]
            fn default() -> Icbrl {
                Icbrl(0)
            }
        }
        impl core::fmt::Debug for Icbrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icbrl")
                    .field("brl", &self.brl())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icbrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icbrl {{ brl: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.brl(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "I2C Bus Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iccr1(pub u8);
        impl Iccr1 {
            #[doc = "SDA Line Monitor"]
            #[inline(always)]
            pub const fn sdai(&self) -> super::vals::Sdai {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sdai::from_bits(val as u8)
            }
            #[doc = "SDA Line Monitor"]
            #[inline(always)]
            pub fn set_sdai(&mut self, val: super::vals::Sdai) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SCL Line Monitor"]
            #[inline(always)]
            pub const fn scli(&self) -> super::vals::Scli {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Scli::from_bits(val as u8)
            }
            #[doc = "SCL Line Monitor"]
            #[inline(always)]
            pub fn set_scli(&mut self, val: super::vals::Scli) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "SDA Output Control/Monitor"]
            #[inline(always)]
            pub const fn sdao(&self) -> super::vals::Sdao {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sdao::from_bits(val as u8)
            }
            #[doc = "SDA Output Control/Monitor"]
            #[inline(always)]
            pub fn set_sdao(&mut self, val: super::vals::Sdao) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "SCL Output Control/Monitor"]
            #[inline(always)]
            pub const fn sclo(&self) -> super::vals::Sclo {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sclo::from_bits(val as u8)
            }
            #[doc = "SCL Output Control/Monitor"]
            #[inline(always)]
            pub fn set_sclo(&mut self, val: super::vals::Sclo) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SCLO/SDAO Write Protect"]
            #[inline(always)]
            pub const fn sowp(&self) -> super::vals::Sowp {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sowp::from_bits(val as u8)
            }
            #[doc = "SCLO/SDAO Write Protect"]
            #[inline(always)]
            pub fn set_sowp(&mut self, val: super::vals::Sowp) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Extra SCL Clock Cycle Output"]
            #[inline(always)]
            pub const fn clo(&self) -> super::vals::Clo {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Clo::from_bits(val as u8)
            }
            #[doc = "Extra SCL Clock Cycle Output"]
            #[inline(always)]
            pub fn set_clo(&mut self, val: super::vals::Clo) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang,up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information)."]
            #[inline(always)]
            pub const fn iicrst(&self) -> super::vals::Iicrst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Iicrst::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface Internal ResetNote:If an internal reset is initiated using the IICRST bit for a bus hang,up occurred during communication with the master device in slave mode, the states may become different between the slave device and the master device (due to the difference in the bit counter information)."]
            #[inline(always)]
            pub fn set_iicrst(&mut self, val: super::vals::Iicrst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "I2C Bus Interface Enable"]
            #[inline(always)]
            pub const fn ice(&self) -> super::vals::Ice {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ice::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface Enable"]
            #[inline(always)]
            pub fn set_ice(&mut self, val: super::vals::Ice) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iccr1 {
            #[inline(always)]
            fn default() -> Iccr1 {
                Iccr1(0)
            }
        }
        impl core::fmt::Debug for Iccr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iccr1")
                    .field("sdai", &self.sdai())
                    .field("scli", &self.scli())
                    .field("sdao", &self.sdao())
                    .field("sclo", &self.sclo())
                    .field("sowp", &self.sowp())
                    .field("clo", &self.clo())
                    .field("iicrst", &self.iicrst())
                    .field("ice", &self.ice())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iccr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Iccr1 {{ sdai: {:?}, scli: {:?}, sdao: {:?}, sclo: {:?}, sowp: {:?}, clo: {:?}, iicrst: {:?}, ice: {:?} }}" , self . sdai () , self . scli () , self . sdao () , self . sclo () , self . sowp () , self . clo () , self . iicrst () , self . ice ())
            }
        }
        #[doc = "I2C Bus Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iccr2(pub u8);
        impl Iccr2 {
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_0_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_0_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state)."]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::St {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::St::from_bits(val as u8)
            }
            #[doc = "Start Condition Issuance RequestSet the ST bit to 1 (start condition issuance request) when the BBSY flag is set to 0 (bus free state)."]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::St) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition."]
            #[inline(always)]
            pub const fn rs(&self) -> super::vals::Rs {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Rs::from_bits(val as u8)
            }
            #[doc = "Restart Condition Issuance RequestNote: Do not set the RS bit to 1 while issuing a stop condition."]
            #[inline(always)]
            pub fn set_rs(&mut self, val: super::vals::Rs) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued."]
            #[inline(always)]
            pub const fn sp(&self) -> super::vals::Sp {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sp::from_bits(val as u8)
            }
            #[doc = "Stop Condition Issuance RequestNote: Writing to the SP bit is not possible while the setting of the BBSY flag is 0 (bus free state).Note: Do not set the SP bit to 1 while a restart condition is being issued."]
            #[inline(always)]
            pub fn set_sp(&mut self, val: super::vals::Sp) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_4_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_4_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit/Receive Mode"]
            #[inline(always)]
            pub const fn trs(&self) -> super::vals::Trs {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Trs::from_bits(val as u8)
            }
            #[doc = "Transmit/Receive Mode"]
            #[inline(always)]
            pub fn set_trs(&mut self, val: super::vals::Trs) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Master/Slave Mode"]
            #[inline(always)]
            pub const fn mst(&self) -> super::vals::Mst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mst::from_bits(val as u8)
            }
            #[doc = "Master/Slave Mode"]
            #[inline(always)]
            pub fn set_mst(&mut self, val: super::vals::Mst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Bus Busy Detection Flag"]
            #[inline(always)]
            pub const fn bbsy(&self) -> super::vals::Bbsy {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bbsy::from_bits(val as u8)
            }
            #[doc = "Bus Busy Detection Flag"]
            #[inline(always)]
            pub fn set_bbsy(&mut self, val: super::vals::Bbsy) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iccr2 {
            #[inline(always)]
            fn default() -> Iccr2 {
                Iccr2(0)
            }
        }
        impl core::fmt::Debug for Iccr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iccr2")
                    .field("reserved_0_0", &self.reserved_0_0())
                    .field("st", &self.st())
                    .field("rs", &self.rs())
                    .field("sp", &self.sp())
                    .field("reserved_4_4", &self.reserved_4_4())
                    .field("trs", &self.trs())
                    .field("mst", &self.mst())
                    .field("bbsy", &self.bbsy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iccr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Iccr2 {{ reserved_0_0: {=bool:?}, st: {:?}, rs: {:?}, sp: {:?}, reserved_4_4: {=bool:?}, trs: {:?}, mst: {:?}, bbsy: {:?} }}" , self . reserved_0_0 () , self . st () , self . rs () , self . sp () , self . reserved_4_4 () , self . trs () , self . mst () , self . bbsy ())
            }
        }
        #[doc = "I2C Bus Receive Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icdrr(pub u8);
        impl Icdrr {
            #[doc = "8-bit register that stores the received data"]
            #[inline(always)]
            pub const fn icdrr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit register that stores the received data"]
            #[inline(always)]
            pub fn set_icdrr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Icdrr {
            #[inline(always)]
            fn default() -> Icdrr {
                Icdrr(0)
            }
        }
        impl core::fmt::Debug for Icdrr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icdrr")
                    .field("icdrr", &self.icdrr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icdrr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Icdrr {{ icdrr: {=u8:?} }}", self.icdrr())
            }
        }
        #[doc = "I2C Bus Transmit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icdrt(pub u8);
        impl Icdrt {
            #[doc = "8-bit read,write register that stores transmit data."]
            #[inline(always)]
            pub const fn icdrt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit read,write register that stores transmit data."]
            #[inline(always)]
            pub fn set_icdrt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Icdrt {
            #[inline(always)]
            fn default() -> Icdrt {
                Icdrt(0)
            }
        }
        impl core::fmt::Debug for Icdrt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icdrt")
                    .field("icdrt", &self.icdrt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icdrt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Icdrt {{ icdrt: {=u8:?} }}", self.icdrt())
            }
        }
        #[doc = "I2C Bus Function Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icfer(pub u8);
        impl Icfer {
            #[doc = "Timeout Function Enable"]
            #[inline(always)]
            pub const fn tmoe(&self) -> super::vals::Tmoe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmoe::from_bits(val as u8)
            }
            #[doc = "Timeout Function Enable"]
            #[inline(always)]
            pub fn set_tmoe(&mut self, val: super::vals::Tmoe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Master Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn male(&self) -> super::vals::Male {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Male::from_bits(val as u8)
            }
            #[doc = "Master Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_male(&mut self, val: super::vals::Male) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "NACK Transmission Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn nale(&self) -> super::vals::Nale {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Nale::from_bits(val as u8)
            }
            #[doc = "NACK Transmission Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_nale(&mut self, val: super::vals::Nale) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Slave Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn sale(&self) -> super::vals::Sale {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sale::from_bits(val as u8)
            }
            #[doc = "Slave Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_sale(&mut self, val: super::vals::Sale) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "NACK Reception Transfer Suspension Enable"]
            #[inline(always)]
            pub const fn nacke(&self) -> super::vals::Nacke {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nacke::from_bits(val as u8)
            }
            #[doc = "NACK Reception Transfer Suspension Enable"]
            #[inline(always)]
            pub fn set_nacke(&mut self, val: super::vals::Nacke) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Digital Noise Filter Circuit Enable"]
            #[inline(always)]
            pub const fn nfe(&self) -> super::vals::Nfe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Nfe::from_bits(val as u8)
            }
            #[doc = "Digital Noise Filter Circuit Enable"]
            #[inline(always)]
            pub fn set_nfe(&mut self, val: super::vals::Nfe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SCL Synchronous Circuit Enable"]
            #[inline(always)]
            pub const fn scle(&self) -> super::vals::Scle {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Scle::from_bits(val as u8)
            }
            #[doc = "SCL Synchronous Circuit Enable"]
            #[inline(always)]
            pub fn set_scle(&mut self, val: super::vals::Scle) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icfer {
            #[inline(always)]
            fn default() -> Icfer {
                Icfer(0)
            }
        }
        impl core::fmt::Debug for Icfer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icfer")
                    .field("tmoe", &self.tmoe())
                    .field("male", &self.male())
                    .field("nale", &self.nale())
                    .field("sale", &self.sale())
                    .field("nacke", &self.nacke())
                    .field("nfe", &self.nfe())
                    .field("scle", &self.scle())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icfer {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icfer {{ tmoe: {:?}, male: {:?}, nale: {:?}, sale: {:?}, nacke: {:?}, nfe: {:?}, scle: {:?}, reserved_7_7: {=bool:?} }}" , self . tmoe () , self . male () , self . nale () , self . sale () , self . nacke () , self . nfe () , self . scle () , self . reserved_7_7 ())
            }
        }
        #[doc = "I2C Bus Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icier(pub u8);
        impl Icier {
            #[doc = "Timeout Interrupt Request Enable"]
            #[inline(always)]
            pub const fn tmoie(&self) -> super::vals::Tmoie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmoie::from_bits(val as u8)
            }
            #[doc = "Timeout Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_tmoie(&mut self, val: super::vals::Tmoie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Arbitration,Lost Interrupt Request Enable"]
            #[inline(always)]
            pub const fn alie(&self) -> super::vals::Alie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Alie::from_bits(val as u8)
            }
            #[doc = "Arbitration,Lost Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_alie(&mut self, val: super::vals::Alie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Start Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub const fn stie(&self) -> super::vals::Stie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Stie::from_bits(val as u8)
            }
            #[doc = "Start Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_stie(&mut self, val: super::vals::Stie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub const fn spie(&self) -> super::vals::Spie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Spie::from_bits(val as u8)
            }
            #[doc = "Stop Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_spie(&mut self, val: super::vals::Spie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "NACK Reception Interrupt Request Enable"]
            #[inline(always)]
            pub const fn nakie(&self) -> super::vals::Nakie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nakie::from_bits(val as u8)
            }
            #[doc = "NACK Reception Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_nakie(&mut self, val: super::vals::Nakie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Receive Data Full Interrupt Request Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::Rie {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rie::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::Rie) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmit End Interrupt Request Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> super::vals::Teie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Teie::from_bits(val as u8)
            }
            #[doc = "Transmit End Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: super::vals::Teie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Interrupt Request Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::Tie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tie::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::Tie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icier {
            #[inline(always)]
            fn default() -> Icier {
                Icier(0)
            }
        }
        impl core::fmt::Debug for Icier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icier")
                    .field("tmoie", &self.tmoie())
                    .field("alie", &self.alie())
                    .field("stie", &self.stie())
                    .field("spie", &self.spie())
                    .field("nakie", &self.nakie())
                    .field("rie", &self.rie())
                    .field("teie", &self.teie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icier {{ tmoie: {:?}, alie: {:?}, stie: {:?}, spie: {:?}, nakie: {:?}, rie: {:?}, teie: {:?}, tie: {:?} }}" , self . tmoie () , self . alie () , self . stie () , self . spie () , self . nakie () , self . rie () , self . teie () , self . tie ())
            }
        }
        #[doc = "I2C Bus Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icmr1(pub u8);
        impl Icmr1 {
            #[doc = "Bit Counter"]
            #[inline(always)]
            pub const fn bc(&self) -> super::vals::Bc {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Bc::from_bits(val as u8)
            }
            #[doc = "Bit Counter"]
            #[inline(always)]
            pub fn set_bc(&mut self, val: super::vals::Bc) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "BC Write Protect(This bit is read as 1.)"]
            #[inline(always)]
            pub const fn bcwp(&self) -> super::vals::Bcwp {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bcwp::from_bits(val as u8)
            }
            #[doc = "BC Write Protect(This bit is read as 1.)"]
            #[inline(always)]
            pub fn set_bcwp(&mut self, val: super::vals::Bcwp) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Cks {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Cks::from_bits(val as u8)
            }
            #[doc = "Internal Reference Clock (fIIC) Selection ( fIIC = PCLKB / 2^CKS )"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Cks) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "MST/TRS Write Protect"]
            #[inline(always)]
            pub const fn mtwp(&self) -> super::vals::Mtwp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Mtwp::from_bits(val as u8)
            }
            #[doc = "MST/TRS Write Protect"]
            #[inline(always)]
            pub fn set_mtwp(&mut self, val: super::vals::Mtwp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icmr1 {
            #[inline(always)]
            fn default() -> Icmr1 {
                Icmr1(0)
            }
        }
        impl core::fmt::Debug for Icmr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icmr1")
                    .field("bc", &self.bc())
                    .field("bcwp", &self.bcwp())
                    .field("cks", &self.cks())
                    .field("mtwp", &self.mtwp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icmr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icmr1 {{ bc: {:?}, bcwp: {:?}, cks: {:?}, mtwp: {:?} }}",
                    self.bc(),
                    self.bcwp(),
                    self.cks(),
                    self.mtwp()
                )
            }
        }
        #[doc = "I2C Bus Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icmr2(pub u8);
        impl Icmr2 {
            #[doc = "Timeout Detection Time Selection"]
            #[inline(always)]
            pub const fn tmos(&self) -> super::vals::Tmos {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmos::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Time Selection"]
            #[inline(always)]
            pub fn set_tmos(&mut self, val: super::vals::Tmos) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Timeout L Count Control"]
            #[inline(always)]
            pub const fn tmol(&self) -> super::vals::Tmol {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tmol::from_bits(val as u8)
            }
            #[doc = "Timeout L Count Control"]
            #[inline(always)]
            pub fn set_tmol(&mut self, val: super::vals::Tmol) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Timeout H Count Control"]
            #[inline(always)]
            pub const fn tmoh(&self) -> super::vals::Tmoh {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tmoh::from_bits(val as u8)
            }
            #[doc = "Timeout H Count Control"]
            #[inline(always)]
            pub fn set_tmoh(&mut self, val: super::vals::Tmoh) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "SDA Output Delay Counter"]
            #[inline(always)]
            pub const fn sddl(&self) -> super::vals::Sddl {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Sddl::from_bits(val as u8)
            }
            #[doc = "SDA Output Delay Counter"]
            #[inline(always)]
            pub fn set_sddl(&mut self, val: super::vals::Sddl) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "SDA Output Delay Clock Source Selection"]
            #[inline(always)]
            pub const fn dlcs(&self) -> super::vals::Dlcs {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dlcs::from_bits(val as u8)
            }
            #[doc = "SDA Output Delay Clock Source Selection"]
            #[inline(always)]
            pub fn set_dlcs(&mut self, val: super::vals::Dlcs) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icmr2 {
            #[inline(always)]
            fn default() -> Icmr2 {
                Icmr2(0)
            }
        }
        impl core::fmt::Debug for Icmr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icmr2")
                    .field("tmos", &self.tmos())
                    .field("tmol", &self.tmol())
                    .field("tmoh", &self.tmoh())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("sddl", &self.sddl())
                    .field("dlcs", &self.dlcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icmr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icmr2 {{ tmos: {:?}, tmol: {:?}, tmoh: {:?}, reserved_3_3: {=bool:?}, sddl: {:?}, dlcs: {:?} }}" , self . tmos () , self . tmol () , self . tmoh () , self . reserved_3_3 () , self . sddl () , self . dlcs ())
            }
        }
        #[doc = "I2C Bus Mode Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icmr3(pub u8);
        impl Icmr3 {
            #[doc = "Noise Filter Stage Selection"]
            #[inline(always)]
            pub const fn nf(&self) -> super::vals::Nf {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nf::from_bits(val as u8)
            }
            #[doc = "Noise Filter Stage Selection"]
            #[inline(always)]
            pub fn set_nf(&mut self, val: super::vals::Nf) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Receive Acknowledge"]
            #[inline(always)]
            pub const fn ackbr(&self) -> super::vals::Ackbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ackbr::from_bits(val as u8)
            }
            #[doc = "Receive Acknowledge"]
            #[inline(always)]
            pub fn set_ackbr(&mut self, val: super::vals::Ackbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmit Acknowledge"]
            #[inline(always)]
            pub const fn ackbt(&self) -> super::vals::Ackbt {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ackbt::from_bits(val as u8)
            }
            #[doc = "Transmit Acknowledge"]
            #[inline(always)]
            pub fn set_ackbt(&mut self, val: super::vals::Ackbt) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "ACKBT Write Protect"]
            #[inline(always)]
            pub const fn ackwp(&self) -> super::vals::Ackwp {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ackwp::from_bits(val as u8)
            }
            #[doc = "ACKBT Write Protect"]
            #[inline(always)]
            pub fn set_ackwp(&mut self, val: super::vals::Ackwp) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "RDRF Flag Set Timing Selection"]
            #[inline(always)]
            pub const fn rdrfs(&self) -> super::vals::Rdrfs {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rdrfs::from_bits(val as u8)
            }
            #[doc = "RDRF Flag Set Timing Selection"]
            #[inline(always)]
            pub fn set_rdrfs(&mut self, val: super::vals::Rdrfs) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand."]
            #[inline(always)]
            pub const fn wait(&self) -> super::vals::Wait {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Wait::from_bits(val as u8)
            }
            #[doc = "WAITNote: When the value of the WAIT bit is to be read, be sure to read the ICDRR beforehand."]
            #[inline(always)]
            pub fn set_wait(&mut self, val: super::vals::Wait) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "SMBus/I2C Bus Selection"]
            #[inline(always)]
            pub const fn smbe(&self) -> super::vals::Smbe {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Smbe::from_bits(val as u8)
            }
            #[doc = "SMBus/I2C Bus Selection"]
            #[inline(always)]
            pub fn set_smbe(&mut self, val: super::vals::Smbe) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icmr3 {
            #[inline(always)]
            fn default() -> Icmr3 {
                Icmr3(0)
            }
        }
        impl core::fmt::Debug for Icmr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icmr3")
                    .field("nf", &self.nf())
                    .field("ackbr", &self.ackbr())
                    .field("ackbt", &self.ackbt())
                    .field("ackwp", &self.ackwp())
                    .field("rdrfs", &self.rdrfs())
                    .field("wait", &self.wait())
                    .field("smbe", &self.smbe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icmr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icmr3 {{ nf: {:?}, ackbr: {:?}, ackbt: {:?}, ackwp: {:?}, rdrfs: {:?}, wait: {:?}, smbe: {:?} }}" , self . nf () , self . ackbr () , self . ackbt () , self . ackwp () , self . rdrfs () , self . wait () , self . smbe ())
            }
        }
        #[doc = "I2C Bus Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icser(pub u8);
        impl Icser {
            #[doc = "Slave Address Register 0 Enable"]
            #[inline(always)]
            pub const fn sar0e(&self) -> super::vals::Sar0e {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sar0e::from_bits(val as u8)
            }
            #[doc = "Slave Address Register 0 Enable"]
            #[inline(always)]
            pub fn set_sar0e(&mut self, val: super::vals::Sar0e) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Slave Address Register 1 Enable"]
            #[inline(always)]
            pub const fn sar1e(&self) -> super::vals::Sar1e {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sar1e::from_bits(val as u8)
            }
            #[doc = "Slave Address Register 1 Enable"]
            #[inline(always)]
            pub fn set_sar1e(&mut self, val: super::vals::Sar1e) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Slave Address Register 2 Enable"]
            #[inline(always)]
            pub const fn sar2e(&self) -> super::vals::Sar2e {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sar2e::from_bits(val as u8)
            }
            #[doc = "Slave Address Register 2 Enable"]
            #[inline(always)]
            pub fn set_sar2e(&mut self, val: super::vals::Sar2e) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "General Call Address Enable"]
            #[inline(always)]
            pub const fn gcae(&self) -> super::vals::Gcae {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Gcae::from_bits(val as u8)
            }
            #[doc = "General Call Address Enable"]
            #[inline(always)]
            pub fn set_gcae(&mut self, val: super::vals::Gcae) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_4_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_4_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "Device,ID Address Detection Enable"]
            #[inline(always)]
            pub const fn dide(&self) -> super::vals::Dide {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Dide::from_bits(val as u8)
            }
            #[doc = "Device,ID Address Detection Enable"]
            #[inline(always)]
            pub fn set_dide(&mut self, val: super::vals::Dide) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "Host Address Enable"]
            #[inline(always)]
            pub const fn hoae(&self) -> super::vals::Hoae {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Hoae::from_bits(val as u8)
            }
            #[doc = "Host Address Enable"]
            #[inline(always)]
            pub fn set_hoae(&mut self, val: super::vals::Hoae) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icser {
            #[inline(always)]
            fn default() -> Icser {
                Icser(0)
            }
        }
        impl core::fmt::Debug for Icser {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icser")
                    .field("sar0e", &self.sar0e())
                    .field("sar1e", &self.sar1e())
                    .field("sar2e", &self.sar2e())
                    .field("gcae", &self.gcae())
                    .field("reserved_4_4", &self.reserved_4_4())
                    .field("dide", &self.dide())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("hoae", &self.hoae())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icser {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icser {{ sar0e: {:?}, sar1e: {:?}, sar2e: {:?}, gcae: {:?}, reserved_4_4: {=bool:?}, dide: {:?}, reserved_6_6: {=bool:?}, hoae: {:?} }}" , self . sar0e () , self . sar1e () , self . sar2e () , self . gcae () , self . reserved_4_4 () , self . dide () , self . reserved_6_6 () , self . hoae ())
            }
        }
        #[doc = "I2C Bus Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icsr1(pub u8);
        impl Icsr1 {
            #[doc = "Slave Address 0 Detection Flag"]
            #[inline(always)]
            pub const fn aas0(&self) -> super::vals::Aas0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Aas0::from_bits(val as u8)
            }
            #[doc = "Slave Address 0 Detection Flag"]
            #[inline(always)]
            pub fn set_aas0(&mut self, val: super::vals::Aas0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Slave Address 1 Detection Flag"]
            #[inline(always)]
            pub const fn aas1(&self) -> super::vals::Aas1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Aas1::from_bits(val as u8)
            }
            #[doc = "Slave Address 1 Detection Flag"]
            #[inline(always)]
            pub fn set_aas1(&mut self, val: super::vals::Aas1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Slave Address 2 Detection Flag"]
            #[inline(always)]
            pub const fn aas2(&self) -> super::vals::Aas2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Aas2::from_bits(val as u8)
            }
            #[doc = "Slave Address 2 Detection Flag"]
            #[inline(always)]
            pub fn set_aas2(&mut self, val: super::vals::Aas2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "General Call Address Detection Flag"]
            #[inline(always)]
            pub const fn gca(&self) -> super::vals::Gca {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Gca::from_bits(val as u8)
            }
            #[doc = "General Call Address Detection Flag"]
            #[inline(always)]
            pub fn set_gca(&mut self, val: super::vals::Gca) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_4_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_4_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "Device,ID Address Detection Flag"]
            #[inline(always)]
            pub const fn did(&self) -> super::vals::Did {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Did::from_bits(val as u8)
            }
            #[doc = "Device,ID Address Detection Flag"]
            #[inline(always)]
            pub fn set_did(&mut self, val: super::vals::Did) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "Host Address Detection Flag"]
            #[inline(always)]
            pub const fn hoa(&self) -> super::vals::Hoa {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Hoa::from_bits(val as u8)
            }
            #[doc = "Host Address Detection Flag"]
            #[inline(always)]
            pub fn set_hoa(&mut self, val: super::vals::Hoa) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icsr1 {
            #[inline(always)]
            fn default() -> Icsr1 {
                Icsr1(0)
            }
        }
        impl core::fmt::Debug for Icsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icsr1")
                    .field("aas0", &self.aas0())
                    .field("aas1", &self.aas1())
                    .field("aas2", &self.aas2())
                    .field("gca", &self.gca())
                    .field("reserved_4_4", &self.reserved_4_4())
                    .field("did", &self.did())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("hoa", &self.hoa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icsr1 {{ aas0: {:?}, aas1: {:?}, aas2: {:?}, gca: {:?}, reserved_4_4: {=bool:?}, did: {:?}, reserved_6_6: {=bool:?}, hoa: {:?} }}" , self . aas0 () , self . aas1 () , self . aas2 () , self . gca () , self . reserved_4_4 () , self . did () , self . reserved_6_6 () , self . hoa ())
            }
        }
        #[doc = "I2C Bus Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icsr2(pub u8);
        impl Icsr2 {
            #[doc = "Timeout Detection Flag"]
            #[inline(always)]
            pub const fn tmof(&self) -> super::vals::Tmof {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmof::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Flag"]
            #[inline(always)]
            pub fn set_tmof(&mut self, val: super::vals::Tmof) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Arbitration,Lost Flag"]
            #[inline(always)]
            pub const fn al(&self) -> super::vals::Al {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Al::from_bits(val as u8)
            }
            #[doc = "Arbitration,Lost Flag"]
            #[inline(always)]
            pub fn set_al(&mut self, val: super::vals::Al) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Start Condition Detection Flag"]
            #[inline(always)]
            pub const fn start(&self) -> super::vals::Start {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Start::from_bits(val as u8)
            }
            #[doc = "Start Condition Detection Flag"]
            #[inline(always)]
            pub fn set_start(&mut self, val: super::vals::Start) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Condition Detection Flag"]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::Stop {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Stop::from_bits(val as u8)
            }
            #[doc = "Stop Condition Detection Flag"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: super::vals::Stop) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "NACK Detection Flag"]
            #[inline(always)]
            pub const fn nackf(&self) -> super::vals::Nackf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nackf::from_bits(val as u8)
            }
            #[doc = "NACK Detection Flag"]
            #[inline(always)]
            pub fn set_nackf(&mut self, val: super::vals::Nackf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::Rdrf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::Rdrf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::Tend {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::Tend) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::Tdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::Tdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icsr2 {
            #[inline(always)]
            fn default() -> Icsr2 {
                Icsr2(0)
            }
        }
        impl core::fmt::Debug for Icsr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icsr2")
                    .field("tmof", &self.tmof())
                    .field("al", &self.al())
                    .field("start", &self.start())
                    .field("stop", &self.stop())
                    .field("nackf", &self.nackf())
                    .field("rdrf", &self.rdrf())
                    .field("tend", &self.tend())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icsr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icsr2 {{ tmof: {:?}, al: {:?}, start: {:?}, stop: {:?}, nackf: {:?}, rdrf: {:?}, tend: {:?}, tdre: {:?} }}" , self . tmof () , self . al () , self . start () , self . stop () , self . nackf () , self . rdrf () , self . tend () , self . tdre ())
            }
        }
        #[doc = "Slave Address Register L%s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sarl(pub u8);
        impl Sarl {
            #[doc = "A slave address is set.7-Bit Address = SVA\\[7:1\\] 10-Bit Address = { SVA9,SVA8,SVA\\[7:0\\] }"]
            #[inline(always)]
            pub const fn sva(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "A slave address is set.7-Bit Address = SVA\\[7:1\\] 10-Bit Address = { SVA9,SVA8,SVA\\[7:0\\] }"]
            #[inline(always)]
            pub fn set_sva(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Sarl {
            #[inline(always)]
            fn default() -> Sarl {
                Sarl(0)
            }
        }
        impl core::fmt::Debug for Sarl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sarl").field("sva", &self.sva()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sarl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sarl {{ sva: {=u8:?} }}", self.sva())
            }
        }
        #[doc = "Slave Address Register U%s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Saru(pub u8);
        impl Saru {
            #[doc = "7-Bit/10-Bit Address Format Selection"]
            #[inline(always)]
            pub const fn fs(&self) -> super::vals::Fs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fs::from_bits(val as u8)
            }
            #[doc = "7-Bit/10-Bit Address Format Selection"]
            #[inline(always)]
            pub fn set_fs(&mut self, val: super::vals::Fs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "10-Bit Address(bit8)"]
            #[inline(always)]
            pub const fn sva8(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "10-Bit Address(bit8)"]
            #[inline(always)]
            pub fn set_sva8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "10-Bit Address(bit9)"]
            #[inline(always)]
            pub const fn sva9(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "10-Bit Address(bit9)"]
            #[inline(always)]
            pub fn set_sva9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Saru {
            #[inline(always)]
            fn default() -> Saru {
                Saru(0)
            }
        }
        impl core::fmt::Debug for Saru {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Saru")
                    .field("fs", &self.fs())
                    .field("sva8", &self.sva8())
                    .field("sva9", &self.sva9())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Saru {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Saru {{ fs: {:?}, sva8: {=bool:?}, sva9: {=bool:?}, reserved_3_7: {=u8:?} }}",
                    self.fs(),
                    self.sva8(),
                    self.sva9(),
                    self.reserved_3_7()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aas0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aas0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aas0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aas0 {
            #[inline(always)]
            fn from(val: u8) -> Aas0 {
                Aas0::from_bits(val)
            }
        }
        impl From<Aas0> for u8 {
            #[inline(always)]
            fn from(val: Aas0) -> u8 {
                Aas0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aas1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aas1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aas1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aas1 {
            #[inline(always)]
            fn from(val: u8) -> Aas1 {
                Aas1::from_bits(val)
            }
        }
        impl From<Aas1> for u8 {
            #[inline(always)]
            fn from(val: Aas1) -> u8 {
                Aas1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aas2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aas2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aas2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aas2 {
            #[inline(always)]
            fn from(val: u8) -> Aas2 {
                Aas2::from_bits(val)
            }
        }
        impl From<Aas2> for u8 {
            #[inline(always)]
            fn from(val: Aas2) -> u8 {
                Aas2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackbr {
            #[inline(always)]
            fn from(val: u8) -> Ackbr {
                Ackbr::from_bits(val)
            }
        }
        impl From<Ackbr> for u8 {
            #[inline(always)]
            fn from(val: Ackbr) -> u8 {
                Ackbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackbt {
            #[inline(always)]
            fn from(val: u8) -> Ackbt {
                Ackbt::from_bits(val)
            }
        }
        impl From<Ackbt> for u8 {
            #[inline(always)]
            fn from(val: Ackbt) -> u8 {
                Ackbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackwp {
            #[inline(always)]
            fn from(val: u8) -> Ackwp {
                Ackwp::from_bits(val)
            }
        }
        impl From<Ackwp> for u8 {
            #[inline(always)]
            fn from(val: Ackwp) -> u8 {
                Ackwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Al {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Al {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Al {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Al {
            #[inline(always)]
            fn from(val: u8) -> Al {
                Al::from_bits(val)
            }
        }
        impl From<Al> for u8 {
            #[inline(always)]
            fn from(val: Al) -> u8 {
                Al::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Alie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Alie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Alie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Alie {
            #[inline(always)]
            fn from(val: u8) -> Alie {
                Alie::from_bits(val)
            }
        }
        impl From<Alie> for u8 {
            #[inline(always)]
            fn from(val: Alie) -> u8 {
                Alie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bbsy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bbsy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bbsy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bbsy {
            #[inline(always)]
            fn from(val: u8) -> Bbsy {
                Bbsy::from_bits(val)
            }
        }
        impl From<Bbsy> for u8 {
            #[inline(always)]
            fn from(val: Bbsy) -> u8 {
                Bbsy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Bc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bc {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bc {
            #[inline(always)]
            fn from(val: u8) -> Bc {
                Bc::from_bits(val)
            }
        }
        impl From<Bc> for u8 {
            #[inline(always)]
            fn from(val: Bc) -> u8 {
                Bc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bcwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcwp {
            #[inline(always)]
            fn from(val: u8) -> Bcwp {
                Bcwp::from_bits(val)
            }
        }
        impl From<Bcwp> for u8 {
            #[inline(always)]
            fn from(val: Bcwp) -> u8 {
                Bcwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cks {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cks {
            #[inline(always)]
            fn from(val: u8) -> Cks {
                Cks::from_bits(val)
            }
        }
        impl From<Cks> for u8 {
            #[inline(always)]
            fn from(val: Cks) -> u8 {
                Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clo {
            #[inline(always)]
            fn from(val: u8) -> Clo {
                Clo::from_bits(val)
            }
        }
        impl From<Clo> for u8 {
            #[inline(always)]
            fn from(val: Clo) -> u8 {
                Clo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Did {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Did {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Did {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Did {
            #[inline(always)]
            fn from(val: u8) -> Did {
                Did::from_bits(val)
            }
        }
        impl From<Did> for u8 {
            #[inline(always)]
            fn from(val: Did) -> u8 {
                Did::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dide {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dide {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dide {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dide {
            #[inline(always)]
            fn from(val: u8) -> Dide {
                Dide::from_bits(val)
            }
        }
        impl From<Dide> for u8 {
            #[inline(always)]
            fn from(val: Dide) -> u8 {
                Dide::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dlcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dlcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dlcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dlcs {
            #[inline(always)]
            fn from(val: u8) -> Dlcs {
                Dlcs::from_bits(val)
            }
        }
        impl From<Dlcs> for u8 {
            #[inline(always)]
            fn from(val: Dlcs) -> u8 {
                Dlcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fs {
            #[inline(always)]
            fn from(val: u8) -> Fs {
                Fs::from_bits(val)
            }
        }
        impl From<Fs> for u8 {
            #[inline(always)]
            fn from(val: Fs) -> u8 {
                Fs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gca {
            #[inline(always)]
            fn from(val: u8) -> Gca {
                Gca::from_bits(val)
            }
        }
        impl From<Gca> for u8 {
            #[inline(always)]
            fn from(val: Gca) -> u8 {
                Gca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gcae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gcae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gcae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gcae {
            #[inline(always)]
            fn from(val: u8) -> Gcae {
                Gcae::from_bits(val)
            }
        }
        impl From<Gcae> for u8 {
            #[inline(always)]
            fn from(val: Gcae) -> u8 {
                Gcae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hoa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hoa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hoa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hoa {
            #[inline(always)]
            fn from(val: u8) -> Hoa {
                Hoa::from_bits(val)
            }
        }
        impl From<Hoa> for u8 {
            #[inline(always)]
            fn from(val: Hoa) -> u8 {
                Hoa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hoae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hoae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hoae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hoae {
            #[inline(always)]
            fn from(val: u8) -> Hoae {
                Hoae::from_bits(val)
            }
        }
        impl From<Hoae> for u8 {
            #[inline(always)]
            fn from(val: Hoae) -> u8 {
                Hoae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ice {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ice {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ice {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ice {
            #[inline(always)]
            fn from(val: u8) -> Ice {
                Ice::from_bits(val)
            }
        }
        impl From<Ice> for u8 {
            #[inline(always)]
            fn from(val: Ice) -> u8 {
                Ice::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicrst {
            #[inline(always)]
            fn from(val: u8) -> Iicrst {
                Iicrst::from_bits(val)
            }
        }
        impl From<Iicrst> for u8 {
            #[inline(always)]
            fn from(val: Iicrst) -> u8 {
                Iicrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Male {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Male {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Male {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Male {
            #[inline(always)]
            fn from(val: u8) -> Male {
                Male::from_bits(val)
            }
        }
        impl From<Male> for u8 {
            #[inline(always)]
            fn from(val: Male) -> u8 {
                Male::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mst {
            #[inline(always)]
            fn from(val: u8) -> Mst {
                Mst::from_bits(val)
            }
        }
        impl From<Mst> for u8 {
            #[inline(always)]
            fn from(val: Mst) -> u8 {
                Mst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mtwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mtwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mtwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mtwp {
            #[inline(always)]
            fn from(val: u8) -> Mtwp {
                Mtwp::from_bits(val)
            }
        }
        impl From<Mtwp> for u8 {
            #[inline(always)]
            fn from(val: Mtwp) -> u8 {
                Mtwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nacke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nacke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nacke {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nacke {
            #[inline(always)]
            fn from(val: u8) -> Nacke {
                Nacke::from_bits(val)
            }
        }
        impl From<Nacke> for u8 {
            #[inline(always)]
            fn from(val: Nacke) -> u8 {
                Nacke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nackf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nackf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nackf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nackf {
            #[inline(always)]
            fn from(val: u8) -> Nackf {
                Nackf::from_bits(val)
            }
        }
        impl From<Nackf> for u8 {
            #[inline(always)]
            fn from(val: Nackf) -> u8 {
                Nackf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nakie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nakie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nakie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nakie {
            #[inline(always)]
            fn from(val: u8) -> Nakie {
                Nakie::from_bits(val)
            }
        }
        impl From<Nakie> for u8 {
            #[inline(always)]
            fn from(val: Nakie) -> u8 {
                Nakie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nale {
            #[inline(always)]
            fn from(val: u8) -> Nale {
                Nale::from_bits(val)
            }
        }
        impl From<Nale> for u8 {
            #[inline(always)]
            fn from(val: Nale) -> u8 {
                Nale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nf {
            #[inline(always)]
            fn from(val: u8) -> Nf {
                Nf::from_bits(val)
            }
        }
        impl From<Nf> for u8 {
            #[inline(always)]
            fn from(val: Nf) -> u8 {
                Nf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfe {
            #[inline(always)]
            fn from(val: u8) -> Nfe {
                Nfe::from_bits(val)
            }
        }
        impl From<Nfe> for u8 {
            #[inline(always)]
            fn from(val: Nfe) -> u8 {
                Nfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdrf {
            #[inline(always)]
            fn from(val: u8) -> Rdrf {
                Rdrf::from_bits(val)
            }
        }
        impl From<Rdrf> for u8 {
            #[inline(always)]
            fn from(val: Rdrf) -> u8 {
                Rdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdrfs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdrfs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdrfs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdrfs {
            #[inline(always)]
            fn from(val: u8) -> Rdrfs {
                Rdrfs::from_bits(val)
            }
        }
        impl From<Rdrfs> for u8 {
            #[inline(always)]
            fn from(val: Rdrfs) -> u8 {
                Rdrfs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rie {
            #[inline(always)]
            fn from(val: u8) -> Rie {
                Rie::from_bits(val)
            }
        }
        impl From<Rie> for u8 {
            #[inline(always)]
            fn from(val: Rie) -> u8 {
                Rie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rs {
            #[inline(always)]
            fn from(val: u8) -> Rs {
                Rs::from_bits(val)
            }
        }
        impl From<Rs> for u8 {
            #[inline(always)]
            fn from(val: Rs) -> u8 {
                Rs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sale {
            #[inline(always)]
            fn from(val: u8) -> Sale {
                Sale::from_bits(val)
            }
        }
        impl From<Sale> for u8 {
            #[inline(always)]
            fn from(val: Sale) -> u8 {
                Sale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sar0e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sar0e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sar0e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sar0e {
            #[inline(always)]
            fn from(val: u8) -> Sar0e {
                Sar0e::from_bits(val)
            }
        }
        impl From<Sar0e> for u8 {
            #[inline(always)]
            fn from(val: Sar0e) -> u8 {
                Sar0e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sar1e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sar1e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sar1e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sar1e {
            #[inline(always)]
            fn from(val: u8) -> Sar1e {
                Sar1e::from_bits(val)
            }
        }
        impl From<Sar1e> for u8 {
            #[inline(always)]
            fn from(val: Sar1e) -> u8 {
                Sar1e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sar2e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sar2e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sar2e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sar2e {
            #[inline(always)]
            fn from(val: u8) -> Sar2e {
                Sar2e::from_bits(val)
            }
        }
        impl From<Sar2e> for u8 {
            #[inline(always)]
            fn from(val: Sar2e) -> u8 {
                Sar2e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scle {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scle {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scle {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scle {
            #[inline(always)]
            fn from(val: u8) -> Scle {
                Scle::from_bits(val)
            }
        }
        impl From<Scle> for u8 {
            #[inline(always)]
            fn from(val: Scle) -> u8 {
                Scle::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scli {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scli {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scli {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scli {
            #[inline(always)]
            fn from(val: u8) -> Scli {
                Scli::from_bits(val)
            }
        }
        impl From<Scli> for u8 {
            #[inline(always)]
            fn from(val: Scli) -> u8 {
                Scli::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sclo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sclo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sclo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sclo {
            #[inline(always)]
            fn from(val: u8) -> Sclo {
                Sclo::from_bits(val)
            }
        }
        impl From<Sclo> for u8 {
            #[inline(always)]
            fn from(val: Sclo) -> u8 {
                Sclo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdai {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdai {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdai {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdai {
            #[inline(always)]
            fn from(val: u8) -> Sdai {
                Sdai::from_bits(val)
            }
        }
        impl From<Sdai> for u8 {
            #[inline(always)]
            fn from(val: Sdai) -> u8 {
                Sdai::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdao {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdao {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdao {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdao {
            #[inline(always)]
            fn from(val: u8) -> Sdao {
                Sdao::from_bits(val)
            }
        }
        impl From<Sdao> for u8 {
            #[inline(always)]
            fn from(val: Sdao) -> u8 {
                Sdao::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sddl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sddl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sddl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sddl {
            #[inline(always)]
            fn from(val: u8) -> Sddl {
                Sddl::from_bits(val)
            }
        }
        impl From<Sddl> for u8 {
            #[inline(always)]
            fn from(val: Sddl) -> u8 {
                Sddl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smbe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smbe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smbe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smbe {
            #[inline(always)]
            fn from(val: u8) -> Smbe {
                Smbe::from_bits(val)
            }
        }
        impl From<Smbe> for u8 {
            #[inline(always)]
            fn from(val: Smbe) -> u8 {
                Smbe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sowp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sowp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sowp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sowp {
            #[inline(always)]
            fn from(val: u8) -> Sowp {
                Sowp::from_bits(val)
            }
        }
        impl From<Sowp> for u8 {
            #[inline(always)]
            fn from(val: Sowp) -> u8 {
                Sowp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sp {
            #[inline(always)]
            fn from(val: u8) -> Sp {
                Sp::from_bits(val)
            }
        }
        impl From<Sp> for u8 {
            #[inline(always)]
            fn from(val: Sp) -> u8 {
                Sp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spie {
            #[inline(always)]
            fn from(val: u8) -> Spie {
                Spie::from_bits(val)
            }
        }
        impl From<Spie> for u8 {
            #[inline(always)]
            fn from(val: Spie) -> u8 {
                Spie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St {
            #[inline(always)]
            fn from(val: u8) -> St {
                St::from_bits(val)
            }
        }
        impl From<St> for u8 {
            #[inline(always)]
            fn from(val: St) -> u8 {
                St::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Start {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Start {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Start {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Start {
            #[inline(always)]
            fn from(val: u8) -> Start {
                Start::from_bits(val)
            }
        }
        impl From<Start> for u8 {
            #[inline(always)]
            fn from(val: Start) -> u8 {
                Start::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stie {
            #[inline(always)]
            fn from(val: u8) -> Stie {
                Stie::from_bits(val)
            }
        }
        impl From<Stie> for u8 {
            #[inline(always)]
            fn from(val: Stie) -> u8 {
                Stie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stop {
            #[inline(always)]
            fn from(val: u8) -> Stop {
                Stop::from_bits(val)
            }
        }
        impl From<Stop> for u8 {
            #[inline(always)]
            fn from(val: Stop) -> u8 {
                Stop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdre {
            #[inline(always)]
            fn from(val: u8) -> Tdre {
                Tdre::from_bits(val)
            }
        }
        impl From<Tdre> for u8 {
            #[inline(always)]
            fn from(val: Tdre) -> u8 {
                Tdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teie {
            #[inline(always)]
            fn from(val: u8) -> Teie {
                Teie::from_bits(val)
            }
        }
        impl From<Teie> for u8 {
            #[inline(always)]
            fn from(val: Teie) -> u8 {
                Teie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tend {
            #[inline(always)]
            fn from(val: u8) -> Tend {
                Tend::from_bits(val)
            }
        }
        impl From<Tend> for u8 {
            #[inline(always)]
            fn from(val: Tend) -> u8 {
                Tend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tie {
            #[inline(always)]
            fn from(val: u8) -> Tie {
                Tie::from_bits(val)
            }
        }
        impl From<Tie> for u8 {
            #[inline(always)]
            fn from(val: Tie) -> u8 {
                Tie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmoe {
            #[inline(always)]
            fn from(val: u8) -> Tmoe {
                Tmoe::from_bits(val)
            }
        }
        impl From<Tmoe> for u8 {
            #[inline(always)]
            fn from(val: Tmoe) -> u8 {
                Tmoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmof {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmof {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmof {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmof {
            #[inline(always)]
            fn from(val: u8) -> Tmof {
                Tmof::from_bits(val)
            }
        }
        impl From<Tmof> for u8 {
            #[inline(always)]
            fn from(val: Tmof) -> u8 {
                Tmof::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmoh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmoh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmoh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmoh {
            #[inline(always)]
            fn from(val: u8) -> Tmoh {
                Tmoh::from_bits(val)
            }
        }
        impl From<Tmoh> for u8 {
            #[inline(always)]
            fn from(val: Tmoh) -> u8 {
                Tmoh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmoie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmoie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmoie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmoie {
            #[inline(always)]
            fn from(val: u8) -> Tmoie {
                Tmoie::from_bits(val)
            }
        }
        impl From<Tmoie> for u8 {
            #[inline(always)]
            fn from(val: Tmoie) -> u8 {
                Tmoie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmol {
            #[inline(always)]
            fn from(val: u8) -> Tmol {
                Tmol::from_bits(val)
            }
        }
        impl From<Tmol> for u8 {
            #[inline(always)]
            fn from(val: Tmol) -> u8 {
                Tmol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmos {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmos {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmos {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmos {
            #[inline(always)]
            fn from(val: u8) -> Tmos {
                Tmos::from_bits(val)
            }
        }
        impl From<Tmos> for u8 {
            #[inline(always)]
            fn from(val: Tmos) -> u8 {
                Tmos::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trs {
            #[inline(always)]
            fn from(val: u8) -> Trs {
                Trs::from_bits(val)
            }
        }
        impl From<Trs> for u8 {
            #[inline(always)]
            fn from(val: Trs) -> u8 {
                Trs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wait {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wait {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wait {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wait {
            #[inline(always)]
            fn from(val: u8) -> Wait {
                Wait::from_bits(val)
            }
        }
        impl From<Wait> for u8 {
            #[inline(always)]
            fn from(val: Wait) -> u8 {
                Wait::to_bits(val)
            }
        }
    }
}
pub mod iwdt {
    #[doc = "Independent Watchdog Timer"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iwdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Iwdt {}
    unsafe impl Sync for Iwdt {}
    impl Iwdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IWDT Refresh Register"]
        #[inline(always)]
        pub const fn iwdtrr(self) -> crate::common::Reg<regs::Iwdtrr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "IWDT Status Register"]
        #[inline(always)]
        pub const fn iwdtsr(self) -> crate::common::Reg<regs::Iwdtsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "IWDT Refresh Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iwdtrr(pub u8);
        impl Iwdtrr {
            #[doc = "The counter is refreshed by writing 0x00 and then writing 0xFF to this register."]
            #[inline(always)]
            pub const fn iwdtrr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The counter is refreshed by writing 0x00 and then writing 0xFF to this register."]
            #[inline(always)]
            pub fn set_iwdtrr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Iwdtrr {
            #[inline(always)]
            fn default() -> Iwdtrr {
                Iwdtrr(0)
            }
        }
        impl core::fmt::Debug for Iwdtrr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iwdtrr")
                    .field("iwdtrr", &self.iwdtrr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iwdtrr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Iwdtrr {{ iwdtrr: {=u8:?} }}", self.iwdtrr())
            }
        }
        #[doc = "IWDT Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iwdtsr(pub u16);
        impl Iwdtsr {
            #[doc = "Counter ValueValue counted by the counter"]
            #[inline(always)]
            pub const fn cntval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Counter ValueValue counted by the counter"]
            #[inline(always)]
            pub fn set_cntval(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u16) & 0x3fff) << 0usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn undff(&self) -> super::vals::Undff {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Undff::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_undff(&mut self, val: super::vals::Undff) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub const fn refef(&self) -> super::vals::Refef {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Refef::from_bits(val as u8)
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub fn set_refef(&mut self, val: super::vals::Refef) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Iwdtsr {
            #[inline(always)]
            fn default() -> Iwdtsr {
                Iwdtsr(0)
            }
        }
        impl core::fmt::Debug for Iwdtsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iwdtsr")
                    .field("cntval", &self.cntval())
                    .field("undff", &self.undff())
                    .field("refef", &self.refef())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iwdtsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Iwdtsr {{ cntval: {=u16:?}, undff: {:?}, refef: {:?} }}",
                    self.cntval(),
                    self.undff(),
                    self.refef()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Refef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refef {
            #[inline(always)]
            fn from(val: u8) -> Refef {
                Refef::from_bits(val)
            }
        }
        impl From<Refef> for u8 {
            #[inline(always)]
            fn from(val: Refef) -> u8 {
                Refef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Undff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Undff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Undff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Undff {
            #[inline(always)]
            fn from(val: u8) -> Undff {
                Undff::from_bits(val)
            }
        }
        impl From<Undff> for u8 {
            #[inline(always)]
            fn from(val: Undff) -> u8 {
                Undff::to_bits(val)
            }
        }
    }
}
pub mod kint {
    #[doc = "Key Interrupt Function"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Kint {
        ptr: *mut u8,
    }
    unsafe impl Send for Kint {}
    unsafe impl Sync for Kint {}
    impl Kint {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "KEY Return Control Register"]
        #[inline(always)]
        pub const fn krctl(self) -> crate::common::Reg<regs::Krctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "KEY Return Flag Register"]
        #[inline(always)]
        pub const fn krf(self) -> crate::common::Reg<regs::Krf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "KEY Return Mode Register"]
        #[inline(always)]
        pub const fn krm(self) -> crate::common::Reg<regs::Krm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "KEY Return Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Krctl(pub u8);
        impl Krctl {
            #[doc = "Detection Edge Selection (KRF0 to KRF7)"]
            #[inline(always)]
            pub const fn kreg(&self) -> super::vals::Kreg {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Kreg::from_bits(val as u8)
            }
            #[doc = "Detection Edge Selection (KRF0 to KRF7)"]
            #[inline(always)]
            pub fn set_kreg(&mut self, val: super::vals::Kreg) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_1_6(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_1_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 1usize)) | (((val as u8) & 0x3f) << 1usize);
            }
            #[doc = "Usage of Key Interrupt Flags(KR0 to KR7)"]
            #[inline(always)]
            pub const fn krmd(&self) -> super::vals::Krmd {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Krmd::from_bits(val as u8)
            }
            #[doc = "Usage of Key Interrupt Flags(KR0 to KR7)"]
            #[inline(always)]
            pub fn set_krmd(&mut self, val: super::vals::Krmd) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Krctl {
            #[inline(always)]
            fn default() -> Krctl {
                Krctl(0)
            }
        }
        impl core::fmt::Debug for Krctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Krctl")
                    .field("kreg", &self.kreg())
                    .field("reserved_1_6", &self.reserved_1_6())
                    .field("krmd", &self.krmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Krctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Krctl {{ kreg: {:?}, reserved_1_6: {=u8:?}, krmd: {:?} }}",
                    self.kreg(),
                    self.reserved_1_6(),
                    self.krmd()
                )
            }
        }
        #[doc = "KEY Return Flag Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Krf(pub u8);
        impl Krf {
            #[doc = "Key interrupt flag 0"]
            #[inline(always)]
            pub const fn krf0(&self) -> super::vals::Krf0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Krf0::from_bits(val as u8)
            }
            #[doc = "Key interrupt flag 0"]
            #[inline(always)]
            pub fn set_krf0(&mut self, val: super::vals::Krf0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Key interrupt flag 1"]
            #[inline(always)]
            pub const fn krf1(&self) -> super::vals::Krf1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Krf1::from_bits(val as u8)
            }
            #[doc = "Key interrupt flag 1"]
            #[inline(always)]
            pub fn set_krf1(&mut self, val: super::vals::Krf1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Key interrupt flag 2"]
            #[inline(always)]
            pub const fn krf2(&self) -> super::vals::Krf2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Krf2::from_bits(val as u8)
            }
            #[doc = "Key interrupt flag 2"]
            #[inline(always)]
            pub fn set_krf2(&mut self, val: super::vals::Krf2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Key interrupt flag 3"]
            #[inline(always)]
            pub const fn krf3(&self) -> super::vals::Krf3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Krf3::from_bits(val as u8)
            }
            #[doc = "Key interrupt flag 3"]
            #[inline(always)]
            pub fn set_krf3(&mut self, val: super::vals::Krf3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Key interrupt flag 4"]
            #[inline(always)]
            pub const fn krf4(&self) -> super::vals::Krf4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Krf4::from_bits(val as u8)
            }
            #[doc = "Key interrupt flag 4"]
            #[inline(always)]
            pub fn set_krf4(&mut self, val: super::vals::Krf4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Key interrupt flag 5"]
            #[inline(always)]
            pub const fn krf5(&self) -> super::vals::Krf5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Krf5::from_bits(val as u8)
            }
            #[doc = "Key interrupt flag 5"]
            #[inline(always)]
            pub fn set_krf5(&mut self, val: super::vals::Krf5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Key interrupt flag 6"]
            #[inline(always)]
            pub const fn krf6(&self) -> super::vals::Krf6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Krf6::from_bits(val as u8)
            }
            #[doc = "Key interrupt flag 6"]
            #[inline(always)]
            pub fn set_krf6(&mut self, val: super::vals::Krf6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Key interrupt flag 7"]
            #[inline(always)]
            pub const fn krf7(&self) -> super::vals::Krf7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Krf7::from_bits(val as u8)
            }
            #[doc = "Key interrupt flag 7"]
            #[inline(always)]
            pub fn set_krf7(&mut self, val: super::vals::Krf7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Krf {
            #[inline(always)]
            fn default() -> Krf {
                Krf(0)
            }
        }
        impl core::fmt::Debug for Krf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Krf")
                    .field("krf0", &self.krf0())
                    .field("krf1", &self.krf1())
                    .field("krf2", &self.krf2())
                    .field("krf3", &self.krf3())
                    .field("krf4", &self.krf4())
                    .field("krf5", &self.krf5())
                    .field("krf6", &self.krf6())
                    .field("krf7", &self.krf7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Krf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Krf {{ krf0: {:?}, krf1: {:?}, krf2: {:?}, krf3: {:?}, krf4: {:?}, krf5: {:?}, krf6: {:?}, krf7: {:?} }}" , self . krf0 () , self . krf1 () , self . krf2 () , self . krf3 () , self . krf4 () , self . krf5 () , self . krf6 () , self . krf7 ())
            }
        }
        #[doc = "KEY Return Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Krm(pub u8);
        impl Krm {
            #[doc = "Key interrupt mode control 0"]
            #[inline(always)]
            pub const fn krm0(&self) -> super::vals::Krm0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Krm0::from_bits(val as u8)
            }
            #[doc = "Key interrupt mode control 0"]
            #[inline(always)]
            pub fn set_krm0(&mut self, val: super::vals::Krm0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Key interrupt mode control 1"]
            #[inline(always)]
            pub const fn krm1(&self) -> super::vals::Krm1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Krm1::from_bits(val as u8)
            }
            #[doc = "Key interrupt mode control 1"]
            #[inline(always)]
            pub fn set_krm1(&mut self, val: super::vals::Krm1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Key interrupt mode control 2"]
            #[inline(always)]
            pub const fn krm2(&self) -> super::vals::Krm2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Krm2::from_bits(val as u8)
            }
            #[doc = "Key interrupt mode control 2"]
            #[inline(always)]
            pub fn set_krm2(&mut self, val: super::vals::Krm2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Key interrupt mode control 3"]
            #[inline(always)]
            pub const fn krm3(&self) -> super::vals::Krm3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Krm3::from_bits(val as u8)
            }
            #[doc = "Key interrupt mode control 3"]
            #[inline(always)]
            pub fn set_krm3(&mut self, val: super::vals::Krm3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Key interrupt mode control 4"]
            #[inline(always)]
            pub const fn krm4(&self) -> super::vals::Krm4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Krm4::from_bits(val as u8)
            }
            #[doc = "Key interrupt mode control 4"]
            #[inline(always)]
            pub fn set_krm4(&mut self, val: super::vals::Krm4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Key interrupt mode control 5"]
            #[inline(always)]
            pub const fn krm5(&self) -> super::vals::Krm5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Krm5::from_bits(val as u8)
            }
            #[doc = "Key interrupt mode control 5"]
            #[inline(always)]
            pub fn set_krm5(&mut self, val: super::vals::Krm5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Key interrupt mode control 6"]
            #[inline(always)]
            pub const fn krm6(&self) -> super::vals::Krm6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Krm6::from_bits(val as u8)
            }
            #[doc = "Key interrupt mode control 6"]
            #[inline(always)]
            pub fn set_krm6(&mut self, val: super::vals::Krm6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Key interrupt mode control 7"]
            #[inline(always)]
            pub const fn krm7(&self) -> super::vals::Krm7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Krm7::from_bits(val as u8)
            }
            #[doc = "Key interrupt mode control 7"]
            #[inline(always)]
            pub fn set_krm7(&mut self, val: super::vals::Krm7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Krm {
            #[inline(always)]
            fn default() -> Krm {
                Krm(0)
            }
        }
        impl core::fmt::Debug for Krm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Krm")
                    .field("krm0", &self.krm0())
                    .field("krm1", &self.krm1())
                    .field("krm2", &self.krm2())
                    .field("krm3", &self.krm3())
                    .field("krm4", &self.krm4())
                    .field("krm5", &self.krm5())
                    .field("krm6", &self.krm6())
                    .field("krm7", &self.krm7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Krm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Krm {{ krm0: {:?}, krm1: {:?}, krm2: {:?}, krm3: {:?}, krm4: {:?}, krm5: {:?}, krm6: {:?}, krm7: {:?} }}" , self . krm0 () , self . krm1 () , self . krm2 () , self . krm3 () , self . krm4 () , self . krm5 () , self . krm6 () , self . krm7 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kreg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kreg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kreg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kreg {
            #[inline(always)]
            fn from(val: u8) -> Kreg {
                Kreg::from_bits(val)
            }
        }
        impl From<Kreg> for u8 {
            #[inline(always)]
            fn from(val: Kreg) -> u8 {
                Kreg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krf0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krf0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krf0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krf0 {
            #[inline(always)]
            fn from(val: u8) -> Krf0 {
                Krf0::from_bits(val)
            }
        }
        impl From<Krf0> for u8 {
            #[inline(always)]
            fn from(val: Krf0) -> u8 {
                Krf0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krf1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krf1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krf1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krf1 {
            #[inline(always)]
            fn from(val: u8) -> Krf1 {
                Krf1::from_bits(val)
            }
        }
        impl From<Krf1> for u8 {
            #[inline(always)]
            fn from(val: Krf1) -> u8 {
                Krf1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krf2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krf2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krf2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krf2 {
            #[inline(always)]
            fn from(val: u8) -> Krf2 {
                Krf2::from_bits(val)
            }
        }
        impl From<Krf2> for u8 {
            #[inline(always)]
            fn from(val: Krf2) -> u8 {
                Krf2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krf3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krf3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krf3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krf3 {
            #[inline(always)]
            fn from(val: u8) -> Krf3 {
                Krf3::from_bits(val)
            }
        }
        impl From<Krf3> for u8 {
            #[inline(always)]
            fn from(val: Krf3) -> u8 {
                Krf3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krf4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krf4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krf4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krf4 {
            #[inline(always)]
            fn from(val: u8) -> Krf4 {
                Krf4::from_bits(val)
            }
        }
        impl From<Krf4> for u8 {
            #[inline(always)]
            fn from(val: Krf4) -> u8 {
                Krf4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krf5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krf5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krf5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krf5 {
            #[inline(always)]
            fn from(val: u8) -> Krf5 {
                Krf5::from_bits(val)
            }
        }
        impl From<Krf5> for u8 {
            #[inline(always)]
            fn from(val: Krf5) -> u8 {
                Krf5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krf6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krf6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krf6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krf6 {
            #[inline(always)]
            fn from(val: u8) -> Krf6 {
                Krf6::from_bits(val)
            }
        }
        impl From<Krf6> for u8 {
            #[inline(always)]
            fn from(val: Krf6) -> u8 {
                Krf6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krf7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krf7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krf7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krf7 {
            #[inline(always)]
            fn from(val: u8) -> Krf7 {
                Krf7::from_bits(val)
            }
        }
        impl From<Krf7> for u8 {
            #[inline(always)]
            fn from(val: Krf7) -> u8 {
                Krf7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krm0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krm0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krm0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krm0 {
            #[inline(always)]
            fn from(val: u8) -> Krm0 {
                Krm0::from_bits(val)
            }
        }
        impl From<Krm0> for u8 {
            #[inline(always)]
            fn from(val: Krm0) -> u8 {
                Krm0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krm1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krm1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krm1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krm1 {
            #[inline(always)]
            fn from(val: u8) -> Krm1 {
                Krm1::from_bits(val)
            }
        }
        impl From<Krm1> for u8 {
            #[inline(always)]
            fn from(val: Krm1) -> u8 {
                Krm1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krm2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krm2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krm2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krm2 {
            #[inline(always)]
            fn from(val: u8) -> Krm2 {
                Krm2::from_bits(val)
            }
        }
        impl From<Krm2> for u8 {
            #[inline(always)]
            fn from(val: Krm2) -> u8 {
                Krm2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krm3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krm3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krm3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krm3 {
            #[inline(always)]
            fn from(val: u8) -> Krm3 {
                Krm3::from_bits(val)
            }
        }
        impl From<Krm3> for u8 {
            #[inline(always)]
            fn from(val: Krm3) -> u8 {
                Krm3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krm4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krm4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krm4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krm4 {
            #[inline(always)]
            fn from(val: u8) -> Krm4 {
                Krm4::from_bits(val)
            }
        }
        impl From<Krm4> for u8 {
            #[inline(always)]
            fn from(val: Krm4) -> u8 {
                Krm4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krm5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krm5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krm5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krm5 {
            #[inline(always)]
            fn from(val: u8) -> Krm5 {
                Krm5::from_bits(val)
            }
        }
        impl From<Krm5> for u8 {
            #[inline(always)]
            fn from(val: Krm5) -> u8 {
                Krm5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krm6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krm6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krm6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krm6 {
            #[inline(always)]
            fn from(val: u8) -> Krm6 {
                Krm6::from_bits(val)
            }
        }
        impl From<Krm6> for u8 {
            #[inline(always)]
            fn from(val: Krm6) -> u8 {
                Krm6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krm7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krm7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krm7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krm7 {
            #[inline(always)]
            fn from(val: u8) -> Krm7 {
                Krm7::from_bits(val)
            }
        }
        impl From<Krm7> for u8 {
            #[inline(always)]
            fn from(val: Krm7) -> u8 {
                Krm7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krmd {
            #[inline(always)]
            fn from(val: u8) -> Krmd {
                Krmd::from_bits(val)
            }
        }
        impl From<Krmd> for u8 {
            #[inline(always)]
            fn from(val: Krmd) -> u8 {
                Krmd::to_bits(val)
            }
        }
    }
}
pub mod mmf {
    #[doc = "Memory Mirror Function"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mmf {
        ptr: *mut u8,
    }
    unsafe impl Send for Mmf {}
    unsafe impl Sync for Mmf {}
    impl Mmf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "MemMirror Special Function Register"]
        #[inline(always)]
        pub const fn mmsfr(self) -> crate::common::Reg<regs::Mmsfr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "MemMirror Enable Register"]
        #[inline(always)]
        pub const fn mmen(self) -> crate::common::Reg<regs::Mmen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "MemMirror Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmen(pub u32);
        impl Mmen {
            #[doc = "Memory Mirror Function Enable"]
            #[inline(always)]
            pub const fn en(&self) -> super::vals::En {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::En::from_bits(val as u8)
            }
            #[doc = "Memory Mirror Function Enable"]
            #[inline(always)]
            pub fn set_en(&mut self, val: super::vals::En) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 00000000000000000000000. The write value should be 00000000000000000000000."]
            #[inline(always)]
            pub const fn reserved_1_23(&self) -> u32 {
                let val = (self.0 >> 1usize) & 0x007f_ffff;
                val as u32
            }
            #[doc = "These bits are read as 00000000000000000000000. The write value should be 00000000000000000000000."]
            #[inline(always)]
            pub fn set_reserved_1_23(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x007f_ffff << 1usize)) | (((val as u32) & 0x007f_ffff) << 1usize);
            }
            #[doc = "MMEN Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::MmenKey {
                let val = (self.0 >> 24usize) & 0xff;
                super::vals::MmenKey::from_bits(val as u8)
            }
            #[doc = "MMEN Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::MmenKey) {
                self.0 =
                    (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Mmen {
            #[inline(always)]
            fn default() -> Mmen {
                Mmen(0)
            }
        }
        impl core::fmt::Debug for Mmen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmen")
                    .field("en", &self.en())
                    .field("reserved_1_23", &self.reserved_1_23())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmen {{ en: {:?}, reserved_1_23: {=u32:?}, key: {:?} }}",
                    self.en(),
                    self.reserved_1_23(),
                    self.key()
                )
            }
        }
        #[doc = "MemMirror Special Function Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmsfr(pub u32);
        impl Mmsfr {
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_0_6(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_0_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Specifies the memory mirror address.NOTE: A value cannot be set in the low,order 7 bits. These bits are fixed to 0."]
            #[inline(always)]
            pub const fn memmiraddr(&self) -> u16 {
                let val = (self.0 >> 7usize) & 0xffff;
                val as u16
            }
            #[doc = "Specifies the memory mirror address.NOTE: A value cannot be set in the low,order 7 bits. These bits are fixed to 0."]
            #[inline(always)]
            pub fn set_memmiraddr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 7usize)) | (((val as u32) & 0xffff) << 7usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_23_23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_23_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "MMSFR Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::MmsfrKey {
                let val = (self.0 >> 24usize) & 0xff;
                super::vals::MmsfrKey::from_bits(val as u8)
            }
            #[doc = "MMSFR Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::MmsfrKey) {
                self.0 =
                    (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Mmsfr {
            #[inline(always)]
            fn default() -> Mmsfr {
                Mmsfr(0)
            }
        }
        impl core::fmt::Debug for Mmsfr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmsfr")
                    .field("reserved_0_6", &self.reserved_0_6())
                    .field("memmiraddr", &self.memmiraddr())
                    .field("reserved_23_23", &self.reserved_23_23())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmsfr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mmsfr {{ reserved_0_6: {=u8:?}, memmiraddr: {=u16:?}, reserved_23_23: {=bool:?}, key: {:?} }}" , self . reserved_0_6 () , self . memmiraddr () , self . reserved_23_23 () , self . key ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En {
            #[inline(always)]
            fn from(val: u8) -> En {
                En::from_bits(val)
            }
        }
        impl From<En> for u8 {
            #[inline(always)]
            fn from(val: En) -> u8 {
                En::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MmenKey(u8);
        impl MmenKey {}
        impl MmenKey {
            pub const fn from_bits(val: u8) -> MmenKey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for MmenKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MmenKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for MmenKey {
            #[inline(always)]
            fn from(val: u8) -> MmenKey {
                MmenKey::from_bits(val)
            }
        }
        impl From<MmenKey> for u8 {
            #[inline(always)]
            fn from(val: MmenKey) -> u8 {
                MmenKey::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MmsfrKey(u8);
        impl MmsfrKey {}
        impl MmsfrKey {
            pub const fn from_bits(val: u8) -> MmsfrKey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for MmsfrKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MmsfrKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for MmsfrKey {
            #[inline(always)]
            fn from(val: u8) -> MmsfrKey {
                MmsfrKey::from_bits(val)
            }
        }
        impl From<MmsfrKey> for u8 {
            #[inline(always)]
            fn from(val: MmsfrKey) -> u8 {
                MmsfrKey::to_bits(val)
            }
        }
    }
}
pub mod mmpu {
    #[doc = "Bus Master MPU"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mmpu {
        ptr: *mut u8,
    }
    unsafe impl Send for Mmpu {}
    unsafe impl Sync for Mmpu {}
    impl Mmpu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Bus Master MPU Control Register"]
        #[inline(always)]
        pub const fn mmpuctla(self) -> crate::common::Reg<regs::Mmpuctla, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Group A Protection of Register"]
        #[inline(always)]
        pub const fn mmpupta(self) -> crate::common::Reg<regs::Mmpupta, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize) as _) }
        }
        #[doc = "Group A Region %s Access Control Register"]
        #[inline(always)]
        pub const fn mmpuaca(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Mmpuaca, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize + n * 16usize) as _) }
        }
        #[doc = "Group A Region %s Start Address Register"]
        #[inline(always)]
        pub const fn mmpusa(self, n: usize) -> crate::common::Reg<regs::Mmpusa, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize + n * 16usize) as _) }
        }
        #[doc = "Group A Region %s End Address Register"]
        #[inline(always)]
        pub const fn mmpuea(self, n: usize) -> crate::common::Reg<regs::Mmpuea, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize + n * 16usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Group A Region %s Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpuaca(pub u16);
        impl Mmpuaca {
            #[doc = "Region enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::MmpuacaEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MmpuacaEnable::from_bits(val as u8)
            }
            #[doc = "Region enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::MmpuacaEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Read protection"]
            #[inline(always)]
            pub const fn rp(&self) -> super::vals::Rp {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rp::from_bits(val as u8)
            }
            #[doc = "Read protection"]
            #[inline(always)]
            pub fn set_rp(&mut self, val: super::vals::Rp) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Write protection"]
            #[inline(always)]
            pub const fn wp(&self) -> super::vals::Wp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Wp::from_bits(val as u8)
            }
            #[doc = "Write protection"]
            #[inline(always)]
            pub fn set_wp(&mut self, val: super::vals::Wp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 0000000000000. The write value should be 0000000000000."]
            #[inline(always)]
            pub const fn reserved_3_15(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x1fff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000. The write value should be 0000000000000."]
            #[inline(always)]
            pub fn set_reserved_3_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 3usize)) | (((val as u16) & 0x1fff) << 3usize);
            }
        }
        impl Default for Mmpuaca {
            #[inline(always)]
            fn default() -> Mmpuaca {
                Mmpuaca(0)
            }
        }
        impl core::fmt::Debug for Mmpuaca {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpuaca")
                    .field("enable", &self.enable())
                    .field("rp", &self.rp())
                    .field("wp", &self.wp())
                    .field("reserved_3_15", &self.reserved_3_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpuaca {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpuaca {{ enable: {:?}, rp: {:?}, wp: {:?}, reserved_3_15: {=u16:?} }}",
                    self.enable(),
                    self.rp(),
                    self.wp(),
                    self.reserved_3_15()
                )
            }
        }
        #[doc = "Bus Master MPU Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpuctla(pub u16);
        impl Mmpuctla {
            #[doc = "Master Group Enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::MmpuctlaEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MmpuctlaEnable::from_bits(val as u8)
            }
            #[doc = "Master Group Enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::MmpuctlaEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::Oad {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Oad::from_bits(val as u8)
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::Oad) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u16) & 0x3f) << 2usize);
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::MmpuctlaKey {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::MmpuctlaKey::from_bits(val as u8)
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::MmpuctlaKey) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mmpuctla {
            #[inline(always)]
            fn default() -> Mmpuctla {
                Mmpuctla(0)
            }
        }
        impl core::fmt::Debug for Mmpuctla {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpuctla")
                    .field("enable", &self.enable())
                    .field("oad", &self.oad())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpuctla {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpuctla {{ enable: {:?}, oad: {:?}, reserved_2_7: {=u8:?}, key: {:?} }}",
                    self.enable(),
                    self.oad(),
                    self.reserved_2_7(),
                    self.key()
                )
            }
        }
        #[doc = "Group A Region %s End Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpuea(pub u32);
        impl Mmpuea {
            #[doc = "Region end address registerAddress where the region end, for use in region determination.NOTE: The low,order 2 bits are fixed to 1."]
            #[inline(always)]
            pub const fn mmpuea(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region end address registerAddress where the region end, for use in region determination.NOTE: The low,order 2 bits are fixed to 1."]
            #[inline(always)]
            pub fn set_mmpuea(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub const fn reserved_0_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub fn set_reserved_0_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Mmpuea {
            #[inline(always)]
            fn default() -> Mmpuea {
                Mmpuea(0)
            }
        }
        impl core::fmt::Debug for Mmpuea {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpuea")
                    .field("mmpuea", &self.mmpuea())
                    .field("reserved_0_1", &self.reserved_0_1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpuea {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpuea {{ mmpuea: {=u32:?}, reserved_0_1: {=u8:?} }}",
                    self.mmpuea(),
                    self.reserved_0_1()
                )
            }
        }
        #[doc = "Group A Protection of Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpupta(pub u16);
        impl Mmpupta {
            #[doc = "Protection of register(MMPUSAn, MMPUEAn, MMPUACAn and MMPUCTLA )"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::Protect {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Protect::from_bits(val as u8)
            }
            #[doc = "Protection of register(MMPUSAn, MMPUEAn, MMPUACAn and MMPUCTLA )"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::Protect) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u16) & 0x7f) << 1usize);
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::MmpuptaKey {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::MmpuptaKey::from_bits(val as u8)
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::MmpuptaKey) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mmpupta {
            #[inline(always)]
            fn default() -> Mmpupta {
                Mmpupta(0)
            }
        }
        impl core::fmt::Debug for Mmpupta {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpupta")
                    .field("protect", &self.protect())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpupta {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpupta {{ protect: {:?}, reserved_1_7: {=u8:?}, key: {:?} }}",
                    self.protect(),
                    self.reserved_1_7(),
                    self.key()
                )
            }
        }
        #[doc = "Group A Region %s Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpusa(pub u32);
        impl Mmpusa {
            #[doc = "Address where the region starts, for use in region determination.NOTE: The low,order 2 bits are fixed to 0."]
            #[inline(always)]
            pub const fn mmpusa(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Address where the region starts, for use in region determination.NOTE: The low,order 2 bits are fixed to 0."]
            #[inline(always)]
            pub fn set_mmpusa(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_0_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_0_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Mmpusa {
            #[inline(always)]
            fn default() -> Mmpusa {
                Mmpusa(0)
            }
        }
        impl core::fmt::Debug for Mmpusa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpusa")
                    .field("mmpusa", &self.mmpusa())
                    .field("reserved_0_1", &self.reserved_0_1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpusa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpusa {{ mmpusa: {=u32:?}, reserved_0_1: {=u8:?} }}",
                    self.mmpusa(),
                    self.reserved_0_1()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuacaEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuacaEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuacaEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuacaEnable {
            #[inline(always)]
            fn from(val: u8) -> MmpuacaEnable {
                MmpuacaEnable::from_bits(val)
            }
        }
        impl From<MmpuacaEnable> for u8 {
            #[inline(always)]
            fn from(val: MmpuacaEnable) -> u8 {
                MmpuacaEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuctlaEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuctlaEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuctlaEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuctlaEnable {
            #[inline(always)]
            fn from(val: u8) -> MmpuctlaEnable {
                MmpuctlaEnable::from_bits(val)
            }
        }
        impl From<MmpuctlaEnable> for u8 {
            #[inline(always)]
            fn from(val: MmpuctlaEnable) -> u8 {
                MmpuctlaEnable::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MmpuctlaKey(u8);
        impl MmpuctlaKey {}
        impl MmpuctlaKey {
            pub const fn from_bits(val: u8) -> MmpuctlaKey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for MmpuctlaKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MmpuctlaKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for MmpuctlaKey {
            #[inline(always)]
            fn from(val: u8) -> MmpuctlaKey {
                MmpuctlaKey::from_bits(val)
            }
        }
        impl From<MmpuctlaKey> for u8 {
            #[inline(always)]
            fn from(val: MmpuctlaKey) -> u8 {
                MmpuctlaKey::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MmpuptaKey(u8);
        impl MmpuptaKey {}
        impl MmpuptaKey {
            pub const fn from_bits(val: u8) -> MmpuptaKey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for MmpuptaKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MmpuptaKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for MmpuptaKey {
            #[inline(always)]
            fn from(val: u8) -> MmpuptaKey {
                MmpuptaKey::from_bits(val)
            }
        }
        impl From<MmpuptaKey> for u8 {
            #[inline(always)]
            fn from(val: MmpuptaKey) -> u8 {
                MmpuptaKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oad {
            #[inline(always)]
            fn from(val: u8) -> Oad {
                Oad::from_bits(val)
            }
        }
        impl From<Oad> for u8 {
            #[inline(always)]
            fn from(val: Oad) -> u8 {
                Oad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Protect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Protect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Protect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Protect {
            #[inline(always)]
            fn from(val: u8) -> Protect {
                Protect::from_bits(val)
            }
        }
        impl From<Protect> for u8 {
            #[inline(always)]
            fn from(val: Protect) -> u8 {
                Protect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rp {
            #[inline(always)]
            fn from(val: u8) -> Rp {
                Rp::from_bits(val)
            }
        }
        impl From<Rp> for u8 {
            #[inline(always)]
            fn from(val: Rp) -> u8 {
                Rp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wp {
            #[inline(always)]
            fn from(val: u8) -> Wp {
                Wp::from_bits(val)
            }
        }
        impl From<Wp> for u8 {
            #[inline(always)]
            fn from(val: Wp) -> u8 {
                Wp::to_bits(val)
            }
        }
    }
}
pub mod mstp {
    #[doc = "Module Stop Control B,C,D"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mstp {
        ptr: *mut u8,
    }
    unsafe impl Send for Mstp {}
    unsafe impl Sync for Mstp {}
    impl Mstp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Module Stop Control Register B"]
        #[inline(always)]
        pub const fn mstpcrb(self) -> crate::common::Reg<regs::Mstpcrb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Module Stop Control Register C"]
        #[inline(always)]
        pub const fn mstpcrc(self) -> crate::common::Reg<regs::Mstpcrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Module Stop Control Register D"]
        #[inline(always)]
        pub const fn mstpcrd(self) -> crate::common::Reg<regs::Mstpcrd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Module Stop Control Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrb(pub u32);
        impl Mstpcrb {
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub const fn reserved_0_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub fn set_reserved_0_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "CAN0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb2(&self) -> super::vals::Mstpb2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mstpb2::from_bits(val as u8)
            }
            #[doc = "CAN0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb2(&mut self, val: super::vals::Mstpb2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 11111. The write value should be 11111."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 11111. The write value should be 11111."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u32) & 0x1f) << 3usize);
            }
            #[doc = "I2C Bus Interface 1 Module Stop"]
            #[inline(always)]
            pub const fn mstpb8(&self) -> super::vals::Mstpb8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mstpb8::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface 1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb8(&mut self, val: super::vals::Mstpb8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "I2C Bus Interface 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb9(&self) -> super::vals::Mstpb9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Mstpb9::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb9(&mut self, val: super::vals::Mstpb9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_10_10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_10_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Universal Serial Bus 2.0 FS Interface Module Stop"]
            #[inline(always)]
            pub const fn mstpb11(&self) -> super::vals::Mstpb11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Mstpb11::from_bits(val as u8)
            }
            #[doc = "Universal Serial Bus 2.0 FS Interface Module Stop"]
            #[inline(always)]
            pub fn set_mstpb11(&mut self, val: super::vals::Mstpb11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "These bits are read as 111111. The write value should be 111111."]
            #[inline(always)]
            pub const fn reserved_12_17(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 111111. The write value should be 111111."]
            #[inline(always)]
            pub fn set_reserved_12_17(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 12usize)) | (((val as u32) & 0x3f) << 12usize);
            }
            #[doc = "Serial Peripheral Interface 1 Module Stop"]
            #[inline(always)]
            pub const fn mstpb18(&self) -> super::vals::Mstpb18 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Mstpb18::from_bits(val as u8)
            }
            #[doc = "Serial Peripheral Interface 1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb18(&mut self, val: super::vals::Mstpb18) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Serial Peripheral Interface 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb19(&self) -> super::vals::Mstpb19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Mstpb19::from_bits(val as u8)
            }
            #[doc = "Serial Peripheral Interface 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb19(&mut self, val: super::vals::Mstpb19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub const fn reserved_20_21(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub fn set_reserved_20_21(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 20usize)) | (((val as u32) & 0x03) << 20usize);
            }
            #[doc = "Serial Communication Interface 9 Module Stop"]
            #[inline(always)]
            pub const fn mstpb22(&self) -> super::vals::Mstpb22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Mstpb22::from_bits(val as u8)
            }
            #[doc = "Serial Communication Interface 9 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb22(&mut self, val: super::vals::Mstpb22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "These bits are read as 1111111. The write value should be 1111111."]
            #[inline(always)]
            pub const fn reserved_23_29(&self) -> u8 {
                let val = (self.0 >> 23usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 1111111. The write value should be 1111111."]
            #[inline(always)]
            pub fn set_reserved_23_29(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 23usize)) | (((val as u32) & 0x7f) << 23usize);
            }
            #[doc = "Serial Communication Interface 1 Module Stop"]
            #[inline(always)]
            pub const fn mstpb30(&self) -> super::vals::Mstpb30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Mstpb30::from_bits(val as u8)
            }
            #[doc = "Serial Communication Interface 1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb30(&mut self, val: super::vals::Mstpb30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Serial Communication Interface 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb31(&self) -> super::vals::Mstpb31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mstpb31::from_bits(val as u8)
            }
            #[doc = "Serial Communication Interface 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb31(&mut self, val: super::vals::Mstpb31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Mstpcrb {
            #[inline(always)]
            fn default() -> Mstpcrb {
                Mstpcrb(0)
            }
        }
        impl core::fmt::Debug for Mstpcrb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrb")
                    .field("reserved_0_1", &self.reserved_0_1())
                    .field("mstpb2", &self.mstpb2())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .field("mstpb8", &self.mstpb8())
                    .field("mstpb9", &self.mstpb9())
                    .field("reserved_10_10", &self.reserved_10_10())
                    .field("mstpb11", &self.mstpb11())
                    .field("reserved_12_17", &self.reserved_12_17())
                    .field("mstpb18", &self.mstpb18())
                    .field("mstpb19", &self.mstpb19())
                    .field("reserved_20_21", &self.reserved_20_21())
                    .field("mstpb22", &self.mstpb22())
                    .field("reserved_23_29", &self.reserved_23_29())
                    .field("mstpb30", &self.mstpb30())
                    .field("mstpb31", &self.mstpb31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrb {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mstpcrb {{ reserved_0_1: {=u8:?}, mstpb2: {:?}, reserved_3_7: {=u8:?}, mstpb8: {:?}, mstpb9: {:?}, reserved_10_10: {=bool:?}, mstpb11: {:?}, reserved_12_17: {=u8:?}, mstpb18: {:?}, mstpb19: {:?}, reserved_20_21: {=u8:?}, mstpb22: {:?}, reserved_23_29: {=u8:?}, mstpb30: {:?}, mstpb31: {:?} }}" , self . reserved_0_1 () , self . mstpb2 () , self . reserved_3_7 () , self . mstpb8 () , self . mstpb9 () , self . reserved_10_10 () , self . mstpb11 () , self . reserved_12_17 () , self . mstpb18 () , self . mstpb19 () , self . reserved_20_21 () , self . mstpb22 () , self . reserved_23_29 () , self . mstpb30 () , self . mstpb31 ())
            }
        }
        #[doc = "Module Stop Control Register C"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrc(pub u32);
        impl Mstpcrc {
            #[doc = "CAC Module Stop"]
            #[inline(always)]
            pub const fn mstpc0(&self) -> super::vals::Mstpc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mstpc0::from_bits(val as u8)
            }
            #[doc = "CAC Module Stop"]
            #[inline(always)]
            pub fn set_mstpc0(&mut self, val: super::vals::Mstpc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "CRC Calculator Module Stop"]
            #[inline(always)]
            pub const fn mstpc1(&self) -> super::vals::Mstpc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mstpc1::from_bits(val as u8)
            }
            #[doc = "CRC Calculator Module Stop"]
            #[inline(always)]
            pub fn set_mstpc1(&mut self, val: super::vals::Mstpc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_2_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_2_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Capacitive Touch Sensing Unit Module Stop"]
            #[inline(always)]
            pub const fn mstpc3(&self) -> super::vals::Mstpc3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mstpc3::from_bits(val as u8)
            }
            #[doc = "Capacitive Touch Sensing Unit Module Stop"]
            #[inline(always)]
            pub fn set_mstpc3(&mut self, val: super::vals::Mstpc3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 111111111. The write value should be 111111111."]
            #[inline(always)]
            pub const fn reserved_4_12(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x01ff;
                val as u16
            }
            #[doc = "These bits are read as 111111111. The write value should be 111111111."]
            #[inline(always)]
            pub fn set_reserved_4_12(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 4usize)) | (((val as u32) & 0x01ff) << 4usize);
            }
            #[doc = "Data Operation Circuit Module Stop"]
            #[inline(always)]
            pub const fn mstpc13(&self) -> super::vals::Mstpc13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Mstpc13::from_bits(val as u8)
            }
            #[doc = "Data Operation Circuit Module Stop"]
            #[inline(always)]
            pub fn set_mstpc13(&mut self, val: super::vals::Mstpc13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Event Link Controller Module Stop"]
            #[inline(always)]
            pub const fn mstpc14(&self) -> super::vals::Mstpc14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Mstpc14::from_bits(val as u8)
            }
            #[doc = "Event Link Controller Module Stop"]
            #[inline(always)]
            pub fn set_mstpc14(&mut self, val: super::vals::Mstpc14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "These bits are read as 1111111111111. The write value should be 1111111111111."]
            #[inline(always)]
            pub const fn reserved_15_27(&self) -> u16 {
                let val = (self.0 >> 15usize) & 0x1fff;
                val as u16
            }
            #[doc = "These bits are read as 1111111111111. The write value should be 1111111111111."]
            #[inline(always)]
            pub fn set_reserved_15_27(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 15usize)) | (((val as u32) & 0x1fff) << 15usize);
            }
            #[doc = "Random Number Generator Module Stop"]
            #[inline(always)]
            pub const fn mstpc28(&self) -> super::vals::Mstpc28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Mstpc28::from_bits(val as u8)
            }
            #[doc = "Random Number Generator Module Stop"]
            #[inline(always)]
            pub fn set_mstpc28(&mut self, val: super::vals::Mstpc28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub const fn reserved_29_30(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub fn set_reserved_29_30(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 29usize)) | (((val as u32) & 0x03) << 29usize);
            }
            #[doc = "AES Module Stop"]
            #[inline(always)]
            pub const fn mstpc31(&self) -> super::vals::Mstpc31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mstpc31::from_bits(val as u8)
            }
            #[doc = "AES Module Stop"]
            #[inline(always)]
            pub fn set_mstpc31(&mut self, val: super::vals::Mstpc31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Mstpcrc {
            #[inline(always)]
            fn default() -> Mstpcrc {
                Mstpcrc(0)
            }
        }
        impl core::fmt::Debug for Mstpcrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrc")
                    .field("mstpc0", &self.mstpc0())
                    .field("mstpc1", &self.mstpc1())
                    .field("reserved_2_2", &self.reserved_2_2())
                    .field("mstpc3", &self.mstpc3())
                    .field("reserved_4_12", &self.reserved_4_12())
                    .field("mstpc13", &self.mstpc13())
                    .field("mstpc14", &self.mstpc14())
                    .field("reserved_15_27", &self.reserved_15_27())
                    .field("mstpc28", &self.mstpc28())
                    .field("reserved_29_30", &self.reserved_29_30())
                    .field("mstpc31", &self.mstpc31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mstpcrc {{ mstpc0: {:?}, mstpc1: {:?}, reserved_2_2: {=bool:?}, mstpc3: {:?}, reserved_4_12: {=u16:?}, mstpc13: {:?}, mstpc14: {:?}, reserved_15_27: {=u16:?}, mstpc28: {:?}, reserved_29_30: {=u8:?}, mstpc31: {:?} }}" , self . mstpc0 () , self . mstpc1 () , self . reserved_2_2 () , self . mstpc3 () , self . reserved_4_12 () , self . mstpc13 () , self . mstpc14 () , self . reserved_15_27 () , self . mstpc28 () , self . reserved_29_30 () , self . mstpc31 ())
            }
        }
        #[doc = "Module Stop Control Register D"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrd(pub u32);
        impl Mstpcrd {
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub const fn reserved_0_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub fn set_reserved_0_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "AGT1 Module StopNote: AGT1 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub,clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT1."]
            #[inline(always)]
            pub const fn mstpd2(&self) -> super::vals::Mstpd2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mstpd2::from_bits(val as u8)
            }
            #[doc = "AGT1 Module StopNote: AGT1 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub,clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT1."]
            #[inline(always)]
            pub fn set_mstpd2(&mut self, val: super::vals::Mstpd2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "AGT0 Module StopNote: AGT0 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub,clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT0."]
            #[inline(always)]
            pub const fn mstpd3(&self) -> super::vals::Mstpd3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mstpd3::from_bits(val as u8)
            }
            #[doc = "AGT0 Module StopNote: AGT0 is in the module stop state when the count source is either of PCLKB, PCLKB/2 or PCLKB/8. In case the count source is sub,clock or LOCO, this bit should be set to 1 except when accessing the registers of AGT0."]
            #[inline(always)]
            pub fn set_mstpd3(&mut self, val: super::vals::Mstpd3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_4_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_4_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPT ch0 Module Stop"]
            #[inline(always)]
            pub const fn mstpd5(&self) -> super::vals::Mstpd5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Mstpd5::from_bits(val as u8)
            }
            #[doc = "GPT ch0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd5(&mut self, val: super::vals::Mstpd5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "GPT ch6 - ch1 Module Stop"]
            #[inline(always)]
            pub const fn mstpd6(&self) -> super::vals::Mstpd6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mstpd6::from_bits(val as u8)
            }
            #[doc = "GPT ch6 - ch1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd6(&mut self, val: super::vals::Mstpd6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 1111111. The write value should be 1111111."]
            #[inline(always)]
            pub const fn reserved_7_13(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 1111111. The write value should be 1111111."]
            #[inline(always)]
            pub fn set_reserved_7_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 7usize)) | (((val as u32) & 0x7f) << 7usize);
            }
            #[doc = "POEG Module Stop"]
            #[inline(always)]
            pub const fn mstpd14(&self) -> super::vals::Mstpd14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Mstpd14::from_bits(val as u8)
            }
            #[doc = "POEG Module Stop"]
            #[inline(always)]
            pub fn set_mstpd14(&mut self, val: super::vals::Mstpd14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_15_15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_15_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "16-Bit A/D Converter Module Stop"]
            #[inline(always)]
            pub const fn mstpd16(&self) -> super::vals::Mstpd16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Mstpd16::from_bits(val as u8)
            }
            #[doc = "16-Bit A/D Converter Module Stop"]
            #[inline(always)]
            pub fn set_mstpd16(&mut self, val: super::vals::Mstpd16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "24-bit Sigma,Delta A/DConverter Module Stop"]
            #[inline(always)]
            pub const fn mstpd17(&self) -> super::vals::Mstpd17 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Mstpd17::from_bits(val as u8)
            }
            #[doc = "24-bit Sigma,Delta A/DConverter Module Stop"]
            #[inline(always)]
            pub fn set_mstpd17(&mut self, val: super::vals::Mstpd17) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_18_18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_18_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "8-Bit D/A Converter Module Stop"]
            #[inline(always)]
            pub const fn mstpd19(&self) -> super::vals::Mstpd19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Mstpd19::from_bits(val as u8)
            }
            #[doc = "8-Bit D/A Converter Module Stop"]
            #[inline(always)]
            pub fn set_mstpd19(&mut self, val: super::vals::Mstpd19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "12-bit D/A Converter Module Stop"]
            #[inline(always)]
            pub const fn mstpd20(&self) -> super::vals::Mstpd20 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Mstpd20::from_bits(val as u8)
            }
            #[doc = "12-bit D/A Converter Module Stop"]
            #[inline(always)]
            pub fn set_mstpd20(&mut self, val: super::vals::Mstpd20) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "These bits are read as 1111111. The write value should be 1111111."]
            #[inline(always)]
            pub const fn reserved_21_27(&self) -> u8 {
                let val = (self.0 >> 21usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 1111111. The write value should be 1111111."]
            #[inline(always)]
            pub fn set_reserved_21_27(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 21usize)) | (((val as u32) & 0x7f) << 21usize);
            }
            #[doc = "ACMPHS0 Module Stop"]
            #[inline(always)]
            pub const fn mstpd28(&self) -> super::vals::Mstpd28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Mstpd28::from_bits(val as u8)
            }
            #[doc = "ACMPHS0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd28(&mut self, val: super::vals::Mstpd28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Comparator,LP Module Stop"]
            #[inline(always)]
            pub const fn mstpd29(&self) -> super::vals::Mstpd29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Mstpd29::from_bits(val as u8)
            }
            #[doc = "Comparator,LP Module Stop"]
            #[inline(always)]
            pub fn set_mstpd29(&mut self, val: super::vals::Mstpd29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_30_30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_30_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Operational Amplifier Module Stop"]
            #[inline(always)]
            pub const fn mstpd31(&self) -> super::vals::Mstpd31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mstpd31::from_bits(val as u8)
            }
            #[doc = "Operational Amplifier Module Stop"]
            #[inline(always)]
            pub fn set_mstpd31(&mut self, val: super::vals::Mstpd31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Mstpcrd {
            #[inline(always)]
            fn default() -> Mstpcrd {
                Mstpcrd(0)
            }
        }
        impl core::fmt::Debug for Mstpcrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrd")
                    .field("reserved_0_1", &self.reserved_0_1())
                    .field("mstpd2", &self.mstpd2())
                    .field("mstpd3", &self.mstpd3())
                    .field("reserved_4_4", &self.reserved_4_4())
                    .field("mstpd5", &self.mstpd5())
                    .field("mstpd6", &self.mstpd6())
                    .field("reserved_7_13", &self.reserved_7_13())
                    .field("mstpd14", &self.mstpd14())
                    .field("reserved_15_15", &self.reserved_15_15())
                    .field("mstpd16", &self.mstpd16())
                    .field("mstpd17", &self.mstpd17())
                    .field("reserved_18_18", &self.reserved_18_18())
                    .field("mstpd19", &self.mstpd19())
                    .field("mstpd20", &self.mstpd20())
                    .field("reserved_21_27", &self.reserved_21_27())
                    .field("mstpd28", &self.mstpd28())
                    .field("mstpd29", &self.mstpd29())
                    .field("reserved_30_30", &self.reserved_30_30())
                    .field("mstpd31", &self.mstpd31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrd {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mstpcrd {{ reserved_0_1: {=u8:?}, mstpd2: {:?}, mstpd3: {:?}, reserved_4_4: {=bool:?}, mstpd5: {:?}, mstpd6: {:?}, reserved_7_13: {=u8:?}, mstpd14: {:?}, reserved_15_15: {=bool:?}, mstpd16: {:?}, mstpd17: {:?}, reserved_18_18: {=bool:?}, mstpd19: {:?}, mstpd20: {:?}, reserved_21_27: {=u8:?}, mstpd28: {:?}, mstpd29: {:?}, reserved_30_30: {=bool:?}, mstpd31: {:?} }}" , self . reserved_0_1 () , self . mstpd2 () , self . mstpd3 () , self . reserved_4_4 () , self . mstpd5 () , self . mstpd6 () , self . reserved_7_13 () , self . mstpd14 () , self . reserved_15_15 () , self . mstpd16 () , self . mstpd17 () , self . reserved_18_18 () , self . mstpd19 () , self . mstpd20 () , self . reserved_21_27 () , self . mstpd28 () , self . mstpd29 () , self . reserved_30_30 () , self . mstpd31 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb11 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb11 {
                Mstpb11::from_bits(val)
            }
        }
        impl From<Mstpb11> for u8 {
            #[inline(always)]
            fn from(val: Mstpb11) -> u8 {
                Mstpb11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb18 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb18 {
                Mstpb18::from_bits(val)
            }
        }
        impl From<Mstpb18> for u8 {
            #[inline(always)]
            fn from(val: Mstpb18) -> u8 {
                Mstpb18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb19 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb19 {
                Mstpb19::from_bits(val)
            }
        }
        impl From<Mstpb19> for u8 {
            #[inline(always)]
            fn from(val: Mstpb19) -> u8 {
                Mstpb19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb2 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb2 {
                Mstpb2::from_bits(val)
            }
        }
        impl From<Mstpb2> for u8 {
            #[inline(always)]
            fn from(val: Mstpb2) -> u8 {
                Mstpb2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb22 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb22 {
                Mstpb22::from_bits(val)
            }
        }
        impl From<Mstpb22> for u8 {
            #[inline(always)]
            fn from(val: Mstpb22) -> u8 {
                Mstpb22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb30 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb30 {
                Mstpb30::from_bits(val)
            }
        }
        impl From<Mstpb30> for u8 {
            #[inline(always)]
            fn from(val: Mstpb30) -> u8 {
                Mstpb30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb31 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb31 {
                Mstpb31::from_bits(val)
            }
        }
        impl From<Mstpb31> for u8 {
            #[inline(always)]
            fn from(val: Mstpb31) -> u8 {
                Mstpb31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb8 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb8 {
                Mstpb8::from_bits(val)
            }
        }
        impl From<Mstpb8> for u8 {
            #[inline(always)]
            fn from(val: Mstpb8) -> u8 {
                Mstpb8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb9 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb9 {
                Mstpb9::from_bits(val)
            }
        }
        impl From<Mstpb9> for u8 {
            #[inline(always)]
            fn from(val: Mstpb9) -> u8 {
                Mstpb9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc0 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc0 {
                Mstpc0::from_bits(val)
            }
        }
        impl From<Mstpc0> for u8 {
            #[inline(always)]
            fn from(val: Mstpc0) -> u8 {
                Mstpc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc1 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc1 {
                Mstpc1::from_bits(val)
            }
        }
        impl From<Mstpc1> for u8 {
            #[inline(always)]
            fn from(val: Mstpc1) -> u8 {
                Mstpc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc13 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc13 {
                Mstpc13::from_bits(val)
            }
        }
        impl From<Mstpc13> for u8 {
            #[inline(always)]
            fn from(val: Mstpc13) -> u8 {
                Mstpc13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc14 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc14 {
                Mstpc14::from_bits(val)
            }
        }
        impl From<Mstpc14> for u8 {
            #[inline(always)]
            fn from(val: Mstpc14) -> u8 {
                Mstpc14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc28 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc28 {
                Mstpc28::from_bits(val)
            }
        }
        impl From<Mstpc28> for u8 {
            #[inline(always)]
            fn from(val: Mstpc28) -> u8 {
                Mstpc28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc3 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc3 {
                Mstpc3::from_bits(val)
            }
        }
        impl From<Mstpc3> for u8 {
            #[inline(always)]
            fn from(val: Mstpc3) -> u8 {
                Mstpc3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc31 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc31 {
                Mstpc31::from_bits(val)
            }
        }
        impl From<Mstpc31> for u8 {
            #[inline(always)]
            fn from(val: Mstpc31) -> u8 {
                Mstpc31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd14 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd14 {
                Mstpd14::from_bits(val)
            }
        }
        impl From<Mstpd14> for u8 {
            #[inline(always)]
            fn from(val: Mstpd14) -> u8 {
                Mstpd14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd16 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd16 {
                Mstpd16::from_bits(val)
            }
        }
        impl From<Mstpd16> for u8 {
            #[inline(always)]
            fn from(val: Mstpd16) -> u8 {
                Mstpd16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd17 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd17 {
                Mstpd17::from_bits(val)
            }
        }
        impl From<Mstpd17> for u8 {
            #[inline(always)]
            fn from(val: Mstpd17) -> u8 {
                Mstpd17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd19 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd19 {
                Mstpd19::from_bits(val)
            }
        }
        impl From<Mstpd19> for u8 {
            #[inline(always)]
            fn from(val: Mstpd19) -> u8 {
                Mstpd19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd2 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd2 {
                Mstpd2::from_bits(val)
            }
        }
        impl From<Mstpd2> for u8 {
            #[inline(always)]
            fn from(val: Mstpd2) -> u8 {
                Mstpd2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd20 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd20 {
                Mstpd20::from_bits(val)
            }
        }
        impl From<Mstpd20> for u8 {
            #[inline(always)]
            fn from(val: Mstpd20) -> u8 {
                Mstpd20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd28 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd28 {
                Mstpd28::from_bits(val)
            }
        }
        impl From<Mstpd28> for u8 {
            #[inline(always)]
            fn from(val: Mstpd28) -> u8 {
                Mstpd28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd29 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd29 {
                Mstpd29::from_bits(val)
            }
        }
        impl From<Mstpd29> for u8 {
            #[inline(always)]
            fn from(val: Mstpd29) -> u8 {
                Mstpd29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd3 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd3 {
                Mstpd3::from_bits(val)
            }
        }
        impl From<Mstpd3> for u8 {
            #[inline(always)]
            fn from(val: Mstpd3) -> u8 {
                Mstpd3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd31 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd31 {
                Mstpd31::from_bits(val)
            }
        }
        impl From<Mstpd31> for u8 {
            #[inline(always)]
            fn from(val: Mstpd31) -> u8 {
                Mstpd31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd5 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd5 {
                Mstpd5::from_bits(val)
            }
        }
        impl From<Mstpd5> for u8 {
            #[inline(always)]
            fn from(val: Mstpd5) -> u8 {
                Mstpd5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd6 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd6 {
                Mstpd6::from_bits(val)
            }
        }
        impl From<Mstpd6> for u8 {
            #[inline(always)]
            fn from(val: Mstpd6) -> u8 {
                Mstpd6::to_bits(val)
            }
        }
    }
}
pub mod opamp {
    #[doc = "OperationalAmplifier"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Opamp {
        ptr: *mut u8,
    }
    unsafe impl Send for Opamp {}
    unsafe impl Sync for Opamp {}
    impl Opamp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Operational amplifier mode control register"]
        #[inline(always)]
        pub const fn ampmc(self) -> crate::common::Reg<regs::Ampmc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Operational amplifier trigger mode control register"]
        #[inline(always)]
        pub const fn amptrm(self) -> crate::common::Reg<regs::Amptrm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Operational Amplifier Activation Trigger Select Register"]
        #[inline(always)]
        pub const fn amptrs(self) -> crate::common::Reg<regs::Amptrs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Operational amplifier control register"]
        #[inline(always)]
        pub const fn ampc(self) -> crate::common::Reg<regs::Ampc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Operational amplifier monitor register"]
        #[inline(always)]
        pub const fn ampmon(self) -> crate::common::Reg<regs::Ampmon, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Operational Amplifier 0 Output Select Register"]
        #[inline(always)]
        pub const fn amp0os(self) -> crate::common::Reg<regs::Amp0os, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Operational Amplifier 0 Minus Input Select Register"]
        #[inline(always)]
        pub const fn amp0ms(self) -> crate::common::Reg<regs::Amp0ms, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Operational Amplifier 0 Plus Input Select Register"]
        #[inline(always)]
        pub const fn amp0ps(self) -> crate::common::Reg<regs::Amp0ps, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Operational Amplifier 1 Minus Input Select Register"]
        #[inline(always)]
        pub const fn amp1ms(self) -> crate::common::Reg<regs::Amp1ms, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Operational Amplifier 1 Plus Input Select Register"]
        #[inline(always)]
        pub const fn amp1ps(self) -> crate::common::Reg<regs::Amp1ps, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "Operational Amplifier 2 Minus Input Select Register"]
        #[inline(always)]
        pub const fn amp2ms(self) -> crate::common::Reg<regs::Amp2ms, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "Operational Amplifier 2 Plus Input Select Register"]
        #[inline(always)]
        pub const fn amp2ps(self) -> crate::common::Reg<regs::Amp2ps, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Operational Amplifier Switch Charge Pump Control Register"]
        #[inline(always)]
        pub const fn ampcpc(self) -> crate::common::Reg<regs::Ampcpc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "Operational Amplifier User Offset Trimming Enable Register"]
        #[inline(always)]
        pub const fn ampuote(self) -> crate::common::Reg<regs::Ampuote, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x17usize) as _) }
        }
        #[doc = "Operational Amplifier 0 Offset Trimming Pch Register"]
        #[inline(always)]
        pub const fn amp0otp(self) -> crate::common::Reg<regs::Amp0otp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Operational Amplifier 0 Offset Trimming Nch Register"]
        #[inline(always)]
        pub const fn amp0otn(self) -> crate::common::Reg<regs::Amp0otn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x19usize) as _) }
        }
        #[doc = "Operational Amplifier 1 Offset Trimming Pch Register"]
        #[inline(always)]
        pub const fn amp1otp(self) -> crate::common::Reg<regs::Amp1otp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "Operational Amplifier 1 Offset Trimming Nch Register"]
        #[inline(always)]
        pub const fn amp1otn(self) -> crate::common::Reg<regs::Amp1otn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1busize) as _) }
        }
        #[doc = "Operational Amplifier 2 Offset Trimming Pch Register"]
        #[inline(always)]
        pub const fn amp2otp(self) -> crate::common::Reg<regs::Amp2otp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Operational Amplifier 2 Offset Trimming Nch Register"]
        #[inline(always)]
        pub const fn amp2otn(self) -> crate::common::Reg<regs::Amp2otn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1dusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Operational Amplifier 0 Minus Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp0ms(pub u8);
        impl Amp0ms {
            #[doc = "AMP0- pin select"]
            #[inline(always)]
            pub const fn ampms0(&self) -> super::vals::Amp0msAmpms0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Amp0msAmpms0::from_bits(val as u8)
            }
            #[doc = "AMP0- pin select"]
            #[inline(always)]
            pub fn set_ampms0(&mut self, val: super::vals::Amp0msAmpms0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AMP0+ pin select"]
            #[inline(always)]
            pub const fn ampms1(&self) -> super::vals::Ampms1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ampms1::from_bits(val as u8)
            }
            #[doc = "AMP0+ pin select"]
            #[inline(always)]
            pub fn set_ampms1(&mut self, val: super::vals::Ampms1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub const fn ampms2(&self) -> super::vals::Ampms2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ampms2::from_bits(val as u8)
            }
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub fn set_ampms2(&mut self, val: super::vals::Ampms2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "AMP1+ pin select"]
            #[inline(always)]
            pub const fn ampms3(&self) -> super::vals::Ampms3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ampms3::from_bits(val as u8)
            }
            #[doc = "AMP1+ pin select"]
            #[inline(always)]
            pub fn set_ampms3(&mut self, val: super::vals::Ampms3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub const fn ampms4(&self) -> super::vals::Ampms4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ampms4::from_bits(val as u8)
            }
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub fn set_ampms4(&mut self, val: super::vals::Ampms4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_5_6(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_5_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u8) & 0x03) << 5usize);
            }
            #[doc = "OPAMP0 output select"]
            #[inline(always)]
            pub const fn ampms7(&self) -> super::vals::Amp0msAmpms7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Amp0msAmpms7::from_bits(val as u8)
            }
            #[doc = "OPAMP0 output select"]
            #[inline(always)]
            pub fn set_ampms7(&mut self, val: super::vals::Amp0msAmpms7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Amp0ms {
            #[inline(always)]
            fn default() -> Amp0ms {
                Amp0ms(0)
            }
        }
        impl core::fmt::Debug for Amp0ms {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp0ms")
                    .field("ampms0", &self.ampms0())
                    .field("ampms1", &self.ampms1())
                    .field("ampms2", &self.ampms2())
                    .field("ampms3", &self.ampms3())
                    .field("ampms4", &self.ampms4())
                    .field("reserved_5_6", &self.reserved_5_6())
                    .field("ampms7", &self.ampms7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp0ms {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Amp0ms {{ ampms0: {:?}, ampms1: {:?}, ampms2: {:?}, ampms3: {:?}, ampms4: {:?}, reserved_5_6: {=u8:?}, ampms7: {:?} }}" , self . ampms0 () , self . ampms1 () , self . ampms2 () , self . ampms3 () , self . ampms4 () , self . reserved_5_6 () , self . ampms7 ())
            }
        }
        #[doc = "Operational Amplifier 0 Output Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp0os(pub u8);
        impl Amp0os {
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub const fn ampos0(&self) -> super::vals::Ampos0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ampos0::from_bits(val as u8)
            }
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub fn set_ampos0(&mut self, val: super::vals::Ampos0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AMP1+ pin select"]
            #[inline(always)]
            pub const fn ampos1(&self) -> super::vals::Ampos1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ampos1::from_bits(val as u8)
            }
            #[doc = "AMP1+ pin select"]
            #[inline(always)]
            pub fn set_ampos1(&mut self, val: super::vals::Ampos1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub const fn ampos2(&self) -> super::vals::Ampos2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ampos2::from_bits(val as u8)
            }
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub fn set_ampos2(&mut self, val: super::vals::Ampos2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "AMP2+ pin select"]
            #[inline(always)]
            pub const fn ampos3(&self) -> super::vals::Ampos3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ampos3::from_bits(val as u8)
            }
            #[doc = "AMP2+ pin select"]
            #[inline(always)]
            pub fn set_ampos3(&mut self, val: super::vals::Ampos3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u8) & 0x0f) << 4usize);
            }
        }
        impl Default for Amp0os {
            #[inline(always)]
            fn default() -> Amp0os {
                Amp0os(0)
            }
        }
        impl core::fmt::Debug for Amp0os {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp0os")
                    .field("ampos0", &self.ampos0())
                    .field("ampos1", &self.ampos1())
                    .field("ampos2", &self.ampos2())
                    .field("ampos3", &self.ampos3())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp0os {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Amp0os {{ ampos0: {:?}, ampos1: {:?}, ampos2: {:?}, ampos3: {:?}, reserved_4_7: {=u8:?} }}" , self . ampos0 () , self . ampos1 () , self . ampos2 () , self . ampos3 () , self . reserved_4_7 ())
            }
        }
        #[doc = "Operational Amplifier 0 Offset Trimming Nch Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp0otn(pub u8);
        impl Amp0otn {
            #[doc = "AMP0 input offset trimming Nch side"]
            #[inline(always)]
            pub const fn trmn(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "AMP0 input offset trimming Nch side"]
            #[inline(always)]
            pub fn set_trmn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Amp0otn {
            #[inline(always)]
            fn default() -> Amp0otn {
                Amp0otn(0)
            }
        }
        impl core::fmt::Debug for Amp0otn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp0otn")
                    .field("trmn", &self.trmn())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp0otn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Amp0otn {{ trmn: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.trmn(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "Operational Amplifier 0 Offset Trimming Pch Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp0otp(pub u8);
        impl Amp0otp {
            #[doc = "AMP0 input offset trimming Pch side"]
            #[inline(always)]
            pub const fn trmp(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "AMP0 input offset trimming Pch side"]
            #[inline(always)]
            pub fn set_trmp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Amp0otp {
            #[inline(always)]
            fn default() -> Amp0otp {
                Amp0otp(0)
            }
        }
        impl core::fmt::Debug for Amp0otp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp0otp")
                    .field("trmp", &self.trmp())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp0otp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Amp0otp {{ trmp: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.trmp(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "Operational Amplifier 0 Plus Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp0ps(pub u8);
        impl Amp0ps {
            #[doc = "AMP0+ pin select"]
            #[inline(always)]
            pub const fn ampps0(&self) -> super::vals::Amp0psAmpps0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Amp0psAmpps0::from_bits(val as u8)
            }
            #[doc = "AMP0+ pin select"]
            #[inline(always)]
            pub fn set_ampps0(&mut self, val: super::vals::Amp0psAmpps0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub const fn ampps1(&self) -> super::vals::Amp0psAmpps1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Amp0psAmpps1::from_bits(val as u8)
            }
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub fn set_ampps1(&mut self, val: super::vals::Amp0psAmpps1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AMP1+pin select"]
            #[inline(always)]
            pub const fn ampps2(&self) -> super::vals::Amp0psAmpps2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Amp0psAmpps2::from_bits(val as u8)
            }
            #[doc = "AMP1+pin select"]
            #[inline(always)]
            pub fn set_ampps2(&mut self, val: super::vals::Amp0psAmpps2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "AMP2+ pin select"]
            #[inline(always)]
            pub const fn ampps3(&self) -> super::vals::Amp0psAmpps3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Amp0psAmpps3::from_bits(val as u8)
            }
            #[doc = "AMP2+ pin select"]
            #[inline(always)]
            pub fn set_ampps3(&mut self, val: super::vals::Amp0psAmpps3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_4_6(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_4_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
            #[doc = "DAC12 output select"]
            #[inline(always)]
            pub const fn ampms7(&self) -> super::vals::Amp0psAmpms7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Amp0psAmpms7::from_bits(val as u8)
            }
            #[doc = "DAC12 output select"]
            #[inline(always)]
            pub fn set_ampms7(&mut self, val: super::vals::Amp0psAmpms7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Amp0ps {
            #[inline(always)]
            fn default() -> Amp0ps {
                Amp0ps(0)
            }
        }
        impl core::fmt::Debug for Amp0ps {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp0ps")
                    .field("ampps0", &self.ampps0())
                    .field("ampps1", &self.ampps1())
                    .field("ampps2", &self.ampps2())
                    .field("ampps3", &self.ampps3())
                    .field("reserved_4_6", &self.reserved_4_6())
                    .field("ampms7", &self.ampms7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp0ps {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Amp0ps {{ ampps0: {:?}, ampps1: {:?}, ampps2: {:?}, ampps3: {:?}, reserved_4_6: {=u8:?}, ampms7: {:?} }}" , self . ampps0 () , self . ampps1 () , self . ampps2 () , self . ampps3 () , self . reserved_4_6 () , self . ampms7 ())
            }
        }
        #[doc = "Operational Amplifier 1 Minus Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp1ms(pub u8);
        impl Amp1ms {
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub const fn ampms0(&self) -> super::vals::Amp1msAmpms0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Amp1msAmpms0::from_bits(val as u8)
            }
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub fn set_ampms0(&mut self, val: super::vals::Amp1msAmpms0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_1_6(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_1_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 1usize)) | (((val as u8) & 0x3f) << 1usize);
            }
            #[doc = "OPAMP1 output select"]
            #[inline(always)]
            pub const fn ampms7(&self) -> super::vals::Amp1msAmpms7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Amp1msAmpms7::from_bits(val as u8)
            }
            #[doc = "OPAMP1 output select"]
            #[inline(always)]
            pub fn set_ampms7(&mut self, val: super::vals::Amp1msAmpms7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Amp1ms {
            #[inline(always)]
            fn default() -> Amp1ms {
                Amp1ms(0)
            }
        }
        impl core::fmt::Debug for Amp1ms {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp1ms")
                    .field("ampms0", &self.ampms0())
                    .field("reserved_1_6", &self.reserved_1_6())
                    .field("ampms7", &self.ampms7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp1ms {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Amp1ms {{ ampms0: {:?}, reserved_1_6: {=u8:?}, ampms7: {:?} }}",
                    self.ampms0(),
                    self.reserved_1_6(),
                    self.ampms7()
                )
            }
        }
        #[doc = "Operational Amplifier 1 Offset Trimming Nch Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp1otn(pub u8);
        impl Amp1otn {
            #[doc = "AMP1 input offset trimming Nch side"]
            #[inline(always)]
            pub const fn trmn(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "AMP1 input offset trimming Nch side"]
            #[inline(always)]
            pub fn set_trmn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Amp1otn {
            #[inline(always)]
            fn default() -> Amp1otn {
                Amp1otn(0)
            }
        }
        impl core::fmt::Debug for Amp1otn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp1otn")
                    .field("trmn", &self.trmn())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp1otn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Amp1otn {{ trmn: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.trmn(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "Operational Amplifier 1 Offset Trimming Pch Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp1otp(pub u8);
        impl Amp1otp {
            #[doc = "AMP1 input offset trimming Pch side"]
            #[inline(always)]
            pub const fn trmp(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "AMP1 input offset trimming Pch side"]
            #[inline(always)]
            pub fn set_trmp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Amp1otp {
            #[inline(always)]
            fn default() -> Amp1otp {
                Amp1otp(0)
            }
        }
        impl core::fmt::Debug for Amp1otp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp1otp")
                    .field("trmp", &self.trmp())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp1otp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Amp1otp {{ trmp: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.trmp(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "Operational Amplifier 1 Plus Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp1ps(pub u8);
        impl Amp1ps {
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub const fn ampps0(&self) -> super::vals::Amp1psAmpps0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Amp1psAmpps0::from_bits(val as u8)
            }
            #[doc = "AMP1- pin select"]
            #[inline(always)]
            pub fn set_ampps0(&mut self, val: super::vals::Amp1psAmpps0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AMP1+ pin select"]
            #[inline(always)]
            pub const fn ampps1(&self) -> super::vals::Amp1psAmpps1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Amp1psAmpps1::from_bits(val as u8)
            }
            #[doc = "AMP1+ pin select"]
            #[inline(always)]
            pub fn set_ampps1(&mut self, val: super::vals::Amp1psAmpps1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub const fn ampps2(&self) -> super::vals::Amp1psAmpps2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Amp1psAmpps2::from_bits(val as u8)
            }
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub fn set_ampps2(&mut self, val: super::vals::Amp1psAmpps2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "AMP2+ pin select"]
            #[inline(always)]
            pub const fn ampps3(&self) -> super::vals::Amp1psAmpps3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Amp1psAmpps3::from_bits(val as u8)
            }
            #[doc = "AMP2+ pin select"]
            #[inline(always)]
            pub fn set_ampps3(&mut self, val: super::vals::Amp1psAmpps3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_4_6(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_4_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
            #[doc = "OPAMP2 output select"]
            #[inline(always)]
            pub const fn ampms7(&self) -> super::vals::Amp1psAmpms7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Amp1psAmpms7::from_bits(val as u8)
            }
            #[doc = "OPAMP2 output select"]
            #[inline(always)]
            pub fn set_ampms7(&mut self, val: super::vals::Amp1psAmpms7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Amp1ps {
            #[inline(always)]
            fn default() -> Amp1ps {
                Amp1ps(0)
            }
        }
        impl core::fmt::Debug for Amp1ps {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp1ps")
                    .field("ampps0", &self.ampps0())
                    .field("ampps1", &self.ampps1())
                    .field("ampps2", &self.ampps2())
                    .field("ampps3", &self.ampps3())
                    .field("reserved_4_6", &self.reserved_4_6())
                    .field("ampms7", &self.ampms7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp1ps {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Amp1ps {{ ampps0: {:?}, ampps1: {:?}, ampps2: {:?}, ampps3: {:?}, reserved_4_6: {=u8:?}, ampms7: {:?} }}" , self . ampps0 () , self . ampps1 () , self . ampps2 () , self . ampps3 () , self . reserved_4_6 () , self . ampms7 ())
            }
        }
        #[doc = "Operational Amplifier 2 Minus Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp2ms(pub u8);
        impl Amp2ms {
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub const fn ampms0(&self) -> super::vals::Amp2msAmpms0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Amp2msAmpms0::from_bits(val as u8)
            }
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub fn set_ampms0(&mut self, val: super::vals::Amp2msAmpms0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_1_6(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_1_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 1usize)) | (((val as u8) & 0x3f) << 1usize);
            }
            #[doc = "OPAMP2 output select"]
            #[inline(always)]
            pub const fn ampms7(&self) -> super::vals::Amp2msAmpms7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Amp2msAmpms7::from_bits(val as u8)
            }
            #[doc = "OPAMP2 output select"]
            #[inline(always)]
            pub fn set_ampms7(&mut self, val: super::vals::Amp2msAmpms7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Amp2ms {
            #[inline(always)]
            fn default() -> Amp2ms {
                Amp2ms(0)
            }
        }
        impl core::fmt::Debug for Amp2ms {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp2ms")
                    .field("ampms0", &self.ampms0())
                    .field("reserved_1_6", &self.reserved_1_6())
                    .field("ampms7", &self.ampms7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp2ms {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Amp2ms {{ ampms0: {:?}, reserved_1_6: {=u8:?}, ampms7: {:?} }}",
                    self.ampms0(),
                    self.reserved_1_6(),
                    self.ampms7()
                )
            }
        }
        #[doc = "Operational Amplifier 2 Offset Trimming Nch Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp2otn(pub u8);
        impl Amp2otn {
            #[doc = "AMP2 input offset trimming Nch side"]
            #[inline(always)]
            pub const fn trmn(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "AMP2 input offset trimming Nch side"]
            #[inline(always)]
            pub fn set_trmn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Amp2otn {
            #[inline(always)]
            fn default() -> Amp2otn {
                Amp2otn(0)
            }
        }
        impl core::fmt::Debug for Amp2otn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp2otn")
                    .field("trmn", &self.trmn())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp2otn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Amp2otn {{ trmn: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.trmn(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "Operational Amplifier 2 Offset Trimming Pch Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp2otp(pub u8);
        impl Amp2otp {
            #[doc = "AMP2 input offset trimming Pch side"]
            #[inline(always)]
            pub const fn trmp(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "AMP2 input offset trimming Pch side"]
            #[inline(always)]
            pub fn set_trmp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Amp2otp {
            #[inline(always)]
            fn default() -> Amp2otp {
                Amp2otp(0)
            }
        }
        impl core::fmt::Debug for Amp2otp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp2otp")
                    .field("trmp", &self.trmp())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp2otp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Amp2otp {{ trmp: {=u8:?}, reserved_5_7: {=u8:?} }}",
                    self.trmp(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "Operational Amplifier 2 Plus Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amp2ps(pub u8);
        impl Amp2ps {
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub const fn ampps0(&self) -> super::vals::Amp2psAmpps0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Amp2psAmpps0::from_bits(val as u8)
            }
            #[doc = "AMP2- pin select"]
            #[inline(always)]
            pub fn set_ampps0(&mut self, val: super::vals::Amp2psAmpps0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AMP2+ pin select"]
            #[inline(always)]
            pub const fn ampps1(&self) -> super::vals::Amp2psAmpps1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Amp2psAmpps1::from_bits(val as u8)
            }
            #[doc = "AMP2+ pin select"]
            #[inline(always)]
            pub fn set_ampps1(&mut self, val: super::vals::Amp2psAmpps1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_2_6(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_2_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 2usize)) | (((val as u8) & 0x1f) << 2usize);
            }
            #[doc = "DAC8 channel 1output select"]
            #[inline(always)]
            pub const fn ampps7(&self) -> super::vals::Ampps7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ampps7::from_bits(val as u8)
            }
            #[doc = "DAC8 channel 1output select"]
            #[inline(always)]
            pub fn set_ampps7(&mut self, val: super::vals::Ampps7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Amp2ps {
            #[inline(always)]
            fn default() -> Amp2ps {
                Amp2ps(0)
            }
        }
        impl core::fmt::Debug for Amp2ps {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amp2ps")
                    .field("ampps0", &self.ampps0())
                    .field("ampps1", &self.ampps1())
                    .field("reserved_2_6", &self.reserved_2_6())
                    .field("ampps7", &self.ampps7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amp2ps {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Amp2ps {{ ampps0: {:?}, ampps1: {:?}, reserved_2_6: {=u8:?}, ampps7: {:?} }}",
                    self.ampps0(),
                    self.ampps1(),
                    self.reserved_2_6(),
                    self.ampps7()
                )
            }
        }
        #[doc = "Operational amplifier control register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ampc(pub u8);
        impl Ampc {
            #[doc = "Operation control of operational amplifier 0"]
            #[inline(always)]
            pub const fn ampe0(&self) -> super::vals::Ampe0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ampe0::from_bits(val as u8)
            }
            #[doc = "Operation control of operational amplifier 0"]
            #[inline(always)]
            pub fn set_ampe0(&mut self, val: super::vals::Ampe0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Operation control of operational amplifier 1"]
            #[inline(always)]
            pub const fn ampe1(&self) -> super::vals::Ampe1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ampe1::from_bits(val as u8)
            }
            #[doc = "Operation control of operational amplifier 1"]
            #[inline(always)]
            pub fn set_ampe1(&mut self, val: super::vals::Ampe1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Operation control of operational amplifier 2"]
            #[inline(always)]
            pub const fn ampe2(&self) -> super::vals::Ampe2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ampe2::from_bits(val as u8)
            }
            #[doc = "Operation control of operational amplifier 2"]
            #[inline(always)]
            pub fn set_ampe2(&mut self, val: super::vals::Ampe2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_3_6(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_3_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 3usize)) | (((val as u8) & 0x0f) << 3usize);
            }
            #[doc = "Reference Current Circuit Operation Control"]
            #[inline(always)]
            pub const fn irefe(&self) -> super::vals::Irefe {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Irefe::from_bits(val as u8)
            }
            #[doc = "Reference Current Circuit Operation Control"]
            #[inline(always)]
            pub fn set_irefe(&mut self, val: super::vals::Irefe) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ampc {
            #[inline(always)]
            fn default() -> Ampc {
                Ampc(0)
            }
        }
        impl core::fmt::Debug for Ampc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ampc")
                    .field("ampe0", &self.ampe0())
                    .field("ampe1", &self.ampe1())
                    .field("ampe2", &self.ampe2())
                    .field("reserved_3_6", &self.reserved_3_6())
                    .field("irefe", &self.irefe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ampc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ampc {{ ampe0: {:?}, ampe1: {:?}, ampe2: {:?}, reserved_3_6: {=u8:?}, irefe: {:?} }}" , self . ampe0 () , self . ampe1 () , self . ampe2 () , self . reserved_3_6 () , self . irefe ())
            }
        }
        #[doc = "Operational Amplifier Switch Charge Pump Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ampcpc(pub u8);
        impl Ampcpc {
            #[doc = "Charge Pump for AMP0 Enable"]
            #[inline(always)]
            pub const fn pump0en(&self) -> super::vals::Pump0en {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pump0en::from_bits(val as u8)
            }
            #[doc = "Charge Pump for AMP0 Enable"]
            #[inline(always)]
            pub fn set_pump0en(&mut self, val: super::vals::Pump0en) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Charge Pump for AMP1 Enable"]
            #[inline(always)]
            pub const fn pump1en(&self) -> super::vals::Pump1en {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pump1en::from_bits(val as u8)
            }
            #[doc = "Charge Pump for AMP1 Enable"]
            #[inline(always)]
            pub fn set_pump1en(&mut self, val: super::vals::Pump1en) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Charge Pump for AMP2 Enable"]
            #[inline(always)]
            pub const fn pump2en(&self) -> super::vals::Pump2en {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pump2en::from_bits(val as u8)
            }
            #[doc = "Charge Pump for AMP2 Enable"]
            #[inline(always)]
            pub fn set_pump2en(&mut self, val: super::vals::Pump2en) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Ampcpc {
            #[inline(always)]
            fn default() -> Ampcpc {
                Ampcpc(0)
            }
        }
        impl core::fmt::Debug for Ampcpc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ampcpc")
                    .field("pump0en", &self.pump0en())
                    .field("pump1en", &self.pump1en())
                    .field("pump2en", &self.pump2en())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ampcpc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ampcpc {{ pump0en: {:?}, pump1en: {:?}, pump2en: {:?}, reserved_3_7: {=u8:?} }}" , self . pump0en () , self . pump1en () , self . pump2en () , self . reserved_3_7 ())
            }
        }
        #[doc = "Operational amplifier mode control register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ampmc(pub u8);
        impl Ampmc {
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_0_5(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_0_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "OPAMP Operation mode selection"]
            #[inline(always)]
            pub const fn ampsp(&self) -> super::vals::Ampsp {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Ampsp::from_bits(val as u8)
            }
            #[doc = "OPAMP Operation mode selection"]
            #[inline(always)]
            pub fn set_ampsp(&mut self, val: super::vals::Ampsp) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Ampmc {
            #[inline(always)]
            fn default() -> Ampmc {
                Ampmc(0)
            }
        }
        impl core::fmt::Debug for Ampmc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ampmc")
                    .field("reserved_0_5", &self.reserved_0_5())
                    .field("ampsp", &self.ampsp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ampmc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ampmc {{ reserved_0_5: {=u8:?}, ampsp: {:?} }}",
                    self.reserved_0_5(),
                    self.ampsp()
                )
            }
        }
        #[doc = "Operational amplifier monitor register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ampmon(pub u8);
        impl Ampmon {
            #[doc = "OPAMP0 Status"]
            #[inline(always)]
            pub const fn ampmon0(&self) -> super::vals::Ampmon0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ampmon0::from_bits(val as u8)
            }
            #[doc = "OPAMP0 Status"]
            #[inline(always)]
            pub fn set_ampmon0(&mut self, val: super::vals::Ampmon0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "OPAMP1 Status"]
            #[inline(always)]
            pub const fn ampmon1(&self) -> super::vals::Ampmon1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ampmon1::from_bits(val as u8)
            }
            #[doc = "OPAMP1 Status"]
            #[inline(always)]
            pub fn set_ampmon1(&mut self, val: super::vals::Ampmon1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "OPAMP2 Status"]
            #[inline(always)]
            pub const fn ampmon2(&self) -> super::vals::Ampmon2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ampmon2::from_bits(val as u8)
            }
            #[doc = "OPAMP2 Status"]
            #[inline(always)]
            pub fn set_ampmon2(&mut self, val: super::vals::Ampmon2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Ampmon {
            #[inline(always)]
            fn default() -> Ampmon {
                Ampmon(0)
            }
        }
        impl core::fmt::Debug for Ampmon {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ampmon")
                    .field("ampmon0", &self.ampmon0())
                    .field("ampmon1", &self.ampmon1())
                    .field("ampmon2", &self.ampmon2())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ampmon {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ampmon {{ ampmon0: {:?}, ampmon1: {:?}, ampmon2: {:?}, reserved_3_7: {=u8:?} }}" , self . ampmon0 () , self . ampmon1 () , self . ampmon2 () , self . reserved_3_7 ())
            }
        }
        #[doc = "Operational amplifier trigger mode control register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amptrm(pub u8);
        impl Amptrm {
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub const fn amptrm00(&self) -> super::vals::Amptrm00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Amptrm00::from_bits(val as u8)
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub fn set_amptrm00(&mut self, val: super::vals::Amptrm00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub const fn amptrm01(&self) -> super::vals::Amptrm01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Amptrm01::from_bits(val as u8)
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub fn set_amptrm01(&mut self, val: super::vals::Amptrm01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub const fn amptrm10(&self) -> super::vals::Amptrm10 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Amptrm10::from_bits(val as u8)
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub fn set_amptrm10(&mut self, val: super::vals::Amptrm10) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub const fn amptrm11(&self) -> super::vals::Amptrm11 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Amptrm11::from_bits(val as u8)
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub fn set_amptrm11(&mut self, val: super::vals::Amptrm11) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub const fn amptrm20(&self) -> super::vals::Amptrm20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Amptrm20::from_bits(val as u8)
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub fn set_amptrm20(&mut self, val: super::vals::Amptrm20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub const fn amptrm21(&self) -> super::vals::Amptrm21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Amptrm21::from_bits(val as u8)
            }
            #[doc = "OPAMP function activation/stop trigger control"]
            #[inline(always)]
            pub fn set_amptrm21(&mut self, val: super::vals::Amptrm21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Amptrm {
            #[inline(always)]
            fn default() -> Amptrm {
                Amptrm(0)
            }
        }
        impl core::fmt::Debug for Amptrm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amptrm")
                    .field("amptrm00", &self.amptrm00())
                    .field("amptrm01", &self.amptrm01())
                    .field("amptrm10", &self.amptrm10())
                    .field("amptrm11", &self.amptrm11())
                    .field("amptrm20", &self.amptrm20())
                    .field("amptrm21", &self.amptrm21())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amptrm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Amptrm {{ amptrm00: {:?}, amptrm01: {:?}, amptrm10: {:?}, amptrm11: {:?}, amptrm20: {:?}, amptrm21: {:?}, reserved_6_7: {=u8:?} }}" , self . amptrm00 () , self . amptrm01 () , self . amptrm10 () , self . amptrm11 () , self . amptrm20 () , self . amptrm21 () , self . reserved_6_7 ())
            }
        }
        #[doc = "Operational Amplifier Activation Trigger Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amptrs(pub u8);
        impl Amptrs {
            #[doc = "Activation Trigger SelectionNote: Do not change the value of the AMPTRS register after setting the AMPTRM register."]
            #[inline(always)]
            pub const fn amptrs(&self) -> super::vals::Amptrs {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Amptrs::from_bits(val as u8)
            }
            #[doc = "Activation Trigger SelectionNote: Do not change the value of the AMPTRS register after setting the AMPTRM register."]
            #[inline(always)]
            pub fn set_amptrs(&mut self, val: super::vals::Amptrs) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Amptrs {
            #[inline(always)]
            fn default() -> Amptrs {
                Amptrs(0)
            }
        }
        impl core::fmt::Debug for Amptrs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amptrs")
                    .field("amptrs", &self.amptrs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amptrs {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Amptrs {{ amptrs: {:?} }}", self.amptrs())
            }
        }
        #[doc = "Operational Amplifier User Offset Trimming Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ampuote(pub u8);
        impl Ampuote {
            #[doc = "AMP0OT write enable"]
            #[inline(always)]
            pub const fn amp0te(&self) -> super::vals::Amp0te {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Amp0te::from_bits(val as u8)
            }
            #[doc = "AMP0OT write enable"]
            #[inline(always)]
            pub fn set_amp0te(&mut self, val: super::vals::Amp0te) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AMP1OT write enable"]
            #[inline(always)]
            pub const fn amp1te(&self) -> super::vals::Amp1te {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Amp1te::from_bits(val as u8)
            }
            #[doc = "AMP1OT write enable"]
            #[inline(always)]
            pub fn set_amp1te(&mut self, val: super::vals::Amp1te) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AMP2OT write enable"]
            #[inline(always)]
            pub const fn amp2te(&self) -> super::vals::Amp2te {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Amp2te::from_bits(val as u8)
            }
            #[doc = "AMP2OT write enable"]
            #[inline(always)]
            pub fn set_amp2te(&mut self, val: super::vals::Amp2te) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Ampuote {
            #[inline(always)]
            fn default() -> Ampuote {
                Ampuote(0)
            }
        }
        impl core::fmt::Debug for Ampuote {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ampuote")
                    .field("amp0te", &self.amp0te())
                    .field("amp1te", &self.amp1te())
                    .field("amp2te", &self.amp2te())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ampuote {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ampuote {{ amp0te: {:?}, amp1te: {:?}, amp2te: {:?}, reserved_3_7: {=u8:?} }}",
                    self.amp0te(),
                    self.amp1te(),
                    self.amp2te(),
                    self.reserved_3_7()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp0msAmpms0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp0msAmpms0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp0msAmpms0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp0msAmpms0 {
            #[inline(always)]
            fn from(val: u8) -> Amp0msAmpms0 {
                Amp0msAmpms0::from_bits(val)
            }
        }
        impl From<Amp0msAmpms0> for u8 {
            #[inline(always)]
            fn from(val: Amp0msAmpms0) -> u8 {
                Amp0msAmpms0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp0msAmpms7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp0msAmpms7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp0msAmpms7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp0msAmpms7 {
            #[inline(always)]
            fn from(val: u8) -> Amp0msAmpms7 {
                Amp0msAmpms7::from_bits(val)
            }
        }
        impl From<Amp0msAmpms7> for u8 {
            #[inline(always)]
            fn from(val: Amp0msAmpms7) -> u8 {
                Amp0msAmpms7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp0psAmpms7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp0psAmpms7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp0psAmpms7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp0psAmpms7 {
            #[inline(always)]
            fn from(val: u8) -> Amp0psAmpms7 {
                Amp0psAmpms7::from_bits(val)
            }
        }
        impl From<Amp0psAmpms7> for u8 {
            #[inline(always)]
            fn from(val: Amp0psAmpms7) -> u8 {
                Amp0psAmpms7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp0psAmpps0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp0psAmpps0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp0psAmpps0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp0psAmpps0 {
            #[inline(always)]
            fn from(val: u8) -> Amp0psAmpps0 {
                Amp0psAmpps0::from_bits(val)
            }
        }
        impl From<Amp0psAmpps0> for u8 {
            #[inline(always)]
            fn from(val: Amp0psAmpps0) -> u8 {
                Amp0psAmpps0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp0psAmpps1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp0psAmpps1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp0psAmpps1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp0psAmpps1 {
            #[inline(always)]
            fn from(val: u8) -> Amp0psAmpps1 {
                Amp0psAmpps1::from_bits(val)
            }
        }
        impl From<Amp0psAmpps1> for u8 {
            #[inline(always)]
            fn from(val: Amp0psAmpps1) -> u8 {
                Amp0psAmpps1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp0psAmpps2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp0psAmpps2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp0psAmpps2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp0psAmpps2 {
            #[inline(always)]
            fn from(val: u8) -> Amp0psAmpps2 {
                Amp0psAmpps2::from_bits(val)
            }
        }
        impl From<Amp0psAmpps2> for u8 {
            #[inline(always)]
            fn from(val: Amp0psAmpps2) -> u8 {
                Amp0psAmpps2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp0psAmpps3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp0psAmpps3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp0psAmpps3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp0psAmpps3 {
            #[inline(always)]
            fn from(val: u8) -> Amp0psAmpps3 {
                Amp0psAmpps3::from_bits(val)
            }
        }
        impl From<Amp0psAmpps3> for u8 {
            #[inline(always)]
            fn from(val: Amp0psAmpps3) -> u8 {
                Amp0psAmpps3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp0te {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp0te {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp0te {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp0te {
            #[inline(always)]
            fn from(val: u8) -> Amp0te {
                Amp0te::from_bits(val)
            }
        }
        impl From<Amp0te> for u8 {
            #[inline(always)]
            fn from(val: Amp0te) -> u8 {
                Amp0te::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp1msAmpms0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp1msAmpms0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp1msAmpms0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp1msAmpms0 {
            #[inline(always)]
            fn from(val: u8) -> Amp1msAmpms0 {
                Amp1msAmpms0::from_bits(val)
            }
        }
        impl From<Amp1msAmpms0> for u8 {
            #[inline(always)]
            fn from(val: Amp1msAmpms0) -> u8 {
                Amp1msAmpms0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp1msAmpms7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp1msAmpms7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp1msAmpms7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp1msAmpms7 {
            #[inline(always)]
            fn from(val: u8) -> Amp1msAmpms7 {
                Amp1msAmpms7::from_bits(val)
            }
        }
        impl From<Amp1msAmpms7> for u8 {
            #[inline(always)]
            fn from(val: Amp1msAmpms7) -> u8 {
                Amp1msAmpms7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp1psAmpms7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp1psAmpms7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp1psAmpms7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp1psAmpms7 {
            #[inline(always)]
            fn from(val: u8) -> Amp1psAmpms7 {
                Amp1psAmpms7::from_bits(val)
            }
        }
        impl From<Amp1psAmpms7> for u8 {
            #[inline(always)]
            fn from(val: Amp1psAmpms7) -> u8 {
                Amp1psAmpms7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp1psAmpps0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp1psAmpps0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp1psAmpps0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp1psAmpps0 {
            #[inline(always)]
            fn from(val: u8) -> Amp1psAmpps0 {
                Amp1psAmpps0::from_bits(val)
            }
        }
        impl From<Amp1psAmpps0> for u8 {
            #[inline(always)]
            fn from(val: Amp1psAmpps0) -> u8 {
                Amp1psAmpps0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp1psAmpps1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp1psAmpps1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp1psAmpps1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp1psAmpps1 {
            #[inline(always)]
            fn from(val: u8) -> Amp1psAmpps1 {
                Amp1psAmpps1::from_bits(val)
            }
        }
        impl From<Amp1psAmpps1> for u8 {
            #[inline(always)]
            fn from(val: Amp1psAmpps1) -> u8 {
                Amp1psAmpps1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp1psAmpps2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp1psAmpps2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp1psAmpps2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp1psAmpps2 {
            #[inline(always)]
            fn from(val: u8) -> Amp1psAmpps2 {
                Amp1psAmpps2::from_bits(val)
            }
        }
        impl From<Amp1psAmpps2> for u8 {
            #[inline(always)]
            fn from(val: Amp1psAmpps2) -> u8 {
                Amp1psAmpps2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp1psAmpps3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp1psAmpps3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp1psAmpps3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp1psAmpps3 {
            #[inline(always)]
            fn from(val: u8) -> Amp1psAmpps3 {
                Amp1psAmpps3::from_bits(val)
            }
        }
        impl From<Amp1psAmpps3> for u8 {
            #[inline(always)]
            fn from(val: Amp1psAmpps3) -> u8 {
                Amp1psAmpps3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp1te {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp1te {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp1te {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp1te {
            #[inline(always)]
            fn from(val: u8) -> Amp1te {
                Amp1te::from_bits(val)
            }
        }
        impl From<Amp1te> for u8 {
            #[inline(always)]
            fn from(val: Amp1te) -> u8 {
                Amp1te::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp2msAmpms0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp2msAmpms0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp2msAmpms0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp2msAmpms0 {
            #[inline(always)]
            fn from(val: u8) -> Amp2msAmpms0 {
                Amp2msAmpms0::from_bits(val)
            }
        }
        impl From<Amp2msAmpms0> for u8 {
            #[inline(always)]
            fn from(val: Amp2msAmpms0) -> u8 {
                Amp2msAmpms0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp2msAmpms7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp2msAmpms7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp2msAmpms7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp2msAmpms7 {
            #[inline(always)]
            fn from(val: u8) -> Amp2msAmpms7 {
                Amp2msAmpms7::from_bits(val)
            }
        }
        impl From<Amp2msAmpms7> for u8 {
            #[inline(always)]
            fn from(val: Amp2msAmpms7) -> u8 {
                Amp2msAmpms7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp2psAmpps0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp2psAmpps0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp2psAmpps0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp2psAmpps0 {
            #[inline(always)]
            fn from(val: u8) -> Amp2psAmpps0 {
                Amp2psAmpps0::from_bits(val)
            }
        }
        impl From<Amp2psAmpps0> for u8 {
            #[inline(always)]
            fn from(val: Amp2psAmpps0) -> u8 {
                Amp2psAmpps0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp2psAmpps1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp2psAmpps1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp2psAmpps1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp2psAmpps1 {
            #[inline(always)]
            fn from(val: u8) -> Amp2psAmpps1 {
                Amp2psAmpps1::from_bits(val)
            }
        }
        impl From<Amp2psAmpps1> for u8 {
            #[inline(always)]
            fn from(val: Amp2psAmpps1) -> u8 {
                Amp2psAmpps1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amp2te {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amp2te {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amp2te {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amp2te {
            #[inline(always)]
            fn from(val: u8) -> Amp2te {
                Amp2te::from_bits(val)
            }
        }
        impl From<Amp2te> for u8 {
            #[inline(always)]
            fn from(val: Amp2te) -> u8 {
                Amp2te::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampe0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampe0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampe0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampe0 {
            #[inline(always)]
            fn from(val: u8) -> Ampe0 {
                Ampe0::from_bits(val)
            }
        }
        impl From<Ampe0> for u8 {
            #[inline(always)]
            fn from(val: Ampe0) -> u8 {
                Ampe0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampe1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampe1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampe1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampe1 {
            #[inline(always)]
            fn from(val: u8) -> Ampe1 {
                Ampe1::from_bits(val)
            }
        }
        impl From<Ampe1> for u8 {
            #[inline(always)]
            fn from(val: Ampe1) -> u8 {
                Ampe1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampe2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampe2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampe2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampe2 {
            #[inline(always)]
            fn from(val: u8) -> Ampe2 {
                Ampe2::from_bits(val)
            }
        }
        impl From<Ampe2> for u8 {
            #[inline(always)]
            fn from(val: Ampe2) -> u8 {
                Ampe2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampmon0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampmon0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampmon0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampmon0 {
            #[inline(always)]
            fn from(val: u8) -> Ampmon0 {
                Ampmon0::from_bits(val)
            }
        }
        impl From<Ampmon0> for u8 {
            #[inline(always)]
            fn from(val: Ampmon0) -> u8 {
                Ampmon0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampmon1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampmon1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampmon1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampmon1 {
            #[inline(always)]
            fn from(val: u8) -> Ampmon1 {
                Ampmon1::from_bits(val)
            }
        }
        impl From<Ampmon1> for u8 {
            #[inline(always)]
            fn from(val: Ampmon1) -> u8 {
                Ampmon1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampmon2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampmon2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampmon2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampmon2 {
            #[inline(always)]
            fn from(val: u8) -> Ampmon2 {
                Ampmon2::from_bits(val)
            }
        }
        impl From<Ampmon2> for u8 {
            #[inline(always)]
            fn from(val: Ampmon2) -> u8 {
                Ampmon2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampms1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampms1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampms1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampms1 {
            #[inline(always)]
            fn from(val: u8) -> Ampms1 {
                Ampms1::from_bits(val)
            }
        }
        impl From<Ampms1> for u8 {
            #[inline(always)]
            fn from(val: Ampms1) -> u8 {
                Ampms1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampms2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampms2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampms2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampms2 {
            #[inline(always)]
            fn from(val: u8) -> Ampms2 {
                Ampms2::from_bits(val)
            }
        }
        impl From<Ampms2> for u8 {
            #[inline(always)]
            fn from(val: Ampms2) -> u8 {
                Ampms2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampms3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampms3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampms3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampms3 {
            #[inline(always)]
            fn from(val: u8) -> Ampms3 {
                Ampms3::from_bits(val)
            }
        }
        impl From<Ampms3> for u8 {
            #[inline(always)]
            fn from(val: Ampms3) -> u8 {
                Ampms3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampms4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampms4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampms4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampms4 {
            #[inline(always)]
            fn from(val: u8) -> Ampms4 {
                Ampms4::from_bits(val)
            }
        }
        impl From<Ampms4> for u8 {
            #[inline(always)]
            fn from(val: Ampms4) -> u8 {
                Ampms4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampos0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampos0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampos0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampos0 {
            #[inline(always)]
            fn from(val: u8) -> Ampos0 {
                Ampos0::from_bits(val)
            }
        }
        impl From<Ampos0> for u8 {
            #[inline(always)]
            fn from(val: Ampos0) -> u8 {
                Ampos0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampos1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampos1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampos1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampos1 {
            #[inline(always)]
            fn from(val: u8) -> Ampos1 {
                Ampos1::from_bits(val)
            }
        }
        impl From<Ampos1> for u8 {
            #[inline(always)]
            fn from(val: Ampos1) -> u8 {
                Ampos1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampos2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampos2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampos2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampos2 {
            #[inline(always)]
            fn from(val: u8) -> Ampos2 {
                Ampos2::from_bits(val)
            }
        }
        impl From<Ampos2> for u8 {
            #[inline(always)]
            fn from(val: Ampos2) -> u8 {
                Ampos2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampos3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampos3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampos3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampos3 {
            #[inline(always)]
            fn from(val: u8) -> Ampos3 {
                Ampos3::from_bits(val)
            }
        }
        impl From<Ampos3> for u8 {
            #[inline(always)]
            fn from(val: Ampos3) -> u8 {
                Ampos3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampps7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ampps7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampps7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampps7 {
            #[inline(always)]
            fn from(val: u8) -> Ampps7 {
                Ampps7::from_bits(val)
            }
        }
        impl From<Ampps7> for u8 {
            #[inline(always)]
            fn from(val: Ampps7) -> u8 {
                Ampps7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ampsp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ampsp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ampsp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ampsp {
            #[inline(always)]
            fn from(val: u8) -> Ampsp {
                Ampsp::from_bits(val)
            }
        }
        impl From<Ampsp> for u8 {
            #[inline(always)]
            fn from(val: Ampsp) -> u8 {
                Ampsp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amptrm00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amptrm00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amptrm00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amptrm00 {
            #[inline(always)]
            fn from(val: u8) -> Amptrm00 {
                Amptrm00::from_bits(val)
            }
        }
        impl From<Amptrm00> for u8 {
            #[inline(always)]
            fn from(val: Amptrm00) -> u8 {
                Amptrm00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amptrm01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amptrm01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amptrm01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amptrm01 {
            #[inline(always)]
            fn from(val: u8) -> Amptrm01 {
                Amptrm01::from_bits(val)
            }
        }
        impl From<Amptrm01> for u8 {
            #[inline(always)]
            fn from(val: Amptrm01) -> u8 {
                Amptrm01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amptrm10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amptrm10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amptrm10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amptrm10 {
            #[inline(always)]
            fn from(val: u8) -> Amptrm10 {
                Amptrm10::from_bits(val)
            }
        }
        impl From<Amptrm10> for u8 {
            #[inline(always)]
            fn from(val: Amptrm10) -> u8 {
                Amptrm10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amptrm11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amptrm11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amptrm11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amptrm11 {
            #[inline(always)]
            fn from(val: u8) -> Amptrm11 {
                Amptrm11::from_bits(val)
            }
        }
        impl From<Amptrm11> for u8 {
            #[inline(always)]
            fn from(val: Amptrm11) -> u8 {
                Amptrm11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amptrm20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amptrm20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amptrm20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amptrm20 {
            #[inline(always)]
            fn from(val: u8) -> Amptrm20 {
                Amptrm20::from_bits(val)
            }
        }
        impl From<Amptrm20> for u8 {
            #[inline(always)]
            fn from(val: Amptrm20) -> u8 {
                Amptrm20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amptrm21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Amptrm21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amptrm21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amptrm21 {
            #[inline(always)]
            fn from(val: u8) -> Amptrm21 {
                Amptrm21::from_bits(val)
            }
        }
        impl From<Amptrm21> for u8 {
            #[inline(always)]
            fn from(val: Amptrm21) -> u8 {
                Amptrm21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Amptrs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Amptrs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Amptrs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Amptrs {
            #[inline(always)]
            fn from(val: u8) -> Amptrs {
                Amptrs::from_bits(val)
            }
        }
        impl From<Amptrs> for u8 {
            #[inline(always)]
            fn from(val: Amptrs) -> u8 {
                Amptrs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irefe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Irefe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irefe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irefe {
            #[inline(always)]
            fn from(val: u8) -> Irefe {
                Irefe::from_bits(val)
            }
        }
        impl From<Irefe> for u8 {
            #[inline(always)]
            fn from(val: Irefe) -> u8 {
                Irefe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pump0en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pump0en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pump0en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pump0en {
            #[inline(always)]
            fn from(val: u8) -> Pump0en {
                Pump0en::from_bits(val)
            }
        }
        impl From<Pump0en> for u8 {
            #[inline(always)]
            fn from(val: Pump0en) -> u8 {
                Pump0en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pump1en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pump1en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pump1en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pump1en {
            #[inline(always)]
            fn from(val: u8) -> Pump1en {
                Pump1en::from_bits(val)
            }
        }
        impl From<Pump1en> for u8 {
            #[inline(always)]
            fn from(val: Pump1en) -> u8 {
                Pump1en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pump2en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pump2en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pump2en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pump2en {
            #[inline(always)]
            fn from(val: u8) -> Pump2en {
                Pump2en::from_bits(val)
            }
        }
        impl From<Pump2en> for u8 {
            #[inline(always)]
            fn from(val: Pump2en) -> u8 {
                Pump2en::to_bits(val)
            }
        }
    }
}
pub mod pfs {
    #[doc = "Pmn Pin Function Control Register"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pfs {
        ptr: *mut u8,
    }
    unsafe impl Send for Pfs {}
    unsafe impl Sync for Pfs {}
    impl Pfs {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "P000 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p000pfs(self) -> crate::common::Reg<regs::P000pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "P000 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p000pfs_ha(self) -> crate::common::Reg<regs::P000pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "P000 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p000pfs_by(self) -> crate::common::Reg<regs::P000pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "P00%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p00pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
        #[doc = "P00%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p00pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize + n * 4usize) as _) }
        }
        #[doc = "P00%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p00pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize + n * 4usize) as _) }
        }
        #[doc = "P0%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p0pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize + n * 4usize) as _) }
        }
        #[doc = "P0%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p0pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x32usize + n * 4usize) as _) }
        }
        #[doc = "P0%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p0pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x33usize + n * 4usize) as _) }
        }
        #[doc = "P100 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p100pfs(self) -> crate::common::Reg<regs::P100pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "P100 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p100pfs_ha(self) -> crate::common::Reg<regs::P100pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x42usize) as _) }
        }
        #[doc = "P100 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p100pfs_by(self) -> crate::common::Reg<regs::P100pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x43usize) as _) }
        }
        #[doc = "P10%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p10pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize + n * 4usize) as _) }
        }
        #[doc = "P10%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p10pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x46usize + n * 4usize) as _) }
        }
        #[doc = "P10%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p10pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x47usize + n * 4usize) as _) }
        }
        #[doc = "P108 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p108pfs(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "P108 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p108pfs_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x62usize) as _) }
        }
        #[doc = "P108 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p108pfs_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x63usize) as _) }
        }
        #[doc = "P109 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p109pfs(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "P109 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p109pfs_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x66usize) as _) }
        }
        #[doc = "P109 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p109pfs_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x67usize) as _) }
        }
        #[doc = "P1%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p1pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize + n * 4usize) as _) }
        }
        #[doc = "P1%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p1pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6ausize + n * 4usize) as _) }
        }
        #[doc = "P1%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p1pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6busize + n * 4usize) as _) }
        }
        #[doc = "P200 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p200pfs(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "P200 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p200pfs_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x82usize) as _) }
        }
        #[doc = "P200 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p200pfs_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x83usize) as _) }
        }
        #[doc = "P201 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p201pfs(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "P201 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p201pfs_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x86usize) as _) }
        }
        #[doc = "P201 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p201pfs_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x87usize) as _) }
        }
        #[doc = "P20%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p20pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize + n * 4usize) as _) }
        }
        #[doc = "P20%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p20pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x92usize + n * 4usize) as _) }
        }
        #[doc = "P20%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p20pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x93usize + n * 4usize) as _) }
        }
        #[doc = "P2%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p2pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize + n * 4usize) as _) }
        }
        #[doc = "P2%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p2pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb2usize + n * 4usize) as _) }
        }
        #[doc = "P2%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p2pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb3usize + n * 4usize) as _) }
        }
        #[doc = "P300 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p300pfs(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "P300 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p300pfs_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc2usize) as _) }
        }
        #[doc = "P300 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p300pfs_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc3usize) as _) }
        }
        #[doc = "P30%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p30pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc4usize + n * 4usize) as _) }
        }
        #[doc = "P30%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p30pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc6usize + n * 4usize) as _) }
        }
        #[doc = "P30%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p30pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc7usize + n * 4usize) as _) }
        }
        #[doc = "P40%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p40pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "P40%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p40pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize + n * 4usize) as _) }
        }
        #[doc = "P40%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p40pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0103usize + n * 4usize) as _) }
        }
        #[doc = "P407 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p407pfs(self) -> crate::common::Reg<regs::P407pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "P407 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p407pfs_ha(self) -> crate::common::Reg<regs::P407pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011eusize) as _) }
        }
        #[doc = "P407 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p407pfs_by(self) -> crate::common::Reg<regs::P407pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011fusize) as _) }
        }
        #[doc = "P40%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p40pfs_1(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize + n * 4usize) as _) }
        }
        #[doc = "P40%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p40pfs_ha_1(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0122usize + n * 4usize) as _) }
        }
        #[doc = "P40%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p40pfs_by_1(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0123usize + n * 4usize) as _) }
        }
        #[doc = "P4%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p4pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize + n * 4usize) as _) }
        }
        #[doc = "P4%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p4pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012ausize + n * 4usize) as _) }
        }
        #[doc = "P4%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p4pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012busize + n * 4usize) as _) }
        }
        #[doc = "P50%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p50pfs(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize + n * 4usize) as _) }
        }
        #[doc = "P50%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p50pfs_ha(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0142usize + n * 4usize) as _) }
        }
        #[doc = "P50%s Pin Function Control Register"]
        #[inline(always)]
        pub const fn p50pfs_by(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0143usize + n * 4usize) as _) }
        }
        #[doc = "P914 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p914pfs(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0278usize) as _) }
        }
        #[doc = "P914 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p914pfs_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x027ausize) as _) }
        }
        #[doc = "P914 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p914pfs_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x027busize) as _) }
        }
        #[doc = "P915 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p915pfs(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x027cusize) as _) }
        }
        #[doc = "P915 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p915pfs_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x027eusize) as _) }
        }
        #[doc = "P915 Pin Function Control Register"]
        #[inline(always)]
        pub const fn p915pfs_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x027fusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "P000 Pin Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P000pfs(pub u32);
        impl P000pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P000pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P000pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P000pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P000pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P000pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P000pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P000pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P000pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P000pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P000pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P000pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P000pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P000pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P000pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P000pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_7_9(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_7_9(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 7usize)) | (((val as u32) & 0x07) << 7usize);
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub const fn dscr(&self) -> super::vals::P000pfsDscr {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::P000pfsDscr::from_bits(val as u8)
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub fn set_dscr(&mut self, val: super::vals::P000pfsDscr) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_11_13(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_11_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 11usize)) | (((val as u32) & 0x07) << 11usize);
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P000pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P000pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P000pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P000pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P000pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P000pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P000pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P000pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P000pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_17_23(&self) -> u8 {
                let val = (self.0 >> 17usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_17_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 17usize)) | (((val as u32) & 0x7f) << 17usize);
            }
            #[doc = "Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_29_31(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_29_31(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
            }
        }
        impl Default for P000pfs {
            #[inline(always)]
            fn default() -> P000pfs {
                P000pfs(0)
            }
        }
        impl core::fmt::Debug for P000pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P000pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("pcr", &self.pcr())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ncodr", &self.ncodr())
                    .field("reserved_7_9", &self.reserved_7_9())
                    .field("dscr", &self.dscr())
                    .field("reserved_11_13", &self.reserved_11_13())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("reserved_17_23", &self.reserved_17_23())
                    .field("psel", &self.psel())
                    .field("reserved_29_31", &self.reserved_29_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P000pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P000pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, reserved_3_3: {=bool:?}, pcr: {:?}, reserved_5_5: {=bool:?}, ncodr: {:?}, reserved_7_9: {=u8:?}, dscr: {:?}, reserved_11_13: {=u8:?}, isel: {:?}, asel: {:?}, pmr: {:?}, reserved_17_23: {=u8:?}, psel: {=u8:?}, reserved_29_31: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . reserved_3_3 () , self . pcr () , self . reserved_5_5 () , self . ncodr () , self . reserved_7_9 () , self . dscr () , self . reserved_11_13 () , self . isel () , self . asel () , self . pmr () , self . reserved_17_23 () , self . psel () , self . reserved_29_31 ())
            }
        }
        #[doc = "P000 Pin Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P000pfsBy(pub u8);
        impl P000pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P000pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P000pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P000pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P000pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P000pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P000pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P000pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P000pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P000pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P000pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P000pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P000pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P000pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P000pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P000pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for P000pfsBy {
            #[inline(always)]
            fn default() -> P000pfsBy {
                P000pfsBy(0)
            }
        }
        impl core::fmt::Debug for P000pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P000pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("pcr", &self.pcr())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ncodr", &self.ncodr())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P000pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P000pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, reserved_3_3: {=bool:?}, pcr: {:?}, reserved_5_5: {=bool:?}, ncodr: {:?}, reserved_7_7: {=bool:?} }}" , self . podr () , self . pidr () , self . pdr () , self . reserved_3_3 () , self . pcr () , self . reserved_5_5 () , self . ncodr () , self . reserved_7_7 ())
            }
        }
        #[doc = "P000 Pin Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P000pfsHa(pub u16);
        impl P000pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P000pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P000pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P000pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P000pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P000pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P000pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P000pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P000pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P000pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u16) & 0x01) << 3usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P000pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P000pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P000pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u16) & 0x01) << 5usize);
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P000pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P000pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P000pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_7_9(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_7_9(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 7usize)) | (((val as u16) & 0x07) << 7usize);
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub const fn dscr(&self) -> super::vals::P000pfsHaDscr {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::P000pfsHaDscr::from_bits(val as u8)
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub fn set_dscr(&mut self, val: super::vals::P000pfsHaDscr) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_11_13(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_11_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 11usize)) | (((val as u16) & 0x07) << 11usize);
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P000pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P000pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P000pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P000pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P000pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P000pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P000pfsHa {
            #[inline(always)]
            fn default() -> P000pfsHa {
                P000pfsHa(0)
            }
        }
        impl core::fmt::Debug for P000pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P000pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("pcr", &self.pcr())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ncodr", &self.ncodr())
                    .field("reserved_7_9", &self.reserved_7_9())
                    .field("dscr", &self.dscr())
                    .field("reserved_11_13", &self.reserved_11_13())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P000pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P000pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, reserved_3_3: {=bool:?}, pcr: {:?}, reserved_5_5: {=bool:?}, ncodr: {:?}, reserved_7_9: {=u8:?}, dscr: {:?}, reserved_11_13: {=u8:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . reserved_3_3 () , self . pcr () , self . reserved_5_5 () , self . ncodr () , self . reserved_7_9 () , self . dscr () , self . reserved_11_13 () , self . isel () , self . asel ())
            }
        }
        #[doc = "P100 Pin Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P100pfs(pub u32);
        impl P100pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P100pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P100pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P100pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P100pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P100pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P100pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P100pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P100pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P100pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P100pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P100pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P100pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P100pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P100pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P100pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_7_9(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_7_9(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 7usize)) | (((val as u32) & 0x07) << 7usize);
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub const fn dscr(&self) -> super::vals::P100pfsDscr {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::P100pfsDscr::from_bits(val as u8)
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub fn set_dscr(&mut self, val: super::vals::P100pfsDscr) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_11_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_11_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P100pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P100pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P100pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P100pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P100pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P100pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P100pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P100pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P100pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P100pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P100pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P100pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_17_23(&self) -> u8 {
                let val = (self.0 >> 17usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_17_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 17usize)) | (((val as u32) & 0x7f) << 17usize);
            }
            #[doc = "Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_29_31(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_29_31(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
            }
        }
        impl Default for P100pfs {
            #[inline(always)]
            fn default() -> P100pfs {
                P100pfs(0)
            }
        }
        impl core::fmt::Debug for P100pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P100pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("pcr", &self.pcr())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ncodr", &self.ncodr())
                    .field("reserved_7_9", &self.reserved_7_9())
                    .field("dscr", &self.dscr())
                    .field("reserved_11_11", &self.reserved_11_11())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("reserved_17_23", &self.reserved_17_23())
                    .field("psel", &self.psel())
                    .field("reserved_29_31", &self.reserved_29_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P100pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P100pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, reserved_3_3: {=bool:?}, pcr: {:?}, reserved_5_5: {=bool:?}, ncodr: {:?}, reserved_7_9: {=u8:?}, dscr: {:?}, reserved_11_11: {=bool:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, reserved_17_23: {=u8:?}, psel: {=u8:?}, reserved_29_31: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . reserved_3_3 () , self . pcr () , self . reserved_5_5 () , self . ncodr () , self . reserved_7_9 () , self . dscr () , self . reserved_11_11 () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . reserved_17_23 () , self . psel () , self . reserved_29_31 ())
            }
        }
        #[doc = "P100 Pin Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P100pfsBy(pub u8);
        impl P100pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P100pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P100pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P100pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P100pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P100pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P100pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P100pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P100pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P100pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P100pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P100pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P100pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P100pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P100pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P100pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for P100pfsBy {
            #[inline(always)]
            fn default() -> P100pfsBy {
                P100pfsBy(0)
            }
        }
        impl core::fmt::Debug for P100pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P100pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("pcr", &self.pcr())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ncodr", &self.ncodr())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P100pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P100pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, reserved_3_3: {=bool:?}, pcr: {:?}, reserved_5_5: {=bool:?}, ncodr: {:?}, reserved_7_7: {=bool:?} }}" , self . podr () , self . pidr () , self . pdr () , self . reserved_3_3 () , self . pcr () , self . reserved_5_5 () , self . ncodr () , self . reserved_7_7 ())
            }
        }
        #[doc = "P100 Pin Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P100pfsHa(pub u16);
        impl P100pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P100pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P100pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P100pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P100pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P100pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P100pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P100pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P100pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P100pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u16) & 0x01) << 3usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P100pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P100pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P100pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u16) & 0x01) << 5usize);
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P100pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P100pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P100pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_7_9(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_7_9(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 7usize)) | (((val as u16) & 0x07) << 7usize);
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub const fn dscr(&self) -> super::vals::P100pfsHaDscr {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::P100pfsHaDscr::from_bits(val as u8)
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub fn set_dscr(&mut self, val: super::vals::P100pfsHaDscr) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_11_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_11_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u16) & 0x01) << 11usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P100pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P100pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P100pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P100pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P100pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P100pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P100pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P100pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P100pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P100pfsHa {
            #[inline(always)]
            fn default() -> P100pfsHa {
                P100pfsHa(0)
            }
        }
        impl core::fmt::Debug for P100pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P100pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("pcr", &self.pcr())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ncodr", &self.ncodr())
                    .field("reserved_7_9", &self.reserved_7_9())
                    .field("dscr", &self.dscr())
                    .field("reserved_11_11", &self.reserved_11_11())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P100pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P100pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, reserved_3_3: {=bool:?}, pcr: {:?}, reserved_5_5: {=bool:?}, ncodr: {:?}, reserved_7_9: {=u8:?}, dscr: {:?}, reserved_11_11: {=bool:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . reserved_3_3 () , self . pcr () , self . reserved_5_5 () , self . ncodr () , self . reserved_7_9 () , self . dscr () , self . reserved_11_11 () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "P407 Pin Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P407pfs(pub u32);
        impl P407pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P407pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P407pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P407pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P407pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P407pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P407pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P407pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P407pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P407pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P407pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P407pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P407pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P407pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P407pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P407pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_7_9(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_7_9(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 7usize)) | (((val as u32) & 0x07) << 7usize);
            }
            #[inline(always)]
            pub const fn dscr(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_dscr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub const fn dscr1(&self) -> super::vals::P407pfsDscr1 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::P407pfsDscr1::from_bits(val as u8)
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub fn set_dscr1(&mut self, val: super::vals::P407pfsDscr1) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_12_13(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_12_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P407pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P407pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P407pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P407pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P407pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P407pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P407pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P407pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P407pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_17_23(&self) -> u8 {
                let val = (self.0 >> 17usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_17_23(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 17usize)) | (((val as u32) & 0x7f) << 17usize);
            }
            #[doc = "Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Port Function Select These bits select the peripheral function. For individual pin functions, see the MPC table"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_29_31(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_29_31(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
            }
        }
        impl Default for P407pfs {
            #[inline(always)]
            fn default() -> P407pfs {
                P407pfs(0)
            }
        }
        impl core::fmt::Debug for P407pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P407pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("pcr", &self.pcr())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ncodr", &self.ncodr())
                    .field("reserved_7_9", &self.reserved_7_9())
                    .field("dscr", &self.dscr())
                    .field("dscr1", &self.dscr1())
                    .field("reserved_12_13", &self.reserved_12_13())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("reserved_17_23", &self.reserved_17_23())
                    .field("psel", &self.psel())
                    .field("reserved_29_31", &self.reserved_29_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P407pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P407pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, reserved_3_3: {=bool:?}, pcr: {:?}, reserved_5_5: {=bool:?}, ncodr: {:?}, reserved_7_9: {=u8:?}, dscr: {=bool:?}, dscr1: {:?}, reserved_12_13: {=u8:?}, isel: {:?}, asel: {:?}, pmr: {:?}, reserved_17_23: {=u8:?}, psel: {=u8:?}, reserved_29_31: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . reserved_3_3 () , self . pcr () , self . reserved_5_5 () , self . ncodr () , self . reserved_7_9 () , self . dscr () , self . dscr1 () , self . reserved_12_13 () , self . isel () , self . asel () , self . pmr () , self . reserved_17_23 () , self . psel () , self . reserved_29_31 ())
            }
        }
        #[doc = "P407 Pin Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P407pfsBy(pub u8);
        impl P407pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P407pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P407pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P407pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P407pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P407pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P407pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P407pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P407pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P407pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P407pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P407pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P407pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P407pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P407pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P407pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for P407pfsBy {
            #[inline(always)]
            fn default() -> P407pfsBy {
                P407pfsBy(0)
            }
        }
        impl core::fmt::Debug for P407pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P407pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("pcr", &self.pcr())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ncodr", &self.ncodr())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P407pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P407pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, reserved_3_3: {=bool:?}, pcr: {:?}, reserved_5_5: {=bool:?}, ncodr: {:?}, reserved_7_7: {=bool:?} }}" , self . podr () , self . pidr () , self . pdr () , self . reserved_3_3 () , self . pcr () , self . reserved_5_5 () , self . ncodr () , self . reserved_7_7 ())
            }
        }
        #[doc = "P407 Pin Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P407pfsHa(pub u16);
        impl P407pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P407pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P407pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P407pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P407pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P407pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port Input Data"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P407pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P407pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P407pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P407pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u16) & 0x01) << 3usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P407pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P407pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P407pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u16) & 0x01) << 5usize);
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P407pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P407pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P407pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_7_9(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_7_9(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 7usize)) | (((val as u16) & 0x07) << 7usize);
            }
            #[inline(always)]
            pub const fn dscr(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_dscr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u16) & 0x01) << 10usize);
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub const fn dscr1(&self) -> super::vals::P407pfsHaDscr1 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::P407pfsHaDscr1::from_bits(val as u8)
            }
            #[doc = "Drive Strength Control Register"]
            #[inline(always)]
            pub fn set_dscr1(&mut self, val: super::vals::P407pfsHaDscr1) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_12_13(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_12_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P407pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P407pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ input enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P407pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P407pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P407pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P407pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P407pfsHa {
            #[inline(always)]
            fn default() -> P407pfsHa {
                P407pfsHa(0)
            }
        }
        impl core::fmt::Debug for P407pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P407pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("pcr", &self.pcr())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ncodr", &self.ncodr())
                    .field("reserved_7_9", &self.reserved_7_9())
                    .field("dscr", &self.dscr())
                    .field("dscr1", &self.dscr1())
                    .field("reserved_12_13", &self.reserved_12_13())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P407pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P407pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, reserved_3_3: {=bool:?}, pcr: {:?}, reserved_5_5: {=bool:?}, ncodr: {:?}, reserved_7_9: {=u8:?}, dscr: {=bool:?}, dscr1: {:?}, reserved_12_13: {=u8:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . reserved_3_3 () , self . pcr () , self . reserved_5_5 () , self . ncodr () , self . reserved_7_9 () , self . dscr () , self . dscr1 () , self . reserved_12_13 () , self . isel () , self . asel ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P000pfsAsel {
                P000pfsAsel::from_bits(val)
            }
        }
        impl From<P000pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P000pfsAsel) -> u8 {
                P000pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsByNcodr {
                P000pfsByNcodr::from_bits(val)
            }
        }
        impl From<P000pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsByNcodr) -> u8 {
                P000pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsByPcr {
                P000pfsByPcr::from_bits(val)
            }
        }
        impl From<P000pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsByPcr) -> u8 {
                P000pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsByPdr {
                P000pfsByPdr::from_bits(val)
            }
        }
        impl From<P000pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsByPdr) -> u8 {
                P000pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsByPidr {
                P000pfsByPidr::from_bits(val)
            }
        }
        impl From<P000pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsByPidr) -> u8 {
                P000pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsByPodr {
                P000pfsByPodr::from_bits(val)
            }
        }
        impl From<P000pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsByPodr) -> u8 {
                P000pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsDscr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsDscr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsDscr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsDscr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsDscr {
                P000pfsDscr::from_bits(val)
            }
        }
        impl From<P000pfsDscr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsDscr) -> u8 {
                P000pfsDscr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P000pfsHaAsel {
                P000pfsHaAsel::from_bits(val)
            }
        }
        impl From<P000pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P000pfsHaAsel) -> u8 {
                P000pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsHaDscr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsHaDscr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsHaDscr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsHaDscr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsHaDscr {
                P000pfsHaDscr::from_bits(val)
            }
        }
        impl From<P000pfsHaDscr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsHaDscr) -> u8 {
                P000pfsHaDscr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P000pfsHaIsel {
                P000pfsHaIsel::from_bits(val)
            }
        }
        impl From<P000pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P000pfsHaIsel) -> u8 {
                P000pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsHaNcodr {
                P000pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P000pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsHaNcodr) -> u8 {
                P000pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsHaPcr {
                P000pfsHaPcr::from_bits(val)
            }
        }
        impl From<P000pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsHaPcr) -> u8 {
                P000pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsHaPdr {
                P000pfsHaPdr::from_bits(val)
            }
        }
        impl From<P000pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsHaPdr) -> u8 {
                P000pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsHaPidr {
                P000pfsHaPidr::from_bits(val)
            }
        }
        impl From<P000pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsHaPidr) -> u8 {
                P000pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsHaPodr {
                P000pfsHaPodr::from_bits(val)
            }
        }
        impl From<P000pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsHaPodr) -> u8 {
                P000pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P000pfsIsel {
                P000pfsIsel::from_bits(val)
            }
        }
        impl From<P000pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P000pfsIsel) -> u8 {
                P000pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsNcodr {
                P000pfsNcodr::from_bits(val)
            }
        }
        impl From<P000pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsNcodr) -> u8 {
                P000pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsPcr {
                P000pfsPcr::from_bits(val)
            }
        }
        impl From<P000pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsPcr) -> u8 {
                P000pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsPdr {
                P000pfsPdr::from_bits(val)
            }
        }
        impl From<P000pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsPdr) -> u8 {
                P000pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsPidr {
                P000pfsPidr::from_bits(val)
            }
        }
        impl From<P000pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsPidr) -> u8 {
                P000pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsPmr {
                P000pfsPmr::from_bits(val)
            }
        }
        impl From<P000pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsPmr) -> u8 {
                P000pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P000pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P000pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P000pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P000pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P000pfsPodr {
                P000pfsPodr::from_bits(val)
            }
        }
        impl From<P000pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P000pfsPodr) -> u8 {
                P000pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P100pfsAsel {
                P100pfsAsel::from_bits(val)
            }
        }
        impl From<P100pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P100pfsAsel) -> u8 {
                P100pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsByNcodr {
                P100pfsByNcodr::from_bits(val)
            }
        }
        impl From<P100pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsByNcodr) -> u8 {
                P100pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsByPcr {
                P100pfsByPcr::from_bits(val)
            }
        }
        impl From<P100pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsByPcr) -> u8 {
                P100pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsByPdr {
                P100pfsByPdr::from_bits(val)
            }
        }
        impl From<P100pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsByPdr) -> u8 {
                P100pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsByPidr {
                P100pfsByPidr::from_bits(val)
            }
        }
        impl From<P100pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsByPidr) -> u8 {
                P100pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsByPodr {
                P100pfsByPodr::from_bits(val)
            }
        }
        impl From<P100pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsByPodr) -> u8 {
                P100pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsDscr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsDscr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsDscr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsDscr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsDscr {
                P100pfsDscr::from_bits(val)
            }
        }
        impl From<P100pfsDscr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsDscr) -> u8 {
                P100pfsDscr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P100pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsEofr {
                P100pfsEofr::from_bits(val)
            }
        }
        impl From<P100pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsEofr) -> u8 {
                P100pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P100pfsHaAsel {
                P100pfsHaAsel::from_bits(val)
            }
        }
        impl From<P100pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P100pfsHaAsel) -> u8 {
                P100pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsHaDscr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsHaDscr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsHaDscr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsHaDscr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsHaDscr {
                P100pfsHaDscr::from_bits(val)
            }
        }
        impl From<P100pfsHaDscr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsHaDscr) -> u8 {
                P100pfsHaDscr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P100pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsHaEofr {
                P100pfsHaEofr::from_bits(val)
            }
        }
        impl From<P100pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsHaEofr) -> u8 {
                P100pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P100pfsHaIsel {
                P100pfsHaIsel::from_bits(val)
            }
        }
        impl From<P100pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P100pfsHaIsel) -> u8 {
                P100pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsHaNcodr {
                P100pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P100pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsHaNcodr) -> u8 {
                P100pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsHaPcr {
                P100pfsHaPcr::from_bits(val)
            }
        }
        impl From<P100pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsHaPcr) -> u8 {
                P100pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsHaPdr {
                P100pfsHaPdr::from_bits(val)
            }
        }
        impl From<P100pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsHaPdr) -> u8 {
                P100pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsHaPidr {
                P100pfsHaPidr::from_bits(val)
            }
        }
        impl From<P100pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsHaPidr) -> u8 {
                P100pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsHaPodr {
                P100pfsHaPodr::from_bits(val)
            }
        }
        impl From<P100pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsHaPodr) -> u8 {
                P100pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P100pfsIsel {
                P100pfsIsel::from_bits(val)
            }
        }
        impl From<P100pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P100pfsIsel) -> u8 {
                P100pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsNcodr {
                P100pfsNcodr::from_bits(val)
            }
        }
        impl From<P100pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsNcodr) -> u8 {
                P100pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsPcr {
                P100pfsPcr::from_bits(val)
            }
        }
        impl From<P100pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsPcr) -> u8 {
                P100pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsPdr {
                P100pfsPdr::from_bits(val)
            }
        }
        impl From<P100pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsPdr) -> u8 {
                P100pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsPidr {
                P100pfsPidr::from_bits(val)
            }
        }
        impl From<P100pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsPidr) -> u8 {
                P100pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsPmr {
                P100pfsPmr::from_bits(val)
            }
        }
        impl From<P100pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsPmr) -> u8 {
                P100pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P100pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P100pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P100pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P100pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P100pfsPodr {
                P100pfsPodr::from_bits(val)
            }
        }
        impl From<P100pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P100pfsPodr) -> u8 {
                P100pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P407pfsAsel {
                P407pfsAsel::from_bits(val)
            }
        }
        impl From<P407pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P407pfsAsel) -> u8 {
                P407pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsByNcodr {
                P407pfsByNcodr::from_bits(val)
            }
        }
        impl From<P407pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsByNcodr) -> u8 {
                P407pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsByPcr {
                P407pfsByPcr::from_bits(val)
            }
        }
        impl From<P407pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsByPcr) -> u8 {
                P407pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsByPdr {
                P407pfsByPdr::from_bits(val)
            }
        }
        impl From<P407pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsByPdr) -> u8 {
                P407pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsByPidr {
                P407pfsByPidr::from_bits(val)
            }
        }
        impl From<P407pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsByPidr) -> u8 {
                P407pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsByPodr {
                P407pfsByPodr::from_bits(val)
            }
        }
        impl From<P407pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsByPodr) -> u8 {
                P407pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsDscr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsDscr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsDscr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsDscr1 {
            #[inline(always)]
            fn from(val: u8) -> P407pfsDscr1 {
                P407pfsDscr1::from_bits(val)
            }
        }
        impl From<P407pfsDscr1> for u8 {
            #[inline(always)]
            fn from(val: P407pfsDscr1) -> u8 {
                P407pfsDscr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P407pfsHaAsel {
                P407pfsHaAsel::from_bits(val)
            }
        }
        impl From<P407pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P407pfsHaAsel) -> u8 {
                P407pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsHaDscr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsHaDscr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsHaDscr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsHaDscr1 {
            #[inline(always)]
            fn from(val: u8) -> P407pfsHaDscr1 {
                P407pfsHaDscr1::from_bits(val)
            }
        }
        impl From<P407pfsHaDscr1> for u8 {
            #[inline(always)]
            fn from(val: P407pfsHaDscr1) -> u8 {
                P407pfsHaDscr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P407pfsHaIsel {
                P407pfsHaIsel::from_bits(val)
            }
        }
        impl From<P407pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P407pfsHaIsel) -> u8 {
                P407pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsHaNcodr {
                P407pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P407pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsHaNcodr) -> u8 {
                P407pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsHaPcr {
                P407pfsHaPcr::from_bits(val)
            }
        }
        impl From<P407pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsHaPcr) -> u8 {
                P407pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsHaPdr {
                P407pfsHaPdr::from_bits(val)
            }
        }
        impl From<P407pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsHaPdr) -> u8 {
                P407pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsHaPidr {
                P407pfsHaPidr::from_bits(val)
            }
        }
        impl From<P407pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsHaPidr) -> u8 {
                P407pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsHaPodr {
                P407pfsHaPodr::from_bits(val)
            }
        }
        impl From<P407pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsHaPodr) -> u8 {
                P407pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P407pfsIsel {
                P407pfsIsel::from_bits(val)
            }
        }
        impl From<P407pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P407pfsIsel) -> u8 {
                P407pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsNcodr {
                P407pfsNcodr::from_bits(val)
            }
        }
        impl From<P407pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsNcodr) -> u8 {
                P407pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsPcr {
                P407pfsPcr::from_bits(val)
            }
        }
        impl From<P407pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsPcr) -> u8 {
                P407pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsPdr {
                P407pfsPdr::from_bits(val)
            }
        }
        impl From<P407pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsPdr) -> u8 {
                P407pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsPidr {
                P407pfsPidr::from_bits(val)
            }
        }
        impl From<P407pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsPidr) -> u8 {
                P407pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsPmr {
                P407pfsPmr::from_bits(val)
            }
        }
        impl From<P407pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsPmr) -> u8 {
                P407pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P407pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P407pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P407pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P407pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P407pfsPodr {
                P407pfsPodr::from_bits(val)
            }
        }
        impl From<P407pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P407pfsPodr) -> u8 {
                P407pfsPodr::to_bits(val)
            }
        }
    }
}
pub mod pmisc {
    #[doc = "Miscellaneous Port Control Register"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pmisc {
        ptr: *mut u8,
    }
    unsafe impl Send for Pmisc {}
    unsafe impl Sync for Pmisc {}
    impl Pmisc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Write,Protect Register"]
        #[inline(always)]
        pub const fn pwpr(self) -> crate::common::Reg<regs::Pwpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Write,Protect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwpr(pub u8);
        impl Pwpr {
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_0_5(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_0_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "PFS Register Write Enable"]
            #[inline(always)]
            pub const fn pfswe(&self) -> super::vals::Pfswe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pfswe::from_bits(val as u8)
            }
            #[doc = "PFS Register Write Enable"]
            #[inline(always)]
            pub fn set_pfswe(&mut self, val: super::vals::Pfswe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "PFSWE Bit Write Disable"]
            #[inline(always)]
            pub const fn b0wi(&self) -> super::vals::B0wi {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::B0wi::from_bits(val as u8)
            }
            #[doc = "PFSWE Bit Write Disable"]
            #[inline(always)]
            pub fn set_b0wi(&mut self, val: super::vals::B0wi) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Pwpr {
            #[inline(always)]
            fn default() -> Pwpr {
                Pwpr(0)
            }
        }
        impl core::fmt::Debug for Pwpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwpr")
                    .field("reserved_0_5", &self.reserved_0_5())
                    .field("pfswe", &self.pfswe())
                    .field("b0wi", &self.b0wi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pwpr {{ reserved_0_5: {=u8:?}, pfswe: {:?}, b0wi: {:?} }}",
                    self.reserved_0_5(),
                    self.pfswe(),
                    self.b0wi()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum B0wi {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl B0wi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> B0wi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for B0wi {
            #[inline(always)]
            fn from(val: u8) -> B0wi {
                B0wi::from_bits(val)
            }
        }
        impl From<B0wi> for u8 {
            #[inline(always)]
            fn from(val: B0wi) -> u8 {
                B0wi::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pfswe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pfswe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pfswe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pfswe {
            #[inline(always)]
            fn from(val: u8) -> Pfswe {
                Pfswe::from_bits(val)
            }
        }
        impl From<Pfswe> for u8 {
            #[inline(always)]
            fn from(val: Pfswe) -> u8 {
                Pfswe::to_bits(val)
            }
        }
    }
}
pub mod poeg {
    #[doc = "Port Output Enable Module for GPT"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Poeg {
        ptr: *mut u8,
    }
    unsafe impl Send for Poeg {}
    unsafe impl Sync for Poeg {}
    impl Poeg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "POEG Group %s Setting Register"]
        #[inline(always)]
        pub const fn poegg(self, n: usize) -> crate::common::Reg<regs::Poegg, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 256usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "POEG Group %s Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Poegg(pub u32);
        impl Poegg {
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub const fn pidf(&self) -> super::vals::Pidf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pidf::from_bits(val as u8)
            }
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub fn set_pidf(&mut self, val: super::vals::Pidf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Real Time Overcurrent Detection Flag"]
            #[inline(always)]
            pub const fn iocf(&self) -> super::vals::Iocf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iocf::from_bits(val as u8)
            }
            #[doc = "Real Time Overcurrent Detection Flag"]
            #[inline(always)]
            pub fn set_iocf(&mut self, val: super::vals::Iocf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub const fn ostpf(&self) -> super::vals::Ostpf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ostpf::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub fn set_ostpf(&mut self, val: super::vals::Ostpf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub const fn ssf(&self) -> super::vals::Ssf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ssf::from_bits(val as u8)
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub fn set_ssf(&mut self, val: super::vals::Ssf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Port Input Detection EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub const fn pide(&self) -> super::vals::Pide {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pide::from_bits(val as u8)
            }
            #[doc = "Port Input Detection EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub fn set_pide(&mut self, val: super::vals::Pide) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Real Time Overcurrent EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub const fn ioce(&self) -> super::vals::Ioce {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ioce::from_bits(val as u8)
            }
            #[doc = "Real Time Overcurrent EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub fn set_ioce(&mut self, val: super::vals::Ioce) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Oscillation Stop Detection EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub const fn ostpe(&self) -> super::vals::Ostpe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ostpe::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub fn set_ostpe(&mut self, val: super::vals::Ostpe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "ACMP_HS0 EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub const fn cdre0(&self) -> super::vals::Cdre0 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cdre0::from_bits(val as u8)
            }
            #[doc = "ACMP_HS0 EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub fn set_cdre0(&mut self, val: super::vals::Cdre0) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_9_11(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_9_11(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 9usize)) | (((val as u32) & 0x07) << 9usize);
            }
            #[doc = "ACMP_LP0 EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub const fn cdre4(&self) -> super::vals::Cdre4 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cdre4::from_bits(val as u8)
            }
            #[doc = "ACMP_LP0 EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub fn set_cdre4(&mut self, val: super::vals::Cdre4) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "ACMP_LP1 EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub const fn cdre5(&self) -> super::vals::Cdre5 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cdre5::from_bits(val as u8)
            }
            #[doc = "ACMP_LP1 EnableNote: Can be modified only once after a reset."]
            #[inline(always)]
            pub fn set_cdre5(&mut self, val: super::vals::Cdre5) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_14_15(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_14_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 14usize)) | (((val as u32) & 0x03) << 14usize);
            }
            #[doc = "GTETRG Input Status Flag"]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::St {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::St::from_bits(val as u8)
            }
            #[doc = "GTETRG Input Status Flag"]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::St) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub const fn reserved_17_27(&self) -> u16 {
                let val = (self.0 >> 17usize) & 0x07ff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub fn set_reserved_17_27(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 17usize)) | (((val as u32) & 0x07ff) << 17usize);
            }
            #[doc = "GTETRG Input Reverse"]
            #[inline(always)]
            pub const fn inv(&self) -> super::vals::Inv {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Inv::from_bits(val as u8)
            }
            #[doc = "GTETRG Input Reverse"]
            #[inline(always)]
            pub fn set_inv(&mut self, val: super::vals::Inv) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::Nfen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Nfen::from_bits(val as u8)
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::Nfen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::Nfcs {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::Nfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::Nfcs) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Poegg {
            #[inline(always)]
            fn default() -> Poegg {
                Poegg(0)
            }
        }
        impl core::fmt::Debug for Poegg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Poegg")
                    .field("pidf", &self.pidf())
                    .field("iocf", &self.iocf())
                    .field("ostpf", &self.ostpf())
                    .field("ssf", &self.ssf())
                    .field("pide", &self.pide())
                    .field("ioce", &self.ioce())
                    .field("ostpe", &self.ostpe())
                    .field("cdre0", &self.cdre0())
                    .field("reserved_9_11", &self.reserved_9_11())
                    .field("cdre4", &self.cdre4())
                    .field("cdre5", &self.cdre5())
                    .field("reserved_14_15", &self.reserved_14_15())
                    .field("st", &self.st())
                    .field("reserved_17_27", &self.reserved_17_27())
                    .field("inv", &self.inv())
                    .field("nfen", &self.nfen())
                    .field("nfcs", &self.nfcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Poegg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Poegg {{ pidf: {:?}, iocf: {:?}, ostpf: {:?}, ssf: {:?}, pide: {:?}, ioce: {:?}, ostpe: {:?}, cdre0: {:?}, reserved_9_11: {=u8:?}, cdre4: {:?}, cdre5: {:?}, reserved_14_15: {=u8:?}, st: {:?}, reserved_17_27: {=u16:?}, inv: {:?}, nfen: {:?}, nfcs: {:?} }}" , self . pidf () , self . iocf () , self . ostpf () , self . ssf () , self . pide () , self . ioce () , self . ostpe () , self . cdre0 () , self . reserved_9_11 () , self . cdre4 () , self . cdre5 () , self . reserved_14_15 () , self . st () , self . reserved_17_27 () , self . inv () , self . nfen () , self . nfcs ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdre0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdre0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdre0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdre0 {
            #[inline(always)]
            fn from(val: u8) -> Cdre0 {
                Cdre0::from_bits(val)
            }
        }
        impl From<Cdre0> for u8 {
            #[inline(always)]
            fn from(val: Cdre0) -> u8 {
                Cdre0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdre4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdre4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdre4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdre4 {
            #[inline(always)]
            fn from(val: u8) -> Cdre4 {
                Cdre4::from_bits(val)
            }
        }
        impl From<Cdre4> for u8 {
            #[inline(always)]
            fn from(val: Cdre4) -> u8 {
                Cdre4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdre5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdre5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdre5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdre5 {
            #[inline(always)]
            fn from(val: u8) -> Cdre5 {
                Cdre5::from_bits(val)
            }
        }
        impl From<Cdre5> for u8 {
            #[inline(always)]
            fn from(val: Cdre5) -> u8 {
                Cdre5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Inv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inv {
            #[inline(always)]
            fn from(val: u8) -> Inv {
                Inv::from_bits(val)
            }
        }
        impl From<Inv> for u8 {
            #[inline(always)]
            fn from(val: Inv) -> u8 {
                Inv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ioce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ioce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ioce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ioce {
            #[inline(always)]
            fn from(val: u8) -> Ioce {
                Ioce::from_bits(val)
            }
        }
        impl From<Ioce> for u8 {
            #[inline(always)]
            fn from(val: Ioce) -> u8 {
                Ioce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iocf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iocf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iocf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iocf {
            #[inline(always)]
            fn from(val: u8) -> Iocf {
                Iocf::from_bits(val)
            }
        }
        impl From<Iocf> for u8 {
            #[inline(always)]
            fn from(val: Iocf) -> u8 {
                Iocf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcs {
            #[inline(always)]
            fn from(val: u8) -> Nfcs {
                Nfcs::from_bits(val)
            }
        }
        impl From<Nfcs> for u8 {
            #[inline(always)]
            fn from(val: Nfcs) -> u8 {
                Nfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfen {
            #[inline(always)]
            fn from(val: u8) -> Nfen {
                Nfen::from_bits(val)
            }
        }
        impl From<Nfen> for u8 {
            #[inline(always)]
            fn from(val: Nfen) -> u8 {
                Nfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostpe {
            #[inline(always)]
            fn from(val: u8) -> Ostpe {
                Ostpe::from_bits(val)
            }
        }
        impl From<Ostpe> for u8 {
            #[inline(always)]
            fn from(val: Ostpe) -> u8 {
                Ostpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostpf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostpf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostpf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostpf {
            #[inline(always)]
            fn from(val: u8) -> Ostpf {
                Ostpf::from_bits(val)
            }
        }
        impl From<Ostpf> for u8 {
            #[inline(always)]
            fn from(val: Ostpf) -> u8 {
                Ostpf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pide {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pide {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pide {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pide {
            #[inline(always)]
            fn from(val: u8) -> Pide {
                Pide::from_bits(val)
            }
        }
        impl From<Pide> for u8 {
            #[inline(always)]
            fn from(val: Pide) -> u8 {
                Pide::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pidf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pidf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pidf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pidf {
            #[inline(always)]
            fn from(val: u8) -> Pidf {
                Pidf::from_bits(val)
            }
        }
        impl From<Pidf> for u8 {
            #[inline(always)]
            fn from(val: Pidf) -> u8 {
                Pidf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssf {
            #[inline(always)]
            fn from(val: u8) -> Ssf {
                Ssf::from_bits(val)
            }
        }
        impl From<Ssf> for u8 {
            #[inline(always)]
            fn from(val: Ssf) -> u8 {
                Ssf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St {
            #[inline(always)]
            fn from(val: u8) -> St {
                St::from_bits(val)
            }
        }
        impl From<St> for u8 {
            #[inline(always)]
            fn from(val: St) -> u8 {
                St::to_bits(val)
            }
        }
    }
}
pub mod port0 {
    #[doc = "Port 0 Control Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port0 {}
    unsafe impl Sync for Port0 {}
    impl Port0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pcntr1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Output data register"]
        #[inline(always)]
        pub const fn podr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Direction register"]
        #[inline(always)]
        pub const fn pdr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pcntr2(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Input data register"]
        #[inline(always)]
        pub const fn pidr(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn pcntr3(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Output reset register"]
        #[inline(always)]
        pub const fn porr(self) -> crate::common::Reg<u16, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Output set register"]
        #[inline(always)]
        pub const fn posr(self) -> crate::common::Reg<u16, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
}
pub mod port1 {
    #[doc = "Port 1 Control Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port1 {}
    unsafe impl Sync for Port1 {}
    impl Port1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pcntr1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Output data register"]
        #[inline(always)]
        pub const fn podr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Direction register"]
        #[inline(always)]
        pub const fn pdr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Event input data register"]
        #[inline(always)]
        pub const fn eidr(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pcntr2(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Input data register"]
        #[inline(always)]
        pub const fn pidr(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn pcntr3(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Output reset register"]
        #[inline(always)]
        pub const fn porr(self) -> crate::common::Reg<u16, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Output set register"]
        #[inline(always)]
        pub const fn posr(self) -> crate::common::Reg<u16, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Event output reset register"]
        #[inline(always)]
        pub const fn eorr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Port Control Register 4"]
        #[inline(always)]
        pub const fn pcntr4(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Event output set register"]
        #[inline(always)]
        pub const fn eosr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
    }
}
pub mod rtc {
    #[doc = "Realtime Clock"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtc {}
    unsafe impl Sync for Rtc {}
    impl Rtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "64-Hz Counter"]
        #[inline(always)]
        pub const fn r64cnt(self) -> crate::common::Reg<regs::R64cnt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Binary Counter 0"]
        #[inline(always)]
        pub const fn bcnt0(self) -> crate::common::Reg<regs::Bcnt0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Second Counter"]
        #[inline(always)]
        pub const fn rseccnt(self) -> crate::common::Reg<regs::Rseccnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Binary Counter 1"]
        #[inline(always)]
        pub const fn bcnt1(self) -> crate::common::Reg<regs::Bcnt1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Minute Counter"]
        #[inline(always)]
        pub const fn rmincnt(self) -> crate::common::Reg<regs::Rmincnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Binary Counter 2"]
        #[inline(always)]
        pub const fn bcnt2(self) -> crate::common::Reg<regs::Bcnt2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Hour Counter"]
        #[inline(always)]
        pub const fn rhrcnt(self) -> crate::common::Reg<regs::Rhrcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Binary Counter 3"]
        #[inline(always)]
        pub const fn bcnt3(self) -> crate::common::Reg<regs::Bcnt3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Day,of,Week Counter"]
        #[inline(always)]
        pub const fn rwkcnt(self) -> crate::common::Reg<regs::Rwkcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Day Counter"]
        #[inline(always)]
        pub const fn rdaycnt(self) -> crate::common::Reg<regs::Rdaycnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Month Counter"]
        #[inline(always)]
        pub const fn rmoncnt(self) -> crate::common::Reg<regs::Rmoncnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Year Counter"]
        #[inline(always)]
        pub const fn ryrcnt(self) -> crate::common::Reg<regs::Ryrcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Binary Counter 0 Alarm Register"]
        #[inline(always)]
        pub const fn bcnt0ar(self) -> crate::common::Reg<regs::Bcnt0ar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Second Alarm Register"]
        #[inline(always)]
        pub const fn rsecar(self) -> crate::common::Reg<regs::Rsecar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Binary Counter 1 Alarm Register"]
        #[inline(always)]
        pub const fn bcnt1ar(self) -> crate::common::Reg<regs::Bcnt1ar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "Minute Alarm Register"]
        #[inline(always)]
        pub const fn rminar(self) -> crate::common::Reg<regs::Rminar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "Binary Counter 2 Alarm Register"]
        #[inline(always)]
        pub const fn bcnt2ar(self) -> crate::common::Reg<regs::Bcnt2ar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Hour Alarm Register"]
        #[inline(always)]
        pub const fn rhrar(self) -> crate::common::Reg<regs::Rhrar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Binary Counter 3 Alarm Register"]
        #[inline(always)]
        pub const fn bcnt3ar(self) -> crate::common::Reg<regs::Bcnt3ar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "Day,of,Week Alarm Register"]
        #[inline(always)]
        pub const fn rwkar(self) -> crate::common::Reg<regs::Rwkar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "Binary Counter 0 Alarm Enable Register"]
        #[inline(always)]
        pub const fn bcnt0aer(self) -> crate::common::Reg<regs::Bcnt0aer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Date Alarm Register"]
        #[inline(always)]
        pub const fn rdayar(self) -> crate::common::Reg<regs::Rdayar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Binary Counter 1 Alarm Enable Register"]
        #[inline(always)]
        pub const fn bcnt1aer(self) -> crate::common::Reg<regs::Bcnt1aer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "Month Alarm Register"]
        #[inline(always)]
        pub const fn rmonar(self) -> crate::common::Reg<regs::Rmonar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "Binary Counter 2 Alarm Enable Register"]
        #[inline(always)]
        pub const fn bcnt2aer(self) -> crate::common::Reg<regs::Bcnt2aer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Year Alarm Register"]
        #[inline(always)]
        pub const fn ryrar(self) -> crate::common::Reg<regs::Ryrar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Binary Counter 3 Alarm Enable Register"]
        #[inline(always)]
        pub const fn bcnt3aer(self) -> crate::common::Reg<regs::Bcnt3aer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1eusize) as _) }
        }
        #[doc = "Year Alarm Enable Register"]
        #[inline(always)]
        pub const fn ryraren(self) -> crate::common::Reg<regs::Ryraren, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1eusize) as _) }
        }
        #[doc = "RTC Control Register 1"]
        #[inline(always)]
        pub const fn rcr1(self) -> crate::common::Reg<regs::Rcr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x22usize) as _) }
        }
        #[doc = "RTC Control Register 2"]
        #[inline(always)]
        pub const fn rcr2(self) -> crate::common::Reg<regs::Rcr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "RTC Control Register 4"]
        #[inline(always)]
        pub const fn rcr4(self) -> crate::common::Reg<regs::Rcr4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Frequency Register H"]
        #[inline(always)]
        pub const fn rfrh(self) -> crate::common::Reg<regs::Rfrh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2ausize) as _) }
        }
        #[doc = "Frequency Register L"]
        #[inline(always)]
        pub const fn rfrl(self) -> crate::common::Reg<regs::Rfrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Time Error Adjustment Register"]
        #[inline(always)]
        pub const fn radj(self) -> crate::common::Reg<regs::Radj, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Binary Counter 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt0(pub u8);
        impl Bcnt0 {
            #[doc = "The BCNT0 counter is a readable/writable 32-bit binary counter b7 to b0."]
            #[inline(always)]
            pub const fn bcnt0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT0 counter is a readable/writable 32-bit binary counter b7 to b0."]
            #[inline(always)]
            pub fn set_bcnt0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt0 {
            #[inline(always)]
            fn default() -> Bcnt0 {
                Bcnt0(0)
            }
        }
        impl core::fmt::Debug for Bcnt0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt0")
                    .field("bcnt0", &self.bcnt0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt0 {{ bcnt0: {=u8:?} }}", self.bcnt0())
            }
        }
        #[doc = "Binary Counter 0 Alarm Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt0aer(pub u8);
        impl Bcnt0aer {
            #[doc = "The BCNT0AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b7 to b0."]
            #[inline(always)]
            pub const fn enb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT0AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b7 to b0."]
            #[inline(always)]
            pub fn set_enb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt0aer {
            #[inline(always)]
            fn default() -> Bcnt0aer {
                Bcnt0aer(0)
            }
        }
        impl core::fmt::Debug for Bcnt0aer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt0aer")
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt0aer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt0aer {{ enb: {=u8:?} }}", self.enb())
            }
        }
        #[doc = "Binary Counter 0 Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt0ar(pub u8);
        impl Bcnt0ar {
            #[doc = "he BCNT0AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b7 to b0."]
            #[inline(always)]
            pub const fn bcnt0ar(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "he BCNT0AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b7 to b0."]
            #[inline(always)]
            pub fn set_bcnt0ar(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt0ar {
            #[inline(always)]
            fn default() -> Bcnt0ar {
                Bcnt0ar(0)
            }
        }
        impl core::fmt::Debug for Bcnt0ar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt0ar")
                    .field("bcnt0ar", &self.bcnt0ar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt0ar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt0ar {{ bcnt0ar: {=u8:?} }}", self.bcnt0ar())
            }
        }
        #[doc = "Binary Counter 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt1(pub u8);
        impl Bcnt1 {
            #[doc = "The BCNT1 counter is a readable/writable 32-bit binary counter b15 to b8."]
            #[inline(always)]
            pub const fn bcnt1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT1 counter is a readable/writable 32-bit binary counter b15 to b8."]
            #[inline(always)]
            pub fn set_bcnt1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt1 {
            #[inline(always)]
            fn default() -> Bcnt1 {
                Bcnt1(0)
            }
        }
        impl core::fmt::Debug for Bcnt1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt1")
                    .field("bcnt1", &self.bcnt1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt1 {{ bcnt1: {=u8:?} }}", self.bcnt1())
            }
        }
        #[doc = "Binary Counter 1 Alarm Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt1aer(pub u8);
        impl Bcnt1aer {
            #[doc = "The BCNT1AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b15 to b8."]
            #[inline(always)]
            pub const fn enb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT1AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b15 to b8."]
            #[inline(always)]
            pub fn set_enb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt1aer {
            #[inline(always)]
            fn default() -> Bcnt1aer {
                Bcnt1aer(0)
            }
        }
        impl core::fmt::Debug for Bcnt1aer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt1aer")
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt1aer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt1aer {{ enb: {=u8:?} }}", self.enb())
            }
        }
        #[doc = "Binary Counter 1 Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt1ar(pub u8);
        impl Bcnt1ar {
            #[doc = "he BCNT1AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b15 to b8."]
            #[inline(always)]
            pub const fn bcnt1ar(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "he BCNT1AR counter is a readable/writable alarm register corresponding to 32-bit binary counter b15 to b8."]
            #[inline(always)]
            pub fn set_bcnt1ar(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt1ar {
            #[inline(always)]
            fn default() -> Bcnt1ar {
                Bcnt1ar(0)
            }
        }
        impl core::fmt::Debug for Bcnt1ar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt1ar")
                    .field("bcnt1ar", &self.bcnt1ar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt1ar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt1ar {{ bcnt1ar: {=u8:?} }}", self.bcnt1ar())
            }
        }
        #[doc = "Binary Counter 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt2(pub u8);
        impl Bcnt2 {
            #[doc = "The BCNT2 counter is a readable/writable 32-bit binary counter b23 to b16."]
            #[inline(always)]
            pub const fn bcnt2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT2 counter is a readable/writable 32-bit binary counter b23 to b16."]
            #[inline(always)]
            pub fn set_bcnt2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt2 {
            #[inline(always)]
            fn default() -> Bcnt2 {
                Bcnt2(0)
            }
        }
        impl core::fmt::Debug for Bcnt2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt2")
                    .field("bcnt2", &self.bcnt2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt2 {{ bcnt2: {=u8:?} }}", self.bcnt2())
            }
        }
        #[doc = "Binary Counter 2 Alarm Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt2aer(pub u16);
        impl Bcnt2aer {
            #[doc = "The BCNT2AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b23 to b16."]
            #[inline(always)]
            pub const fn enb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT2AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b23 to b16."]
            #[inline(always)]
            pub fn set_enb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Bcnt2aer {
            #[inline(always)]
            fn default() -> Bcnt2aer {
                Bcnt2aer(0)
            }
        }
        impl core::fmt::Debug for Bcnt2aer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt2aer")
                    .field("enb", &self.enb())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt2aer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bcnt2aer {{ enb: {=u8:?}, reserved_8_15: {=u8:?} }}",
                    self.enb(),
                    self.reserved_8_15()
                )
            }
        }
        #[doc = "Binary Counter 2 Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt2ar(pub u8);
        impl Bcnt2ar {
            #[doc = "The BCNT2AR counter is a readable/writable 32-bit binary counter b23 to b16."]
            #[inline(always)]
            pub const fn bcnt2ar(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT2AR counter is a readable/writable 32-bit binary counter b23 to b16."]
            #[inline(always)]
            pub fn set_bcnt2ar(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt2ar {
            #[inline(always)]
            fn default() -> Bcnt2ar {
                Bcnt2ar(0)
            }
        }
        impl core::fmt::Debug for Bcnt2ar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt2ar")
                    .field("bcnt2ar", &self.bcnt2ar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt2ar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt2ar {{ bcnt2ar: {=u8:?} }}", self.bcnt2ar())
            }
        }
        #[doc = "Binary Counter 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt3(pub u8);
        impl Bcnt3 {
            #[doc = "The BCNT3 counter is a readable/writable 32-bit binary counter b31 to b24."]
            #[inline(always)]
            pub const fn bcnt3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT3 counter is a readable/writable 32-bit binary counter b31 to b24."]
            #[inline(always)]
            pub fn set_bcnt3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt3 {
            #[inline(always)]
            fn default() -> Bcnt3 {
                Bcnt3(0)
            }
        }
        impl core::fmt::Debug for Bcnt3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt3")
                    .field("bcnt3", &self.bcnt3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt3 {{ bcnt3: {=u8:?} }}", self.bcnt3())
            }
        }
        #[doc = "Binary Counter 3 Alarm Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt3aer(pub u8);
        impl Bcnt3aer {
            #[doc = "The BCNT3AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b31 to b24."]
            #[inline(always)]
            pub const fn enb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT3AER register is a readable/writable register for setting the alarm enable corresponding to 32-bit binary counter b31 to b24."]
            #[inline(always)]
            pub fn set_enb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt3aer {
            #[inline(always)]
            fn default() -> Bcnt3aer {
                Bcnt3aer(0)
            }
        }
        impl core::fmt::Debug for Bcnt3aer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt3aer")
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt3aer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt3aer {{ enb: {=u8:?} }}", self.enb())
            }
        }
        #[doc = "Binary Counter 3 Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt3ar(pub u8);
        impl Bcnt3ar {
            #[doc = "The BCNT3AR counter is a readable/writable 32-bit binary counter b31 to b24."]
            #[inline(always)]
            pub const fn bcnt3ar(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The BCNT3AR counter is a readable/writable 32-bit binary counter b31 to b24."]
            #[inline(always)]
            pub fn set_bcnt3ar(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt3ar {
            #[inline(always)]
            fn default() -> Bcnt3ar {
                Bcnt3ar(0)
            }
        }
        impl core::fmt::Debug for Bcnt3ar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt3ar")
                    .field("bcnt3ar", &self.bcnt3ar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt3ar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt3ar {{ bcnt3ar: {=u8:?} }}", self.bcnt3ar())
            }
        }
        #[doc = "64-Hz Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct R64cnt(pub u8);
        impl R64cnt {
            #[doc = "64Hz"]
            #[inline(always)]
            pub const fn f64hz(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "64Hz"]
            #[inline(always)]
            pub fn set_f64hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "32Hz"]
            #[inline(always)]
            pub const fn f32hz(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "32Hz"]
            #[inline(always)]
            pub fn set_f32hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "16Hz"]
            #[inline(always)]
            pub const fn f16hz(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "16Hz"]
            #[inline(always)]
            pub fn set_f16hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "8Hz"]
            #[inline(always)]
            pub const fn f8hz(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "8Hz"]
            #[inline(always)]
            pub fn set_f8hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "4Hz"]
            #[inline(always)]
            pub const fn f4hz(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "4Hz"]
            #[inline(always)]
            pub fn set_f4hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "2Hz"]
            #[inline(always)]
            pub const fn f2hz(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "2Hz"]
            #[inline(always)]
            pub fn set_f2hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "1Hz"]
            #[inline(always)]
            pub const fn f1hz(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "1Hz"]
            #[inline(always)]
            pub fn set_f1hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
        }
        impl Default for R64cnt {
            #[inline(always)]
            fn default() -> R64cnt {
                R64cnt(0)
            }
        }
        impl core::fmt::Debug for R64cnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("R64cnt")
                    .field("f64hz", &self.f64hz())
                    .field("f32hz", &self.f32hz())
                    .field("f16hz", &self.f16hz())
                    .field("f8hz", &self.f8hz())
                    .field("f4hz", &self.f4hz())
                    .field("f2hz", &self.f2hz())
                    .field("f1hz", &self.f1hz())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for R64cnt {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "R64cnt {{ f64hz: {=bool:?}, f32hz: {=bool:?}, f16hz: {=bool:?}, f8hz: {=bool:?}, f4hz: {=bool:?}, f2hz: {=bool:?}, f1hz: {=bool:?} }}" , self . f64hz () , self . f32hz () , self . f16hz () , self . f8hz () , self . f4hz () , self . f2hz () , self . f1hz ())
            }
        }
        #[doc = "Time Error Adjustment Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Radj(pub u8);
        impl Radj {
            #[doc = "Adjustment Value These bits specify the adjustment value from the prescaler."]
            #[inline(always)]
            pub const fn adj(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Adjustment Value These bits specify the adjustment value from the prescaler."]
            #[inline(always)]
            pub fn set_adj(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "Plus,Minus"]
            #[inline(always)]
            pub const fn pmadj(&self) -> super::vals::Pmadj {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Pmadj::from_bits(val as u8)
            }
            #[doc = "Plus,Minus"]
            #[inline(always)]
            pub fn set_pmadj(&mut self, val: super::vals::Pmadj) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Radj {
            #[inline(always)]
            fn default() -> Radj {
                Radj(0)
            }
        }
        impl core::fmt::Debug for Radj {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Radj")
                    .field("adj", &self.adj())
                    .field("pmadj", &self.pmadj())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Radj {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Radj {{ adj: {=u8:?}, pmadj: {:?} }}",
                    self.adj(),
                    self.pmadj()
                )
            }
        }
        #[doc = "RTC Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rcr1(pub u8);
        impl Rcr1 {
            #[doc = "Alarm Interrupt Enable"]
            #[inline(always)]
            pub const fn aie(&self) -> super::vals::Aie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Aie::from_bits(val as u8)
            }
            #[doc = "Alarm Interrupt Enable"]
            #[inline(always)]
            pub fn set_aie(&mut self, val: super::vals::Aie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Carry Interrupt Enable"]
            #[inline(always)]
            pub const fn cie(&self) -> super::vals::Cie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cie::from_bits(val as u8)
            }
            #[doc = "Carry Interrupt Enable"]
            #[inline(always)]
            pub fn set_cie(&mut self, val: super::vals::Cie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Periodic Interrupt Enable"]
            #[inline(always)]
            pub const fn pie(&self) -> super::vals::Pie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pie::from_bits(val as u8)
            }
            #[doc = "Periodic Interrupt Enable"]
            #[inline(always)]
            pub fn set_pie(&mut self, val: super::vals::Pie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "RTCOUT Output Select"]
            #[inline(always)]
            pub const fn rtcos(&self) -> super::vals::Rtcos {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rtcos::from_bits(val as u8)
            }
            #[doc = "RTCOUT Output Select"]
            #[inline(always)]
            pub fn set_rtcos(&mut self, val: super::vals::Rtcos) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Periodic Interrupt Select"]
            #[inline(always)]
            pub const fn pes(&self) -> super::vals::Pes {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Pes::from_bits(val as u8)
            }
            #[doc = "Periodic Interrupt Select"]
            #[inline(always)]
            pub fn set_pes(&mut self, val: super::vals::Pes) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u8) & 0x0f) << 4usize);
            }
        }
        impl Default for Rcr1 {
            #[inline(always)]
            fn default() -> Rcr1 {
                Rcr1(0)
            }
        }
        impl core::fmt::Debug for Rcr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rcr1")
                    .field("aie", &self.aie())
                    .field("cie", &self.cie())
                    .field("pie", &self.pie())
                    .field("rtcos", &self.rtcos())
                    .field("pes", &self.pes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rcr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rcr1 {{ aie: {:?}, cie: {:?}, pie: {:?}, rtcos: {:?}, pes: {:?} }}",
                    self.aie(),
                    self.cie(),
                    self.pie(),
                    self.rtcos(),
                    self.pes()
                )
            }
        }
        #[doc = "RTC Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rcr2(pub u8);
        impl Rcr2 {
            #[doc = "Start"]
            #[inline(always)]
            pub const fn start(&self) -> super::vals::Start {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Start::from_bits(val as u8)
            }
            #[doc = "Start"]
            #[inline(always)]
            pub fn set_start(&mut self, val: super::vals::Start) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "RTC Software Reset"]
            #[inline(always)]
            pub const fn reset(&self) -> super::vals::Reset {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Reset::from_bits(val as u8)
            }
            #[doc = "RTC Software Reset"]
            #[inline(always)]
            pub fn set_reset(&mut self, val: super::vals::Reset) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "30-Second Adjustment"]
            #[inline(always)]
            pub const fn adj30(&self) -> super::vals::Adj30 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Adj30::from_bits(val as u8)
            }
            #[doc = "30-Second Adjustment"]
            #[inline(always)]
            pub fn set_adj30(&mut self, val: super::vals::Adj30) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "RTCOUT Output Enable"]
            #[inline(always)]
            pub const fn rtcoe(&self) -> super::vals::Rtcoe {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rtcoe::from_bits(val as u8)
            }
            #[doc = "RTCOUT Output Enable"]
            #[inline(always)]
            pub fn set_rtcoe(&mut self, val: super::vals::Rtcoe) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Automatic Adjustment Enable (When the LOCO clock is selected, the setting of this bit is disabled.)"]
            #[inline(always)]
            pub const fn aadje(&self) -> super::vals::Aadje {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Aadje::from_bits(val as u8)
            }
            #[doc = "Automatic Adjustment Enable (When the LOCO clock is selected, the setting of this bit is disabled.)"]
            #[inline(always)]
            pub fn set_aadje(&mut self, val: super::vals::Aadje) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Automatic Adjustment Period Select (When the LOCO clock is selected, the setting of this bit is disabled.)"]
            #[inline(always)]
            pub const fn aadjp(&self) -> super::vals::Aadjp {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Aadjp::from_bits(val as u8)
            }
            #[doc = "Automatic Adjustment Period Select (When the LOCO clock is selected, the setting of this bit is disabled.)"]
            #[inline(always)]
            pub fn set_aadjp(&mut self, val: super::vals::Aadjp) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Hours Mode"]
            #[inline(always)]
            pub const fn hr24(&self) -> super::vals::Hr24 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Hr24::from_bits(val as u8)
            }
            #[doc = "Hours Mode"]
            #[inline(always)]
            pub fn set_hr24(&mut self, val: super::vals::Hr24) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Count Mode Select"]
            #[inline(always)]
            pub const fn cntmd(&self) -> super::vals::Cntmd {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cntmd::from_bits(val as u8)
            }
            #[doc = "Count Mode Select"]
            #[inline(always)]
            pub fn set_cntmd(&mut self, val: super::vals::Cntmd) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rcr2 {
            #[inline(always)]
            fn default() -> Rcr2 {
                Rcr2(0)
            }
        }
        impl core::fmt::Debug for Rcr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rcr2")
                    .field("start", &self.start())
                    .field("reset", &self.reset())
                    .field("adj30", &self.adj30())
                    .field("rtcoe", &self.rtcoe())
                    .field("aadje", &self.aadje())
                    .field("aadjp", &self.aadjp())
                    .field("hr24", &self.hr24())
                    .field("cntmd", &self.cntmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rcr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rcr2 {{ start: {:?}, reset: {:?}, adj30: {:?}, rtcoe: {:?}, aadje: {:?}, aadjp: {:?}, hr24: {:?}, cntmd: {:?} }}" , self . start () , self . reset () , self . adj30 () , self . rtcoe () , self . aadje () , self . aadjp () , self . hr24 () , self . cntmd ())
            }
        }
        #[doc = "RTC Control Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rcr4(pub u8);
        impl Rcr4 {
            #[doc = "Count Source Select"]
            #[inline(always)]
            pub const fn rcksel(&self) -> super::vals::Rcksel {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rcksel::from_bits(val as u8)
            }
            #[doc = "Count Source Select"]
            #[inline(always)]
            pub fn set_rcksel(&mut self, val: super::vals::Rcksel) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Rcr4 {
            #[inline(always)]
            fn default() -> Rcr4 {
                Rcr4(0)
            }
        }
        impl core::fmt::Debug for Rcr4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rcr4")
                    .field("rcksel", &self.rcksel())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rcr4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rcr4 {{ rcksel: {:?}, reserved_1_7: {=u8:?} }}",
                    self.rcksel(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "Date Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdayar(pub u8);
        impl Rdayar {
            #[doc = "1 Day Value for the ones place of days"]
            #[inline(always)]
            pub const fn date1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1 Day Value for the ones place of days"]
            #[inline(always)]
            pub fn set_date1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10 Days Value for the tens place of days"]
            #[inline(always)]
            pub const fn date10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10 Days Value for the tens place of days"]
            #[inline(always)]
            pub fn set_date10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RdayarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RdayarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RdayarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rdayar {
            #[inline(always)]
            fn default() -> Rdayar {
                Rdayar(0)
            }
        }
        impl core::fmt::Debug for Rdayar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdayar")
                    .field("date1", &self.date1())
                    .field("date10", &self.date10())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdayar {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rdayar {{ date1: {=u8:?}, date10: {=u8:?}, reserved_6_6: {=bool:?}, enb: {:?} }}" , self . date1 () , self . date10 () , self . reserved_6_6 () , self . enb ())
            }
        }
        #[doc = "Day Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdaycnt(pub u8);
        impl Rdaycnt {
            #[doc = "1-Day Count Counts from 0 to 9 once per day. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub const fn date1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Day Count Counts from 0 to 9 once per day. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub fn set_date1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Day Count Counts from 0 to 3 once per carry from the ones place."]
            #[inline(always)]
            pub const fn date10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-Day Count Counts from 0 to 3 once per carry from the ones place."]
            #[inline(always)]
            pub fn set_date10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Rdaycnt {
            #[inline(always)]
            fn default() -> Rdaycnt {
                Rdaycnt(0)
            }
        }
        impl core::fmt::Debug for Rdaycnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdaycnt")
                    .field("date1", &self.date1())
                    .field("date10", &self.date10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdaycnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rdaycnt {{ date1: {=u8:?}, date10: {=u8:?} }}",
                    self.date1(),
                    self.date10()
                )
            }
        }
        #[doc = "Frequency Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rfrh(pub u16);
        impl Rfrh {
            #[doc = "Frequency Comparison Value (b16) To generate the operating clock from the LOCOclock, this bit sets the comparison value of the 128-Hz clock cycle."]
            #[inline(always)]
            pub const fn rfc16(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Frequency Comparison Value (b16) To generate the operating clock from the LOCOclock, this bit sets the comparison value of the 128-Hz clock cycle."]
            #[inline(always)]
            pub fn set_rfc16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub const fn reserved_1_15(&self) -> u16 {
                let val = (self.0 >> 1usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_1_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 1usize)) | (((val as u16) & 0x7fff) << 1usize);
            }
        }
        impl Default for Rfrh {
            #[inline(always)]
            fn default() -> Rfrh {
                Rfrh(0)
            }
        }
        impl core::fmt::Debug for Rfrh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rfrh")
                    .field("rfc16", &self.rfc16())
                    .field("reserved_1_15", &self.reserved_1_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rfrh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rfrh {{ rfc16: {=bool:?}, reserved_1_15: {=u16:?} }}",
                    self.rfc16(),
                    self.reserved_1_15()
                )
            }
        }
        #[doc = "Frequency Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rfrl(pub u16);
        impl Rfrl {
            #[doc = "Frequency Comparison Value(b15-b0) To generate the operating clock from the main clock, this bit sets the comparison value of the 128-Hz clock cycle."]
            #[inline(always)]
            pub const fn rfc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Frequency Comparison Value(b15-b0) To generate the operating clock from the main clock, this bit sets the comparison value of the 128-Hz clock cycle."]
            #[inline(always)]
            pub fn set_rfc(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Rfrl {
            #[inline(always)]
            fn default() -> Rfrl {
                Rfrl(0)
            }
        }
        impl core::fmt::Debug for Rfrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rfrl").field("rfc", &self.rfc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rfrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rfrl {{ rfc: {=u16:?} }}", self.rfc())
            }
        }
        #[doc = "Hour Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rhrar(pub u8);
        impl Rhrar {
            #[doc = "1-Hour Count Value for the ones place of hours"]
            #[inline(always)]
            pub const fn hr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Hour Count Value for the ones place of hours"]
            #[inline(always)]
            pub fn set_hr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Hour Count Value for the tens place of hours"]
            #[inline(always)]
            pub const fn hr10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-Hour Count Value for the tens place of hours"]
            #[inline(always)]
            pub fn set_hr10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "Time Counter Setting for a.m./p.m."]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::RhrarPm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::RhrarPm::from_bits(val as u8)
            }
            #[doc = "Time Counter Setting for a.m./p.m."]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::RhrarPm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RhrarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RhrarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RhrarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rhrar {
            #[inline(always)]
            fn default() -> Rhrar {
                Rhrar(0)
            }
        }
        impl core::fmt::Debug for Rhrar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rhrar")
                    .field("hr1", &self.hr1())
                    .field("hr10", &self.hr10())
                    .field("pm", &self.pm())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rhrar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rhrar {{ hr1: {=u8:?}, hr10: {=u8:?}, pm: {:?}, enb: {:?} }}",
                    self.hr1(),
                    self.hr10(),
                    self.pm(),
                    self.enb()
                )
            }
        }
        #[doc = "Hour Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rhrcnt(pub u8);
        impl Rhrcnt {
            #[doc = "1-Hour Count Counts from 0 to 9 once per hour. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub const fn hr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Hour Count Counts from 0 to 9 once per hour. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub fn set_hr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Hour Count Counts from 0 to 2 once per carry from the ones place."]
            #[inline(always)]
            pub const fn hr10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-Hour Count Counts from 0 to 2 once per carry from the ones place."]
            #[inline(always)]
            pub fn set_hr10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "Time Counter Setting for a.m./p.m."]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::RhrcntPm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::RhrcntPm::from_bits(val as u8)
            }
            #[doc = "Time Counter Setting for a.m./p.m."]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::RhrcntPm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Rhrcnt {
            #[inline(always)]
            fn default() -> Rhrcnt {
                Rhrcnt(0)
            }
        }
        impl core::fmt::Debug for Rhrcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rhrcnt")
                    .field("hr1", &self.hr1())
                    .field("hr10", &self.hr10())
                    .field("pm", &self.pm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rhrcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rhrcnt {{ hr1: {=u8:?}, hr10: {=u8:?}, pm: {:?} }}",
                    self.hr1(),
                    self.hr10(),
                    self.pm()
                )
            }
        }
        #[doc = "Minute Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rminar(pub u8);
        impl Rminar {
            #[doc = "1-Minute Count Value for the ones place of minutes"]
            #[inline(always)]
            pub const fn min1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Minute Count Value for the ones place of minutes"]
            #[inline(always)]
            pub fn set_min1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Minute Count Value for the tens place of minutes"]
            #[inline(always)]
            pub const fn min10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-Minute Count Value for the tens place of minutes"]
            #[inline(always)]
            pub fn set_min10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RminarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RminarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RminarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rminar {
            #[inline(always)]
            fn default() -> Rminar {
                Rminar(0)
            }
        }
        impl core::fmt::Debug for Rminar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rminar")
                    .field("min1", &self.min1())
                    .field("min10", &self.min10())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rminar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rminar {{ min1: {=u8:?}, min10: {=u8:?}, enb: {:?} }}",
                    self.min1(),
                    self.min10(),
                    self.enb()
                )
            }
        }
        #[doc = "Minute Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rmincnt(pub u8);
        impl Rmincnt {
            #[doc = "1-Minute Count Counts from 0 to 9 every minute. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub const fn min1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Minute Count Counts from 0 to 9 every minute. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub fn set_min1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Minute Count Counts from 0 to 5 for 60-minute counting."]
            #[inline(always)]
            pub const fn min10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-Minute Count Counts from 0 to 5 for 60-minute counting."]
            #[inline(always)]
            pub fn set_min10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Rmincnt {
            #[inline(always)]
            fn default() -> Rmincnt {
                Rmincnt(0)
            }
        }
        impl core::fmt::Debug for Rmincnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rmincnt")
                    .field("min1", &self.min1())
                    .field("min10", &self.min10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rmincnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rmincnt {{ min1: {=u8:?}, min10: {=u8:?} }}",
                    self.min1(),
                    self.min10()
                )
            }
        }
        #[doc = "Month Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rmonar(pub u8);
        impl Rmonar {
            #[doc = "1 Month Value for the ones place of months"]
            #[inline(always)]
            pub const fn mon1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1 Month Value for the ones place of months"]
            #[inline(always)]
            pub fn set_mon1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10 Months Value for the tens place of months"]
            #[inline(always)]
            pub const fn mon10(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "10 Months Value for the tens place of months"]
            #[inline(always)]
            pub fn set_mon10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_5_6(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_5_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u8) & 0x03) << 5usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RmonarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RmonarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RmonarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rmonar {
            #[inline(always)]
            fn default() -> Rmonar {
                Rmonar(0)
            }
        }
        impl core::fmt::Debug for Rmonar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rmonar")
                    .field("mon1", &self.mon1())
                    .field("mon10", &self.mon10())
                    .field("reserved_5_6", &self.reserved_5_6())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rmonar {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rmonar {{ mon1: {=u8:?}, mon10: {=bool:?}, reserved_5_6: {=u8:?}, enb: {:?} }}" , self . mon1 () , self . mon10 () , self . reserved_5_6 () , self . enb ())
            }
        }
        #[doc = "Month Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rmoncnt(pub u8);
        impl Rmoncnt {
            #[doc = "1-Month Count Counts from 0 to 9 once per month. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub const fn mon1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Month Count Counts from 0 to 9 once per month. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub fn set_mon1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Month Count Counts from 0 to 1 once per carry from the ones place."]
            #[inline(always)]
            pub const fn mon10(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "10-Month Count Counts from 0 to 1 once per carry from the ones place."]
            #[inline(always)]
            pub fn set_mon10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Rmoncnt {
            #[inline(always)]
            fn default() -> Rmoncnt {
                Rmoncnt(0)
            }
        }
        impl core::fmt::Debug for Rmoncnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rmoncnt")
                    .field("mon1", &self.mon1())
                    .field("mon10", &self.mon10())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rmoncnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rmoncnt {{ mon1: {=u8:?}, mon10: {=bool:?}, reserved_5_7: {=u8:?} }}",
                    self.mon1(),
                    self.mon10(),
                    self.reserved_5_7()
                )
            }
        }
        #[doc = "Second Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rsecar(pub u8);
        impl Rsecar {
            #[doc = "1-Second Value for the ones place of seconds"]
            #[inline(always)]
            pub const fn sec1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Second Value for the ones place of seconds"]
            #[inline(always)]
            pub fn set_sec1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Seconds Value for the tens place of seconds"]
            #[inline(always)]
            pub const fn sec10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-Seconds Value for the tens place of seconds"]
            #[inline(always)]
            pub fn set_sec10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RsecarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RsecarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RsecarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rsecar {
            #[inline(always)]
            fn default() -> Rsecar {
                Rsecar(0)
            }
        }
        impl core::fmt::Debug for Rsecar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rsecar")
                    .field("sec1", &self.sec1())
                    .field("sec10", &self.sec10())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rsecar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rsecar {{ sec1: {=u8:?}, sec10: {=u8:?}, enb: {:?} }}",
                    self.sec1(),
                    self.sec10(),
                    self.enb()
                )
            }
        }
        #[doc = "Second Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rseccnt(pub u8);
        impl Rseccnt {
            #[doc = "1-Second Count Counts from 0 to 9 every second. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub const fn sec1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Second Count Counts from 0 to 9 every second. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub fn set_sec1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Second Count Counts from 0 to 5 for 60-second counting."]
            #[inline(always)]
            pub const fn sec10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-Second Count Counts from 0 to 5 for 60-second counting."]
            #[inline(always)]
            pub fn set_sec10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Rseccnt {
            #[inline(always)]
            fn default() -> Rseccnt {
                Rseccnt(0)
            }
        }
        impl core::fmt::Debug for Rseccnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rseccnt")
                    .field("sec1", &self.sec1())
                    .field("sec10", &self.sec10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rseccnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rseccnt {{ sec1: {=u8:?}, sec10: {=u8:?} }}",
                    self.sec1(),
                    self.sec10()
                )
            }
        }
        #[doc = "Day,of,Week Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rwkar(pub u8);
        impl Rwkar {
            #[doc = "Day,of,Week Counting"]
            #[inline(always)]
            pub const fn dayw(&self) -> super::vals::RwkarDayw {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::RwkarDayw::from_bits(val as u8)
            }
            #[doc = "Day,of,Week Counting"]
            #[inline(always)]
            pub fn set_dayw(&mut self, val: super::vals::RwkarDayw) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_3_6(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_3_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 3usize)) | (((val as u8) & 0x0f) << 3usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RwkarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RwkarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RwkarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rwkar {
            #[inline(always)]
            fn default() -> Rwkar {
                Rwkar(0)
            }
        }
        impl core::fmt::Debug for Rwkar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rwkar")
                    .field("dayw", &self.dayw())
                    .field("reserved_3_6", &self.reserved_3_6())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rwkar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rwkar {{ dayw: {:?}, reserved_3_6: {=u8:?}, enb: {:?} }}",
                    self.dayw(),
                    self.reserved_3_6(),
                    self.enb()
                )
            }
        }
        #[doc = "Day,of,Week Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rwkcnt(pub u8);
        impl Rwkcnt {
            #[doc = "Day,of,Week Counting"]
            #[inline(always)]
            pub const fn dayw(&self) -> super::vals::RwkcntDayw {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::RwkcntDayw::from_bits(val as u8)
            }
            #[doc = "Day,of,Week Counting"]
            #[inline(always)]
            pub fn set_dayw(&mut self, val: super::vals::RwkcntDayw) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Rwkcnt {
            #[inline(always)]
            fn default() -> Rwkcnt {
                Rwkcnt(0)
            }
        }
        impl core::fmt::Debug for Rwkcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rwkcnt")
                    .field("dayw", &self.dayw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rwkcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rwkcnt {{ dayw: {:?} }}", self.dayw())
            }
        }
        #[doc = "Year Alarm Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ryrar(pub u16);
        impl Ryrar {
            #[doc = "1 Year Value for the ones place of years"]
            #[inline(always)]
            pub const fn yr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1 Year Value for the ones place of years"]
            #[inline(always)]
            pub fn set_yr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "10 Years Value for the tens place of years"]
            #[inline(always)]
            pub const fn yr10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "10 Years Value for the tens place of years"]
            #[inline(always)]
            pub fn set_yr10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u16) & 0x0f) << 4usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Ryrar {
            #[inline(always)]
            fn default() -> Ryrar {
                Ryrar(0)
            }
        }
        impl core::fmt::Debug for Ryrar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ryrar")
                    .field("yr1", &self.yr1())
                    .field("yr10", &self.yr10())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ryrar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ryrar {{ yr1: {=u8:?}, yr10: {=u8:?}, reserved_8_15: {=u8:?} }}",
                    self.yr1(),
                    self.yr10(),
                    self.reserved_8_15()
                )
            }
        }
        #[doc = "Year Alarm Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ryraren(pub u8);
        impl Ryraren {
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_0_6(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_0_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u8) & 0x7f) << 0usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RyrarenEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RyrarenEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RyrarenEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ryraren {
            #[inline(always)]
            fn default() -> Ryraren {
                Ryraren(0)
            }
        }
        impl core::fmt::Debug for Ryraren {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ryraren")
                    .field("reserved_0_6", &self.reserved_0_6())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ryraren {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ryraren {{ reserved_0_6: {=u8:?}, enb: {:?} }}",
                    self.reserved_0_6(),
                    self.enb()
                )
            }
        }
        #[doc = "Year Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ryrcnt(pub u16);
        impl Ryrcnt {
            #[doc = "1-Year Count Counts from 0 to 9 once per year. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub const fn yr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Year Count Counts from 0 to 9 once per year. When a carry is generated, 1 is added to the tens place."]
            #[inline(always)]
            pub fn set_yr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "10-Year Count Counts from 0 to 9 once per carry from ones place. When a carry is generated in the tens place, 1 is added to the hundreds place."]
            #[inline(always)]
            pub const fn yr10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "10-Year Count Counts from 0 to 9 once per carry from ones place. When a carry is generated in the tens place, 1 is added to the hundreds place."]
            #[inline(always)]
            pub fn set_yr10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u16) & 0x0f) << 4usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Ryrcnt {
            #[inline(always)]
            fn default() -> Ryrcnt {
                Ryrcnt(0)
            }
        }
        impl core::fmt::Debug for Ryrcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ryrcnt")
                    .field("yr1", &self.yr1())
                    .field("yr10", &self.yr10())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ryrcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ryrcnt {{ yr1: {=u8:?}, yr10: {=u8:?}, reserved_8_15: {=u8:?} }}",
                    self.yr1(),
                    self.yr10(),
                    self.reserved_8_15()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aadje {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aadje {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aadje {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aadje {
            #[inline(always)]
            fn from(val: u8) -> Aadje {
                Aadje::from_bits(val)
            }
        }
        impl From<Aadje> for u8 {
            #[inline(always)]
            fn from(val: Aadje) -> u8 {
                Aadje::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aadjp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aadjp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aadjp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aadjp {
            #[inline(always)]
            fn from(val: u8) -> Aadjp {
                Aadjp::from_bits(val)
            }
        }
        impl From<Aadjp> for u8 {
            #[inline(always)]
            fn from(val: Aadjp) -> u8 {
                Aadjp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adj30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adj30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adj30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adj30 {
            #[inline(always)]
            fn from(val: u8) -> Adj30 {
                Adj30::from_bits(val)
            }
        }
        impl From<Adj30> for u8 {
            #[inline(always)]
            fn from(val: Adj30) -> u8 {
                Adj30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aie {
            #[inline(always)]
            fn from(val: u8) -> Aie {
                Aie::from_bits(val)
            }
        }
        impl From<Aie> for u8 {
            #[inline(always)]
            fn from(val: Aie) -> u8 {
                Aie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cie {
            #[inline(always)]
            fn from(val: u8) -> Cie {
                Cie::from_bits(val)
            }
        }
        impl From<Cie> for u8 {
            #[inline(always)]
            fn from(val: Cie) -> u8 {
                Cie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cntmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cntmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cntmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cntmd {
            #[inline(always)]
            fn from(val: u8) -> Cntmd {
                Cntmd::from_bits(val)
            }
        }
        impl From<Cntmd> for u8 {
            #[inline(always)]
            fn from(val: Cntmd) -> u8 {
                Cntmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hr24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hr24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hr24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hr24 {
            #[inline(always)]
            fn from(val: u8) -> Hr24 {
                Hr24::from_bits(val)
            }
        }
        impl From<Hr24> for u8 {
            #[inline(always)]
            fn from(val: Hr24) -> u8 {
                Hr24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pes {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Pes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pes {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pes {
            #[inline(always)]
            fn from(val: u8) -> Pes {
                Pes::from_bits(val)
            }
        }
        impl From<Pes> for u8 {
            #[inline(always)]
            fn from(val: Pes) -> u8 {
                Pes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pie {
            #[inline(always)]
            fn from(val: u8) -> Pie {
                Pie::from_bits(val)
            }
        }
        impl From<Pie> for u8 {
            #[inline(always)]
            fn from(val: Pie) -> u8 {
                Pie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pmadj {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Pmadj {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pmadj {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pmadj {
            #[inline(always)]
            fn from(val: u8) -> Pmadj {
                Pmadj::from_bits(val)
            }
        }
        impl From<Pmadj> for u8 {
            #[inline(always)]
            fn from(val: Pmadj) -> u8 {
                Pmadj::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcksel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcksel {
            #[inline(always)]
            fn from(val: u8) -> Rcksel {
                Rcksel::from_bits(val)
            }
        }
        impl From<Rcksel> for u8 {
            #[inline(always)]
            fn from(val: Rcksel) -> u8 {
                Rcksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RdayarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RdayarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RdayarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RdayarEnb {
            #[inline(always)]
            fn from(val: u8) -> RdayarEnb {
                RdayarEnb::from_bits(val)
            }
        }
        impl From<RdayarEnb> for u8 {
            #[inline(always)]
            fn from(val: RdayarEnb) -> u8 {
                RdayarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Reset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reset {
            #[inline(always)]
            fn from(val: u8) -> Reset {
                Reset::from_bits(val)
            }
        }
        impl From<Reset> for u8 {
            #[inline(always)]
            fn from(val: Reset) -> u8 {
                Reset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RhrarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RhrarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RhrarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RhrarEnb {
            #[inline(always)]
            fn from(val: u8) -> RhrarEnb {
                RhrarEnb::from_bits(val)
            }
        }
        impl From<RhrarEnb> for u8 {
            #[inline(always)]
            fn from(val: RhrarEnb) -> u8 {
                RhrarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RhrarPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RhrarPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RhrarPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RhrarPm {
            #[inline(always)]
            fn from(val: u8) -> RhrarPm {
                RhrarPm::from_bits(val)
            }
        }
        impl From<RhrarPm> for u8 {
            #[inline(always)]
            fn from(val: RhrarPm) -> u8 {
                RhrarPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RhrcntPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RhrcntPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RhrcntPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RhrcntPm {
            #[inline(always)]
            fn from(val: u8) -> RhrcntPm {
                RhrcntPm::from_bits(val)
            }
        }
        impl From<RhrcntPm> for u8 {
            #[inline(always)]
            fn from(val: RhrcntPm) -> u8 {
                RhrcntPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RminarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RminarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RminarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RminarEnb {
            #[inline(always)]
            fn from(val: u8) -> RminarEnb {
                RminarEnb::from_bits(val)
            }
        }
        impl From<RminarEnb> for u8 {
            #[inline(always)]
            fn from(val: RminarEnb) -> u8 {
                RminarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RmonarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RmonarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RmonarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RmonarEnb {
            #[inline(always)]
            fn from(val: u8) -> RmonarEnb {
                RmonarEnb::from_bits(val)
            }
        }
        impl From<RmonarEnb> for u8 {
            #[inline(always)]
            fn from(val: RmonarEnb) -> u8 {
                RmonarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RsecarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RsecarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RsecarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RsecarEnb {
            #[inline(always)]
            fn from(val: u8) -> RsecarEnb {
                RsecarEnb::from_bits(val)
            }
        }
        impl From<RsecarEnb> for u8 {
            #[inline(always)]
            fn from(val: RsecarEnb) -> u8 {
                RsecarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcoe {
            #[inline(always)]
            fn from(val: u8) -> Rtcoe {
                Rtcoe::from_bits(val)
            }
        }
        impl From<Rtcoe> for u8 {
            #[inline(always)]
            fn from(val: Rtcoe) -> u8 {
                Rtcoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcos {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcos {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcos {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcos {
            #[inline(always)]
            fn from(val: u8) -> Rtcos {
                Rtcos::from_bits(val)
            }
        }
        impl From<Rtcos> for u8 {
            #[inline(always)]
            fn from(val: Rtcos) -> u8 {
                Rtcos::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RwkarDayw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl RwkarDayw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RwkarDayw {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RwkarDayw {
            #[inline(always)]
            fn from(val: u8) -> RwkarDayw {
                RwkarDayw::from_bits(val)
            }
        }
        impl From<RwkarDayw> for u8 {
            #[inline(always)]
            fn from(val: RwkarDayw) -> u8 {
                RwkarDayw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RwkarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RwkarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RwkarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RwkarEnb {
            #[inline(always)]
            fn from(val: u8) -> RwkarEnb {
                RwkarEnb::from_bits(val)
            }
        }
        impl From<RwkarEnb> for u8 {
            #[inline(always)]
            fn from(val: RwkarEnb) -> u8 {
                RwkarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RwkcntDayw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl RwkcntDayw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RwkcntDayw {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RwkcntDayw {
            #[inline(always)]
            fn from(val: u8) -> RwkcntDayw {
                RwkcntDayw::from_bits(val)
            }
        }
        impl From<RwkcntDayw> for u8 {
            #[inline(always)]
            fn from(val: RwkcntDayw) -> u8 {
                RwkcntDayw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RyrarenEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RyrarenEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RyrarenEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RyrarenEnb {
            #[inline(always)]
            fn from(val: u8) -> RyrarenEnb {
                RyrarenEnb::from_bits(val)
            }
        }
        impl From<RyrarenEnb> for u8 {
            #[inline(always)]
            fn from(val: RyrarenEnb) -> u8 {
                RyrarenEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Start {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Start {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Start {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Start {
            #[inline(always)]
            fn from(val: u8) -> Start {
                Start::from_bits(val)
            }
        }
        impl From<Start> for u8 {
            #[inline(always)]
            fn from(val: Start) -> u8 {
                Start::to_bits(val)
            }
        }
    }
}
pub mod sci0 {
    #[doc = "Serial Communication Interface 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sci0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Sci0 {}
    unsafe impl Sync for Sci0 {}
    impl Sci0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Serial Mode Register (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn smr(self) -> crate::common::Reg<regs::Smr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Serial mode register (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn smr_smci(self) -> crate::common::Reg<regs::SmrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Bit Rate Register"]
        #[inline(always)]
        pub const fn brr(self) -> crate::common::Reg<regs::Brr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Serial Control Register (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<regs::Scr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Serial Control Register (SCMR.SMIF =1)"]
        #[inline(always)]
        pub const fn scr_smci(self) -> crate::common::Reg<regs::ScrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Transmit Data Register"]
        #[inline(always)]
        pub const fn tdr(self) -> crate::common::Reg<regs::Tdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)"]
        #[inline(always)]
        pub const fn ssr(self) -> crate::common::Reg<regs::Ssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 0 and FCR.FM=1)"]
        #[inline(always)]
        pub const fn ssr_fifo(self) -> crate::common::Reg<regs::SsrFifo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn ssr_smci(self) -> crate::common::Reg<regs::SsrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Receive Data Register"]
        #[inline(always)]
        pub const fn rdr(self) -> crate::common::Reg<regs::Rdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "Smart Card Mode Register"]
        #[inline(always)]
        pub const fn scmr(self) -> crate::common::Reg<regs::Scmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Serial Extended Mode Register"]
        #[inline(always)]
        pub const fn semr(self) -> crate::common::Reg<regs::Semr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Noise Filter Setting Register"]
        #[inline(always)]
        pub const fn snfr(self) -> crate::common::Reg<regs::Snfr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "I2C Mode Register 1"]
        #[inline(always)]
        pub const fn simr1(self) -> crate::common::Reg<regs::Simr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "I2C Mode Register 2"]
        #[inline(always)]
        pub const fn simr2(self) -> crate::common::Reg<regs::Simr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "IIC Mode Register 3"]
        #[inline(always)]
        pub const fn simr3(self) -> crate::common::Reg<regs::Simr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "IIC Status Register"]
        #[inline(always)]
        pub const fn sisr(self) -> crate::common::Reg<regs::Sisr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Mode Register"]
        #[inline(always)]
        pub const fn spmr(self) -> crate::common::Reg<regs::Spmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "Transmit FIFO Data Register H"]
        #[inline(always)]
        pub const fn ftdrh(self) -> crate::common::Reg<regs::Ftdrh, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Transmit FIFO Data Register HL"]
        #[inline(always)]
        pub const fn ftdrhl(self) -> crate::common::Reg<regs::Ftdrhl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Transmit 9-bit Data Register"]
        #[inline(always)]
        pub const fn tdrhl(self) -> crate::common::Reg<regs::Tdrhl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Transmit FIFO Data Register L"]
        #[inline(always)]
        pub const fn ftdrl(self) -> crate::common::Reg<regs::Ftdrl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
        #[doc = "Receive FIFO Data Register H"]
        #[inline(always)]
        pub const fn frdrh(self) -> crate::common::Reg<regs::Frdrh, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Receive FIFO Data Register HL"]
        #[inline(always)]
        pub const fn frdrhl(self) -> crate::common::Reg<regs::Frdrhl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Receive 9-bit Data Register"]
        #[inline(always)]
        pub const fn rdrhl(self) -> crate::common::Reg<regs::Rdrhl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Receive FIFO Data Register L"]
        #[inline(always)]
        pub const fn frdrl(self) -> crate::common::Reg<regs::Frdrl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
        #[doc = "Modulation Duty Register"]
        #[inline(always)]
        pub const fn mddr(self) -> crate::common::Reg<regs::Mddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "Data Compare Match Control Register"]
        #[inline(always)]
        pub const fn dccr(self) -> crate::common::Reg<regs::Dccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13usize) as _) }
        }
        #[doc = "FIFO Control Register"]
        #[inline(always)]
        pub const fn fcr(self) -> crate::common::Reg<regs::Fcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "FIFO Data Count Register"]
        #[inline(always)]
        pub const fn fdr(self) -> crate::common::Reg<regs::Fdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "Line Status Register"]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::Lsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Compare Match Data Register"]
        #[inline(always)]
        pub const fn cdr(self) -> crate::common::Reg<regs::Cdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "Serial Port Register"]
        #[inline(always)]
        pub const fn sptr(self) -> crate::common::Reg<regs::Sptr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bit Rate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Brr(pub u8);
        impl Brr {
            #[doc = "BRR is an 8-bit register that adjusts the bit rate."]
            #[inline(always)]
            pub const fn brr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "BRR is an 8-bit register that adjusts the bit rate."]
            #[inline(always)]
            pub fn set_brr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Brr {
            #[inline(always)]
            fn default() -> Brr {
                Brr(0)
            }
        }
        impl core::fmt::Debug for Brr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Brr").field("brr", &self.brr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Brr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Brr {{ brr: {=u8:?} }}", self.brr())
            }
        }
        #[doc = "Compare Match Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cdr(pub u16);
        impl Cdr {
            #[doc = "Compare Match DataCompare data pattern for address match wake,up function"]
            #[inline(always)]
            pub const fn cmpd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Compare Match DataCompare data pattern for address match wake,up function"]
            #[inline(always)]
            pub fn set_cmpd(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Cdr {
            #[inline(always)]
            fn default() -> Cdr {
                Cdr(0)
            }
        }
        impl core::fmt::Debug for Cdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cdr")
                    .field("cmpd", &self.cmpd())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cdr {{ cmpd: {=u16:?}, reserved_9_15: {=u8:?} }}",
                    self.cmpd(),
                    self.reserved_9_15()
                )
            }
        }
        #[doc = "Data Compare Match Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dccr(pub u8);
        impl Dccr {
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub const fn dcmf(&self) -> super::vals::Dcmf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dcmf::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub fn set_dcmf(&mut self, val: super::vals::Dcmf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_1_2(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_1_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u8) & 0x03) << 1usize);
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub const fn dper(&self) -> super::vals::Dper {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dper::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub fn set_dper(&mut self, val: super::vals::Dper) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub const fn dfer(&self) -> super::vals::Dfer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dfer::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub fn set_dfer(&mut self, val: super::vals::Dfer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "ID frame select Bit(Valid only in asynchronous mode(including multi,processor)"]
            #[inline(always)]
            pub const fn idsel(&self) -> super::vals::Idsel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Idsel::from_bits(val as u8)
            }
            #[doc = "ID frame select Bit(Valid only in asynchronous mode(including multi,processor)"]
            #[inline(always)]
            pub fn set_idsel(&mut self, val: super::vals::Idsel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Data Compare Match Enable(Valid only in asynchronous mode(including multi,processor)"]
            #[inline(always)]
            pub const fn dcme(&self) -> super::vals::Dcme {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dcme::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Enable(Valid only in asynchronous mode(including multi,processor)"]
            #[inline(always)]
            pub fn set_dcme(&mut self, val: super::vals::Dcme) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Dccr {
            #[inline(always)]
            fn default() -> Dccr {
                Dccr(0)
            }
        }
        impl core::fmt::Debug for Dccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dccr")
                    .field("dcmf", &self.dcmf())
                    .field("reserved_1_2", &self.reserved_1_2())
                    .field("dper", &self.dper())
                    .field("dfer", &self.dfer())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("idsel", &self.idsel())
                    .field("dcme", &self.dcme())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dccr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dccr {{ dcmf: {:?}, reserved_1_2: {=u8:?}, dper: {:?}, dfer: {:?}, reserved_5_5: {=bool:?}, idsel: {:?}, dcme: {:?} }}" , self . dcmf () , self . reserved_1_2 () , self . dper () , self . dfer () , self . reserved_5_5 () , self . idsel () , self . dcme ())
            }
        }
        #[doc = "FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fcr(pub u16);
        impl Fcr {
            #[doc = "FIFO Mode Select(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode)"]
            #[inline(always)]
            pub const fn fm(&self) -> super::vals::Fm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fm::from_bits(val as u8)
            }
            #[doc = "FIFO Mode Select(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode)"]
            #[inline(always)]
            pub fn set_fm(&mut self, val: super::vals::Fm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Receive FIFO Data Register Reset(Valid only in FCR.FM=1)"]
            #[inline(always)]
            pub const fn rfrst(&self) -> super::vals::Rfrst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rfrst::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Data Register Reset(Valid only in FCR.FM=1)"]
            #[inline(always)]
            pub fn set_rfrst(&mut self, val: super::vals::Rfrst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Transmit FIFO Data Register Reset(Valid only in FCR.FM=1)"]
            #[inline(always)]
            pub const fn tfrst(&self) -> super::vals::Tfrst {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tfrst::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Data Register Reset(Valid only in FCR.FM=1)"]
            #[inline(always)]
            pub fn set_tfrst(&mut self, val: super::vals::Tfrst) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Receive data ready error select bit(When detecting a reception data ready, the interrupt request is selected.)"]
            #[inline(always)]
            pub const fn dres(&self) -> super::vals::Dres {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dres::from_bits(val as u8)
            }
            #[doc = "Receive data ready error select bit(When detecting a reception data ready, the interrupt request is selected.)"]
            #[inline(always)]
            pub fn set_dres(&mut self, val: super::vals::Dres) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Transmit FIFO data trigger number(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode)"]
            #[inline(always)]
            pub const fn ttrg(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Transmit FIFO data trigger number(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode)"]
            #[inline(always)]
            pub fn set_ttrg(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u16) & 0x0f) << 4usize);
            }
            #[doc = "Receive FIFO data trigger number"]
            #[inline(always)]
            pub const fn rtrg(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Receive FIFO data trigger number"]
            #[inline(always)]
            pub fn set_rtrg(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u16) & 0x0f) << 8usize);
            }
            #[doc = "RTS# Output Active Trigger Number Select(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode)"]
            #[inline(always)]
            pub const fn rstrg(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "RTS# Output Active Trigger Number Select(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode)"]
            #[inline(always)]
            pub fn set_rstrg(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u16) & 0x0f) << 12usize);
            }
        }
        impl Default for Fcr {
            #[inline(always)]
            fn default() -> Fcr {
                Fcr(0)
            }
        }
        impl core::fmt::Debug for Fcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fcr")
                    .field("fm", &self.fm())
                    .field("rfrst", &self.rfrst())
                    .field("tfrst", &self.tfrst())
                    .field("dres", &self.dres())
                    .field("ttrg", &self.ttrg())
                    .field("rtrg", &self.rtrg())
                    .field("rstrg", &self.rstrg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fcr {{ fm: {:?}, rfrst: {:?}, tfrst: {:?}, dres: {:?}, ttrg: {=u8:?}, rtrg: {=u8:?}, rstrg: {=u8:?} }}" , self . fm () , self . rfrst () , self . tfrst () , self . dres () , self . ttrg () , self . rtrg () , self . rstrg ())
            }
        }
        #[doc = "FIFO Data Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fdr(pub u16);
        impl Fdr {
            #[doc = "Receive FIFO Data CountIndicate the quantity of receive data stored in FRDRH and FRDRL(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, while FCR.FM=1)"]
            #[inline(always)]
            pub const fn r(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Receive FIFO Data CountIndicate the quantity of receive data stored in FRDRH and FRDRL(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, while FCR.FM=1)"]
            #[inline(always)]
            pub fn set_r(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u16) & 0x1f) << 0usize);
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u16) & 0x07) << 5usize);
            }
            #[doc = "Transmit FIFO Data CountIndicate the quantity of non,transmit data stored in FTDRH and FTDRL(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, while FCR.FM=1)"]
            #[inline(always)]
            pub const fn t(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "Transmit FIFO Data CountIndicate the quantity of non,transmit data stored in FTDRH and FTDRL(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, while FCR.FM=1)"]
            #[inline(always)]
            pub fn set_t(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u16) & 0x1f) << 8usize);
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub const fn reserved_13_15(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub fn set_reserved_13_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u16) & 0x07) << 13usize);
            }
        }
        impl Default for Fdr {
            #[inline(always)]
            fn default() -> Fdr {
                Fdr(0)
            }
        }
        impl core::fmt::Debug for Fdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fdr")
                    .field("r", &self.r())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .field("t", &self.t())
                    .field("reserved_13_15", &self.reserved_13_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fdr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fdr {{ r: {=u8:?}, reserved_5_7: {=u8:?}, t: {=u8:?}, reserved_13_15: {=u8:?} }}" , self . r () , self . reserved_5_7 () , self . t () , self . reserved_13_15 ())
            }
        }
        #[doc = "Receive FIFO Data Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frdrh(pub u8);
        impl Frdrh {
            #[doc = "Serial receive data(b8)(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub const fn rdath(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Serial receive data(b8)(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub fn set_rdath(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi,processor bit corresponded to serial receive data(RDATA\\[8:0\\])"]
            #[inline(always)]
            pub const fn mpb(&self) -> super::vals::FrdrhMpb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::FrdrhMpb::from_bits(val as u8)
            }
            #[doc = "Multi,processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi,processor bit corresponded to serial receive data(RDATA\\[8:0\\])"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: super::vals::FrdrhMpb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Receive data ready flag(It is same as SSR.DR)"]
            #[inline(always)]
            pub const fn dr(&self) -> super::vals::FrdrhDr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::FrdrhDr::from_bits(val as u8)
            }
            #[doc = "Receive data ready flag(It is same as SSR.DR)"]
            #[inline(always)]
            pub fn set_dr(&mut self, val: super::vals::FrdrhDr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity error flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::FrdrhPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::FrdrhPer::from_bits(val as u8)
            }
            #[doc = "Parity error flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::FrdrhPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Framing error flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::FrdrhFer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::FrdrhFer::from_bits(val as u8)
            }
            #[doc = "Framing error flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::FrdrhFer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun error flag(It is same as SSR.ORER)"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::FrdrhOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::FrdrhOrer::from_bits(val as u8)
            }
            #[doc = "Overrun error flag(It is same as SSR.ORER)"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::FrdrhOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive FIFO data full flag(It is same as SSR.RDF)"]
            #[inline(always)]
            pub const fn rdf(&self) -> super::vals::FrdrhRdf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::FrdrhRdf::from_bits(val as u8)
            }
            #[doc = "Receive FIFO data full flag(It is same as SSR.RDF)"]
            #[inline(always)]
            pub fn set_rdf(&mut self, val: super::vals::FrdrhRdf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Frdrh {
            #[inline(always)]
            fn default() -> Frdrh {
                Frdrh(0)
            }
        }
        impl core::fmt::Debug for Frdrh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frdrh")
                    .field("rdath", &self.rdath())
                    .field("mpb", &self.mpb())
                    .field("dr", &self.dr())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdf", &self.rdf())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frdrh {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Frdrh {{ rdath: {=bool:?}, mpb: {:?}, dr: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdf: {:?}, reserved_7_7: {=bool:?} }}" , self . rdath () , self . mpb () , self . dr () , self . per () , self . fer () , self . orer () , self . rdf () , self . reserved_7_7 ())
            }
        }
        #[doc = "Receive FIFO Data Register HL"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frdrhl(pub u16);
        impl Frdrhl {
            #[doc = "Serial receive data(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub const fn rdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial receive data(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub fn set_rdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "Multi,processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi,processor bit corresponded to serial receive data(RDATA\\[8:0\\])"]
            #[inline(always)]
            pub const fn mpb(&self) -> super::vals::FrdrhlMpb {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::FrdrhlMpb::from_bits(val as u8)
            }
            #[doc = "Multi,processor bit flag(Valid only in asynchronous mode with SMR.MP=1 and FIFO selected) It can read multi,processor bit corresponded to serial receive data(RDATA\\[8:0\\])"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: super::vals::FrdrhlMpb) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Receive data ready flag(It is same as SSR.DR)"]
            #[inline(always)]
            pub const fn dr(&self) -> super::vals::FrdrhlDr {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::FrdrhlDr::from_bits(val as u8)
            }
            #[doc = "Receive data ready flag(It is same as SSR.DR)"]
            #[inline(always)]
            pub fn set_dr(&mut self, val: super::vals::FrdrhlDr) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Parity error flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::FrdrhlPer {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::FrdrhlPer::from_bits(val as u8)
            }
            #[doc = "Parity error flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::FrdrhlPer) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Framing error flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::FrdrhlFer {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::FrdrhlFer::from_bits(val as u8)
            }
            #[doc = "Framing error flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::FrdrhlFer) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Overrun error flag(It is same as SSR.ORER)"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::FrdrhlOrer {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::FrdrhlOrer::from_bits(val as u8)
            }
            #[doc = "Overrun error flag(It is same as SSR.ORER)"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::FrdrhlOrer) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Receive FIFO data full flag(It is same as SSR.RDF)"]
            #[inline(always)]
            pub const fn rdf(&self) -> super::vals::FrdrhlRdf {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::FrdrhlRdf::from_bits(val as u8)
            }
            #[doc = "Receive FIFO data full flag(It is same as SSR.RDF)"]
            #[inline(always)]
            pub fn set_rdf(&mut self, val: super::vals::FrdrhlRdf) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_15_15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_15_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Frdrhl {
            #[inline(always)]
            fn default() -> Frdrhl {
                Frdrhl(0)
            }
        }
        impl core::fmt::Debug for Frdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frdrhl")
                    .field("rdat", &self.rdat())
                    .field("mpb", &self.mpb())
                    .field("dr", &self.dr())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdf", &self.rdf())
                    .field("reserved_15_15", &self.reserved_15_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Frdrhl {{ rdat: {=u16:?}, mpb: {:?}, dr: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdf: {:?}, reserved_15_15: {=bool:?} }}" , self . rdat () , self . mpb () , self . dr () , self . per () , self . fer () , self . orer () , self . rdf () , self . reserved_15_15 ())
            }
        }
        #[doc = "Receive FIFO Data Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frdrl(pub u8);
        impl Frdrl {
            #[doc = "Serial receive data(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)NOTE: When reading both of FRDRH register and FRDRL register, please read by an order of the FRDRH register and the FRDRL register."]
            #[inline(always)]
            pub const fn rdatl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Serial receive data(Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)NOTE: When reading both of FRDRH register and FRDRL register, please read by an order of the FRDRH register and the FRDRL register."]
            #[inline(always)]
            pub fn set_rdatl(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Frdrl {
            #[inline(always)]
            fn default() -> Frdrl {
                Frdrl(0)
            }
        }
        impl core::fmt::Debug for Frdrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frdrl")
                    .field("rdatl", &self.rdatl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frdrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frdrl {{ rdatl: {=u8:?} }}", self.rdatl())
            }
        }
        #[doc = "Transmit FIFO Data Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ftdrh(pub u8);
        impl Ftdrh {
            #[doc = "Serial transmit data (b8) (Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub const fn tdath(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Serial transmit data (b8) (Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub fn set_tdath(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)"]
            #[inline(always)]
            pub const fn mpbt(&self) -> super::vals::FtdrhMpbt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::FtdrhMpbt::from_bits(val as u8)
            }
            #[doc = "Multi,processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: super::vals::FtdrhMpbt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "The write value should be 111111."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "The write value should be 111111."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Ftdrh {
            #[inline(always)]
            fn default() -> Ftdrh {
                Ftdrh(0)
            }
        }
        impl core::fmt::Debug for Ftdrh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ftdrh")
                    .field("tdath", &self.tdath())
                    .field("mpbt", &self.mpbt())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ftdrh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ftdrh {{ tdath: {=bool:?}, mpbt: {:?}, reserved_2_7: {=u8:?} }}",
                    self.tdath(),
                    self.mpbt(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "Transmit FIFO Data Register HL"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ftdrhl(pub u16);
        impl Ftdrhl {
            #[doc = "Serial transmit data (Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub const fn tdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial transmit data (Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub fn set_tdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "Multi,processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)"]
            #[inline(always)]
            pub const fn mpbt(&self) -> super::vals::FtdrhlMpbt {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::FtdrhlMpbt::from_bits(val as u8)
            }
            #[doc = "Multi,processor transfer bit flag(Valid only in asynchronous mode and SMR.MP=1 and FIFO selected)"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: super::vals::FtdrhlMpbt) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "The write value should be 111111."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "The write value should be 111111."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Ftdrhl {
            #[inline(always)]
            fn default() -> Ftdrhl {
                Ftdrhl(0)
            }
        }
        impl core::fmt::Debug for Ftdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ftdrhl")
                    .field("tdat", &self.tdat())
                    .field("mpbt", &self.mpbt())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ftdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ftdrhl {{ tdat: {=u16:?}, mpbt: {:?}, reserved_10_15: {=u8:?} }}",
                    self.tdat(),
                    self.mpbt(),
                    self.reserved_10_15()
                )
            }
        }
        #[doc = "Transmit FIFO Data Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ftdrl(pub u8);
        impl Ftdrl {
            #[doc = "Serial transmit data(b7-b0) (Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub const fn tdatl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Serial transmit data(b7-b0) (Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub fn set_tdatl(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ftdrl {
            #[inline(always)]
            fn default() -> Ftdrl {
                Ftdrl(0)
            }
        }
        impl core::fmt::Debug for Ftdrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ftdrl")
                    .field("tdatl", &self.tdatl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ftdrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ftdrl {{ tdatl: {=u8:?} }}", self.tdatl())
            }
        }
        #[doc = "Line Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsr(pub u16);
        impl Lsr {
            #[doc = "Overrun Error Flag (Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::LsrOrer {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::LsrOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag (Valid only in asynchronous mode(including multi,processor) or clock synchronous mode, and FIFO selected)"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::LsrOrer) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u16) & 0x01) << 1usize);
            }
            #[doc = "Framing Error CountIndicates the quantity of data with a framing error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL)."]
            #[inline(always)]
            pub const fn fnum(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x1f;
                val as u8
            }
            #[doc = "Framing Error CountIndicates the quantity of data with a framing error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL)."]
            #[inline(always)]
            pub fn set_fnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 2usize)) | (((val as u16) & 0x1f) << 2usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u16) & 0x01) << 7usize);
            }
            #[doc = "Parity Error CountIndicates the quantity of data with a parity error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL)."]
            #[inline(always)]
            pub const fn pnum(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "Parity Error CountIndicates the quantity of data with a parity error among the receive data stored in the receive FIFO data register (FRDRH and FRDRL)."]
            #[inline(always)]
            pub fn set_pnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u16) & 0x1f) << 8usize);
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub const fn reserved_13_15(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000."]
            #[inline(always)]
            pub fn set_reserved_13_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u16) & 0x07) << 13usize);
            }
        }
        impl Default for Lsr {
            #[inline(always)]
            fn default() -> Lsr {
                Lsr(0)
            }
        }
        impl core::fmt::Debug for Lsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsr")
                    .field("orer", &self.orer())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("fnum", &self.fnum())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .field("pnum", &self.pnum())
                    .field("reserved_13_15", &self.reserved_13_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Lsr {{ orer: {:?}, reserved_1_1: {=bool:?}, fnum: {=u8:?}, reserved_7_7: {=bool:?}, pnum: {=u8:?}, reserved_13_15: {=u8:?} }}" , self . orer () , self . reserved_1_1 () , self . fnum () , self . reserved_7_7 () , self . pnum () , self . reserved_13_15 ())
            }
        }
        #[doc = "Modulation Duty Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mddr(pub u8);
        impl Mddr {
            #[doc = "MDDR corrects the bit rate adjusted by the BRR register."]
            #[inline(always)]
            pub const fn mddr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MDDR corrects the bit rate adjusted by the BRR register."]
            #[inline(always)]
            pub fn set_mddr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Mddr {
            #[inline(always)]
            fn default() -> Mddr {
                Mddr(0)
            }
        }
        impl core::fmt::Debug for Mddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mddr").field("mddr", &self.mddr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mddr {{ mddr: {=u8:?} }}", self.mddr())
            }
        }
        #[doc = "Receive Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdr(pub u8);
        impl Rdr {
            #[doc = "RDR is an 8-bit register that stores receive data."]
            #[inline(always)]
            pub const fn rdr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "RDR is an 8-bit register that stores receive data."]
            #[inline(always)]
            pub fn set_rdr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Rdr {
            #[inline(always)]
            fn default() -> Rdr {
                Rdr(0)
            }
        }
        impl core::fmt::Debug for Rdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdr").field("rdr", &self.rdr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rdr {{ rdr: {=u8:?} }}", self.rdr())
            }
        }
        #[doc = "Receive 9-bit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdrhl(pub u16);
        impl Rdrhl {
            #[doc = "RDRHL is an 16-bit register that stores receive data."]
            #[inline(always)]
            pub const fn rdrhl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "RDRHL is an 16-bit register that stores receive data."]
            #[inline(always)]
            pub fn set_rdrhl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Rdrhl {
            #[inline(always)]
            fn default() -> Rdrhl {
                Rdrhl(0)
            }
        }
        impl core::fmt::Debug for Rdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdrhl")
                    .field("rdrhl", &self.rdrhl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rdrhl {{ rdrhl: {=u16:?} }}", self.rdrhl())
            }
        }
        #[doc = "Smart Card Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scmr(pub u8);
        impl Scmr {
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub const fn smif(&self) -> super::vals::Smif {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smif::from_bits(val as u8)
            }
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub fn set_smif(&mut self, val: super::vals::Smif) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmitted/Received Data InvertSet this bit to 0 if operation is to be in simple I2C mode."]
            #[inline(always)]
            pub const fn sinv(&self) -> super::vals::Sinv {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sinv::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data InvertSet this bit to 0 if operation is to be in simple I2C mode."]
            #[inline(always)]
            pub fn set_sinv(&mut self, val: super::vals::Sinv) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmitted/Received Data Transfer DirectionNOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode.Set this bit to 1 if operation is to be in simple I2C mode."]
            #[inline(always)]
            pub const fn sdir(&self) -> super::vals::Sdir {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sdir::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data Transfer DirectionNOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode.Set this bit to 1 if operation is to be in simple I2C mode."]
            #[inline(always)]
            pub fn set_sdir(&mut self, val: super::vals::Sdir) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Character Length 1(Only valid in asynchronous mode)"]
            #[inline(always)]
            pub const fn chr1(&self) -> super::vals::Chr1 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Chr1::from_bits(val as u8)
            }
            #[doc = "Character Length 1(Only valid in asynchronous mode)"]
            #[inline(always)]
            pub fn set_chr1(&mut self, val: super::vals::Chr1) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub const fn reserved_5_6(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub fn set_reserved_5_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u8) & 0x03) << 5usize);
            }
            #[doc = "Base Clock Pulse 2Selects the number of base clock cycles in combination with the SMR.BCP\\[1:0\\] bits"]
            #[inline(always)]
            pub const fn bcp2(&self) -> super::vals::Bcp2 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bcp2::from_bits(val as u8)
            }
            #[doc = "Base Clock Pulse 2Selects the number of base clock cycles in combination with the SMR.BCP\\[1:0\\] bits"]
            #[inline(always)]
            pub fn set_bcp2(&mut self, val: super::vals::Bcp2) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scmr {
            #[inline(always)]
            fn default() -> Scmr {
                Scmr(0)
            }
        }
        impl core::fmt::Debug for Scmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scmr")
                    .field("smif", &self.smif())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("sinv", &self.sinv())
                    .field("sdir", &self.sdir())
                    .field("chr1", &self.chr1())
                    .field("reserved_5_6", &self.reserved_5_6())
                    .field("bcp2", &self.bcp2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scmr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scmr {{ smif: {:?}, reserved_1_1: {=bool:?}, sinv: {:?}, sdir: {:?}, chr1: {:?}, reserved_5_6: {=u8:?}, bcp2: {:?} }}" , self . smif () , self . reserved_1_1 () , self . sinv () , self . sdir () , self . chr1 () , self . reserved_5_6 () , self . bcp2 ())
            }
        }
        #[doc = "Serial Control Register (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr(pub u8);
        impl Scr {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> super::vals::Teie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Teie::from_bits(val as u8)
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: super::vals::Teie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Multi,Processor Interrupt Enable(Valid in asynchronous mode when SMR.MP = 1)"]
            #[inline(always)]
            pub const fn mpie(&self) -> super::vals::Mpie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mpie::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Interrupt Enable(Valid in asynchronous mode when SMR.MP = 1)"]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: super::vals::Mpie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scr {
            #[inline(always)]
            fn default() -> Scr {
                Scr(0)
            }
        }
        impl core::fmt::Debug for Scr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scr {{ cke: {:?}, teie: {:?}, mpie: {:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Control Register (SCMR.SMIF =1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ScrSmci(pub u8);
        impl ScrSmci {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrSmciCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrSmciCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrSmciCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "This bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub const fn teie(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub fn set_teie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub const fn mpie(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrSmciRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrSmciRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrSmciRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrSmciTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrSmciTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrSmciTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrSmciRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrSmciRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrSmciRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrSmciTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrSmciTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrSmciTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for ScrSmci {
            #[inline(always)]
            fn default() -> ScrSmci {
                ScrSmci(0)
            }
        }
        impl core::fmt::Debug for ScrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ScrSmci")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ScrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ScrSmci {{ cke: {:?}, teie: {=bool:?}, mpie: {=bool:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Extended Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Semr(pub u8);
        impl Semr {
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_0_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_0_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub const fn brme(&self) -> super::vals::Brme {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Brme::from_bits(val as u8)
            }
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub fn set_brme(&mut self, val: super::vals::Brme) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select1(Valid only in asynchronous mode and SCR.CKE\\[1\\]=0)"]
            #[inline(always)]
            pub const fn abcse(&self) -> super::vals::Abcse {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Abcse::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select1(Valid only in asynchronous mode and SCR.CKE\\[1\\]=0)"]
            #[inline(always)]
            pub fn set_abcse(&mut self, val: super::vals::Abcse) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Asynchronous Mode Base Clock Select(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn abcs(&self) -> super::vals::Abcs {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Abcs::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Base Clock Select(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_abcs(&mut self, val: super::vals::Abcs) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Digital Noise Filter Function Enable(The NFEN bit should be 0 without simple I2C mode and asynchronous mode.)In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input."]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::Nfen {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Nfen::from_bits(val as u8)
            }
            #[doc = "Digital Noise Filter Function Enable(The NFEN bit should be 0 without simple I2C mode and asynchronous mode.)In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input."]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::Nfen) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select(Only valid the CKE\\[1\\] bit in SCR is 0 in asynchronous mode)."]
            #[inline(always)]
            pub const fn bgdm(&self) -> super::vals::Bgdm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Bgdm::from_bits(val as u8)
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select(Only valid the CKE\\[1\\] bit in SCR is 0 in asynchronous mode)."]
            #[inline(always)]
            pub fn set_bgdm(&mut self, val: super::vals::Bgdm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn rxdesel(&self) -> super::vals::Rxdesel {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rxdesel::from_bits(val as u8)
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_rxdesel(&mut self, val: super::vals::Rxdesel) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Semr {
            #[inline(always)]
            fn default() -> Semr {
                Semr(0)
            }
        }
        impl core::fmt::Debug for Semr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Semr")
                    .field("reserved_0_1", &self.reserved_0_1())
                    .field("brme", &self.brme())
                    .field("abcse", &self.abcse())
                    .field("abcs", &self.abcs())
                    .field("nfen", &self.nfen())
                    .field("bgdm", &self.bgdm())
                    .field("rxdesel", &self.rxdesel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Semr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Semr {{ reserved_0_1: {=u8:?}, brme: {:?}, abcse: {:?}, abcs: {:?}, nfen: {:?}, bgdm: {:?}, rxdesel: {:?} }}" , self . reserved_0_1 () , self . brme () , self . abcse () , self . abcs () , self . nfen () , self . bgdm () , self . rxdesel ())
            }
        }
        #[doc = "I2C Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr1(pub u8);
        impl Simr1 {
            #[doc = "Simple I2C Mode Select"]
            #[inline(always)]
            pub const fn iicm(&self) -> super::vals::Iicm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicm::from_bits(val as u8)
            }
            #[doc = "Simple I2C Mode Select"]
            #[inline(always)]
            pub fn set_iicm(&mut self, val: super::vals::Iicm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_1_2(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_1_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u8) & 0x03) << 1usize);
            }
            #[doc = "SSDA Delay Output SelectCycles below are of the clock signal from the on,chip baud rate generator."]
            #[inline(always)]
            pub const fn iicdl(&self) -> super::vals::Iicdl {
                let val = (self.0 >> 3usize) & 0x1f;
                super::vals::Iicdl::from_bits(val as u8)
            }
            #[doc = "SSDA Delay Output SelectCycles below are of the clock signal from the on,chip baud rate generator."]
            #[inline(always)]
            pub fn set_iicdl(&mut self, val: super::vals::Iicdl) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val.to_bits() as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Simr1 {
            #[inline(always)]
            fn default() -> Simr1 {
                Simr1(0)
            }
        }
        impl core::fmt::Debug for Simr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr1")
                    .field("iicm", &self.iicm())
                    .field("reserved_1_2", &self.reserved_1_2())
                    .field("iicdl", &self.iicdl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Simr1 {{ iicm: {:?}, reserved_1_2: {=u8:?}, iicdl: {:?} }}",
                    self.iicm(),
                    self.reserved_1_2(),
                    self.iicdl()
                )
            }
        }
        #[doc = "I2C Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr2(pub u8);
        impl Simr2 {
            #[doc = "I2C Interrupt Mode Select"]
            #[inline(always)]
            pub const fn iicintm(&self) -> super::vals::Iicintm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicintm::from_bits(val as u8)
            }
            #[doc = "I2C Interrupt Mode Select"]
            #[inline(always)]
            pub fn set_iicintm(&mut self, val: super::vals::Iicintm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub const fn iiccsc(&self) -> super::vals::Iiccsc {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iiccsc::from_bits(val as u8)
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub fn set_iiccsc(&mut self, val: super::vals::Iiccsc) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_2_4(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_2_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val as u8) & 0x07) << 2usize);
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub const fn iicackt(&self) -> super::vals::Iicackt {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Iicackt::from_bits(val as u8)
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub fn set_iicackt(&mut self, val: super::vals::Iicackt) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Simr2 {
            #[inline(always)]
            fn default() -> Simr2 {
                Simr2(0)
            }
        }
        impl core::fmt::Debug for Simr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr2")
                    .field("iicintm", &self.iicintm())
                    .field("iiccsc", &self.iiccsc())
                    .field("reserved_2_4", &self.reserved_2_4())
                    .field("iicackt", &self.iicackt())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Simr2 {{ iicintm: {:?}, iiccsc: {:?}, reserved_2_4: {=u8:?}, iicackt: {:?}, reserved_6_7: {=u8:?} }}" , self . iicintm () , self . iiccsc () , self . reserved_2_4 () , self . iicackt () , self . reserved_6_7 ())
            }
        }
        #[doc = "IIC Mode Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr3(pub u8);
        impl Simr3 {
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub const fn iicstareq(&self) -> super::vals::Iicstareq {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicstareq::from_bits(val as u8)
            }
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub fn set_iicstareq(&mut self, val: super::vals::Iicstareq) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub const fn iicrstareq(&self) -> super::vals::Iicrstareq {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iicrstareq::from_bits(val as u8)
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub fn set_iicrstareq(&mut self, val: super::vals::Iicrstareq) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub const fn iicstpreq(&self) -> super::vals::Iicstpreq {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Iicstpreq::from_bits(val as u8)
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub fn set_iicstpreq(&mut self, val: super::vals::Iicstpreq) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag(When 0 is written to IICSTIF, it is cleared to 0.)"]
            #[inline(always)]
            pub const fn iicstif(&self) -> super::vals::Iicstif {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Iicstif::from_bits(val as u8)
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag(When 0 is written to IICSTIF, it is cleared to 0.)"]
            #[inline(always)]
            pub fn set_iicstif(&mut self, val: super::vals::Iicstif) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SDA Output Select"]
            #[inline(always)]
            pub const fn iicsdas(&self) -> super::vals::Iicsdas {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Iicsdas::from_bits(val as u8)
            }
            #[doc = "SDA Output Select"]
            #[inline(always)]
            pub fn set_iicsdas(&mut self, val: super::vals::Iicsdas) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "SCL Output Select"]
            #[inline(always)]
            pub const fn iicscls(&self) -> super::vals::Iicscls {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Iicscls::from_bits(val as u8)
            }
            #[doc = "SCL Output Select"]
            #[inline(always)]
            pub fn set_iicscls(&mut self, val: super::vals::Iicscls) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Simr3 {
            #[inline(always)]
            fn default() -> Simr3 {
                Simr3(0)
            }
        }
        impl core::fmt::Debug for Simr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr3")
                    .field("iicstareq", &self.iicstareq())
                    .field("iicrstareq", &self.iicrstareq())
                    .field("iicstpreq", &self.iicstpreq())
                    .field("iicstif", &self.iicstif())
                    .field("iicsdas", &self.iicsdas())
                    .field("iicscls", &self.iicscls())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Simr3 {{ iicstareq: {:?}, iicrstareq: {:?}, iicstpreq: {:?}, iicstif: {:?}, iicsdas: {:?}, iicscls: {:?} }}" , self . iicstareq () , self . iicrstareq () , self . iicstpreq () , self . iicstif () , self . iicsdas () , self . iicscls ())
            }
        }
        #[doc = "IIC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sisr(pub u8);
        impl Sisr {
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub const fn iicackr(&self) -> super::vals::Iicackr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicackr::from_bits(val as u8)
            }
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub fn set_iicackr(&mut self, val: super::vals::Iicackr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_2_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_2_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_4_5(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_4_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Sisr {
            #[inline(always)]
            fn default() -> Sisr {
                Sisr(0)
            }
        }
        impl core::fmt::Debug for Sisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sisr")
                    .field("iicackr", &self.iicackr())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("reserved_2_2", &self.reserved_2_2())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("reserved_4_5", &self.reserved_4_5())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sisr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sisr {{ iicackr: {:?}, reserved_1_1: {=bool:?}, reserved_2_2: {=bool:?}, reserved_3_3: {=bool:?}, reserved_4_5: {=u8:?}, reserved_6_7: {=u8:?} }}" , self . iicackr () , self . reserved_1_1 () , self . reserved_2_2 () , self . reserved_3_3 () , self . reserved_4_5 () , self . reserved_6_7 ())
            }
        }
        #[doc = "Serial Mode Register (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr(pub u8);
        impl Smr {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Multi,Processor Mode(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn mp(&self) -> super::vals::Mp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mp::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Mode(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_mp(&mut self, val: super::vals::Mp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Bit Length(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::Stop {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Stop::from_bits(val as u8)
            }
            #[doc = "Stop Bit Length(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: super::vals::Stop) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Parity Mode (Valid only when the PE bit is 1)"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode (Valid only when the PE bit is 1)"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn pe(&self) -> super::vals::SmrPe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SmrPe::from_bits(val as u8)
            }
            #[doc = "Parity Enable(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: super::vals::SmrPe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Character Length(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn chr(&self) -> super::vals::Chr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Chr::from_bits(val as u8)
            }
            #[doc = "Character Length(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_chr(&mut self, val: super::vals::Chr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Communications Mode"]
            #[inline(always)]
            pub const fn cm(&self) -> super::vals::Cm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cm::from_bits(val as u8)
            }
            #[doc = "Communications Mode"]
            #[inline(always)]
            pub fn set_cm(&mut self, val: super::vals::Cm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Smr {
            #[inline(always)]
            fn default() -> Smr {
                Smr(0)
            }
        }
        impl core::fmt::Debug for Smr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr")
                    .field("cks", &self.cks())
                    .field("mp", &self.mp())
                    .field("stop", &self.stop())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("chr", &self.chr())
                    .field("cm", &self.cm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smr {{ cks: {:?}, mp: {:?}, stop: {:?}, pm: {:?}, pe: {:?}, chr: {:?}, cm: {:?} }}" , self . cks () , self . mp () , self . stop () , self . pm () , self . pe () , self . chr () , self . cm ())
            }
        }
        #[doc = "Serial mode register (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SmrSmci(pub u8);
        impl SmrSmci {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrSmciCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrSmciCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrSmciCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub const fn bcp(&self) -> super::vals::Bcp {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Bcp::from_bits(val as u8)
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub fn set_bcp(&mut self, val: super::vals::Bcp) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u8) & 0x03) << 2usize);
            }
            #[doc = "Parity Mode (Valid only when the PE bit is 1)"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrSmciPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrSmciPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode (Valid only when the PE bit is 1)"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrSmciPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn pe(&self) -> super::vals::SmrSmciPe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SmrSmciPe::from_bits(val as u8)
            }
            #[doc = "Parity Enable(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: super::vals::SmrSmciPe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub const fn blk(&self) -> super::vals::Blk {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Blk::from_bits(val as u8)
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub fn set_blk(&mut self, val: super::vals::Blk) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub const fn gm(&self) -> super::vals::Gm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Gm::from_bits(val as u8)
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub fn set_gm(&mut self, val: super::vals::Gm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SmrSmci {
            #[inline(always)]
            fn default() -> SmrSmci {
                SmrSmci(0)
            }
        }
        impl core::fmt::Debug for SmrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SmrSmci")
                    .field("cks", &self.cks())
                    .field("bcp", &self.bcp())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("blk", &self.blk())
                    .field("gm", &self.gm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SmrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SmrSmci {{ cks: {:?}, bcp: {:?}, pm: {:?}, pe: {:?}, blk: {:?}, gm: {:?} }}",
                    self.cks(),
                    self.bcp(),
                    self.pm(),
                    self.pe(),
                    self.blk(),
                    self.gm()
                )
            }
        }
        #[doc = "Noise Filter Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snfr(pub u8);
        impl Snfr {
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::Nfcs {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Nfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::Nfcs) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Snfr {
            #[inline(always)]
            fn default() -> Snfr {
                Snfr(0)
            }
        }
        impl core::fmt::Debug for Snfr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snfr")
                    .field("nfcs", &self.nfcs())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snfr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Snfr {{ nfcs: {:?}, reserved_3_7: {=u8:?} }}",
                    self.nfcs(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "SPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spmr(pub u8);
        impl Spmr {
            #[doc = "SSn# Pin Function Enable"]
            #[inline(always)]
            pub const fn sse(&self) -> super::vals::Sse {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sse::from_bits(val as u8)
            }
            #[doc = "SSn# Pin Function Enable"]
            #[inline(always)]
            pub fn set_sse(&mut self, val: super::vals::Sse) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub const fn ctse(&self) -> super::vals::Ctse {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ctse::from_bits(val as u8)
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub fn set_ctse(&mut self, val: super::vals::Ctse) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub const fn mss(&self) -> super::vals::Mss {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mss::from_bits(val as u8)
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub fn set_mss(&mut self, val: super::vals::Mss) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub const fn mff(&self) -> super::vals::Mff {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mff::from_bits(val as u8)
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub fn set_mff(&mut self, val: super::vals::Mff) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub const fn ckpol(&self) -> super::vals::Ckpol {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ckpol::from_bits(val as u8)
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub fn set_ckpol(&mut self, val: super::vals::Ckpol) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub const fn ckph(&self) -> super::vals::Ckph {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ckph::from_bits(val as u8)
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub fn set_ckph(&mut self, val: super::vals::Ckph) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spmr {
            #[inline(always)]
            fn default() -> Spmr {
                Spmr(0)
            }
        }
        impl core::fmt::Debug for Spmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spmr")
                    .field("sse", &self.sse())
                    .field("ctse", &self.ctse())
                    .field("mss", &self.mss())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("mff", &self.mff())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ckpol", &self.ckpol())
                    .field("ckph", &self.ckph())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spmr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spmr {{ sse: {:?}, ctse: {:?}, mss: {:?}, reserved_3_3: {=bool:?}, mff: {:?}, reserved_5_5: {=bool:?}, ckpol: {:?}, ckph: {:?} }}" , self . sse () , self . ctse () , self . mss () , self . reserved_3_3 () , self . mff () , self . reserved_5_5 () , self . ckpol () , self . ckph ())
            }
        }
        #[doc = "Serial Port Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sptr(pub u8);
        impl Sptr {
            #[doc = "Serial input data monitor bit(The state of the RXD terminal is shown.)"]
            #[inline(always)]
            pub const fn rxdmon(&self) -> super::vals::Rxdmon {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rxdmon::from_bits(val as u8)
            }
            #[doc = "Serial input data monitor bit(The state of the RXD terminal is shown.)"]
            #[inline(always)]
            pub fn set_rxdmon(&mut self, val: super::vals::Rxdmon) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Serial port break data select bit(The output level of TxD terminal is selected when SCR.TE = 0.)"]
            #[inline(always)]
            pub const fn spb2dt(&self) -> super::vals::Spb2dt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spb2dt::from_bits(val as u8)
            }
            #[doc = "Serial port break data select bit(The output level of TxD terminal is selected when SCR.TE = 0.)"]
            #[inline(always)]
            pub fn set_spb2dt(&mut self, val: super::vals::Spb2dt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Serial port break I/O bit(It's selected whether the value of SPB2DT is output to TxD terminal.)"]
            #[inline(always)]
            pub const fn spb2io(&self) -> super::vals::Spb2io {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Spb2io::from_bits(val as u8)
            }
            #[doc = "Serial port break I/O bit(It's selected whether the value of SPB2DT is output to TxD terminal.)"]
            #[inline(always)]
            pub fn set_spb2io(&mut self, val: super::vals::Spb2io) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Sptr {
            #[inline(always)]
            fn default() -> Sptr {
                Sptr(0)
            }
        }
        impl core::fmt::Debug for Sptr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sptr")
                    .field("rxdmon", &self.rxdmon())
                    .field("spb2dt", &self.spb2dt())
                    .field("spb2io", &self.spb2io())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sptr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sptr {{ rxdmon: {:?}, spb2dt: {:?}, spb2io: {:?}, reserved_3_7: {=u8:?} }}",
                    self.rxdmon(),
                    self.spb2dt(),
                    self.spb2io(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr(pub u8);
        impl Ssr {
            #[doc = "Multi,Processor Bit Transfer. Sets the multi,processor bit for adding to the transmission frame"]
            #[inline(always)]
            pub const fn mpbt(&self) -> super::vals::SsrMpbt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SsrMpbt::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Bit Transfer. Sets the multi,processor bit for adding to the transmission frame"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: super::vals::SsrMpbt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor Bit. Value of the multi,processor bit in the reception frame"]
            #[inline(always)]
            pub const fn mpb(&self) -> super::vals::SsrMpb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::SsrMpb::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Bit. Value of the multi,processor bit in the reception frame"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: super::vals::SsrMpb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::SsrFer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SsrFer::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::SsrFer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ssr {
            #[inline(always)]
            fn default() -> Ssr {
                Ssr(0)
            }
        }
        impl core::fmt::Debug for Ssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ssr {{ mpbt: {:?}, mpb: {:?}, tend: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . fer () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 0 and FCR.FM=1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SsrFifo(pub u8);
        impl SsrFifo {
            #[doc = "Receive Data Ready flag(Valid only in asynchronous mode(including multi,processor) and FIFO selected)"]
            #[inline(always)]
            pub const fn dr(&self) -> super::vals::SsrFifoDr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SsrFifoDr::from_bits(val as u8)
            }
            #[doc = "Receive Data Ready flag(Valid only in asynchronous mode(including multi,processor) and FIFO selected)"]
            #[inline(always)]
            pub fn set_dr(&mut self, val: super::vals::SsrFifoDr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrFifoTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrFifoTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrFifoTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrFifoPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrFifoPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrFifoPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::SsrFifoFer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SsrFifoFer::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::SsrFifoFer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrFifoOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrFifoOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrFifoOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive FIFO data full flag"]
            #[inline(always)]
            pub const fn rdf(&self) -> super::vals::SsrFifoRdf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrFifoRdf::from_bits(val as u8)
            }
            #[doc = "Receive FIFO data full flag"]
            #[inline(always)]
            pub fn set_rdf(&mut self, val: super::vals::SsrFifoRdf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO data empty flag"]
            #[inline(always)]
            pub const fn tdfe(&self) -> super::vals::Tdfe {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tdfe::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO data empty flag"]
            #[inline(always)]
            pub fn set_tdfe(&mut self, val: super::vals::Tdfe) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SsrFifo {
            #[inline(always)]
            fn default() -> SsrFifo {
                SsrFifo(0)
            }
        }
        impl core::fmt::Debug for SsrFifo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SsrFifo")
                    .field("dr", &self.dr())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdf", &self.rdf())
                    .field("tdfe", &self.tdfe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SsrFifo {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SsrFifo {{ dr: {:?}, reserved_1_1: {=bool:?}, tend: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdf: {:?}, tdfe: {:?} }}" , self . dr () , self . reserved_1_1 () , self . tend () , self . per () , self . fer () , self . orer () , self . rdf () , self . tdfe ())
            }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SsrSmci(pub u8);
        impl SsrSmci {
            #[doc = "Multi,Processor Bit TransferThis bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub const fn mpbt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor Bit TransferThis bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,ProcessorThis bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub const fn mpb(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,ProcessorThis bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrSmciTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrSmciTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrSmciTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrSmciPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrSmciPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrSmciPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub const fn ers(&self) -> super::vals::Ers {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ers::from_bits(val as u8)
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub fn set_ers(&mut self, val: super::vals::Ers) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrSmciOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrSmciOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrSmciOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrSmciRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrSmciRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrSmciRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrSmciTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrSmciTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrSmciTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SsrSmci {
            #[inline(always)]
            fn default() -> SsrSmci {
                SsrSmci(0)
            }
        }
        impl core::fmt::Debug for SsrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SsrSmci")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("ers", &self.ers())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SsrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SsrSmci {{ mpbt: {=bool:?}, mpb: {=bool:?}, tend: {:?}, per: {:?}, ers: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . ers () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Transmit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tdr(pub u8);
        impl Tdr {
            #[doc = "TDR is an 8-bit register that stores transmit data."]
            #[inline(always)]
            pub const fn tdr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "TDR is an 8-bit register that stores transmit data."]
            #[inline(always)]
            pub fn set_tdr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Tdr {
            #[inline(always)]
            fn default() -> Tdr {
                Tdr(0)
            }
        }
        impl core::fmt::Debug for Tdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tdr").field("tdr", &self.tdr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tdr {{ tdr: {=u8:?} }}", self.tdr())
            }
        }
        #[doc = "Transmit 9-bit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tdrhl(pub u16);
        impl Tdrhl {
            #[doc = "TDRHL is a 16-bit register that stores transmit data."]
            #[inline(always)]
            pub const fn tdrhl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "TDRHL is a 16-bit register that stores transmit data."]
            #[inline(always)]
            pub fn set_tdrhl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Tdrhl {
            #[inline(always)]
            fn default() -> Tdrhl {
                Tdrhl(0)
            }
        }
        impl core::fmt::Debug for Tdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tdrhl")
                    .field("tdrhl", &self.tdrhl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tdrhl {{ tdrhl: {=u16:?} }}", self.tdrhl())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcs {
            #[inline(always)]
            fn from(val: u8) -> Abcs {
                Abcs::from_bits(val)
            }
        }
        impl From<Abcs> for u8 {
            #[inline(always)]
            fn from(val: Abcs) -> u8 {
                Abcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcse {
            #[inline(always)]
            fn from(val: u8) -> Abcse {
                Abcse::from_bits(val)
            }
        }
        impl From<Abcse> for u8 {
            #[inline(always)]
            fn from(val: Abcse) -> u8 {
                Abcse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Bcp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcp {
            #[inline(always)]
            fn from(val: u8) -> Bcp {
                Bcp::from_bits(val)
            }
        }
        impl From<Bcp> for u8 {
            #[inline(always)]
            fn from(val: Bcp) -> u8 {
                Bcp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcp2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bcp2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcp2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcp2 {
            #[inline(always)]
            fn from(val: u8) -> Bcp2 {
                Bcp2::from_bits(val)
            }
        }
        impl From<Bcp2> for u8 {
            #[inline(always)]
            fn from(val: Bcp2) -> u8 {
                Bcp2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bgdm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bgdm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bgdm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bgdm {
            #[inline(always)]
            fn from(val: u8) -> Bgdm {
                Bgdm::from_bits(val)
            }
        }
        impl From<Bgdm> for u8 {
            #[inline(always)]
            fn from(val: Bgdm) -> u8 {
                Bgdm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Blk {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Blk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Blk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Blk {
            #[inline(always)]
            fn from(val: u8) -> Blk {
                Blk::from_bits(val)
            }
        }
        impl From<Blk> for u8 {
            #[inline(always)]
            fn from(val: Blk) -> u8 {
                Blk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Brme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brme {
            #[inline(always)]
            fn from(val: u8) -> Brme {
                Brme::from_bits(val)
            }
        }
        impl From<Brme> for u8 {
            #[inline(always)]
            fn from(val: Brme) -> u8 {
                Brme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr {
            #[inline(always)]
            fn from(val: u8) -> Chr {
                Chr::from_bits(val)
            }
        }
        impl From<Chr> for u8 {
            #[inline(always)]
            fn from(val: Chr) -> u8 {
                Chr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr1 {
            #[inline(always)]
            fn from(val: u8) -> Chr1 {
                Chr1::from_bits(val)
            }
        }
        impl From<Chr1> for u8 {
            #[inline(always)]
            fn from(val: Chr1) -> u8 {
                Chr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckph {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckph {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckph {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckph {
            #[inline(always)]
            fn from(val: u8) -> Ckph {
                Ckph::from_bits(val)
            }
        }
        impl From<Ckph> for u8 {
            #[inline(always)]
            fn from(val: Ckph) -> u8 {
                Ckph::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckpol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckpol {
            #[inline(always)]
            fn from(val: u8) -> Ckpol {
                Ckpol::from_bits(val)
            }
        }
        impl From<Ckpol> for u8 {
            #[inline(always)]
            fn from(val: Ckpol) -> u8 {
                Ckpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cm {
            #[inline(always)]
            fn from(val: u8) -> Cm {
                Cm::from_bits(val)
            }
        }
        impl From<Cm> for u8 {
            #[inline(always)]
            fn from(val: Cm) -> u8 {
                Cm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctse {
            #[inline(always)]
            fn from(val: u8) -> Ctse {
                Ctse::from_bits(val)
            }
        }
        impl From<Ctse> for u8 {
            #[inline(always)]
            fn from(val: Ctse) -> u8 {
                Ctse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcme {
            #[inline(always)]
            fn from(val: u8) -> Dcme {
                Dcme::from_bits(val)
            }
        }
        impl From<Dcme> for u8 {
            #[inline(always)]
            fn from(val: Dcme) -> u8 {
                Dcme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcmf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcmf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcmf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcmf {
            #[inline(always)]
            fn from(val: u8) -> Dcmf {
                Dcmf::from_bits(val)
            }
        }
        impl From<Dcmf> for u8 {
            #[inline(always)]
            fn from(val: Dcmf) -> u8 {
                Dcmf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dfer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfer {
            #[inline(always)]
            fn from(val: u8) -> Dfer {
                Dfer::from_bits(val)
            }
        }
        impl From<Dfer> for u8 {
            #[inline(always)]
            fn from(val: Dfer) -> u8 {
                Dfer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dper {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dper {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dper {
            #[inline(always)]
            fn from(val: u8) -> Dper {
                Dper::from_bits(val)
            }
        }
        impl From<Dper> for u8 {
            #[inline(always)]
            fn from(val: Dper) -> u8 {
                Dper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dres {
            #[inline(always)]
            fn from(val: u8) -> Dres {
                Dres::from_bits(val)
            }
        }
        impl From<Dres> for u8 {
            #[inline(always)]
            fn from(val: Dres) -> u8 {
                Dres::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ers {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ers {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ers {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ers {
            #[inline(always)]
            fn from(val: u8) -> Ers {
                Ers::from_bits(val)
            }
        }
        impl From<Ers> for u8 {
            #[inline(always)]
            fn from(val: Ers) -> u8 {
                Ers::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fm {
            #[inline(always)]
            fn from(val: u8) -> Fm {
                Fm::from_bits(val)
            }
        }
        impl From<Fm> for u8 {
            #[inline(always)]
            fn from(val: Fm) -> u8 {
                Fm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhDr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhDr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhDr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhDr {
            #[inline(always)]
            fn from(val: u8) -> FrdrhDr {
                FrdrhDr::from_bits(val)
            }
        }
        impl From<FrdrhDr> for u8 {
            #[inline(always)]
            fn from(val: FrdrhDr) -> u8 {
                FrdrhDr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhFer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhFer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhFer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhFer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhFer {
                FrdrhFer::from_bits(val)
            }
        }
        impl From<FrdrhFer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhFer) -> u8 {
                FrdrhFer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhMpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhMpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhMpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhMpb {
            #[inline(always)]
            fn from(val: u8) -> FrdrhMpb {
                FrdrhMpb::from_bits(val)
            }
        }
        impl From<FrdrhMpb> for u8 {
            #[inline(always)]
            fn from(val: FrdrhMpb) -> u8 {
                FrdrhMpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhOrer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhOrer {
                FrdrhOrer::from_bits(val)
            }
        }
        impl From<FrdrhOrer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhOrer) -> u8 {
                FrdrhOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhPer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhPer {
                FrdrhPer::from_bits(val)
            }
        }
        impl From<FrdrhPer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhPer) -> u8 {
                FrdrhPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhRdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhRdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhRdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhRdf {
            #[inline(always)]
            fn from(val: u8) -> FrdrhRdf {
                FrdrhRdf::from_bits(val)
            }
        }
        impl From<FrdrhRdf> for u8 {
            #[inline(always)]
            fn from(val: FrdrhRdf) -> u8 {
                FrdrhRdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlDr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlDr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlDr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlDr {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlDr {
                FrdrhlDr::from_bits(val)
            }
        }
        impl From<FrdrhlDr> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlDr) -> u8 {
                FrdrhlDr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlFer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlFer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlFer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlFer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlFer {
                FrdrhlFer::from_bits(val)
            }
        }
        impl From<FrdrhlFer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlFer) -> u8 {
                FrdrhlFer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlMpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlMpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlMpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlMpb {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlMpb {
                FrdrhlMpb::from_bits(val)
            }
        }
        impl From<FrdrhlMpb> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlMpb) -> u8 {
                FrdrhlMpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlOrer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlOrer {
                FrdrhlOrer::from_bits(val)
            }
        }
        impl From<FrdrhlOrer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlOrer) -> u8 {
                FrdrhlOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlPer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlPer {
                FrdrhlPer::from_bits(val)
            }
        }
        impl From<FrdrhlPer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlPer) -> u8 {
                FrdrhlPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlRdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlRdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlRdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlRdf {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlRdf {
                FrdrhlRdf::from_bits(val)
            }
        }
        impl From<FrdrhlRdf> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlRdf) -> u8 {
                FrdrhlRdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FtdrhMpbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FtdrhMpbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FtdrhMpbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FtdrhMpbt {
            #[inline(always)]
            fn from(val: u8) -> FtdrhMpbt {
                FtdrhMpbt::from_bits(val)
            }
        }
        impl From<FtdrhMpbt> for u8 {
            #[inline(always)]
            fn from(val: FtdrhMpbt) -> u8 {
                FtdrhMpbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FtdrhlMpbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FtdrhlMpbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FtdrhlMpbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FtdrhlMpbt {
            #[inline(always)]
            fn from(val: u8) -> FtdrhlMpbt {
                FtdrhlMpbt::from_bits(val)
            }
        }
        impl From<FtdrhlMpbt> for u8 {
            #[inline(always)]
            fn from(val: FtdrhlMpbt) -> u8 {
                FtdrhlMpbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gm {
            #[inline(always)]
            fn from(val: u8) -> Gm {
                Gm::from_bits(val)
            }
        }
        impl From<Gm> for u8 {
            #[inline(always)]
            fn from(val: Gm) -> u8 {
                Gm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idsel {
            #[inline(always)]
            fn from(val: u8) -> Idsel {
                Idsel::from_bits(val)
            }
        }
        impl From<Idsel> for u8 {
            #[inline(always)]
            fn from(val: Idsel) -> u8 {
                Idsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackr {
            #[inline(always)]
            fn from(val: u8) -> Iicackr {
                Iicackr::from_bits(val)
            }
        }
        impl From<Iicackr> for u8 {
            #[inline(always)]
            fn from(val: Iicackr) -> u8 {
                Iicackr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackt {
            #[inline(always)]
            fn from(val: u8) -> Iicackt {
                Iicackt::from_bits(val)
            }
        }
        impl From<Iicackt> for u8 {
            #[inline(always)]
            fn from(val: Iicackt) -> u8 {
                Iicackt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iiccsc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iiccsc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iiccsc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iiccsc {
            #[inline(always)]
            fn from(val: u8) -> Iiccsc {
                Iiccsc::from_bits(val)
            }
        }
        impl From<Iiccsc> for u8 {
            #[inline(always)]
            fn from(val: Iiccsc) -> u8 {
                Iiccsc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicdl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Iicdl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicdl {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicdl {
            #[inline(always)]
            fn from(val: u8) -> Iicdl {
                Iicdl::from_bits(val)
            }
        }
        impl From<Iicdl> for u8 {
            #[inline(always)]
            fn from(val: Iicdl) -> u8 {
                Iicdl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicintm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicintm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicintm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicintm {
            #[inline(always)]
            fn from(val: u8) -> Iicintm {
                Iicintm::from_bits(val)
            }
        }
        impl From<Iicintm> for u8 {
            #[inline(always)]
            fn from(val: Iicintm) -> u8 {
                Iicintm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicm {
            #[inline(always)]
            fn from(val: u8) -> Iicm {
                Iicm::from_bits(val)
            }
        }
        impl From<Iicm> for u8 {
            #[inline(always)]
            fn from(val: Iicm) -> u8 {
                Iicm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicrstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicrstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicrstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicrstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicrstareq {
                Iicrstareq::from_bits(val)
            }
        }
        impl From<Iicrstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicrstareq) -> u8 {
                Iicrstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicscls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicscls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicscls {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicscls {
            #[inline(always)]
            fn from(val: u8) -> Iicscls {
                Iicscls::from_bits(val)
            }
        }
        impl From<Iicscls> for u8 {
            #[inline(always)]
            fn from(val: Iicscls) -> u8 {
                Iicscls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicsdas {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicsdas {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicsdas {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicsdas {
            #[inline(always)]
            fn from(val: u8) -> Iicsdas {
                Iicsdas::from_bits(val)
            }
        }
        impl From<Iicsdas> for u8 {
            #[inline(always)]
            fn from(val: Iicsdas) -> u8 {
                Iicsdas::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicstareq {
                Iicstareq::from_bits(val)
            }
        }
        impl From<Iicstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicstareq) -> u8 {
                Iicstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstif {
            #[inline(always)]
            fn from(val: u8) -> Iicstif {
                Iicstif::from_bits(val)
            }
        }
        impl From<Iicstif> for u8 {
            #[inline(always)]
            fn from(val: Iicstif) -> u8 {
                Iicstif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstpreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstpreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstpreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstpreq {
            #[inline(always)]
            fn from(val: u8) -> Iicstpreq {
                Iicstpreq::from_bits(val)
            }
        }
        impl From<Iicstpreq> for u8 {
            #[inline(always)]
            fn from(val: Iicstpreq) -> u8 {
                Iicstpreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LsrOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl LsrOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> LsrOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for LsrOrer {
            #[inline(always)]
            fn from(val: u8) -> LsrOrer {
                LsrOrer::from_bits(val)
            }
        }
        impl From<LsrOrer> for u8 {
            #[inline(always)]
            fn from(val: LsrOrer) -> u8 {
                LsrOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mff {
            #[inline(always)]
            fn from(val: u8) -> Mff {
                Mff::from_bits(val)
            }
        }
        impl From<Mff> for u8 {
            #[inline(always)]
            fn from(val: Mff) -> u8 {
                Mff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mp {
            #[inline(always)]
            fn from(val: u8) -> Mp {
                Mp::from_bits(val)
            }
        }
        impl From<Mp> for u8 {
            #[inline(always)]
            fn from(val: Mp) -> u8 {
                Mp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpie {
            #[inline(always)]
            fn from(val: u8) -> Mpie {
                Mpie::from_bits(val)
            }
        }
        impl From<Mpie> for u8 {
            #[inline(always)]
            fn from(val: Mpie) -> u8 {
                Mpie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mss {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mss {
            #[inline(always)]
            fn from(val: u8) -> Mss {
                Mss::from_bits(val)
            }
        }
        impl From<Mss> for u8 {
            #[inline(always)]
            fn from(val: Mss) -> u8 {
                Mss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Nfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcs {
            #[inline(always)]
            fn from(val: u8) -> Nfcs {
                Nfcs::from_bits(val)
            }
        }
        impl From<Nfcs> for u8 {
            #[inline(always)]
            fn from(val: Nfcs) -> u8 {
                Nfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfen {
            #[inline(always)]
            fn from(val: u8) -> Nfen {
                Nfen::from_bits(val)
            }
        }
        impl From<Nfen> for u8 {
            #[inline(always)]
            fn from(val: Nfen) -> u8 {
                Nfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rfrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rfrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rfrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rfrst {
            #[inline(always)]
            fn from(val: u8) -> Rfrst {
                Rfrst::from_bits(val)
            }
        }
        impl From<Rfrst> for u8 {
            #[inline(always)]
            fn from(val: Rfrst) -> u8 {
                Rfrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdesel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdesel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdesel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdesel {
            #[inline(always)]
            fn from(val: u8) -> Rxdesel {
                Rxdesel::from_bits(val)
            }
        }
        impl From<Rxdesel> for u8 {
            #[inline(always)]
            fn from(val: Rxdesel) -> u8 {
                Rxdesel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdmon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdmon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdmon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdmon {
            #[inline(always)]
            fn from(val: u8) -> Rxdmon {
                Rxdmon::from_bits(val)
            }
        }
        impl From<Rxdmon> for u8 {
            #[inline(always)]
            fn from(val: Rxdmon) -> u8 {
                Rxdmon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrCke {
            #[inline(always)]
            fn from(val: u8) -> ScrCke {
                ScrCke::from_bits(val)
            }
        }
        impl From<ScrCke> for u8 {
            #[inline(always)]
            fn from(val: ScrCke) -> u8 {
                ScrCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRe {
            #[inline(always)]
            fn from(val: u8) -> ScrRe {
                ScrRe::from_bits(val)
            }
        }
        impl From<ScrRe> for u8 {
            #[inline(always)]
            fn from(val: ScrRe) -> u8 {
                ScrRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRie {
            #[inline(always)]
            fn from(val: u8) -> ScrRie {
                ScrRie::from_bits(val)
            }
        }
        impl From<ScrRie> for u8 {
            #[inline(always)]
            fn from(val: ScrRie) -> u8 {
                ScrRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrSmciCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciCke {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciCke {
                ScrSmciCke::from_bits(val)
            }
        }
        impl From<ScrSmciCke> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciCke) -> u8 {
                ScrSmciCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRe {
                ScrSmciRe::from_bits(val)
            }
        }
        impl From<ScrSmciRe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRe) -> u8 {
                ScrSmciRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRie {
                ScrSmciRie::from_bits(val)
            }
        }
        impl From<ScrSmciRie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRie) -> u8 {
                ScrSmciRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTe {
                ScrSmciTe::from_bits(val)
            }
        }
        impl From<ScrSmciTe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTe) -> u8 {
                ScrSmciTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTie {
                ScrSmciTie::from_bits(val)
            }
        }
        impl From<ScrSmciTie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTie) -> u8 {
                ScrSmciTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTe {
            #[inline(always)]
            fn from(val: u8) -> ScrTe {
                ScrTe::from_bits(val)
            }
        }
        impl From<ScrTe> for u8 {
            #[inline(always)]
            fn from(val: ScrTe) -> u8 {
                ScrTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTie {
            #[inline(always)]
            fn from(val: u8) -> ScrTie {
                ScrTie::from_bits(val)
            }
        }
        impl From<ScrTie> for u8 {
            #[inline(always)]
            fn from(val: ScrTie) -> u8 {
                ScrTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdir {
            #[inline(always)]
            fn from(val: u8) -> Sdir {
                Sdir::from_bits(val)
            }
        }
        impl From<Sdir> for u8 {
            #[inline(always)]
            fn from(val: Sdir) -> u8 {
                Sdir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sinv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sinv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sinv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sinv {
            #[inline(always)]
            fn from(val: u8) -> Sinv {
                Sinv::from_bits(val)
            }
        }
        impl From<Sinv> for u8 {
            #[inline(always)]
            fn from(val: Sinv) -> u8 {
                Sinv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smif {
            #[inline(always)]
            fn from(val: u8) -> Smif {
                Smif::from_bits(val)
            }
        }
        impl From<Smif> for u8 {
            #[inline(always)]
            fn from(val: Smif) -> u8 {
                Smif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrCks {
            #[inline(always)]
            fn from(val: u8) -> SmrCks {
                SmrCks::from_bits(val)
            }
        }
        impl From<SmrCks> for u8 {
            #[inline(always)]
            fn from(val: SmrCks) -> u8 {
                SmrCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrPe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrPe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrPe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrPe {
            #[inline(always)]
            fn from(val: u8) -> SmrPe {
                SmrPe::from_bits(val)
            }
        }
        impl From<SmrPe> for u8 {
            #[inline(always)]
            fn from(val: SmrPe) -> u8 {
                SmrPe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrPm {
            #[inline(always)]
            fn from(val: u8) -> SmrPm {
                SmrPm::from_bits(val)
            }
        }
        impl From<SmrPm> for u8 {
            #[inline(always)]
            fn from(val: SmrPm) -> u8 {
                SmrPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrSmciCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciCks {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciCks {
                SmrSmciCks::from_bits(val)
            }
        }
        impl From<SmrSmciCks> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciCks) -> u8 {
                SmrSmciCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciPe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrSmciPe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciPe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciPe {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciPe {
                SmrSmciPe::from_bits(val)
            }
        }
        impl From<SmrSmciPe> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciPe) -> u8 {
                SmrSmciPe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrSmciPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciPm {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciPm {
                SmrSmciPm::from_bits(val)
            }
        }
        impl From<SmrSmciPm> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciPm) -> u8 {
                SmrSmciPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb2dt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spb2dt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb2dt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb2dt {
            #[inline(always)]
            fn from(val: u8) -> Spb2dt {
                Spb2dt::from_bits(val)
            }
        }
        impl From<Spb2dt> for u8 {
            #[inline(always)]
            fn from(val: Spb2dt) -> u8 {
                Spb2dt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb2io {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spb2io {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb2io {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb2io {
            #[inline(always)]
            fn from(val: u8) -> Spb2io {
                Spb2io::from_bits(val)
            }
        }
        impl From<Spb2io> for u8 {
            #[inline(always)]
            fn from(val: Spb2io) -> u8 {
                Spb2io::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sse {
            #[inline(always)]
            fn from(val: u8) -> Sse {
                Sse::from_bits(val)
            }
        }
        impl From<Sse> for u8 {
            #[inline(always)]
            fn from(val: Sse) -> u8 {
                Sse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFer {
            #[inline(always)]
            fn from(val: u8) -> SsrFer {
                SsrFer::from_bits(val)
            }
        }
        impl From<SsrFer> for u8 {
            #[inline(always)]
            fn from(val: SsrFer) -> u8 {
                SsrFer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoDr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoDr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoDr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoDr {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoDr {
                SsrFifoDr::from_bits(val)
            }
        }
        impl From<SsrFifoDr> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoDr) -> u8 {
                SsrFifoDr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoFer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoFer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoFer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoFer {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoFer {
                SsrFifoFer::from_bits(val)
            }
        }
        impl From<SsrFifoFer> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoFer) -> u8 {
                SsrFifoFer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoOrer {
                SsrFifoOrer::from_bits(val)
            }
        }
        impl From<SsrFifoOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoOrer) -> u8 {
                SsrFifoOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoPer {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoPer {
                SsrFifoPer::from_bits(val)
            }
        }
        impl From<SsrFifoPer> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoPer) -> u8 {
                SsrFifoPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoRdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoRdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoRdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoRdf {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoRdf {
                SsrFifoRdf::from_bits(val)
            }
        }
        impl From<SsrFifoRdf> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoRdf) -> u8 {
                SsrFifoRdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoTend {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoTend {
                SsrFifoTend::from_bits(val)
            }
        }
        impl From<SsrFifoTend> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoTend) -> u8 {
                SsrFifoTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrMpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrMpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrMpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrMpb {
            #[inline(always)]
            fn from(val: u8) -> SsrMpb {
                SsrMpb::from_bits(val)
            }
        }
        impl From<SsrMpb> for u8 {
            #[inline(always)]
            fn from(val: SsrMpb) -> u8 {
                SsrMpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrMpbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrMpbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrMpbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrMpbt {
            #[inline(always)]
            fn from(val: u8) -> SsrMpbt {
                SsrMpbt::from_bits(val)
            }
        }
        impl From<SsrMpbt> for u8 {
            #[inline(always)]
            fn from(val: SsrMpbt) -> u8 {
                SsrMpbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrOrer {
                SsrOrer::from_bits(val)
            }
        }
        impl From<SsrOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrOrer) -> u8 {
                SsrOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrPer {
            #[inline(always)]
            fn from(val: u8) -> SsrPer {
                SsrPer::from_bits(val)
            }
        }
        impl From<SsrPer> for u8 {
            #[inline(always)]
            fn from(val: SsrPer) -> u8 {
                SsrPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrRdrf {
                SsrRdrf::from_bits(val)
            }
        }
        impl From<SsrRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrRdrf) -> u8 {
                SsrRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciOrer {
                SsrSmciOrer::from_bits(val)
            }
        }
        impl From<SsrSmciOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciOrer) -> u8 {
                SsrSmciOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciPer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciPer {
                SsrSmciPer::from_bits(val)
            }
        }
        impl From<SsrSmciPer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciPer) -> u8 {
                SsrSmciPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciRdrf {
                SsrSmciRdrf::from_bits(val)
            }
        }
        impl From<SsrSmciRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciRdrf) -> u8 {
                SsrSmciRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTdre {
                SsrSmciTdre::from_bits(val)
            }
        }
        impl From<SsrSmciTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTdre) -> u8 {
                SsrSmciTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTend {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTend {
                SsrSmciTend::from_bits(val)
            }
        }
        impl From<SsrSmciTend> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTend) -> u8 {
                SsrSmciTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrTdre {
                SsrTdre::from_bits(val)
            }
        }
        impl From<SsrTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrTdre) -> u8 {
                SsrTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTend {
            #[inline(always)]
            fn from(val: u8) -> SsrTend {
                SsrTend::from_bits(val)
            }
        }
        impl From<SsrTend> for u8 {
            #[inline(always)]
            fn from(val: SsrTend) -> u8 {
                SsrTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stop {
            #[inline(always)]
            fn from(val: u8) -> Stop {
                Stop::from_bits(val)
            }
        }
        impl From<Stop> for u8 {
            #[inline(always)]
            fn from(val: Stop) -> u8 {
                Stop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdfe {
            #[inline(always)]
            fn from(val: u8) -> Tdfe {
                Tdfe::from_bits(val)
            }
        }
        impl From<Tdfe> for u8 {
            #[inline(always)]
            fn from(val: Tdfe) -> u8 {
                Tdfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teie {
            #[inline(always)]
            fn from(val: u8) -> Teie {
                Teie::from_bits(val)
            }
        }
        impl From<Teie> for u8 {
            #[inline(always)]
            fn from(val: Teie) -> u8 {
                Teie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tfrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tfrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tfrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tfrst {
            #[inline(always)]
            fn from(val: u8) -> Tfrst {
                Tfrst::from_bits(val)
            }
        }
        impl From<Tfrst> for u8 {
            #[inline(always)]
            fn from(val: Tfrst) -> u8 {
                Tfrst::to_bits(val)
            }
        }
    }
}
pub mod sci1 {
    #[doc = "Serial Communication Interface 1"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sci1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Sci1 {}
    unsafe impl Sync for Sci1 {}
    impl Sci1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Serial Mode Register (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn smr(self) -> crate::common::Reg<regs::Smr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Serial mode register (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn smr_smci(self) -> crate::common::Reg<regs::SmrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Bit Rate Register"]
        #[inline(always)]
        pub const fn brr(self) -> crate::common::Reg<regs::Brr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Serial Control Register (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<regs::Scr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Serial Control Register (SCMR.SMIF =1)"]
        #[inline(always)]
        pub const fn scr_smci(self) -> crate::common::Reg<regs::ScrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Transmit Data Register"]
        #[inline(always)]
        pub const fn tdr(self) -> crate::common::Reg<regs::Tdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)"]
        #[inline(always)]
        pub const fn ssr(self) -> crate::common::Reg<regs::Ssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn ssr_smci(self) -> crate::common::Reg<regs::SsrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Receive Data Register"]
        #[inline(always)]
        pub const fn rdr(self) -> crate::common::Reg<regs::Rdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "Smart Card Mode Register"]
        #[inline(always)]
        pub const fn scmr(self) -> crate::common::Reg<regs::Scmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Serial Extended Mode Register"]
        #[inline(always)]
        pub const fn semr(self) -> crate::common::Reg<regs::Semr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Noise Filter Setting Register"]
        #[inline(always)]
        pub const fn snfr(self) -> crate::common::Reg<regs::Snfr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "I2C Mode Register 1"]
        #[inline(always)]
        pub const fn simr1(self) -> crate::common::Reg<regs::Simr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "I2C Mode Register 2"]
        #[inline(always)]
        pub const fn simr2(self) -> crate::common::Reg<regs::Simr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "IIC Mode Register 3"]
        #[inline(always)]
        pub const fn simr3(self) -> crate::common::Reg<regs::Simr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "IIC Status Register"]
        #[inline(always)]
        pub const fn sisr(self) -> crate::common::Reg<regs::Sisr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Mode Register"]
        #[inline(always)]
        pub const fn spmr(self) -> crate::common::Reg<regs::Spmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "Transmit 9-bit Data Register"]
        #[inline(always)]
        pub const fn tdrhl(self) -> crate::common::Reg<regs::Tdrhl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Receive 9-bit Data Register"]
        #[inline(always)]
        pub const fn rdrhl(self) -> crate::common::Reg<regs::Rdrhl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Modulation Duty Register"]
        #[inline(always)]
        pub const fn mddr(self) -> crate::common::Reg<regs::Mddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "Data Compare Match Control Register"]
        #[inline(always)]
        pub const fn dccr(self) -> crate::common::Reg<regs::Dccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13usize) as _) }
        }
        #[doc = "Compare Match Data Register"]
        #[inline(always)]
        pub const fn cdr(self) -> crate::common::Reg<regs::Cdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "Serial Port Register"]
        #[inline(always)]
        pub const fn sptr(self) -> crate::common::Reg<regs::Sptr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bit Rate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Brr(pub u8);
        impl Brr {
            #[doc = "BRR is an 8-bit register that adjusts the bit rate."]
            #[inline(always)]
            pub const fn brr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "BRR is an 8-bit register that adjusts the bit rate."]
            #[inline(always)]
            pub fn set_brr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Brr {
            #[inline(always)]
            fn default() -> Brr {
                Brr(0)
            }
        }
        impl core::fmt::Debug for Brr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Brr").field("brr", &self.brr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Brr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Brr {{ brr: {=u8:?} }}", self.brr())
            }
        }
        #[doc = "Compare Match Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cdr(pub u16);
        impl Cdr {
            #[doc = "Compare Match DataCompare data pattern for address match wake,up function"]
            #[inline(always)]
            pub const fn cmpd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Compare Match DataCompare data pattern for address match wake,up function"]
            #[inline(always)]
            pub fn set_cmpd(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Cdr {
            #[inline(always)]
            fn default() -> Cdr {
                Cdr(0)
            }
        }
        impl core::fmt::Debug for Cdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cdr")
                    .field("cmpd", &self.cmpd())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cdr {{ cmpd: {=u16:?}, reserved_9_15: {=u8:?} }}",
                    self.cmpd(),
                    self.reserved_9_15()
                )
            }
        }
        #[doc = "Data Compare Match Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dccr(pub u8);
        impl Dccr {
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub const fn dcmf(&self) -> super::vals::Dcmf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dcmf::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub fn set_dcmf(&mut self, val: super::vals::Dcmf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_1_2(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_1_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u8) & 0x03) << 1usize);
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub const fn dper(&self) -> super::vals::Dper {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dper::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub fn set_dper(&mut self, val: super::vals::Dper) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub const fn dfer(&self) -> super::vals::Dfer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dfer::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub fn set_dfer(&mut self, val: super::vals::Dfer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "ID frame select Bit(Valid only in asynchronous mode(including multi,processor)"]
            #[inline(always)]
            pub const fn idsel(&self) -> super::vals::Idsel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Idsel::from_bits(val as u8)
            }
            #[doc = "ID frame select Bit(Valid only in asynchronous mode(including multi,processor)"]
            #[inline(always)]
            pub fn set_idsel(&mut self, val: super::vals::Idsel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Data Compare Match Enable(Valid only in asynchronous mode(including multi,processor)"]
            #[inline(always)]
            pub const fn dcme(&self) -> super::vals::Dcme {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dcme::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Enable(Valid only in asynchronous mode(including multi,processor)"]
            #[inline(always)]
            pub fn set_dcme(&mut self, val: super::vals::Dcme) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Dccr {
            #[inline(always)]
            fn default() -> Dccr {
                Dccr(0)
            }
        }
        impl core::fmt::Debug for Dccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dccr")
                    .field("dcmf", &self.dcmf())
                    .field("reserved_1_2", &self.reserved_1_2())
                    .field("dper", &self.dper())
                    .field("dfer", &self.dfer())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("idsel", &self.idsel())
                    .field("dcme", &self.dcme())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dccr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dccr {{ dcmf: {:?}, reserved_1_2: {=u8:?}, dper: {:?}, dfer: {:?}, reserved_5_5: {=bool:?}, idsel: {:?}, dcme: {:?} }}" , self . dcmf () , self . reserved_1_2 () , self . dper () , self . dfer () , self . reserved_5_5 () , self . idsel () , self . dcme ())
            }
        }
        #[doc = "Modulation Duty Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mddr(pub u8);
        impl Mddr {
            #[doc = "MDDR corrects the bit rate adjusted by the BRR register."]
            #[inline(always)]
            pub const fn mddr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MDDR corrects the bit rate adjusted by the BRR register."]
            #[inline(always)]
            pub fn set_mddr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Mddr {
            #[inline(always)]
            fn default() -> Mddr {
                Mddr(0)
            }
        }
        impl core::fmt::Debug for Mddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mddr").field("mddr", &self.mddr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mddr {{ mddr: {=u8:?} }}", self.mddr())
            }
        }
        #[doc = "Receive Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdr(pub u8);
        impl Rdr {
            #[doc = "RDR is an 8-bit register that stores receive data."]
            #[inline(always)]
            pub const fn rdr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "RDR is an 8-bit register that stores receive data."]
            #[inline(always)]
            pub fn set_rdr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Rdr {
            #[inline(always)]
            fn default() -> Rdr {
                Rdr(0)
            }
        }
        impl core::fmt::Debug for Rdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdr").field("rdr", &self.rdr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rdr {{ rdr: {=u8:?} }}", self.rdr())
            }
        }
        #[doc = "Receive 9-bit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdrhl(pub u16);
        impl Rdrhl {
            #[doc = "RDRHL is an 16-bit register that stores receive data."]
            #[inline(always)]
            pub const fn rdrhl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "RDRHL is an 16-bit register that stores receive data."]
            #[inline(always)]
            pub fn set_rdrhl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Rdrhl {
            #[inline(always)]
            fn default() -> Rdrhl {
                Rdrhl(0)
            }
        }
        impl core::fmt::Debug for Rdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdrhl")
                    .field("rdrhl", &self.rdrhl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rdrhl {{ rdrhl: {=u16:?} }}", self.rdrhl())
            }
        }
        #[doc = "Smart Card Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scmr(pub u8);
        impl Scmr {
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub const fn smif(&self) -> super::vals::Smif {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smif::from_bits(val as u8)
            }
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub fn set_smif(&mut self, val: super::vals::Smif) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmitted/Received Data InvertSet this bit to 0 if operation is to be in simple I2C mode."]
            #[inline(always)]
            pub const fn sinv(&self) -> super::vals::Sinv {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sinv::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data InvertSet this bit to 0 if operation is to be in simple I2C mode."]
            #[inline(always)]
            pub fn set_sinv(&mut self, val: super::vals::Sinv) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmitted/Received Data Transfer DirectionNOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode.Set this bit to 1 if operation is to be in simple I2C mode."]
            #[inline(always)]
            pub const fn sdir(&self) -> super::vals::Sdir {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sdir::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data Transfer DirectionNOTE: The setting is invalid and a fixed data length of 8 bits is used in modes other than asynchronous mode.Set this bit to 1 if operation is to be in simple I2C mode."]
            #[inline(always)]
            pub fn set_sdir(&mut self, val: super::vals::Sdir) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Character Length 1(Only valid in asynchronous mode)"]
            #[inline(always)]
            pub const fn chr1(&self) -> super::vals::Chr1 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Chr1::from_bits(val as u8)
            }
            #[doc = "Character Length 1(Only valid in asynchronous mode)"]
            #[inline(always)]
            pub fn set_chr1(&mut self, val: super::vals::Chr1) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub const fn reserved_5_6(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 11. The write value should be 11."]
            #[inline(always)]
            pub fn set_reserved_5_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u8) & 0x03) << 5usize);
            }
            #[doc = "Base Clock Pulse 2Selects the number of base clock cycles in combination with the SMR.BCP\\[1:0\\] bits"]
            #[inline(always)]
            pub const fn bcp2(&self) -> super::vals::Bcp2 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bcp2::from_bits(val as u8)
            }
            #[doc = "Base Clock Pulse 2Selects the number of base clock cycles in combination with the SMR.BCP\\[1:0\\] bits"]
            #[inline(always)]
            pub fn set_bcp2(&mut self, val: super::vals::Bcp2) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scmr {
            #[inline(always)]
            fn default() -> Scmr {
                Scmr(0)
            }
        }
        impl core::fmt::Debug for Scmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scmr")
                    .field("smif", &self.smif())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("sinv", &self.sinv())
                    .field("sdir", &self.sdir())
                    .field("chr1", &self.chr1())
                    .field("reserved_5_6", &self.reserved_5_6())
                    .field("bcp2", &self.bcp2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scmr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scmr {{ smif: {:?}, reserved_1_1: {=bool:?}, sinv: {:?}, sdir: {:?}, chr1: {:?}, reserved_5_6: {=u8:?}, bcp2: {:?} }}" , self . smif () , self . reserved_1_1 () , self . sinv () , self . sdir () , self . chr1 () , self . reserved_5_6 () , self . bcp2 ())
            }
        }
        #[doc = "Serial Control Register (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr(pub u8);
        impl Scr {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> super::vals::Teie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Teie::from_bits(val as u8)
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: super::vals::Teie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Multi,Processor Interrupt Enable(Valid in asynchronous mode when SMR.MP = 1)"]
            #[inline(always)]
            pub const fn mpie(&self) -> super::vals::Mpie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mpie::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Interrupt Enable(Valid in asynchronous mode when SMR.MP = 1)"]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: super::vals::Mpie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scr {
            #[inline(always)]
            fn default() -> Scr {
                Scr(0)
            }
        }
        impl core::fmt::Debug for Scr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scr {{ cke: {:?}, teie: {:?}, mpie: {:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Control Register (SCMR.SMIF =1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ScrSmci(pub u8);
        impl ScrSmci {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrSmciCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrSmciCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrSmciCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "This bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub const fn teie(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub fn set_teie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub const fn mpie(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrSmciRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrSmciRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrSmciRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrSmciTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrSmciTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrSmciTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrSmciRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrSmciRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrSmciRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrSmciTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrSmciTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrSmciTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for ScrSmci {
            #[inline(always)]
            fn default() -> ScrSmci {
                ScrSmci(0)
            }
        }
        impl core::fmt::Debug for ScrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ScrSmci")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ScrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ScrSmci {{ cke: {:?}, teie: {=bool:?}, mpie: {=bool:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Extended Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Semr(pub u8);
        impl Semr {
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_0_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_0_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub const fn brme(&self) -> super::vals::Brme {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Brme::from_bits(val as u8)
            }
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub fn set_brme(&mut self, val: super::vals::Brme) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select1(Valid only in asynchronous mode and SCR.CKE\\[1\\]=0)"]
            #[inline(always)]
            pub const fn abcse(&self) -> super::vals::Abcse {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Abcse::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select1(Valid only in asynchronous mode and SCR.CKE\\[1\\]=0)"]
            #[inline(always)]
            pub fn set_abcse(&mut self, val: super::vals::Abcse) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Asynchronous Mode Base Clock Select(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn abcs(&self) -> super::vals::Abcs {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Abcs::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Base Clock Select(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_abcs(&mut self, val: super::vals::Abcs) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Digital Noise Filter Function Enable(The NFEN bit should be 0 without simple I2C mode and asynchronous mode.)In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input."]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::Nfen {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Nfen::from_bits(val as u8)
            }
            #[doc = "Digital Noise Filter Function Enable(The NFEN bit should be 0 without simple I2C mode and asynchronous mode.)In asynchronous mode, for RXDn input only. In simple I2C mode, for RXDn/TxDn input."]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::Nfen) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select(Only valid the CKE\\[1\\] bit in SCR is 0 in asynchronous mode)."]
            #[inline(always)]
            pub const fn bgdm(&self) -> super::vals::Bgdm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Bgdm::from_bits(val as u8)
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select(Only valid the CKE\\[1\\] bit in SCR is 0 in asynchronous mode)."]
            #[inline(always)]
            pub fn set_bgdm(&mut self, val: super::vals::Bgdm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn rxdesel(&self) -> super::vals::Rxdesel {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rxdesel::from_bits(val as u8)
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_rxdesel(&mut self, val: super::vals::Rxdesel) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Semr {
            #[inline(always)]
            fn default() -> Semr {
                Semr(0)
            }
        }
        impl core::fmt::Debug for Semr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Semr")
                    .field("reserved_0_1", &self.reserved_0_1())
                    .field("brme", &self.brme())
                    .field("abcse", &self.abcse())
                    .field("abcs", &self.abcs())
                    .field("nfen", &self.nfen())
                    .field("bgdm", &self.bgdm())
                    .field("rxdesel", &self.rxdesel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Semr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Semr {{ reserved_0_1: {=u8:?}, brme: {:?}, abcse: {:?}, abcs: {:?}, nfen: {:?}, bgdm: {:?}, rxdesel: {:?} }}" , self . reserved_0_1 () , self . brme () , self . abcse () , self . abcs () , self . nfen () , self . bgdm () , self . rxdesel ())
            }
        }
        #[doc = "I2C Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr1(pub u8);
        impl Simr1 {
            #[doc = "Simple I2C Mode Select"]
            #[inline(always)]
            pub const fn iicm(&self) -> super::vals::Iicm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicm::from_bits(val as u8)
            }
            #[doc = "Simple I2C Mode Select"]
            #[inline(always)]
            pub fn set_iicm(&mut self, val: super::vals::Iicm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_1_2(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_1_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u8) & 0x03) << 1usize);
            }
            #[doc = "SSDA Delay Output SelectCycles below are of the clock signal from the on,chip baud rate generator."]
            #[inline(always)]
            pub const fn iicdl(&self) -> super::vals::Iicdl {
                let val = (self.0 >> 3usize) & 0x1f;
                super::vals::Iicdl::from_bits(val as u8)
            }
            #[doc = "SSDA Delay Output SelectCycles below are of the clock signal from the on,chip baud rate generator."]
            #[inline(always)]
            pub fn set_iicdl(&mut self, val: super::vals::Iicdl) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val.to_bits() as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Simr1 {
            #[inline(always)]
            fn default() -> Simr1 {
                Simr1(0)
            }
        }
        impl core::fmt::Debug for Simr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr1")
                    .field("iicm", &self.iicm())
                    .field("reserved_1_2", &self.reserved_1_2())
                    .field("iicdl", &self.iicdl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Simr1 {{ iicm: {:?}, reserved_1_2: {=u8:?}, iicdl: {:?} }}",
                    self.iicm(),
                    self.reserved_1_2(),
                    self.iicdl()
                )
            }
        }
        #[doc = "I2C Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr2(pub u8);
        impl Simr2 {
            #[doc = "I2C Interrupt Mode Select"]
            #[inline(always)]
            pub const fn iicintm(&self) -> super::vals::Iicintm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicintm::from_bits(val as u8)
            }
            #[doc = "I2C Interrupt Mode Select"]
            #[inline(always)]
            pub fn set_iicintm(&mut self, val: super::vals::Iicintm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub const fn iiccsc(&self) -> super::vals::Iiccsc {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iiccsc::from_bits(val as u8)
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub fn set_iiccsc(&mut self, val: super::vals::Iiccsc) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_2_4(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_2_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val as u8) & 0x07) << 2usize);
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub const fn iicackt(&self) -> super::vals::Iicackt {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Iicackt::from_bits(val as u8)
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub fn set_iicackt(&mut self, val: super::vals::Iicackt) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Simr2 {
            #[inline(always)]
            fn default() -> Simr2 {
                Simr2(0)
            }
        }
        impl core::fmt::Debug for Simr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr2")
                    .field("iicintm", &self.iicintm())
                    .field("iiccsc", &self.iiccsc())
                    .field("reserved_2_4", &self.reserved_2_4())
                    .field("iicackt", &self.iicackt())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Simr2 {{ iicintm: {:?}, iiccsc: {:?}, reserved_2_4: {=u8:?}, iicackt: {:?}, reserved_6_7: {=u8:?} }}" , self . iicintm () , self . iiccsc () , self . reserved_2_4 () , self . iicackt () , self . reserved_6_7 ())
            }
        }
        #[doc = "IIC Mode Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr3(pub u8);
        impl Simr3 {
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub const fn iicstareq(&self) -> super::vals::Iicstareq {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicstareq::from_bits(val as u8)
            }
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub fn set_iicstareq(&mut self, val: super::vals::Iicstareq) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub const fn iicrstareq(&self) -> super::vals::Iicrstareq {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iicrstareq::from_bits(val as u8)
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub fn set_iicrstareq(&mut self, val: super::vals::Iicrstareq) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub const fn iicstpreq(&self) -> super::vals::Iicstpreq {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Iicstpreq::from_bits(val as u8)
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub fn set_iicstpreq(&mut self, val: super::vals::Iicstpreq) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag(When 0 is written to IICSTIF, it is cleared to 0.)"]
            #[inline(always)]
            pub const fn iicstif(&self) -> super::vals::Iicstif {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Iicstif::from_bits(val as u8)
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag(When 0 is written to IICSTIF, it is cleared to 0.)"]
            #[inline(always)]
            pub fn set_iicstif(&mut self, val: super::vals::Iicstif) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SDA Output Select"]
            #[inline(always)]
            pub const fn iicsdas(&self) -> super::vals::Iicsdas {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Iicsdas::from_bits(val as u8)
            }
            #[doc = "SDA Output Select"]
            #[inline(always)]
            pub fn set_iicsdas(&mut self, val: super::vals::Iicsdas) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "SCL Output Select"]
            #[inline(always)]
            pub const fn iicscls(&self) -> super::vals::Iicscls {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Iicscls::from_bits(val as u8)
            }
            #[doc = "SCL Output Select"]
            #[inline(always)]
            pub fn set_iicscls(&mut self, val: super::vals::Iicscls) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Simr3 {
            #[inline(always)]
            fn default() -> Simr3 {
                Simr3(0)
            }
        }
        impl core::fmt::Debug for Simr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr3")
                    .field("iicstareq", &self.iicstareq())
                    .field("iicrstareq", &self.iicrstareq())
                    .field("iicstpreq", &self.iicstpreq())
                    .field("iicstif", &self.iicstif())
                    .field("iicsdas", &self.iicsdas())
                    .field("iicscls", &self.iicscls())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Simr3 {{ iicstareq: {:?}, iicrstareq: {:?}, iicstpreq: {:?}, iicstif: {:?}, iicsdas: {:?}, iicscls: {:?} }}" , self . iicstareq () , self . iicrstareq () , self . iicstpreq () , self . iicstif () , self . iicsdas () , self . iicscls ())
            }
        }
        #[doc = "IIC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sisr(pub u8);
        impl Sisr {
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub const fn iicackr(&self) -> super::vals::Iicackr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicackr::from_bits(val as u8)
            }
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub fn set_iicackr(&mut self, val: super::vals::Iicackr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_2_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_2_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_4_5(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_4_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Sisr {
            #[inline(always)]
            fn default() -> Sisr {
                Sisr(0)
            }
        }
        impl core::fmt::Debug for Sisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sisr")
                    .field("iicackr", &self.iicackr())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("reserved_2_2", &self.reserved_2_2())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("reserved_4_5", &self.reserved_4_5())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sisr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sisr {{ iicackr: {:?}, reserved_1_1: {=bool:?}, reserved_2_2: {=bool:?}, reserved_3_3: {=bool:?}, reserved_4_5: {=u8:?}, reserved_6_7: {=u8:?} }}" , self . iicackr () , self . reserved_1_1 () , self . reserved_2_2 () , self . reserved_3_3 () , self . reserved_4_5 () , self . reserved_6_7 ())
            }
        }
        #[doc = "Serial Mode Register (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr(pub u8);
        impl Smr {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Multi,Processor Mode(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn mp(&self) -> super::vals::Mp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mp::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Mode(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_mp(&mut self, val: super::vals::Mp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Bit Length(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::Stop {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Stop::from_bits(val as u8)
            }
            #[doc = "Stop Bit Length(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: super::vals::Stop) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Parity Mode (Valid only when the PE bit is 1)"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode (Valid only when the PE bit is 1)"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn pe(&self) -> super::vals::SmrPe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SmrPe::from_bits(val as u8)
            }
            #[doc = "Parity Enable(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: super::vals::SmrPe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Character Length(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn chr(&self) -> super::vals::Chr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Chr::from_bits(val as u8)
            }
            #[doc = "Character Length(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_chr(&mut self, val: super::vals::Chr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Communications Mode"]
            #[inline(always)]
            pub const fn cm(&self) -> super::vals::Cm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cm::from_bits(val as u8)
            }
            #[doc = "Communications Mode"]
            #[inline(always)]
            pub fn set_cm(&mut self, val: super::vals::Cm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Smr {
            #[inline(always)]
            fn default() -> Smr {
                Smr(0)
            }
        }
        impl core::fmt::Debug for Smr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr")
                    .field("cks", &self.cks())
                    .field("mp", &self.mp())
                    .field("stop", &self.stop())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("chr", &self.chr())
                    .field("cm", &self.cm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smr {{ cks: {:?}, mp: {:?}, stop: {:?}, pm: {:?}, pe: {:?}, chr: {:?}, cm: {:?} }}" , self . cks () , self . mp () , self . stop () , self . pm () , self . pe () , self . chr () , self . cm ())
            }
        }
        #[doc = "Serial mode register (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SmrSmci(pub u8);
        impl SmrSmci {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrSmciCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrSmciCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrSmciCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub const fn bcp(&self) -> super::vals::Bcp {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Bcp::from_bits(val as u8)
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub fn set_bcp(&mut self, val: super::vals::Bcp) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u8) & 0x03) << 2usize);
            }
            #[doc = "Parity Mode (Valid only when the PE bit is 1)"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrSmciPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrSmciPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode (Valid only when the PE bit is 1)"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrSmciPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub const fn pe(&self) -> super::vals::SmrSmciPe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SmrSmciPe::from_bits(val as u8)
            }
            #[doc = "Parity Enable(Valid only in asynchronous mode)"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: super::vals::SmrSmciPe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub const fn blk(&self) -> super::vals::Blk {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Blk::from_bits(val as u8)
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub fn set_blk(&mut self, val: super::vals::Blk) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub const fn gm(&self) -> super::vals::Gm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Gm::from_bits(val as u8)
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub fn set_gm(&mut self, val: super::vals::Gm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SmrSmci {
            #[inline(always)]
            fn default() -> SmrSmci {
                SmrSmci(0)
            }
        }
        impl core::fmt::Debug for SmrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SmrSmci")
                    .field("cks", &self.cks())
                    .field("bcp", &self.bcp())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("blk", &self.blk())
                    .field("gm", &self.gm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SmrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SmrSmci {{ cks: {:?}, bcp: {:?}, pm: {:?}, pe: {:?}, blk: {:?}, gm: {:?} }}",
                    self.cks(),
                    self.bcp(),
                    self.pm(),
                    self.pe(),
                    self.blk(),
                    self.gm()
                )
            }
        }
        #[doc = "Noise Filter Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snfr(pub u8);
        impl Snfr {
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::Nfcs {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Nfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::Nfcs) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Snfr {
            #[inline(always)]
            fn default() -> Snfr {
                Snfr(0)
            }
        }
        impl core::fmt::Debug for Snfr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snfr")
                    .field("nfcs", &self.nfcs())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snfr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Snfr {{ nfcs: {:?}, reserved_3_7: {=u8:?} }}",
                    self.nfcs(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "SPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spmr(pub u8);
        impl Spmr {
            #[doc = "SSn# Pin Function Enable"]
            #[inline(always)]
            pub const fn sse(&self) -> super::vals::Sse {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sse::from_bits(val as u8)
            }
            #[doc = "SSn# Pin Function Enable"]
            #[inline(always)]
            pub fn set_sse(&mut self, val: super::vals::Sse) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub const fn ctse(&self) -> super::vals::Ctse {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ctse::from_bits(val as u8)
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub fn set_ctse(&mut self, val: super::vals::Ctse) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub const fn mss(&self) -> super::vals::Mss {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mss::from_bits(val as u8)
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub fn set_mss(&mut self, val: super::vals::Mss) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub const fn mff(&self) -> super::vals::Mff {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mff::from_bits(val as u8)
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub fn set_mff(&mut self, val: super::vals::Mff) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub const fn ckpol(&self) -> super::vals::Ckpol {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ckpol::from_bits(val as u8)
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub fn set_ckpol(&mut self, val: super::vals::Ckpol) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub const fn ckph(&self) -> super::vals::Ckph {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ckph::from_bits(val as u8)
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub fn set_ckph(&mut self, val: super::vals::Ckph) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spmr {
            #[inline(always)]
            fn default() -> Spmr {
                Spmr(0)
            }
        }
        impl core::fmt::Debug for Spmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spmr")
                    .field("sse", &self.sse())
                    .field("ctse", &self.ctse())
                    .field("mss", &self.mss())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("mff", &self.mff())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("ckpol", &self.ckpol())
                    .field("ckph", &self.ckph())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spmr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spmr {{ sse: {:?}, ctse: {:?}, mss: {:?}, reserved_3_3: {=bool:?}, mff: {:?}, reserved_5_5: {=bool:?}, ckpol: {:?}, ckph: {:?} }}" , self . sse () , self . ctse () , self . mss () , self . reserved_3_3 () , self . mff () , self . reserved_5_5 () , self . ckpol () , self . ckph ())
            }
        }
        #[doc = "Serial Port Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sptr(pub u8);
        impl Sptr {
            #[doc = "Serial input data monitor bit(The state of the RXD terminal is shown.)"]
            #[inline(always)]
            pub const fn rxdmon(&self) -> super::vals::Rxdmon {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rxdmon::from_bits(val as u8)
            }
            #[doc = "Serial input data monitor bit(The state of the RXD terminal is shown.)"]
            #[inline(always)]
            pub fn set_rxdmon(&mut self, val: super::vals::Rxdmon) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Serial port break data select bit(The output level of TxD terminal is selected when SCR.TE = 0.)"]
            #[inline(always)]
            pub const fn spb2dt(&self) -> super::vals::Spb2dt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spb2dt::from_bits(val as u8)
            }
            #[doc = "Serial port break data select bit(The output level of TxD terminal is selected when SCR.TE = 0.)"]
            #[inline(always)]
            pub fn set_spb2dt(&mut self, val: super::vals::Spb2dt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Serial port break I/O bit(It's selected whether the value of SPB2DT is output to TxD terminal.)"]
            #[inline(always)]
            pub const fn spb2io(&self) -> super::vals::Spb2io {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Spb2io::from_bits(val as u8)
            }
            #[doc = "Serial port break I/O bit(It's selected whether the value of SPB2DT is output to TxD terminal.)"]
            #[inline(always)]
            pub fn set_spb2io(&mut self, val: super::vals::Spb2io) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Sptr {
            #[inline(always)]
            fn default() -> Sptr {
                Sptr(0)
            }
        }
        impl core::fmt::Debug for Sptr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sptr")
                    .field("rxdmon", &self.rxdmon())
                    .field("spb2dt", &self.spb2dt())
                    .field("spb2io", &self.spb2io())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sptr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sptr {{ rxdmon: {:?}, spb2dt: {:?}, spb2io: {:?}, reserved_3_7: {=u8:?} }}",
                    self.rxdmon(),
                    self.spb2dt(),
                    self.spb2io(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr(pub u8);
        impl Ssr {
            #[doc = "Multi,Processor Bit Transfer. Sets the multi,processor bit for adding to the transmission frame"]
            #[inline(always)]
            pub const fn mpbt(&self) -> super::vals::Mpbt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mpbt::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Bit Transfer. Sets the multi,processor bit for adding to the transmission frame"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: super::vals::Mpbt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor Bit. Value of the multi,processor bit in the reception frame"]
            #[inline(always)]
            pub const fn mpb(&self) -> super::vals::Mpb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mpb::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Bit. Value of the multi,processor bit in the reception frame"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: super::vals::Mpb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::Fer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Fer::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::Fer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ssr {
            #[inline(always)]
            fn default() -> Ssr {
                Ssr(0)
            }
        }
        impl core::fmt::Debug for Ssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ssr {{ mpbt: {:?}, mpb: {:?}, tend: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . fer () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Serial Status Register(SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SsrSmci(pub u8);
        impl SsrSmci {
            #[doc = "Multi,Processor Bit TransferThis bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub const fn mpbt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor Bit TransferThis bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,ProcessorThis bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub const fn mpb(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,ProcessorThis bit should be 0 in smart card interface mode."]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrSmciTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrSmciTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrSmciTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrSmciPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrSmciPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrSmciPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub const fn ers(&self) -> super::vals::Ers {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ers::from_bits(val as u8)
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub fn set_ers(&mut self, val: super::vals::Ers) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrSmciOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrSmciOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrSmciOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrSmciRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrSmciRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrSmciRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrSmciTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrSmciTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrSmciTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SsrSmci {
            #[inline(always)]
            fn default() -> SsrSmci {
                SsrSmci(0)
            }
        }
        impl core::fmt::Debug for SsrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SsrSmci")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("ers", &self.ers())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SsrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SsrSmci {{ mpbt: {=bool:?}, mpb: {=bool:?}, tend: {:?}, per: {:?}, ers: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . ers () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Transmit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tdr(pub u8);
        impl Tdr {
            #[doc = "TDR is an 8-bit register that stores transmit data."]
            #[inline(always)]
            pub const fn tdr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "TDR is an 8-bit register that stores transmit data."]
            #[inline(always)]
            pub fn set_tdr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Tdr {
            #[inline(always)]
            fn default() -> Tdr {
                Tdr(0)
            }
        }
        impl core::fmt::Debug for Tdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tdr").field("tdr", &self.tdr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tdr {{ tdr: {=u8:?} }}", self.tdr())
            }
        }
        #[doc = "Transmit 9-bit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tdrhl(pub u16);
        impl Tdrhl {
            #[doc = "TDRHL is a 16-bit register that stores transmit data."]
            #[inline(always)]
            pub const fn tdrhl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "TDRHL is a 16-bit register that stores transmit data."]
            #[inline(always)]
            pub fn set_tdrhl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Tdrhl {
            #[inline(always)]
            fn default() -> Tdrhl {
                Tdrhl(0)
            }
        }
        impl core::fmt::Debug for Tdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tdrhl")
                    .field("tdrhl", &self.tdrhl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tdrhl {{ tdrhl: {=u16:?} }}", self.tdrhl())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcs {
            #[inline(always)]
            fn from(val: u8) -> Abcs {
                Abcs::from_bits(val)
            }
        }
        impl From<Abcs> for u8 {
            #[inline(always)]
            fn from(val: Abcs) -> u8 {
                Abcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcse {
            #[inline(always)]
            fn from(val: u8) -> Abcse {
                Abcse::from_bits(val)
            }
        }
        impl From<Abcse> for u8 {
            #[inline(always)]
            fn from(val: Abcse) -> u8 {
                Abcse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Bcp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcp {
            #[inline(always)]
            fn from(val: u8) -> Bcp {
                Bcp::from_bits(val)
            }
        }
        impl From<Bcp> for u8 {
            #[inline(always)]
            fn from(val: Bcp) -> u8 {
                Bcp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcp2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bcp2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcp2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcp2 {
            #[inline(always)]
            fn from(val: u8) -> Bcp2 {
                Bcp2::from_bits(val)
            }
        }
        impl From<Bcp2> for u8 {
            #[inline(always)]
            fn from(val: Bcp2) -> u8 {
                Bcp2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bgdm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bgdm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bgdm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bgdm {
            #[inline(always)]
            fn from(val: u8) -> Bgdm {
                Bgdm::from_bits(val)
            }
        }
        impl From<Bgdm> for u8 {
            #[inline(always)]
            fn from(val: Bgdm) -> u8 {
                Bgdm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Blk {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Blk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Blk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Blk {
            #[inline(always)]
            fn from(val: u8) -> Blk {
                Blk::from_bits(val)
            }
        }
        impl From<Blk> for u8 {
            #[inline(always)]
            fn from(val: Blk) -> u8 {
                Blk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Brme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brme {
            #[inline(always)]
            fn from(val: u8) -> Brme {
                Brme::from_bits(val)
            }
        }
        impl From<Brme> for u8 {
            #[inline(always)]
            fn from(val: Brme) -> u8 {
                Brme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr {
            #[inline(always)]
            fn from(val: u8) -> Chr {
                Chr::from_bits(val)
            }
        }
        impl From<Chr> for u8 {
            #[inline(always)]
            fn from(val: Chr) -> u8 {
                Chr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr1 {
            #[inline(always)]
            fn from(val: u8) -> Chr1 {
                Chr1::from_bits(val)
            }
        }
        impl From<Chr1> for u8 {
            #[inline(always)]
            fn from(val: Chr1) -> u8 {
                Chr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckph {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckph {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckph {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckph {
            #[inline(always)]
            fn from(val: u8) -> Ckph {
                Ckph::from_bits(val)
            }
        }
        impl From<Ckph> for u8 {
            #[inline(always)]
            fn from(val: Ckph) -> u8 {
                Ckph::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckpol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckpol {
            #[inline(always)]
            fn from(val: u8) -> Ckpol {
                Ckpol::from_bits(val)
            }
        }
        impl From<Ckpol> for u8 {
            #[inline(always)]
            fn from(val: Ckpol) -> u8 {
                Ckpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cm {
            #[inline(always)]
            fn from(val: u8) -> Cm {
                Cm::from_bits(val)
            }
        }
        impl From<Cm> for u8 {
            #[inline(always)]
            fn from(val: Cm) -> u8 {
                Cm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctse {
            #[inline(always)]
            fn from(val: u8) -> Ctse {
                Ctse::from_bits(val)
            }
        }
        impl From<Ctse> for u8 {
            #[inline(always)]
            fn from(val: Ctse) -> u8 {
                Ctse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcme {
            #[inline(always)]
            fn from(val: u8) -> Dcme {
                Dcme::from_bits(val)
            }
        }
        impl From<Dcme> for u8 {
            #[inline(always)]
            fn from(val: Dcme) -> u8 {
                Dcme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcmf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcmf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcmf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcmf {
            #[inline(always)]
            fn from(val: u8) -> Dcmf {
                Dcmf::from_bits(val)
            }
        }
        impl From<Dcmf> for u8 {
            #[inline(always)]
            fn from(val: Dcmf) -> u8 {
                Dcmf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dfer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfer {
            #[inline(always)]
            fn from(val: u8) -> Dfer {
                Dfer::from_bits(val)
            }
        }
        impl From<Dfer> for u8 {
            #[inline(always)]
            fn from(val: Dfer) -> u8 {
                Dfer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dper {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dper {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dper {
            #[inline(always)]
            fn from(val: u8) -> Dper {
                Dper::from_bits(val)
            }
        }
        impl From<Dper> for u8 {
            #[inline(always)]
            fn from(val: Dper) -> u8 {
                Dper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ers {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ers {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ers {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ers {
            #[inline(always)]
            fn from(val: u8) -> Ers {
                Ers::from_bits(val)
            }
        }
        impl From<Ers> for u8 {
            #[inline(always)]
            fn from(val: Ers) -> u8 {
                Ers::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fer {
            #[inline(always)]
            fn from(val: u8) -> Fer {
                Fer::from_bits(val)
            }
        }
        impl From<Fer> for u8 {
            #[inline(always)]
            fn from(val: Fer) -> u8 {
                Fer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gm {
            #[inline(always)]
            fn from(val: u8) -> Gm {
                Gm::from_bits(val)
            }
        }
        impl From<Gm> for u8 {
            #[inline(always)]
            fn from(val: Gm) -> u8 {
                Gm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idsel {
            #[inline(always)]
            fn from(val: u8) -> Idsel {
                Idsel::from_bits(val)
            }
        }
        impl From<Idsel> for u8 {
            #[inline(always)]
            fn from(val: Idsel) -> u8 {
                Idsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackr {
            #[inline(always)]
            fn from(val: u8) -> Iicackr {
                Iicackr::from_bits(val)
            }
        }
        impl From<Iicackr> for u8 {
            #[inline(always)]
            fn from(val: Iicackr) -> u8 {
                Iicackr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackt {
            #[inline(always)]
            fn from(val: u8) -> Iicackt {
                Iicackt::from_bits(val)
            }
        }
        impl From<Iicackt> for u8 {
            #[inline(always)]
            fn from(val: Iicackt) -> u8 {
                Iicackt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iiccsc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iiccsc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iiccsc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iiccsc {
            #[inline(always)]
            fn from(val: u8) -> Iiccsc {
                Iiccsc::from_bits(val)
            }
        }
        impl From<Iiccsc> for u8 {
            #[inline(always)]
            fn from(val: Iiccsc) -> u8 {
                Iiccsc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicdl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Iicdl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicdl {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicdl {
            #[inline(always)]
            fn from(val: u8) -> Iicdl {
                Iicdl::from_bits(val)
            }
        }
        impl From<Iicdl> for u8 {
            #[inline(always)]
            fn from(val: Iicdl) -> u8 {
                Iicdl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicintm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicintm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicintm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicintm {
            #[inline(always)]
            fn from(val: u8) -> Iicintm {
                Iicintm::from_bits(val)
            }
        }
        impl From<Iicintm> for u8 {
            #[inline(always)]
            fn from(val: Iicintm) -> u8 {
                Iicintm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicm {
            #[inline(always)]
            fn from(val: u8) -> Iicm {
                Iicm::from_bits(val)
            }
        }
        impl From<Iicm> for u8 {
            #[inline(always)]
            fn from(val: Iicm) -> u8 {
                Iicm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicrstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicrstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicrstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicrstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicrstareq {
                Iicrstareq::from_bits(val)
            }
        }
        impl From<Iicrstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicrstareq) -> u8 {
                Iicrstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicscls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicscls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicscls {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicscls {
            #[inline(always)]
            fn from(val: u8) -> Iicscls {
                Iicscls::from_bits(val)
            }
        }
        impl From<Iicscls> for u8 {
            #[inline(always)]
            fn from(val: Iicscls) -> u8 {
                Iicscls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicsdas {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicsdas {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicsdas {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicsdas {
            #[inline(always)]
            fn from(val: u8) -> Iicsdas {
                Iicsdas::from_bits(val)
            }
        }
        impl From<Iicsdas> for u8 {
            #[inline(always)]
            fn from(val: Iicsdas) -> u8 {
                Iicsdas::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicstareq {
                Iicstareq::from_bits(val)
            }
        }
        impl From<Iicstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicstareq) -> u8 {
                Iicstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstif {
            #[inline(always)]
            fn from(val: u8) -> Iicstif {
                Iicstif::from_bits(val)
            }
        }
        impl From<Iicstif> for u8 {
            #[inline(always)]
            fn from(val: Iicstif) -> u8 {
                Iicstif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstpreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstpreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstpreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstpreq {
            #[inline(always)]
            fn from(val: u8) -> Iicstpreq {
                Iicstpreq::from_bits(val)
            }
        }
        impl From<Iicstpreq> for u8 {
            #[inline(always)]
            fn from(val: Iicstpreq) -> u8 {
                Iicstpreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mff {
            #[inline(always)]
            fn from(val: u8) -> Mff {
                Mff::from_bits(val)
            }
        }
        impl From<Mff> for u8 {
            #[inline(always)]
            fn from(val: Mff) -> u8 {
                Mff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mp {
            #[inline(always)]
            fn from(val: u8) -> Mp {
                Mp::from_bits(val)
            }
        }
        impl From<Mp> for u8 {
            #[inline(always)]
            fn from(val: Mp) -> u8 {
                Mp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpb {
            #[inline(always)]
            fn from(val: u8) -> Mpb {
                Mpb::from_bits(val)
            }
        }
        impl From<Mpb> for u8 {
            #[inline(always)]
            fn from(val: Mpb) -> u8 {
                Mpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpbt {
            #[inline(always)]
            fn from(val: u8) -> Mpbt {
                Mpbt::from_bits(val)
            }
        }
        impl From<Mpbt> for u8 {
            #[inline(always)]
            fn from(val: Mpbt) -> u8 {
                Mpbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpie {
            #[inline(always)]
            fn from(val: u8) -> Mpie {
                Mpie::from_bits(val)
            }
        }
        impl From<Mpie> for u8 {
            #[inline(always)]
            fn from(val: Mpie) -> u8 {
                Mpie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mss {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mss {
            #[inline(always)]
            fn from(val: u8) -> Mss {
                Mss::from_bits(val)
            }
        }
        impl From<Mss> for u8 {
            #[inline(always)]
            fn from(val: Mss) -> u8 {
                Mss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Nfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcs {
            #[inline(always)]
            fn from(val: u8) -> Nfcs {
                Nfcs::from_bits(val)
            }
        }
        impl From<Nfcs> for u8 {
            #[inline(always)]
            fn from(val: Nfcs) -> u8 {
                Nfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfen {
            #[inline(always)]
            fn from(val: u8) -> Nfen {
                Nfen::from_bits(val)
            }
        }
        impl From<Nfen> for u8 {
            #[inline(always)]
            fn from(val: Nfen) -> u8 {
                Nfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdesel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdesel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdesel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdesel {
            #[inline(always)]
            fn from(val: u8) -> Rxdesel {
                Rxdesel::from_bits(val)
            }
        }
        impl From<Rxdesel> for u8 {
            #[inline(always)]
            fn from(val: Rxdesel) -> u8 {
                Rxdesel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdmon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdmon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdmon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdmon {
            #[inline(always)]
            fn from(val: u8) -> Rxdmon {
                Rxdmon::from_bits(val)
            }
        }
        impl From<Rxdmon> for u8 {
            #[inline(always)]
            fn from(val: Rxdmon) -> u8 {
                Rxdmon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrCke {
            #[inline(always)]
            fn from(val: u8) -> ScrCke {
                ScrCke::from_bits(val)
            }
        }
        impl From<ScrCke> for u8 {
            #[inline(always)]
            fn from(val: ScrCke) -> u8 {
                ScrCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRe {
            #[inline(always)]
            fn from(val: u8) -> ScrRe {
                ScrRe::from_bits(val)
            }
        }
        impl From<ScrRe> for u8 {
            #[inline(always)]
            fn from(val: ScrRe) -> u8 {
                ScrRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRie {
            #[inline(always)]
            fn from(val: u8) -> ScrRie {
                ScrRie::from_bits(val)
            }
        }
        impl From<ScrRie> for u8 {
            #[inline(always)]
            fn from(val: ScrRie) -> u8 {
                ScrRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrSmciCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciCke {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciCke {
                ScrSmciCke::from_bits(val)
            }
        }
        impl From<ScrSmciCke> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciCke) -> u8 {
                ScrSmciCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRe {
                ScrSmciRe::from_bits(val)
            }
        }
        impl From<ScrSmciRe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRe) -> u8 {
                ScrSmciRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRie {
                ScrSmciRie::from_bits(val)
            }
        }
        impl From<ScrSmciRie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRie) -> u8 {
                ScrSmciRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTe {
                ScrSmciTe::from_bits(val)
            }
        }
        impl From<ScrSmciTe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTe) -> u8 {
                ScrSmciTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTie {
                ScrSmciTie::from_bits(val)
            }
        }
        impl From<ScrSmciTie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTie) -> u8 {
                ScrSmciTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTe {
            #[inline(always)]
            fn from(val: u8) -> ScrTe {
                ScrTe::from_bits(val)
            }
        }
        impl From<ScrTe> for u8 {
            #[inline(always)]
            fn from(val: ScrTe) -> u8 {
                ScrTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTie {
            #[inline(always)]
            fn from(val: u8) -> ScrTie {
                ScrTie::from_bits(val)
            }
        }
        impl From<ScrTie> for u8 {
            #[inline(always)]
            fn from(val: ScrTie) -> u8 {
                ScrTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdir {
            #[inline(always)]
            fn from(val: u8) -> Sdir {
                Sdir::from_bits(val)
            }
        }
        impl From<Sdir> for u8 {
            #[inline(always)]
            fn from(val: Sdir) -> u8 {
                Sdir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sinv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sinv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sinv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sinv {
            #[inline(always)]
            fn from(val: u8) -> Sinv {
                Sinv::from_bits(val)
            }
        }
        impl From<Sinv> for u8 {
            #[inline(always)]
            fn from(val: Sinv) -> u8 {
                Sinv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smif {
            #[inline(always)]
            fn from(val: u8) -> Smif {
                Smif::from_bits(val)
            }
        }
        impl From<Smif> for u8 {
            #[inline(always)]
            fn from(val: Smif) -> u8 {
                Smif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrCks {
            #[inline(always)]
            fn from(val: u8) -> SmrCks {
                SmrCks::from_bits(val)
            }
        }
        impl From<SmrCks> for u8 {
            #[inline(always)]
            fn from(val: SmrCks) -> u8 {
                SmrCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrPe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrPe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrPe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrPe {
            #[inline(always)]
            fn from(val: u8) -> SmrPe {
                SmrPe::from_bits(val)
            }
        }
        impl From<SmrPe> for u8 {
            #[inline(always)]
            fn from(val: SmrPe) -> u8 {
                SmrPe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrPm {
            #[inline(always)]
            fn from(val: u8) -> SmrPm {
                SmrPm::from_bits(val)
            }
        }
        impl From<SmrPm> for u8 {
            #[inline(always)]
            fn from(val: SmrPm) -> u8 {
                SmrPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrSmciCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciCks {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciCks {
                SmrSmciCks::from_bits(val)
            }
        }
        impl From<SmrSmciCks> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciCks) -> u8 {
                SmrSmciCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciPe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrSmciPe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciPe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciPe {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciPe {
                SmrSmciPe::from_bits(val)
            }
        }
        impl From<SmrSmciPe> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciPe) -> u8 {
                SmrSmciPe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrSmciPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciPm {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciPm {
                SmrSmciPm::from_bits(val)
            }
        }
        impl From<SmrSmciPm> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciPm) -> u8 {
                SmrSmciPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb2dt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spb2dt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb2dt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb2dt {
            #[inline(always)]
            fn from(val: u8) -> Spb2dt {
                Spb2dt::from_bits(val)
            }
        }
        impl From<Spb2dt> for u8 {
            #[inline(always)]
            fn from(val: Spb2dt) -> u8 {
                Spb2dt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb2io {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spb2io {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb2io {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb2io {
            #[inline(always)]
            fn from(val: u8) -> Spb2io {
                Spb2io::from_bits(val)
            }
        }
        impl From<Spb2io> for u8 {
            #[inline(always)]
            fn from(val: Spb2io) -> u8 {
                Spb2io::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sse {
            #[inline(always)]
            fn from(val: u8) -> Sse {
                Sse::from_bits(val)
            }
        }
        impl From<Sse> for u8 {
            #[inline(always)]
            fn from(val: Sse) -> u8 {
                Sse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrOrer {
                SsrOrer::from_bits(val)
            }
        }
        impl From<SsrOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrOrer) -> u8 {
                SsrOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrPer {
            #[inline(always)]
            fn from(val: u8) -> SsrPer {
                SsrPer::from_bits(val)
            }
        }
        impl From<SsrPer> for u8 {
            #[inline(always)]
            fn from(val: SsrPer) -> u8 {
                SsrPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrRdrf {
                SsrRdrf::from_bits(val)
            }
        }
        impl From<SsrRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrRdrf) -> u8 {
                SsrRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciOrer {
                SsrSmciOrer::from_bits(val)
            }
        }
        impl From<SsrSmciOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciOrer) -> u8 {
                SsrSmciOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciPer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciPer {
                SsrSmciPer::from_bits(val)
            }
        }
        impl From<SsrSmciPer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciPer) -> u8 {
                SsrSmciPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciRdrf {
                SsrSmciRdrf::from_bits(val)
            }
        }
        impl From<SsrSmciRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciRdrf) -> u8 {
                SsrSmciRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTdre {
                SsrSmciTdre::from_bits(val)
            }
        }
        impl From<SsrSmciTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTdre) -> u8 {
                SsrSmciTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTend {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTend {
                SsrSmciTend::from_bits(val)
            }
        }
        impl From<SsrSmciTend> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTend) -> u8 {
                SsrSmciTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrTdre {
                SsrTdre::from_bits(val)
            }
        }
        impl From<SsrTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrTdre) -> u8 {
                SsrTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTend {
            #[inline(always)]
            fn from(val: u8) -> SsrTend {
                SsrTend::from_bits(val)
            }
        }
        impl From<SsrTend> for u8 {
            #[inline(always)]
            fn from(val: SsrTend) -> u8 {
                SsrTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stop {
            #[inline(always)]
            fn from(val: u8) -> Stop {
                Stop::from_bits(val)
            }
        }
        impl From<Stop> for u8 {
            #[inline(always)]
            fn from(val: Stop) -> u8 {
                Stop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teie {
            #[inline(always)]
            fn from(val: u8) -> Teie {
                Teie::from_bits(val)
            }
        }
        impl From<Teie> for u8 {
            #[inline(always)]
            fn from(val: Teie) -> u8 {
                Teie::to_bits(val)
            }
        }
    }
}
pub mod sdadc24 {
    #[doc = "24-Bit Sigma,Delta A/D Converter"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sdadc24 {
        ptr: *mut u8,
    }
    unsafe impl Send for Sdadc24 {}
    unsafe impl Sync for Sdadc24 {}
    impl Sdadc24 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Startup Control Register 1"]
        #[inline(always)]
        pub const fn stc1(self) -> crate::common::Reg<regs::Stc1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Startup Control Register 2"]
        #[inline(always)]
        pub const fn stc2(self) -> crate::common::Reg<regs::Stc2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Input Multiplexer %s Setting Register"]
        #[inline(always)]
        pub const fn pgac(self, n: usize) -> crate::common::Reg<regs::Pgac, crate::common::RW> {
            assert!(n < 5usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize + n * 4usize) as _) }
        }
        #[doc = "Sigma,delta A/D Converter Control Register 1"]
        #[inline(always)]
        pub const fn adc1(self) -> crate::common::Reg<regs::Adc1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Sigma,delta A/D Converter Control Register 2"]
        #[inline(always)]
        pub const fn adc2(self) -> crate::common::Reg<regs::Adc2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Sigma,delta A/D Converter Conversion Result Register"]
        #[inline(always)]
        pub const fn adcr(self) -> crate::common::Reg<regs::Adcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Sigma,delta A/D Converter Average Value Register"]
        #[inline(always)]
        pub const fn adar(self) -> crate::common::Reg<regs::Adar, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Calibration Control Register"]
        #[inline(always)]
        pub const fn clbc(self) -> crate::common::Reg<regs::Clbc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Calibration Start Control Register"]
        #[inline(always)]
        pub const fn clbstr(self) -> crate::common::Reg<regs::Clbstr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Calibration Status Register"]
        #[inline(always)]
        pub const fn clbssr(self) -> crate::common::Reg<regs::Clbssr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Sigma,delta A/D Converter Average Value Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adar(pub u32);
        impl Adar {
            #[doc = "These bits are read as 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_0_15(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_0_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "The 24-bit A/D average value"]
            #[inline(always)]
            pub const fn sdadmvd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "The 24-bit A/D average value"]
            #[inline(always)]
            pub fn set_sdadmvd(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "Status of an A/D conversion result"]
            #[inline(always)]
            pub const fn sdadmvs(&self) -> super::vals::Sdadmvs {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Sdadmvs::from_bits(val as u8)
            }
            #[doc = "Status of an A/D conversion result"]
            #[inline(always)]
            pub fn set_sdadmvs(&mut self, val: super::vals::Sdadmvs) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Channel number for an A/D conversion result"]
            #[inline(always)]
            pub const fn sdadmvc(&self) -> super::vals::Sdadmvc {
                let val = (self.0 >> 25usize) & 0x07;
                super::vals::Sdadmvc::from_bits(val as u8)
            }
            #[doc = "Channel number for an A/D conversion result"]
            #[inline(always)]
            pub fn set_sdadmvc(&mut self, val: super::vals::Sdadmvc) {
                self.0 =
                    (self.0 & !(0x07 << 25usize)) | (((val.to_bits() as u32) & 0x07) << 25usize);
            }
            #[doc = "These bits are read as 0000."]
            #[inline(always)]
            pub const fn reserved_28_31(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000."]
            #[inline(always)]
            pub fn set_reserved_28_31(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Adar {
            #[inline(always)]
            fn default() -> Adar {
                Adar(0)
            }
        }
        impl core::fmt::Debug for Adar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adar")
                    .field("reserved_0_15", &self.reserved_0_15())
                    .field("sdadmvd", &self.sdadmvd())
                    .field("sdadmvs", &self.sdadmvs())
                    .field("sdadmvc", &self.sdadmvc())
                    .field("reserved_28_31", &self.reserved_28_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adar {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adar {{ reserved_0_15: {=u16:?}, sdadmvd: {=u32:?}, sdadmvs: {:?}, sdadmvc: {:?}, reserved_28_31: {=u8:?} }}" , self . reserved_0_15 () , self . sdadmvd () , self . sdadmvs () , self . sdadmvc () , self . reserved_28_31 ())
            }
        }
        #[doc = "Sigma,delta A/D Converter Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adc1(pub u32);
        impl Adc1 {
            #[doc = "Selection of autoscan mode"]
            #[inline(always)]
            pub const fn sdadscm(&self) -> super::vals::Sdadscm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sdadscm::from_bits(val as u8)
            }
            #[doc = "Selection of autoscan mode"]
            #[inline(always)]
            pub fn set_sdadscm(&mut self, val: super::vals::Sdadscm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_1_3(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_1_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u32) & 0x07) << 1usize);
            }
            #[doc = "Selection of A/D conversion trigger signal"]
            #[inline(always)]
            pub const fn sdadtmd(&self) -> super::vals::Sdadtmd {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sdadtmd::from_bits(val as u8)
            }
            #[doc = "Selection of A/D conversion trigger signal"]
            #[inline(always)]
            pub fn set_sdadtmd(&mut self, val: super::vals::Sdadtmd) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u32) & 0x07) << 5usize);
            }
            #[doc = "A/D conversion control of the signal from input multiplexer"]
            #[inline(always)]
            pub const fn sdadbmp(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "A/D conversion control of the signal from input multiplexer"]
            #[inline(always)]
            pub fn set_sdadbmp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_13_15(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_13_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u32) & 0x07) << 13usize);
            }
            #[doc = "Control of disconnection detection"]
            #[inline(always)]
            pub const fn pgadisa(&self) -> super::vals::Pgadisa {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pgadisa::from_bits(val as u8)
            }
            #[doc = "Control of disconnection detection"]
            #[inline(always)]
            pub fn set_pgadisa(&mut self, val: super::vals::Pgadisa) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Disconnection Detection Assist Setting"]
            #[inline(always)]
            pub const fn pgadisc(&self) -> super::vals::Pgadisc {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pgadisc::from_bits(val as u8)
            }
            #[doc = "Disconnection Detection Assist Setting"]
            #[inline(always)]
            pub fn set_pgadisc(&mut self, val: super::vals::Pgadisc) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_18_19(&self) -> u8 {
                let val = (self.0 >> 18usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_18_19(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 18usize)) | (((val as u32) & 0x03) << 18usize);
            }
            #[doc = "PGA offset self,diagnosis enable"]
            #[inline(always)]
            pub const fn pgaslft(&self) -> super::vals::Pgaslft {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pgaslft::from_bits(val as u8)
            }
            #[doc = "PGA offset self,diagnosis enable"]
            #[inline(always)]
            pub fn set_pgaslft(&mut self, val: super::vals::Pgaslft) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub const fn reserved_21_31(&self) -> u16 {
                let val = (self.0 >> 21usize) & 0x07ff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000. The write value should be 00000000000."]
            #[inline(always)]
            pub fn set_reserved_21_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 21usize)) | (((val as u32) & 0x07ff) << 21usize);
            }
        }
        impl Default for Adc1 {
            #[inline(always)]
            fn default() -> Adc1 {
                Adc1(0)
            }
        }
        impl core::fmt::Debug for Adc1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adc1")
                    .field("sdadscm", &self.sdadscm())
                    .field("reserved_1_3", &self.reserved_1_3())
                    .field("sdadtmd", &self.sdadtmd())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .field("sdadbmp", &self.sdadbmp())
                    .field("reserved_13_15", &self.reserved_13_15())
                    .field("pgadisa", &self.pgadisa())
                    .field("pgadisc", &self.pgadisc())
                    .field("reserved_18_19", &self.reserved_18_19())
                    .field("pgaslft", &self.pgaslft())
                    .field("reserved_21_31", &self.reserved_21_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adc1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adc1 {{ sdadscm: {:?}, reserved_1_3: {=u8:?}, sdadtmd: {:?}, reserved_5_7: {=u8:?}, sdadbmp: {=u8:?}, reserved_13_15: {=u8:?}, pgadisa: {:?}, pgadisc: {:?}, reserved_18_19: {=u8:?}, pgaslft: {:?}, reserved_21_31: {=u16:?} }}" , self . sdadscm () , self . reserved_1_3 () , self . sdadtmd () , self . reserved_5_7 () , self . sdadbmp () , self . reserved_13_15 () , self . pgadisa () , self . pgadisc () , self . reserved_18_19 () , self . pgaslft () , self . reserved_21_31 ())
            }
        }
        #[doc = "Sigma,delta A/D Converter Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adc2(pub u8);
        impl Adc2 {
            #[doc = "Control of A/D conversion"]
            #[inline(always)]
            pub const fn sdadst(&self) -> super::vals::Sdadst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sdadst::from_bits(val as u8)
            }
            #[doc = "Control of A/D conversion"]
            #[inline(always)]
            pub fn set_sdadst(&mut self, val: super::vals::Sdadst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Adc2 {
            #[inline(always)]
            fn default() -> Adc2 {
                Adc2(0)
            }
        }
        impl core::fmt::Debug for Adc2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adc2")
                    .field("sdadst", &self.sdadst())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adc2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adc2 {{ sdadst: {:?}, reserved_1_7: {=u8:?} }}",
                    self.sdadst(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "Sigma,delta A/D Converter Conversion Result Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcr(pub u32);
        impl Adcr {
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub const fn reserved_0_15(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000000. The write value should be 0000000000000000."]
            #[inline(always)]
            pub fn set_reserved_0_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "The 24-bit A/D conversion result"]
            #[inline(always)]
            pub const fn sdadcrd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "The 24-bit A/D conversion result"]
            #[inline(always)]
            pub fn set_sdadcrd(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "Status of an A/D conversion result"]
            #[inline(always)]
            pub const fn sdadcrs(&self) -> super::vals::Sdadcrs {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Sdadcrs::from_bits(val as u8)
            }
            #[doc = "Status of an A/D conversion result"]
            #[inline(always)]
            pub fn set_sdadcrs(&mut self, val: super::vals::Sdadcrs) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Channel number for an A/D conversion result"]
            #[inline(always)]
            pub const fn sdadcrc(&self) -> super::vals::Sdadcrc {
                let val = (self.0 >> 25usize) & 0x07;
                super::vals::Sdadcrc::from_bits(val as u8)
            }
            #[doc = "Channel number for an A/D conversion result"]
            #[inline(always)]
            pub fn set_sdadcrc(&mut self, val: super::vals::Sdadcrc) {
                self.0 =
                    (self.0 & !(0x07 << 25usize)) | (((val.to_bits() as u32) & 0x07) << 25usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_28_31(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_28_31(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Adcr {
            #[inline(always)]
            fn default() -> Adcr {
                Adcr(0)
            }
        }
        impl core::fmt::Debug for Adcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcr")
                    .field("reserved_0_15", &self.reserved_0_15())
                    .field("sdadcrd", &self.sdadcrd())
                    .field("sdadcrs", &self.sdadcrs())
                    .field("sdadcrc", &self.sdadcrc())
                    .field("reserved_28_31", &self.reserved_28_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcr {{ reserved_0_15: {=u16:?}, sdadcrd: {=u32:?}, sdadcrs: {:?}, sdadcrc: {:?}, reserved_28_31: {=u8:?} }}" , self . reserved_0_15 () , self . sdadcrd () , self . sdadcrs () , self . sdadcrc () , self . reserved_28_31 ())
            }
        }
        #[doc = "Calibration Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clbc(pub u8);
        impl Clbc {
            #[doc = "These bits are read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn clbmd(&self) -> super::vals::Clbmd {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Clbmd::from_bits(val as u8)
            }
            #[doc = "These bits are read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_clbmd(&mut self, val: super::vals::Clbmd) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Clbc {
            #[inline(always)]
            fn default() -> Clbc {
                Clbc(0)
            }
        }
        impl core::fmt::Debug for Clbc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clbc")
                    .field("clbmd", &self.clbmd())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clbc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clbc {{ clbmd: {:?}, reserved_2_7: {=u8:?} }}",
                    self.clbmd(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "Calibration Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clbssr(pub u8);
        impl Clbssr {
            #[doc = "Calibration status"]
            #[inline(always)]
            pub const fn clbss(&self) -> super::vals::Clbss {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Clbss::from_bits(val as u8)
            }
            #[doc = "Calibration status"]
            #[inline(always)]
            pub fn set_clbss(&mut self, val: super::vals::Clbss) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Clbssr {
            #[inline(always)]
            fn default() -> Clbssr {
                Clbssr(0)
            }
        }
        impl core::fmt::Debug for Clbssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clbssr")
                    .field("clbss", &self.clbss())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clbssr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clbssr {{ clbss: {:?}, reserved_1_7: {=u8:?} }}",
                    self.clbss(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "Calibration Start Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clbstr(pub u8);
        impl Clbstr {
            #[doc = "Calibration start control"]
            #[inline(always)]
            pub const fn clbst(&self) -> super::vals::Clbst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Clbst::from_bits(val as u8)
            }
            #[doc = "Calibration start control"]
            #[inline(always)]
            pub fn set_clbst(&mut self, val: super::vals::Clbst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Clbstr {
            #[inline(always)]
            fn default() -> Clbstr {
                Clbstr(0)
            }
        }
        impl core::fmt::Debug for Clbstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clbstr")
                    .field("clbst", &self.clbst())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clbstr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clbstr {{ clbst: {:?}, reserved_1_7: {=u8:?} }}",
                    self.clbst(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "Input Multiplexer %s Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pgac(pub u32);
        impl Pgac {
            #[doc = "Gain selection of a programmable gain instrumentation amplifier ( Gset1, Gset2, Gtotal )"]
            #[inline(always)]
            pub const fn pgagc(&self) -> super::vals::Pgagc {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Pgagc::from_bits(val as u8)
            }
            #[doc = "Gain selection of a programmable gain instrumentation amplifier ( Gset1, Gset2, Gtotal )"]
            #[inline(always)]
            pub fn set_pgagc(&mut self, val: super::vals::Pgagc) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "Oversampling ratio select"]
            #[inline(always)]
            pub const fn pgaosr(&self) -> super::vals::Pgaosr {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::Pgaosr::from_bits(val as u8)
            }
            #[doc = "Oversampling ratio select"]
            #[inline(always)]
            pub fn set_pgaosr(&mut self, val: super::vals::Pgaosr) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u32) & 0x07) << 5usize);
            }
            #[doc = "Offset voltage select"]
            #[inline(always)]
            pub const fn pgaofs(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "Offset voltage select"]
            #[inline(always)]
            pub fn set_pgaofs(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_13_13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_13_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Polarity select"]
            #[inline(always)]
            pub const fn pgapol(&self) -> super::vals::Pgapol {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pgapol::from_bits(val as u8)
            }
            #[doc = "Polarity select"]
            #[inline(always)]
            pub fn set_pgapol(&mut self, val: super::vals::Pgapol) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Channel Input Mode Select"]
            #[inline(always)]
            pub const fn pgasel(&self) -> super::vals::Pgasel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pgasel::from_bits(val as u8)
            }
            #[doc = "Analog Channel Input Mode Select"]
            #[inline(always)]
            pub fn set_pgasel(&mut self, val: super::vals::Pgasel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Coefficient (m) selection of the A/D conversion count (N) in AUTOSCAN"]
            #[inline(always)]
            pub const fn pgactm(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "Coefficient (m) selection of the A/D conversion count (N) in AUTOSCAN"]
            #[inline(always)]
            pub fn set_pgactm(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
            #[doc = "Coefficient (n) selection of the A/D conversion count (N) in AUTOSCAN"]
            #[inline(always)]
            pub const fn pgactn(&self) -> super::vals::Pgactn {
                let val = (self.0 >> 21usize) & 0x07;
                super::vals::Pgactn::from_bits(val as u8)
            }
            #[doc = "Coefficient (n) selection of the A/D conversion count (N) in AUTOSCAN"]
            #[inline(always)]
            pub fn set_pgactn(&mut self, val: super::vals::Pgactn) {
                self.0 =
                    (self.0 & !(0x07 << 21usize)) | (((val.to_bits() as u32) & 0x07) << 21usize);
            }
            #[doc = "Selection of the number of data to be averaged"]
            #[inline(always)]
            pub const fn pgaavn(&self) -> super::vals::Pgaavn {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Pgaavn::from_bits(val as u8)
            }
            #[doc = "Selection of the number of data to be averaged"]
            #[inline(always)]
            pub fn set_pgaavn(&mut self, val: super::vals::Pgaavn) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Selection of averaging processing"]
            #[inline(always)]
            pub const fn pgaave(&self) -> super::vals::Pgaave {
                let val = (self.0 >> 26usize) & 0x03;
                super::vals::Pgaave::from_bits(val as u8)
            }
            #[doc = "Selection of averaging processing"]
            #[inline(always)]
            pub fn set_pgaave(&mut self, val: super::vals::Pgaave) {
                self.0 =
                    (self.0 & !(0x03 << 26usize)) | (((val.to_bits() as u32) & 0x03) << 26usize);
            }
            #[doc = "Single,End Input A/D Converted Data Inversion Select"]
            #[inline(always)]
            pub const fn pgarev(&self) -> super::vals::Pgarev {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pgarev::from_bits(val as u8)
            }
            #[doc = "Single,End Input A/D Converted Data Inversion Select"]
            #[inline(always)]
            pub fn set_pgarev(&mut self, val: super::vals::Pgarev) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_29_29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_29_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Calibration enable"]
            #[inline(always)]
            pub const fn pgacve(&self) -> super::vals::Pgacve {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pgacve::from_bits(val as u8)
            }
            #[doc = "Calibration enable"]
            #[inline(always)]
            pub fn set_pgacve(&mut self, val: super::vals::Pgacve) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Selection of the mode for specifying the number of A/D conversions in ADSCAN"]
            #[inline(always)]
            pub const fn pgaasn(&self) -> super::vals::Pgaasn {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pgaasn::from_bits(val as u8)
            }
            #[doc = "Selection of the mode for specifying the number of A/D conversions in ADSCAN"]
            #[inline(always)]
            pub fn set_pgaasn(&mut self, val: super::vals::Pgaasn) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pgac {
            #[inline(always)]
            fn default() -> Pgac {
                Pgac(0)
            }
        }
        impl core::fmt::Debug for Pgac {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pgac")
                    .field("pgagc", &self.pgagc())
                    .field("pgaosr", &self.pgaosr())
                    .field("pgaofs", &self.pgaofs())
                    .field("reserved_13_13", &self.reserved_13_13())
                    .field("pgapol", &self.pgapol())
                    .field("pgasel", &self.pgasel())
                    .field("pgactm", &self.pgactm())
                    .field("pgactn", &self.pgactn())
                    .field("pgaavn", &self.pgaavn())
                    .field("pgaave", &self.pgaave())
                    .field("pgarev", &self.pgarev())
                    .field("reserved_29_29", &self.reserved_29_29())
                    .field("pgacve", &self.pgacve())
                    .field("pgaasn", &self.pgaasn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pgac {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pgac {{ pgagc: {:?}, pgaosr: {:?}, pgaofs: {=u8:?}, reserved_13_13: {=bool:?}, pgapol: {:?}, pgasel: {:?}, pgactm: {=u8:?}, pgactn: {:?}, pgaavn: {:?}, pgaave: {:?}, pgarev: {:?}, reserved_29_29: {=bool:?}, pgacve: {:?}, pgaasn: {:?} }}" , self . pgagc () , self . pgaosr () , self . pgaofs () , self . reserved_13_13 () , self . pgapol () , self . pgasel () , self . pgactm () , self . pgactn () , self . pgaavn () , self . pgaave () , self . pgarev () , self . reserved_29_29 () , self . pgacve () , self . pgaasn ())
            }
        }
        #[doc = "Startup Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Stc1(pub u16);
        impl Stc1 {
            #[doc = "SDADC24 reference clock division select"]
            #[inline(always)]
            pub const fn clkdiv(&self) -> super::vals::Clkdiv {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Clkdiv::from_bits(val as u8)
            }
            #[doc = "SDADC24 reference clock division select"]
            #[inline(always)]
            pub fn set_clkdiv(&mut self, val: super::vals::Clkdiv) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_4_6(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_4_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u16) & 0x07) << 4usize);
            }
            #[doc = "A/D conversion operation mode select"]
            #[inline(always)]
            pub const fn sdadlpm(&self) -> super::vals::Sdadlpm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sdadlpm::from_bits(val as u8)
            }
            #[doc = "A/D conversion operation mode select"]
            #[inline(always)]
            pub fn set_sdadlpm(&mut self, val: super::vals::Sdadlpm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Reference voltage select"]
            #[inline(always)]
            pub const fn vsbias(&self) -> super::vals::Vsbias {
                let val = (self.0 >> 8usize) & 0x0f;
                super::vals::Vsbias::from_bits(val as u8)
            }
            #[doc = "Reference voltage select"]
            #[inline(always)]
            pub fn set_vsbias(&mut self, val: super::vals::Vsbias) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u16) & 0x0f) << 8usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_12_14(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_12_14(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 12usize)) | (((val as u16) & 0x07) << 12usize);
            }
            #[doc = "VREF mode select"]
            #[inline(always)]
            pub const fn vrefsel(&self) -> super::vals::Vrefsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Vrefsel::from_bits(val as u8)
            }
            #[doc = "VREF mode select"]
            #[inline(always)]
            pub fn set_vrefsel(&mut self, val: super::vals::Vrefsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Stc1 {
            #[inline(always)]
            fn default() -> Stc1 {
                Stc1(0)
            }
        }
        impl core::fmt::Debug for Stc1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Stc1")
                    .field("clkdiv", &self.clkdiv())
                    .field("reserved_4_6", &self.reserved_4_6())
                    .field("sdadlpm", &self.sdadlpm())
                    .field("vsbias", &self.vsbias())
                    .field("reserved_12_14", &self.reserved_12_14())
                    .field("vrefsel", &self.vrefsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Stc1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Stc1 {{ clkdiv: {:?}, reserved_4_6: {=u8:?}, sdadlpm: {:?}, vsbias: {:?}, reserved_12_14: {=u8:?}, vrefsel: {:?} }}" , self . clkdiv () , self . reserved_4_6 () , self . sdadlpm () , self . vsbias () , self . reserved_12_14 () , self . vrefsel ())
            }
        }
        #[doc = "Startup Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Stc2(pub u8);
        impl Stc2 {
            #[doc = "BGR part power control"]
            #[inline(always)]
            pub const fn bgrpon(&self) -> super::vals::Bgrpon {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bgrpon::from_bits(val as u8)
            }
            #[doc = "BGR part power control"]
            #[inline(always)]
            pub fn set_bgrpon(&mut self, val: super::vals::Bgrpon) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "ADC reference supply part power control"]
            #[inline(always)]
            pub const fn adcpon(&self) -> super::vals::Adcpon {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Adcpon::from_bits(val as u8)
            }
            #[doc = "ADC reference supply part power control"]
            #[inline(always)]
            pub fn set_adcpon(&mut self, val: super::vals::Adcpon) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "ADREG forced power,down mode"]
            #[inline(always)]
            pub const fn adfpwds(&self) -> super::vals::Adfpwds {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Adfpwds::from_bits(val as u8)
            }
            #[doc = "ADREG forced power,down mode"]
            #[inline(always)]
            pub fn set_adfpwds(&mut self, val: super::vals::Adfpwds) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Stc2 {
            #[inline(always)]
            fn default() -> Stc2 {
                Stc2(0)
            }
        }
        impl core::fmt::Debug for Stc2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Stc2")
                    .field("bgrpon", &self.bgrpon())
                    .field("adcpon", &self.adcpon())
                    .field("adfpwds", &self.adfpwds())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Stc2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Stc2 {{ bgrpon: {:?}, adcpon: {:?}, adfpwds: {:?}, reserved_3_7: {=u8:?} }}",
                    self.bgrpon(),
                    self.adcpon(),
                    self.adfpwds(),
                    self.reserved_3_7()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adcpon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adcpon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adcpon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adcpon {
            #[inline(always)]
            fn from(val: u8) -> Adcpon {
                Adcpon::from_bits(val)
            }
        }
        impl From<Adcpon> for u8 {
            #[inline(always)]
            fn from(val: Adcpon) -> u8 {
                Adcpon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adfpwds {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adfpwds {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adfpwds {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adfpwds {
            #[inline(always)]
            fn from(val: u8) -> Adfpwds {
                Adfpwds::from_bits(val)
            }
        }
        impl From<Adfpwds> for u8 {
            #[inline(always)]
            fn from(val: Adfpwds) -> u8 {
                Adfpwds::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bgrpon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bgrpon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bgrpon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bgrpon {
            #[inline(always)]
            fn from(val: u8) -> Bgrpon {
                Bgrpon::from_bits(val)
            }
        }
        impl From<Bgrpon> for u8 {
            #[inline(always)]
            fn from(val: Bgrpon) -> u8 {
                Bgrpon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clbmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Clbmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clbmd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clbmd {
            #[inline(always)]
            fn from(val: u8) -> Clbmd {
                Clbmd::from_bits(val)
            }
        }
        impl From<Clbmd> for u8 {
            #[inline(always)]
            fn from(val: Clbmd) -> u8 {
                Clbmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clbss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clbss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clbss {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clbss {
            #[inline(always)]
            fn from(val: u8) -> Clbss {
                Clbss::from_bits(val)
            }
        }
        impl From<Clbss> for u8 {
            #[inline(always)]
            fn from(val: Clbss) -> u8 {
                Clbss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clbst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clbst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clbst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clbst {
            #[inline(always)]
            fn from(val: u8) -> Clbst {
                Clbst::from_bits(val)
            }
        }
        impl From<Clbst> for u8 {
            #[inline(always)]
            fn from(val: Clbst) -> u8 {
                Clbst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clkdiv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Clkdiv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clkdiv {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clkdiv {
            #[inline(always)]
            fn from(val: u8) -> Clkdiv {
                Clkdiv::from_bits(val)
            }
        }
        impl From<Clkdiv> for u8 {
            #[inline(always)]
            fn from(val: Clkdiv) -> u8 {
                Clkdiv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgaasn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgaasn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgaasn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgaasn {
            #[inline(always)]
            fn from(val: u8) -> Pgaasn {
                Pgaasn::from_bits(val)
            }
        }
        impl From<Pgaasn> for u8 {
            #[inline(always)]
            fn from(val: Pgaasn) -> u8 {
                Pgaasn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgaave {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Pgaave {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgaave {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgaave {
            #[inline(always)]
            fn from(val: u8) -> Pgaave {
                Pgaave::from_bits(val)
            }
        }
        impl From<Pgaave> for u8 {
            #[inline(always)]
            fn from(val: Pgaave) -> u8 {
                Pgaave::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgaavn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Pgaavn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgaavn {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgaavn {
            #[inline(always)]
            fn from(val: u8) -> Pgaavn {
                Pgaavn::from_bits(val)
            }
        }
        impl From<Pgaavn> for u8 {
            #[inline(always)]
            fn from(val: Pgaavn) -> u8 {
                Pgaavn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgactn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Pgactn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgactn {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgactn {
            #[inline(always)]
            fn from(val: u8) -> Pgactn {
                Pgactn::from_bits(val)
            }
        }
        impl From<Pgactn> for u8 {
            #[inline(always)]
            fn from(val: Pgactn) -> u8 {
                Pgactn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgacve {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgacve {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgacve {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgacve {
            #[inline(always)]
            fn from(val: u8) -> Pgacve {
                Pgacve::from_bits(val)
            }
        }
        impl From<Pgacve> for u8 {
            #[inline(always)]
            fn from(val: Pgacve) -> u8 {
                Pgacve::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgadisa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgadisa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgadisa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgadisa {
            #[inline(always)]
            fn from(val: u8) -> Pgadisa {
                Pgadisa::from_bits(val)
            }
        }
        impl From<Pgadisa> for u8 {
            #[inline(always)]
            fn from(val: Pgadisa) -> u8 {
                Pgadisa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgadisc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgadisc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgadisc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgadisc {
            #[inline(always)]
            fn from(val: u8) -> Pgadisc {
                Pgadisc::from_bits(val)
            }
        }
        impl From<Pgadisc> for u8 {
            #[inline(always)]
            fn from(val: Pgadisc) -> u8 {
                Pgadisc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgagc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Pgagc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgagc {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgagc {
            #[inline(always)]
            fn from(val: u8) -> Pgagc {
                Pgagc::from_bits(val)
            }
        }
        impl From<Pgagc> for u8 {
            #[inline(always)]
            fn from(val: Pgagc) -> u8 {
                Pgagc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgaosr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Pgaosr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgaosr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgaosr {
            #[inline(always)]
            fn from(val: u8) -> Pgaosr {
                Pgaosr::from_bits(val)
            }
        }
        impl From<Pgaosr> for u8 {
            #[inline(always)]
            fn from(val: Pgaosr) -> u8 {
                Pgaosr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgapol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgapol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgapol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgapol {
            #[inline(always)]
            fn from(val: u8) -> Pgapol {
                Pgapol::from_bits(val)
            }
        }
        impl From<Pgapol> for u8 {
            #[inline(always)]
            fn from(val: Pgapol) -> u8 {
                Pgapol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgarev {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgarev {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgarev {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgarev {
            #[inline(always)]
            fn from(val: u8) -> Pgarev {
                Pgarev::from_bits(val)
            }
        }
        impl From<Pgarev> for u8 {
            #[inline(always)]
            fn from(val: Pgarev) -> u8 {
                Pgarev::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgasel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgasel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgasel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgasel {
            #[inline(always)]
            fn from(val: u8) -> Pgasel {
                Pgasel::from_bits(val)
            }
        }
        impl From<Pgasel> for u8 {
            #[inline(always)]
            fn from(val: Pgasel) -> u8 {
                Pgasel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgaslft {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgaslft {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgaslft {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgaslft {
            #[inline(always)]
            fn from(val: u8) -> Pgaslft {
                Pgaslft::from_bits(val)
            }
        }
        impl From<Pgaslft> for u8 {
            #[inline(always)]
            fn from(val: Pgaslft) -> u8 {
                Pgaslft::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadcrc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sdadcrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadcrc {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadcrc {
            #[inline(always)]
            fn from(val: u8) -> Sdadcrc {
                Sdadcrc::from_bits(val)
            }
        }
        impl From<Sdadcrc> for u8 {
            #[inline(always)]
            fn from(val: Sdadcrc) -> u8 {
                Sdadcrc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadcrs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdadcrs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadcrs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadcrs {
            #[inline(always)]
            fn from(val: u8) -> Sdadcrs {
                Sdadcrs::from_bits(val)
            }
        }
        impl From<Sdadcrs> for u8 {
            #[inline(always)]
            fn from(val: Sdadcrs) -> u8 {
                Sdadcrs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadlpm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdadlpm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadlpm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadlpm {
            #[inline(always)]
            fn from(val: u8) -> Sdadlpm {
                Sdadlpm::from_bits(val)
            }
        }
        impl From<Sdadlpm> for u8 {
            #[inline(always)]
            fn from(val: Sdadlpm) -> u8 {
                Sdadlpm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadmvc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sdadmvc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadmvc {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadmvc {
            #[inline(always)]
            fn from(val: u8) -> Sdadmvc {
                Sdadmvc::from_bits(val)
            }
        }
        impl From<Sdadmvc> for u8 {
            #[inline(always)]
            fn from(val: Sdadmvc) -> u8 {
                Sdadmvc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadmvs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdadmvs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadmvs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadmvs {
            #[inline(always)]
            fn from(val: u8) -> Sdadmvs {
                Sdadmvs::from_bits(val)
            }
        }
        impl From<Sdadmvs> for u8 {
            #[inline(always)]
            fn from(val: Sdadmvs) -> u8 {
                Sdadmvs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadscm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdadscm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadscm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadscm {
            #[inline(always)]
            fn from(val: u8) -> Sdadscm {
                Sdadscm::from_bits(val)
            }
        }
        impl From<Sdadscm> for u8 {
            #[inline(always)]
            fn from(val: Sdadscm) -> u8 {
                Sdadscm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdadst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadst {
            #[inline(always)]
            fn from(val: u8) -> Sdadst {
                Sdadst::from_bits(val)
            }
        }
        impl From<Sdadst> for u8 {
            #[inline(always)]
            fn from(val: Sdadst) -> u8 {
                Sdadst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadtmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdadtmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadtmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadtmd {
            #[inline(always)]
            fn from(val: u8) -> Sdadtmd {
                Sdadtmd::from_bits(val)
            }
        }
        impl From<Sdadtmd> for u8 {
            #[inline(always)]
            fn from(val: Sdadtmd) -> u8 {
                Sdadtmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vrefsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vrefsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vrefsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vrefsel {
            #[inline(always)]
            fn from(val: u8) -> Vrefsel {
                Vrefsel::from_bits(val)
            }
        }
        impl From<Vrefsel> for u8 {
            #[inline(always)]
            fn from(val: Vrefsel) -> u8 {
                Vrefsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vsbias {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Vsbias {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vsbias {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vsbias {
            #[inline(always)]
            fn from(val: u8) -> Vsbias {
                Vsbias::from_bits(val)
            }
        }
        impl From<Vsbias> for u8 {
            #[inline(always)]
            fn from(val: Vsbias) -> u8 {
                Vsbias::to_bits(val)
            }
        }
    }
}
pub mod smpu {
    #[doc = "Bus Slave MPU"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Smpu {
        ptr: *mut u8,
    }
    unsafe impl Send for Smpu {}
    unsafe impl Sync for Smpu {}
    impl Smpu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Slave MPU Control Register"]
        #[inline(always)]
        pub const fn smpuctl(self) -> crate::common::Reg<regs::Smpuctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Access Control Register for MBIU"]
        #[inline(always)]
        pub const fn smpumbiu(self) -> crate::common::Reg<regs::Smpumbiu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Access Control Register for FBIU"]
        #[inline(always)]
        pub const fn smpufbiu(self) -> crate::common::Reg<regs::Smpufbiu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Access Control Register for SRAM"]
        #[inline(always)]
        pub const fn smpusram0(self) -> crate::common::Reg<regs::Smpusram0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Access Control Register for P%sBIU"]
        #[inline(always)]
        pub const fn smpupbiu(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Smpupbiu, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Slave MPU Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpuctl(pub u16);
        impl Smpuctl {
            #[doc = "Operation after detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::Oad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Oad::from_bits(val as u8)
            }
            #[doc = "Operation after detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::Oad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Protection of register"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::Protect {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Protect::from_bits(val as u8)
            }
            #[doc = "Protection of register"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::Protect) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u16) & 0x3f) << 2usize);
            }
            #[doc = "Key Code This bit is used to enable or disable writing of the PROTECT and OAD bit."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::Key {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::Key::from_bits(val as u8)
            }
            #[doc = "Key Code This bit is used to enable or disable writing of the PROTECT and OAD bit."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::Key) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Smpuctl {
            #[inline(always)]
            fn default() -> Smpuctl {
                Smpuctl(0)
            }
        }
        impl core::fmt::Debug for Smpuctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpuctl")
                    .field("oad", &self.oad())
                    .field("protect", &self.protect())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpuctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpuctl {{ oad: {:?}, protect: {:?}, reserved_2_7: {=u8:?}, key: {:?} }}",
                    self.oad(),
                    self.protect(),
                    self.reserved_2_7(),
                    self.key()
                )
            }
        }
        #[doc = "Access Control Register for FBIU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpufbiu(pub u16);
        impl Smpufbiu {
            #[doc = "CPU Read protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::SmpufbiuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SmpufbiuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::SmpufbiuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::SmpufbiuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::SmpufbiuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::SmpufbiuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master Group A Read protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::SmpufbiuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SmpufbiuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master Group A Read protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::SmpufbiuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master Group A Write protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::SmpufbiuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SmpufbiuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master Group A Write protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::SmpufbiuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub const fn reserved_4_15(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub fn set_reserved_4_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u16) & 0x0fff) << 4usize);
            }
        }
        impl Default for Smpufbiu {
            #[inline(always)]
            fn default() -> Smpufbiu {
                Smpufbiu(0)
            }
        }
        impl core::fmt::Debug for Smpufbiu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpufbiu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .field("reserved_4_15", &self.reserved_4_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpufbiu {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smpufbiu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?}, reserved_4_15: {=u16:?} }}" , self . rpcpu () , self . wpcpu () , self . rpgrpa () , self . wpgrpa () , self . reserved_4_15 ())
            }
        }
        #[doc = "Access Control Register for MBIU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpumbiu(pub u16);
        impl Smpumbiu {
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_0_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_0_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u16) & 0x03) << 0usize);
            }
            #[doc = "Master Group A Read protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::SmpumbiuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SmpumbiuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master Group A Read protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::SmpumbiuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master Group A Write protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::SmpumbiuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SmpumbiuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master Group A Write protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::SmpumbiuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub const fn reserved_4_15(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub fn set_reserved_4_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u16) & 0x0fff) << 4usize);
            }
        }
        impl Default for Smpumbiu {
            #[inline(always)]
            fn default() -> Smpumbiu {
                Smpumbiu(0)
            }
        }
        impl core::fmt::Debug for Smpumbiu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpumbiu")
                    .field("reserved_0_1", &self.reserved_0_1())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .field("reserved_4_15", &self.reserved_4_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpumbiu {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smpumbiu {{ reserved_0_1: {=u8:?}, rpgrpa: {:?}, wpgrpa: {:?}, reserved_4_15: {=u16:?} }}" , self . reserved_0_1 () , self . rpgrpa () , self . wpgrpa () , self . reserved_4_15 ())
            }
        }
        #[doc = "Access Control Register for P%sBIU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpupbiu(pub u16);
        impl Smpupbiu {
            #[doc = "CPU Read protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::SmpupbiuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SmpupbiuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::SmpupbiuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::SmpupbiuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::SmpupbiuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::SmpupbiuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master Group A Read protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::SmpupbiuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SmpupbiuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master Group A Read protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::SmpupbiuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master Group A Write protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::SmpupbiuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SmpupbiuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master Group A Write protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::SmpupbiuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub const fn reserved_4_15(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub fn set_reserved_4_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u16) & 0x0fff) << 4usize);
            }
        }
        impl Default for Smpupbiu {
            #[inline(always)]
            fn default() -> Smpupbiu {
                Smpupbiu(0)
            }
        }
        impl core::fmt::Debug for Smpupbiu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpupbiu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .field("reserved_4_15", &self.reserved_4_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpupbiu {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smpupbiu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?}, reserved_4_15: {=u16:?} }}" , self . rpcpu () , self . wpcpu () , self . rpgrpa () , self . wpgrpa () , self . reserved_4_15 ())
            }
        }
        #[doc = "Access Control Register for SRAM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpusram0(pub u16);
        impl Smpusram0 {
            #[doc = "CPU Read protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::Smpusram0Rpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smpusram0Rpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::Smpusram0Rpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::Smpusram0Wpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Smpusram0Wpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::Smpusram0Wpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master Group A Read protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::Smpusram0Rpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Smpusram0Rpgrpa::from_bits(val as u8)
            }
            #[doc = "Master Group A Read protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::Smpusram0Rpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master Group A Write protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::Smpusram0Wpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smpusram0Wpgrpa::from_bits(val as u8)
            }
            #[doc = "Master Group A Write protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::Smpusram0Wpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub const fn reserved_4_15(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub fn set_reserved_4_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u16) & 0x0fff) << 4usize);
            }
        }
        impl Default for Smpusram0 {
            #[inline(always)]
            fn default() -> Smpusram0 {
                Smpusram0(0)
            }
        }
        impl core::fmt::Debug for Smpusram0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpusram0")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .field("reserved_4_15", &self.reserved_4_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpusram0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smpusram0 {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?}, reserved_4_15: {=u16:?} }}" , self . rpcpu () , self . wpcpu () , self . rpgrpa () , self . wpgrpa () , self . reserved_4_15 ())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Key(u8);
        impl Key {}
        impl Key {
            pub const fn from_bits(val: u8) -> Key {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Key {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Key {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Key {
            #[inline(always)]
            fn from(val: u8) -> Key {
                Key::from_bits(val)
            }
        }
        impl From<Key> for u8 {
            #[inline(always)]
            fn from(val: Key) -> u8 {
                Key::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oad {
            #[inline(always)]
            fn from(val: u8) -> Oad {
                Oad::from_bits(val)
            }
        }
        impl From<Oad> for u8 {
            #[inline(always)]
            fn from(val: Oad) -> u8 {
                Oad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Protect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Protect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Protect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Protect {
            #[inline(always)]
            fn from(val: u8) -> Protect {
                Protect::from_bits(val)
            }
        }
        impl From<Protect> for u8 {
            #[inline(always)]
            fn from(val: Protect) -> u8 {
                Protect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuRpcpu {
                SmpufbiuRpcpu::from_bits(val)
            }
        }
        impl From<SmpufbiuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuRpcpu) -> u8 {
                SmpufbiuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuRpgrpa {
                SmpufbiuRpgrpa::from_bits(val)
            }
        }
        impl From<SmpufbiuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuRpgrpa) -> u8 {
                SmpufbiuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuWpcpu {
                SmpufbiuWpcpu::from_bits(val)
            }
        }
        impl From<SmpufbiuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuWpcpu) -> u8 {
                SmpufbiuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuWpgrpa {
                SmpufbiuWpgrpa::from_bits(val)
            }
        }
        impl From<SmpufbiuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuWpgrpa) -> u8 {
                SmpufbiuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpumbiuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpumbiuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpumbiuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpumbiuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpumbiuRpgrpa {
                SmpumbiuRpgrpa::from_bits(val)
            }
        }
        impl From<SmpumbiuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpumbiuRpgrpa) -> u8 {
                SmpumbiuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpumbiuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpumbiuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpumbiuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpumbiuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpumbiuWpgrpa {
                SmpumbiuWpgrpa::from_bits(val)
            }
        }
        impl From<SmpumbiuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpumbiuWpgrpa) -> u8 {
                SmpumbiuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpupbiuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpupbiuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpupbiuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpupbiuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> SmpupbiuRpcpu {
                SmpupbiuRpcpu::from_bits(val)
            }
        }
        impl From<SmpupbiuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: SmpupbiuRpcpu) -> u8 {
                SmpupbiuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpupbiuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpupbiuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpupbiuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpupbiuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpupbiuRpgrpa {
                SmpupbiuRpgrpa::from_bits(val)
            }
        }
        impl From<SmpupbiuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpupbiuRpgrpa) -> u8 {
                SmpupbiuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpupbiuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpupbiuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpupbiuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpupbiuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> SmpupbiuWpcpu {
                SmpupbiuWpcpu::from_bits(val)
            }
        }
        impl From<SmpupbiuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: SmpupbiuWpcpu) -> u8 {
                SmpupbiuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpupbiuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpupbiuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpupbiuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpupbiuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpupbiuWpgrpa {
                SmpupbiuWpgrpa::from_bits(val)
            }
        }
        impl From<SmpupbiuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpupbiuWpgrpa) -> u8 {
                SmpupbiuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Rpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Rpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Rpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Rpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Rpcpu {
                Smpusram0Rpcpu::from_bits(val)
            }
        }
        impl From<Smpusram0Rpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Rpcpu) -> u8 {
                Smpusram0Rpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Rpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Rpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Rpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Rpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Rpgrpa {
                Smpusram0Rpgrpa::from_bits(val)
            }
        }
        impl From<Smpusram0Rpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Rpgrpa) -> u8 {
                Smpusram0Rpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Wpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Wpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Wpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Wpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Wpcpu {
                Smpusram0Wpcpu::from_bits(val)
            }
        }
        impl From<Smpusram0Wpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Wpcpu) -> u8 {
                Smpusram0Wpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Wpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Wpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Wpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Wpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Wpgrpa {
                Smpusram0Wpgrpa::from_bits(val)
            }
        }
        impl From<Smpusram0Wpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Wpgrpa) -> u8 {
                Smpusram0Wpgrpa::to_bits(val)
            }
        }
    }
}
pub mod spi0 {
    #[doc = "Serial Peripheral Interface 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spi0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Spi0 {}
    unsafe impl Sync for Spi0 {}
    impl Spi0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SPI Control Register"]
        #[inline(always)]
        pub const fn spcr(self) -> crate::common::Reg<regs::Spcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SPI Slave Select Polarity Register"]
        #[inline(always)]
        pub const fn sslp(self) -> crate::common::Reg<regs::Sslp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "SPI Pin Control Register"]
        #[inline(always)]
        pub const fn sppcr(self) -> crate::common::Reg<regs::Sppcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "SPI Status Register"]
        #[inline(always)]
        pub const fn spsr(self) -> crate::common::Reg<regs::Spsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "SPI Data Register"]
        #[inline(always)]
        pub const fn spdr(self) -> crate::common::Reg<regs::Spdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Data Register ( halfword access )"]
        #[inline(always)]
        pub const fn spdr_ha(self) -> crate::common::Reg<regs::SpdrHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Bit Rate Register"]
        #[inline(always)]
        pub const fn spbr(self) -> crate::common::Reg<regs::Spbr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "SPI Data Control Register"]
        #[inline(always)]
        pub const fn spdcr(self) -> crate::common::Reg<regs::Spdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "SPI Clock Delay Register"]
        #[inline(always)]
        pub const fn spckd(self) -> crate::common::Reg<regs::Spckd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Slave Select Negation Delay Register"]
        #[inline(always)]
        pub const fn sslnd(self) -> crate::common::Reg<regs::Sslnd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "SPI Next,Access Delay Register"]
        #[inline(always)]
        pub const fn spnd(self) -> crate::common::Reg<regs::Spnd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "SPI Control Register 2"]
        #[inline(always)]
        pub const fn spcr2(self) -> crate::common::Reg<regs::Spcr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
        #[doc = "SPI Command Register 0"]
        #[inline(always)]
        pub const fn spcmd0(self) -> crate::common::Reg<regs::Spcmd0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SPI Bit Rate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spbr(pub u8);
        impl Spbr {
            #[doc = "SPBR sets the bit rate in master mode."]
            #[inline(always)]
            pub const fn spr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "SPBR sets the bit rate in master mode."]
            #[inline(always)]
            pub fn set_spr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Spbr {
            #[inline(always)]
            fn default() -> Spbr {
                Spbr(0)
            }
        }
        impl core::fmt::Debug for Spbr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spbr").field("spr", &self.spr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spbr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Spbr {{ spr: {=u8:?} }}", self.spr())
            }
        }
        #[doc = "SPI Clock Delay Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spckd(pub u8);
        impl Spckd {
            #[doc = "RSPCK Delay Setting"]
            #[inline(always)]
            pub const fn sckdl(&self) -> super::vals::Sckdl {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Sckdl::from_bits(val as u8)
            }
            #[doc = "RSPCK Delay Setting"]
            #[inline(always)]
            pub fn set_sckdl(&mut self, val: super::vals::Sckdl) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Spckd {
            #[inline(always)]
            fn default() -> Spckd {
                Spckd(0)
            }
        }
        impl core::fmt::Debug for Spckd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spckd")
                    .field("sckdl", &self.sckdl())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spckd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Spckd {{ sckdl: {:?}, reserved_3_7: {=u8:?} }}",
                    self.sckdl(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "SPI Command Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spcmd0(pub u16);
        impl Spcmd0 {
            #[doc = "RSPCK Phase Setting"]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "RSPCK Phase Setting"]
            #[inline(always)]
            pub fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "RSPCK Polarity Setting"]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "RSPCK Polarity Setting"]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Bit Rate Division Setting"]
            #[inline(always)]
            pub const fn brdv(&self) -> super::vals::Brdv {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Brdv::from_bits(val as u8)
            }
            #[doc = "Bit Rate Division Setting"]
            #[inline(always)]
            pub fn set_brdv(&mut self, val: super::vals::Brdv) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u16) & 0x03) << 2usize);
            }
            #[doc = "SSL Signal Assertion Setting"]
            #[inline(always)]
            pub const fn ssla(&self) -> super::vals::Ssla {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Ssla::from_bits(val as u8)
            }
            #[doc = "SSL Signal Assertion Setting"]
            #[inline(always)]
            pub fn set_ssla(&mut self, val: super::vals::Ssla) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u16) & 0x07) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u16) & 0x01) << 7usize);
            }
            #[doc = "SPI Data Length Setting"]
            #[inline(always)]
            pub const fn spb(&self) -> super::vals::Spb {
                let val = (self.0 >> 8usize) & 0x0f;
                super::vals::Spb::from_bits(val as u8)
            }
            #[doc = "SPI Data Length Setting"]
            #[inline(always)]
            pub fn set_spb(&mut self, val: super::vals::Spb) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u16) & 0x0f) << 8usize);
            }
            #[doc = "SPI LSB First"]
            #[inline(always)]
            pub const fn lsbf(&self) -> super::vals::Lsbf {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Lsbf::from_bits(val as u8)
            }
            #[doc = "SPI LSB First"]
            #[inline(always)]
            pub fn set_lsbf(&mut self, val: super::vals::Lsbf) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "SPI Next,Access Delay Enable"]
            #[inline(always)]
            pub const fn spnden(&self) -> super::vals::Spnden {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Spnden::from_bits(val as u8)
            }
            #[doc = "SPI Next,Access Delay Enable"]
            #[inline(always)]
            pub fn set_spnden(&mut self, val: super::vals::Spnden) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "SSL Negation Delay Setting Enable"]
            #[inline(always)]
            pub const fn slnden(&self) -> super::vals::Slnden {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Slnden::from_bits(val as u8)
            }
            #[doc = "SSL Negation Delay Setting Enable"]
            #[inline(always)]
            pub fn set_slnden(&mut self, val: super::vals::Slnden) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "RSPCK Delay Setting Enable"]
            #[inline(always)]
            pub const fn sckden(&self) -> super::vals::Sckden {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sckden::from_bits(val as u8)
            }
            #[doc = "RSPCK Delay Setting Enable"]
            #[inline(always)]
            pub fn set_sckden(&mut self, val: super::vals::Sckden) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Spcmd0 {
            #[inline(always)]
            fn default() -> Spcmd0 {
                Spcmd0(0)
            }
        }
        impl core::fmt::Debug for Spcmd0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spcmd0")
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .field("brdv", &self.brdv())
                    .field("ssla", &self.ssla())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .field("spb", &self.spb())
                    .field("lsbf", &self.lsbf())
                    .field("spnden", &self.spnden())
                    .field("slnden", &self.slnden())
                    .field("sckden", &self.sckden())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spcmd0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spcmd0 {{ cpha: {:?}, cpol: {:?}, brdv: {:?}, ssla: {:?}, reserved_7_7: {=bool:?}, spb: {:?}, lsbf: {:?}, spnden: {:?}, slnden: {:?}, sckden: {:?} }}" , self . cpha () , self . cpol () , self . brdv () , self . ssla () , self . reserved_7_7 () , self . spb () , self . lsbf () , self . spnden () , self . slnden () , self . sckden ())
            }
        }
        #[doc = "SPI Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spcr(pub u8);
        impl Spcr {
            #[doc = "SPI Mode Select"]
            #[inline(always)]
            pub const fn spms(&self) -> super::vals::Spms {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Spms::from_bits(val as u8)
            }
            #[doc = "SPI Mode Select"]
            #[inline(always)]
            pub fn set_spms(&mut self, val: super::vals::Spms) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Communications Operating Mode Select"]
            #[inline(always)]
            pub const fn txmd(&self) -> super::vals::Txmd {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Txmd::from_bits(val as u8)
            }
            #[doc = "Communications Operating Mode Select"]
            #[inline(always)]
            pub fn set_txmd(&mut self, val: super::vals::Txmd) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Mode Fault Error Detection Enable"]
            #[inline(always)]
            pub const fn modfen(&self) -> super::vals::Modfen {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Modfen::from_bits(val as u8)
            }
            #[doc = "Mode Fault Error Detection Enable"]
            #[inline(always)]
            pub fn set_modfen(&mut self, val: super::vals::Modfen) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "SPI Master/Slave Mode Select"]
            #[inline(always)]
            pub const fn mstr(&self) -> super::vals::Mstr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mstr::from_bits(val as u8)
            }
            #[doc = "SPI Master/Slave Mode Select"]
            #[inline(always)]
            pub fn set_mstr(&mut self, val: super::vals::Mstr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SPI Error Interrupt Enable"]
            #[inline(always)]
            pub const fn speie(&self) -> super::vals::Speie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Speie::from_bits(val as u8)
            }
            #[doc = "SPI Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_speie(&mut self, val: super::vals::Speie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub const fn sptie(&self) -> super::vals::Sptie {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Sptie::from_bits(val as u8)
            }
            #[doc = "Transmit Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub fn set_sptie(&mut self, val: super::vals::Sptie) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SPI Function Enable"]
            #[inline(always)]
            pub const fn spe(&self) -> super::vals::Spe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Spe::from_bits(val as u8)
            }
            #[doc = "SPI Function Enable"]
            #[inline(always)]
            pub fn set_spe(&mut self, val: super::vals::Spe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "SPI Receive Buffer Full Interrupt Enable"]
            #[inline(always)]
            pub const fn sprie(&self) -> super::vals::Sprie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sprie::from_bits(val as u8)
            }
            #[doc = "SPI Receive Buffer Full Interrupt Enable"]
            #[inline(always)]
            pub fn set_sprie(&mut self, val: super::vals::Sprie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spcr {
            #[inline(always)]
            fn default() -> Spcr {
                Spcr(0)
            }
        }
        impl core::fmt::Debug for Spcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spcr")
                    .field("spms", &self.spms())
                    .field("txmd", &self.txmd())
                    .field("modfen", &self.modfen())
                    .field("mstr", &self.mstr())
                    .field("speie", &self.speie())
                    .field("sptie", &self.sptie())
                    .field("spe", &self.spe())
                    .field("sprie", &self.sprie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spcr {{ spms: {:?}, txmd: {:?}, modfen: {:?}, mstr: {:?}, speie: {:?}, sptie: {:?}, spe: {:?}, sprie: {:?} }}" , self . spms () , self . txmd () , self . modfen () , self . mstr () , self . speie () , self . sptie () , self . spe () , self . sprie ())
            }
        }
        #[doc = "SPI Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spcr2(pub u8);
        impl Spcr2 {
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub const fn sppe(&self) -> super::vals::Sppe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sppe::from_bits(val as u8)
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub fn set_sppe(&mut self, val: super::vals::Sppe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub const fn spoe(&self) -> super::vals::Spoe {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spoe::from_bits(val as u8)
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub fn set_spoe(&mut self, val: super::vals::Spoe) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "SPI Idle Interrupt Enable"]
            #[inline(always)]
            pub const fn spiie(&self) -> super::vals::Spiie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Spiie::from_bits(val as u8)
            }
            #[doc = "SPI Idle Interrupt Enable"]
            #[inline(always)]
            pub fn set_spiie(&mut self, val: super::vals::Spiie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Self,Testing"]
            #[inline(always)]
            pub const fn pte(&self) -> super::vals::Pte {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pte::from_bits(val as u8)
            }
            #[doc = "Parity Self,Testing"]
            #[inline(always)]
            pub fn set_pte(&mut self, val: super::vals::Pte) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "RSPCK Auto,Stop Function Enable"]
            #[inline(always)]
            pub const fn sckase(&self) -> super::vals::Sckase {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sckase::from_bits(val as u8)
            }
            #[doc = "RSPCK Auto,Stop Function Enable"]
            #[inline(always)]
            pub fn set_sckase(&mut self, val: super::vals::Sckase) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Spcr2 {
            #[inline(always)]
            fn default() -> Spcr2 {
                Spcr2(0)
            }
        }
        impl core::fmt::Debug for Spcr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spcr2")
                    .field("sppe", &self.sppe())
                    .field("spoe", &self.spoe())
                    .field("spiie", &self.spiie())
                    .field("pte", &self.pte())
                    .field("sckase", &self.sckase())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spcr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spcr2 {{ sppe: {:?}, spoe: {:?}, spiie: {:?}, pte: {:?}, sckase: {:?}, reserved_5_7: {=u8:?} }}" , self . sppe () , self . spoe () , self . spiie () , self . pte () , self . sckase () , self . reserved_5_7 ())
            }
        }
        #[doc = "SPI Data Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spdcr(pub u8);
        impl Spdcr {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "SPI Receive/Transmit Data Selection"]
            #[inline(always)]
            pub const fn sprdtd(&self) -> super::vals::Sprdtd {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sprdtd::from_bits(val as u8)
            }
            #[doc = "SPI Receive/Transmit Data Selection"]
            #[inline(always)]
            pub fn set_sprdtd(&mut self, val: super::vals::Sprdtd) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "SPI Word Access/Halfword Access Specification"]
            #[inline(always)]
            pub const fn splw(&self) -> super::vals::Splw {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Splw::from_bits(val as u8)
            }
            #[doc = "SPI Word Access/Halfword Access Specification"]
            #[inline(always)]
            pub fn set_splw(&mut self, val: super::vals::Splw) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Spdcr {
            #[inline(always)]
            fn default() -> Spdcr {
                Spdcr(0)
            }
        }
        impl core::fmt::Debug for Spdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spdcr")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("sprdtd", &self.sprdtd())
                    .field("splw", &self.splw())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spdcr {{ reserved_0_3: {=u8:?}, sprdtd: {:?}, splw: {:?}, reserved_6_7: {=u8:?} }}" , self . reserved_0_3 () , self . sprdtd () , self . splw () , self . reserved_6_7 ())
            }
        }
        #[doc = "SPI Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spdr(pub u32);
        impl Spdr {
            #[doc = "SPDR is the interface with the buffers that hold data for transmission and reception by the RSPI.When accessing in word (SPDCR.SPLW=1), access SPDR."]
            #[inline(always)]
            pub const fn spdr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "SPDR is the interface with the buffers that hold data for transmission and reception by the RSPI.When accessing in word (SPDCR.SPLW=1), access SPDR."]
            #[inline(always)]
            pub fn set_spdr(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Spdr {
            #[inline(always)]
            fn default() -> Spdr {
                Spdr(0)
            }
        }
        impl core::fmt::Debug for Spdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spdr").field("spdr", &self.spdr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Spdr {{ spdr: {=u32:?} }}", self.spdr())
            }
        }
        #[doc = "SPI Data Register ( halfword access )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpdrHa(pub u16);
        impl SpdrHa {
            #[doc = "SPDR is the interface with the buffers that hold data for transmission and reception by the SPI.When accessing in halfword (SPDCR.SPLW=0), access SPDR_HA."]
            #[inline(always)]
            pub const fn spdr_ha(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "SPDR is the interface with the buffers that hold data for transmission and reception by the SPI.When accessing in halfword (SPDCR.SPLW=0), access SPDR_HA."]
            #[inline(always)]
            pub fn set_spdr_ha(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for SpdrHa {
            #[inline(always)]
            fn default() -> SpdrHa {
                SpdrHa(0)
            }
        }
        impl core::fmt::Debug for SpdrHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpdrHa")
                    .field("spdr_ha", &self.spdr_ha())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpdrHa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SpdrHa {{ spdr_ha: {=u16:?} }}", self.spdr_ha())
            }
        }
        #[doc = "SPI Next,Access Delay Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spnd(pub u8);
        impl Spnd {
            #[doc = "SPI Next,Access Delay Setting"]
            #[inline(always)]
            pub const fn spndl(&self) -> super::vals::Spndl {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Spndl::from_bits(val as u8)
            }
            #[doc = "SPI Next,Access Delay Setting"]
            #[inline(always)]
            pub fn set_spndl(&mut self, val: super::vals::Spndl) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Spnd {
            #[inline(always)]
            fn default() -> Spnd {
                Spnd(0)
            }
        }
        impl core::fmt::Debug for Spnd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spnd")
                    .field("spndl", &self.spndl())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spnd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Spnd {{ spndl: {:?}, reserved_3_7: {=u8:?} }}",
                    self.spndl(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "SPI Pin Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sppcr(pub u8);
        impl Sppcr {
            #[doc = "SPI Loopback"]
            #[inline(always)]
            pub const fn splp(&self) -> super::vals::Splp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Splp::from_bits(val as u8)
            }
            #[doc = "SPI Loopback"]
            #[inline(always)]
            pub fn set_splp(&mut self, val: super::vals::Splp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SPI Loopback 2"]
            #[inline(always)]
            pub const fn splp2(&self) -> super::vals::Splp2 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Splp2::from_bits(val as u8)
            }
            #[doc = "SPI Loopback 2"]
            #[inline(always)]
            pub fn set_splp2(&mut self, val: super::vals::Splp2) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_2_3(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_2_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "MOSI Idle Fixed Value"]
            #[inline(always)]
            pub const fn moifv(&self) -> super::vals::Moifv {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Moifv::from_bits(val as u8)
            }
            #[doc = "MOSI Idle Fixed Value"]
            #[inline(always)]
            pub fn set_moifv(&mut self, val: super::vals::Moifv) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "MOSI Idle Value Fixing Enable"]
            #[inline(always)]
            pub const fn moife(&self) -> super::vals::Moife {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Moife::from_bits(val as u8)
            }
            #[doc = "MOSI Idle Value Fixing Enable"]
            #[inline(always)]
            pub fn set_moife(&mut self, val: super::vals::Moife) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Sppcr {
            #[inline(always)]
            fn default() -> Sppcr {
                Sppcr(0)
            }
        }
        impl core::fmt::Debug for Sppcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sppcr")
                    .field("splp", &self.splp())
                    .field("splp2", &self.splp2())
                    .field("reserved_2_3", &self.reserved_2_3())
                    .field("moifv", &self.moifv())
                    .field("moife", &self.moife())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sppcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sppcr {{ splp: {:?}, splp2: {:?}, reserved_2_3: {=u8:?}, moifv: {:?}, moife: {:?}, reserved_6_7: {=u8:?} }}" , self . splp () , self . splp2 () , self . reserved_2_3 () , self . moifv () , self . moife () , self . reserved_6_7 ())
            }
        }
        #[doc = "SPI Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spsr(pub u8);
        impl Spsr {
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn ovrf(&self) -> super::vals::Ovrf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ovrf::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_ovrf(&mut self, val: super::vals::Ovrf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SPI Idle Flag"]
            #[inline(always)]
            pub const fn idlnf(&self) -> super::vals::Idlnf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Idlnf::from_bits(val as u8)
            }
            #[doc = "SPI Idle Flag"]
            #[inline(always)]
            pub fn set_idlnf(&mut self, val: super::vals::Idlnf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Mode Fault Error Flag"]
            #[inline(always)]
            pub const fn modf(&self) -> super::vals::Modf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Modf::from_bits(val as u8)
            }
            #[doc = "Mode Fault Error Flag"]
            #[inline(always)]
            pub fn set_modf(&mut self, val: super::vals::Modf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn perf(&self) -> super::vals::Perf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Perf::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_perf(&mut self, val: super::vals::Perf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Underrun Error Flag(When MODF is 0, This bit is invalid.)"]
            #[inline(always)]
            pub const fn udrf(&self) -> super::vals::Udrf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Udrf::from_bits(val as u8)
            }
            #[doc = "Underrun Error Flag(When MODF is 0, This bit is invalid.)"]
            #[inline(always)]
            pub fn set_udrf(&mut self, val: super::vals::Udrf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "SPI Transmit Buffer Empty Flag"]
            #[inline(always)]
            pub const fn sptef(&self) -> super::vals::Sptef {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Sptef::from_bits(val as u8)
            }
            #[doc = "SPI Transmit Buffer Empty Flag"]
            #[inline(always)]
            pub fn set_sptef(&mut self, val: super::vals::Sptef) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "SPI Receive Buffer Full Flag"]
            #[inline(always)]
            pub const fn sprf(&self) -> super::vals::Sprf {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sprf::from_bits(val as u8)
            }
            #[doc = "SPI Receive Buffer Full Flag"]
            #[inline(always)]
            pub fn set_sprf(&mut self, val: super::vals::Sprf) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spsr {
            #[inline(always)]
            fn default() -> Spsr {
                Spsr(0)
            }
        }
        impl core::fmt::Debug for Spsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spsr")
                    .field("ovrf", &self.ovrf())
                    .field("idlnf", &self.idlnf())
                    .field("modf", &self.modf())
                    .field("perf", &self.perf())
                    .field("udrf", &self.udrf())
                    .field("sptef", &self.sptef())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("sprf", &self.sprf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spsr {{ ovrf: {:?}, idlnf: {:?}, modf: {:?}, perf: {:?}, udrf: {:?}, sptef: {:?}, reserved_6_6: {=bool:?}, sprf: {:?} }}" , self . ovrf () , self . idlnf () , self . modf () , self . perf () , self . udrf () , self . sptef () , self . reserved_6_6 () , self . sprf ())
            }
        }
        #[doc = "SPI Slave Select Negation Delay Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sslnd(pub u8);
        impl Sslnd {
            #[doc = "SSL Negation Delay Setting"]
            #[inline(always)]
            pub const fn slndl(&self) -> super::vals::Slndl {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Slndl::from_bits(val as u8)
            }
            #[doc = "SSL Negation Delay Setting"]
            #[inline(always)]
            pub fn set_slndl(&mut self, val: super::vals::Slndl) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Sslnd {
            #[inline(always)]
            fn default() -> Sslnd {
                Sslnd(0)
            }
        }
        impl core::fmt::Debug for Sslnd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sslnd")
                    .field("slndl", &self.slndl())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sslnd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sslnd {{ slndl: {:?}, reserved_3_7: {=u8:?} }}",
                    self.slndl(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "SPI Slave Select Polarity Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sslp(pub u8);
        impl Sslp {
            #[doc = "SSL0 Signal Polarity Setting"]
            #[inline(always)]
            pub const fn ssl0p(&self) -> super::vals::Ssl0p {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssl0p::from_bits(val as u8)
            }
            #[doc = "SSL0 Signal Polarity Setting"]
            #[inline(always)]
            pub fn set_ssl0p(&mut self, val: super::vals::Ssl0p) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SSL1 Signal Polarity Setting"]
            #[inline(always)]
            pub const fn ssl1p(&self) -> super::vals::Ssl1p {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssl1p::from_bits(val as u8)
            }
            #[doc = "SSL1 Signal Polarity Setting"]
            #[inline(always)]
            pub fn set_ssl1p(&mut self, val: super::vals::Ssl1p) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "SSL2 Signal Polarity Setting"]
            #[inline(always)]
            pub const fn ssl2p(&self) -> super::vals::Ssl2p {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ssl2p::from_bits(val as u8)
            }
            #[doc = "SSL2 Signal Polarity Setting"]
            #[inline(always)]
            pub fn set_ssl2p(&mut self, val: super::vals::Ssl2p) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "SSL3 Signal Polarity Setting"]
            #[inline(always)]
            pub const fn ssl3p(&self) -> super::vals::Ssl3p {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ssl3p::from_bits(val as u8)
            }
            #[doc = "SSL3 Signal Polarity Setting"]
            #[inline(always)]
            pub fn set_ssl3p(&mut self, val: super::vals::Ssl3p) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u8) & 0x0f) << 4usize);
            }
        }
        impl Default for Sslp {
            #[inline(always)]
            fn default() -> Sslp {
                Sslp(0)
            }
        }
        impl core::fmt::Debug for Sslp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sslp")
                    .field("ssl0p", &self.ssl0p())
                    .field("ssl1p", &self.ssl1p())
                    .field("ssl2p", &self.ssl2p())
                    .field("ssl3p", &self.ssl3p())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sslp {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sslp {{ ssl0p: {:?}, ssl1p: {:?}, ssl2p: {:?}, ssl3p: {:?}, reserved_4_7: {=u8:?} }}" , self . ssl0p () , self . ssl1p () , self . ssl2p () , self . ssl3p () , self . reserved_4_7 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brdv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Brdv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brdv {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brdv {
            #[inline(always)]
            fn from(val: u8) -> Brdv {
                Brdv::from_bits(val)
            }
        }
        impl From<Brdv> for u8 {
            #[inline(always)]
            fn from(val: Brdv) -> u8 {
                Brdv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idlnf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idlnf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idlnf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idlnf {
            #[inline(always)]
            fn from(val: u8) -> Idlnf {
                Idlnf::from_bits(val)
            }
        }
        impl From<Idlnf> for u8 {
            #[inline(always)]
            fn from(val: Idlnf) -> u8 {
                Idlnf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lsbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lsbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lsbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lsbf {
            #[inline(always)]
            fn from(val: u8) -> Lsbf {
                Lsbf::from_bits(val)
            }
        }
        impl From<Lsbf> for u8 {
            #[inline(always)]
            fn from(val: Lsbf) -> u8 {
                Lsbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Modf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modf {
            #[inline(always)]
            fn from(val: u8) -> Modf {
                Modf::from_bits(val)
            }
        }
        impl From<Modf> for u8 {
            #[inline(always)]
            fn from(val: Modf) -> u8 {
                Modf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Modfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modfen {
            #[inline(always)]
            fn from(val: u8) -> Modfen {
                Modfen::from_bits(val)
            }
        }
        impl From<Modfen> for u8 {
            #[inline(always)]
            fn from(val: Modfen) -> u8 {
                Modfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moife {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moife {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moife {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moife {
            #[inline(always)]
            fn from(val: u8) -> Moife {
                Moife::from_bits(val)
            }
        }
        impl From<Moife> for u8 {
            #[inline(always)]
            fn from(val: Moife) -> u8 {
                Moife::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moifv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moifv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moifv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moifv {
            #[inline(always)]
            fn from(val: u8) -> Moifv {
                Moifv::from_bits(val)
            }
        }
        impl From<Moifv> for u8 {
            #[inline(always)]
            fn from(val: Moifv) -> u8 {
                Moifv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstr {
            #[inline(always)]
            fn from(val: u8) -> Mstr {
                Mstr::from_bits(val)
            }
        }
        impl From<Mstr> for u8 {
            #[inline(always)]
            fn from(val: Mstr) -> u8 {
                Mstr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovrf {
            #[inline(always)]
            fn from(val: u8) -> Ovrf {
                Ovrf::from_bits(val)
            }
        }
        impl From<Ovrf> for u8 {
            #[inline(always)]
            fn from(val: Ovrf) -> u8 {
                Ovrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Perf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Perf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Perf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Perf {
            #[inline(always)]
            fn from(val: u8) -> Perf {
                Perf::from_bits(val)
            }
        }
        impl From<Perf> for u8 {
            #[inline(always)]
            fn from(val: Perf) -> u8 {
                Perf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pte {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pte {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pte {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pte {
            #[inline(always)]
            fn from(val: u8) -> Pte {
                Pte::from_bits(val)
            }
        }
        impl From<Pte> for u8 {
            #[inline(always)]
            fn from(val: Pte) -> u8 {
                Pte::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckase {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sckase {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckase {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckase {
            #[inline(always)]
            fn from(val: u8) -> Sckase {
                Sckase::from_bits(val)
            }
        }
        impl From<Sckase> for u8 {
            #[inline(always)]
            fn from(val: Sckase) -> u8 {
                Sckase::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckden {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sckden {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckden {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckden {
            #[inline(always)]
            fn from(val: u8) -> Sckden {
                Sckden::from_bits(val)
            }
        }
        impl From<Sckden> for u8 {
            #[inline(always)]
            fn from(val: Sckden) -> u8 {
                Sckden::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckdl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sckdl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckdl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckdl {
            #[inline(always)]
            fn from(val: u8) -> Sckdl {
                Sckdl::from_bits(val)
            }
        }
        impl From<Sckdl> for u8 {
            #[inline(always)]
            fn from(val: Sckdl) -> u8 {
                Sckdl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slnden {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Slnden {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slnden {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slnden {
            #[inline(always)]
            fn from(val: u8) -> Slnden {
                Slnden::from_bits(val)
            }
        }
        impl From<Slnden> for u8 {
            #[inline(always)]
            fn from(val: Slnden) -> u8 {
                Slnden::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slndl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Slndl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slndl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slndl {
            #[inline(always)]
            fn from(val: u8) -> Slndl {
                Slndl::from_bits(val)
            }
        }
        impl From<Slndl> for u8 {
            #[inline(always)]
            fn from(val: Slndl) -> u8 {
                Slndl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Spb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb {
            #[inline(always)]
            fn from(val: u8) -> Spb {
                Spb::from_bits(val)
            }
        }
        impl From<Spb> for u8 {
            #[inline(always)]
            fn from(val: Spb) -> u8 {
                Spb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spe {
            #[inline(always)]
            fn from(val: u8) -> Spe {
                Spe::from_bits(val)
            }
        }
        impl From<Spe> for u8 {
            #[inline(always)]
            fn from(val: Spe) -> u8 {
                Spe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Speie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Speie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Speie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Speie {
            #[inline(always)]
            fn from(val: u8) -> Speie {
                Speie::from_bits(val)
            }
        }
        impl From<Speie> for u8 {
            #[inline(always)]
            fn from(val: Speie) -> u8 {
                Speie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spiie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spiie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spiie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spiie {
            #[inline(always)]
            fn from(val: u8) -> Spiie {
                Spiie::from_bits(val)
            }
        }
        impl From<Spiie> for u8 {
            #[inline(always)]
            fn from(val: Spiie) -> u8 {
                Spiie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Splp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Splp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Splp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Splp {
            #[inline(always)]
            fn from(val: u8) -> Splp {
                Splp::from_bits(val)
            }
        }
        impl From<Splp> for u8 {
            #[inline(always)]
            fn from(val: Splp) -> u8 {
                Splp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Splp2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Splp2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Splp2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Splp2 {
            #[inline(always)]
            fn from(val: u8) -> Splp2 {
                Splp2::from_bits(val)
            }
        }
        impl From<Splp2> for u8 {
            #[inline(always)]
            fn from(val: Splp2) -> u8 {
                Splp2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Splw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Splw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Splw {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Splw {
            #[inline(always)]
            fn from(val: u8) -> Splw {
                Splw::from_bits(val)
            }
        }
        impl From<Splw> for u8 {
            #[inline(always)]
            fn from(val: Splw) -> u8 {
                Splw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spms {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spms {
            #[inline(always)]
            fn from(val: u8) -> Spms {
                Spms::from_bits(val)
            }
        }
        impl From<Spms> for u8 {
            #[inline(always)]
            fn from(val: Spms) -> u8 {
                Spms::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spnden {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spnden {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spnden {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spnden {
            #[inline(always)]
            fn from(val: u8) -> Spnden {
                Spnden::from_bits(val)
            }
        }
        impl From<Spnden> for u8 {
            #[inline(always)]
            fn from(val: Spnden) -> u8 {
                Spnden::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spndl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Spndl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spndl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spndl {
            #[inline(always)]
            fn from(val: u8) -> Spndl {
                Spndl::from_bits(val)
            }
        }
        impl From<Spndl> for u8 {
            #[inline(always)]
            fn from(val: Spndl) -> u8 {
                Spndl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spoe {
            #[inline(always)]
            fn from(val: u8) -> Spoe {
                Spoe::from_bits(val)
            }
        }
        impl From<Spoe> for u8 {
            #[inline(always)]
            fn from(val: Spoe) -> u8 {
                Spoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sppe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sppe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sppe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sppe {
            #[inline(always)]
            fn from(val: u8) -> Sppe {
                Sppe::from_bits(val)
            }
        }
        impl From<Sppe> for u8 {
            #[inline(always)]
            fn from(val: Sppe) -> u8 {
                Sppe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprdtd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sprdtd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprdtd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprdtd {
            #[inline(always)]
            fn from(val: u8) -> Sprdtd {
                Sprdtd::from_bits(val)
            }
        }
        impl From<Sprdtd> for u8 {
            #[inline(always)]
            fn from(val: Sprdtd) -> u8 {
                Sprdtd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sprf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprf {
            #[inline(always)]
            fn from(val: u8) -> Sprf {
                Sprf::from_bits(val)
            }
        }
        impl From<Sprf> for u8 {
            #[inline(always)]
            fn from(val: Sprf) -> u8 {
                Sprf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sprie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprie {
            #[inline(always)]
            fn from(val: u8) -> Sprie {
                Sprie::from_bits(val)
            }
        }
        impl From<Sprie> for u8 {
            #[inline(always)]
            fn from(val: Sprie) -> u8 {
                Sprie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sptef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sptef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sptef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sptef {
            #[inline(always)]
            fn from(val: u8) -> Sptef {
                Sptef::from_bits(val)
            }
        }
        impl From<Sptef> for u8 {
            #[inline(always)]
            fn from(val: Sptef) -> u8 {
                Sptef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sptie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sptie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sptie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sptie {
            #[inline(always)]
            fn from(val: u8) -> Sptie {
                Sptie::from_bits(val)
            }
        }
        impl From<Sptie> for u8 {
            #[inline(always)]
            fn from(val: Sptie) -> u8 {
                Sptie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssl0p {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssl0p {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssl0p {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssl0p {
            #[inline(always)]
            fn from(val: u8) -> Ssl0p {
                Ssl0p::from_bits(val)
            }
        }
        impl From<Ssl0p> for u8 {
            #[inline(always)]
            fn from(val: Ssl0p) -> u8 {
                Ssl0p::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssl1p {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssl1p {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssl1p {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssl1p {
            #[inline(always)]
            fn from(val: u8) -> Ssl1p {
                Ssl1p::from_bits(val)
            }
        }
        impl From<Ssl1p> for u8 {
            #[inline(always)]
            fn from(val: Ssl1p) -> u8 {
                Ssl1p::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssl2p {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssl2p {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssl2p {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssl2p {
            #[inline(always)]
            fn from(val: u8) -> Ssl2p {
                Ssl2p::from_bits(val)
            }
        }
        impl From<Ssl2p> for u8 {
            #[inline(always)]
            fn from(val: Ssl2p) -> u8 {
                Ssl2p::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssl3p {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssl3p {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssl3p {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssl3p {
            #[inline(always)]
            fn from(val: u8) -> Ssl3p {
                Ssl3p::from_bits(val)
            }
        }
        impl From<Ssl3p> for u8 {
            #[inline(always)]
            fn from(val: Ssl3p) -> u8 {
                Ssl3p::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssla {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ssla {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssla {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssla {
            #[inline(always)]
            fn from(val: u8) -> Ssla {
                Ssla::from_bits(val)
            }
        }
        impl From<Ssla> for u8 {
            #[inline(always)]
            fn from(val: Ssla) -> u8 {
                Ssla::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Txmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txmd {
            #[inline(always)]
            fn from(val: u8) -> Txmd {
                Txmd::from_bits(val)
            }
        }
        impl From<Txmd> for u8 {
            #[inline(always)]
            fn from(val: Txmd) -> u8 {
                Txmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Udrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Udrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Udrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Udrf {
            #[inline(always)]
            fn from(val: u8) -> Udrf {
                Udrf::from_bits(val)
            }
        }
        impl From<Udrf> for u8 {
            #[inline(always)]
            fn from(val: Udrf) -> u8 {
                Udrf::to_bits(val)
            }
        }
    }
}
pub mod spmon {
    #[doc = "CPU Stack Pointer Monitor"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spmon {
        ptr: *mut u8,
    }
    unsafe impl Send for Spmon {}
    unsafe impl Sync for Spmon {}
    impl Spmon {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[inline(always)]
        pub const fn mspmpuoad(self) -> crate::common::Reg<regs::Mspmpuoad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[inline(always)]
        pub const fn mspmpuctl(self) -> crate::common::Reg<regs::Mspmpuctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[inline(always)]
        pub const fn mspmpupt(self) -> crate::common::Reg<regs::Mspmpupt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Main Stack Pointer Monitor Start Address Register"]
        #[inline(always)]
        pub const fn mspmpusa(self) -> crate::common::Reg<regs::Mspmpusa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Main Stack Pointer Monitor End Address Register"]
        #[inline(always)]
        pub const fn mspmpuea(self) -> crate::common::Reg<regs::Mspmpuea, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[inline(always)]
        pub const fn pspmpuoad(self) -> crate::common::Reg<regs::Pspmpuoad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[inline(always)]
        pub const fn pspmpuctl(self) -> crate::common::Reg<regs::Pspmpuctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[inline(always)]
        pub const fn pspmpupt(self) -> crate::common::Reg<regs::Pspmpupt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "Process Stack Pointer Monitor Start Address Register"]
        #[inline(always)]
        pub const fn pspmpusa(self) -> crate::common::Reg<regs::Pspmpusa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Process Stack Pointer Monitor End Address Register"]
        #[inline(always)]
        pub const fn pspmpuea(self) -> crate::common::Reg<regs::Pspmpuea, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpuctl(pub u16);
        impl Mspmpuctl {
            #[doc = "SP_main monitor enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::MspmpuctlEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MspmpuctlEnable::from_bits(val as u8)
            }
            #[doc = "SP_main monitor enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::MspmpuctlEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u16) & 0x7f) << 1usize);
            }
            #[doc = "SP_main monitor error flag"]
            #[inline(always)]
            pub const fn error(&self) -> super::vals::MspmpuctlError {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::MspmpuctlError::from_bits(val as u8)
            }
            #[doc = "SP_main monitor error flag"]
            #[inline(always)]
            pub fn set_error(&mut self, val: super::vals::MspmpuctlError) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Mspmpuctl {
            #[inline(always)]
            fn default() -> Mspmpuctl {
                Mspmpuctl(0)
            }
        }
        impl core::fmt::Debug for Mspmpuctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpuctl")
                    .field("enable", &self.enable())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("error", &self.error())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpuctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mspmpuctl {{ enable: {:?}, reserved_1_7: {=u8:?}, error: {:?}, reserved_9_15: {=u8:?} }}" , self . enable () , self . reserved_1_7 () , self . error () , self . reserved_9_15 ())
            }
        }
        #[doc = "Main Stack Pointer Monitor End Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpuea(pub u32);
        impl Mspmpuea {
            #[doc = "Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low,order 2 bits are fixed to 1."]
            #[inline(always)]
            pub const fn mspmpuea(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low,order 2 bits are fixed to 1."]
            #[inline(always)]
            pub fn set_mspmpuea(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mspmpuea {
            #[inline(always)]
            fn default() -> Mspmpuea {
                Mspmpuea(0)
            }
        }
        impl core::fmt::Debug for Mspmpuea {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpuea")
                    .field("mspmpuea", &self.mspmpuea())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpuea {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mspmpuea {{ mspmpuea: {=u32:?} }}", self.mspmpuea())
            }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpuoad(pub u16);
        impl Mspmpuoad {
            #[doc = "Operation after detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::MspmpuoadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MspmpuoadOad::from_bits(val as u8)
            }
            #[doc = "Operation after detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::MspmpuoadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u16) & 0x7f) << 1usize);
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::MspmpuoadKey {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::MspmpuoadKey::from_bits(val as u8)
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::MspmpuoadKey) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mspmpuoad {
            #[inline(always)]
            fn default() -> Mspmpuoad {
                Mspmpuoad(0)
            }
        }
        impl core::fmt::Debug for Mspmpuoad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpuoad")
                    .field("oad", &self.oad())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpuoad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mspmpuoad {{ oad: {:?}, reserved_1_7: {=u8:?}, key: {:?} }}",
                    self.oad(),
                    self.reserved_1_7(),
                    self.key()
                )
            }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpupt(pub u16);
        impl Mspmpupt {
            #[doc = "Protection of register (MSPMPUAC, MSPMPUSA and MSPMPUSE)"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::MspmpuptProtect {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MspmpuptProtect::from_bits(val as u8)
            }
            #[doc = "Protection of register (MSPMPUAC, MSPMPUSA and MSPMPUSE)"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::MspmpuptProtect) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u16) & 0x7f) << 1usize);
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::MspmpuptKey {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::MspmpuptKey::from_bits(val as u8)
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::MspmpuptKey) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mspmpupt {
            #[inline(always)]
            fn default() -> Mspmpupt {
                Mspmpupt(0)
            }
        }
        impl core::fmt::Debug for Mspmpupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpupt")
                    .field("protect", &self.protect())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mspmpupt {{ protect: {:?}, reserved_1_7: {=u8:?}, key: {:?} }}",
                    self.protect(),
                    self.reserved_1_7(),
                    self.key()
                )
            }
        }
        #[doc = "Main Stack Pointer Monitor Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpusa(pub u32);
        impl Mspmpusa {
            #[doc = "Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low,order 2 bits are fixed to 0."]
            #[inline(always)]
            pub const fn mspmpusa(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low,order 2 bits are fixed to 0."]
            #[inline(always)]
            pub fn set_mspmpusa(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mspmpusa {
            #[inline(always)]
            fn default() -> Mspmpusa {
                Mspmpusa(0)
            }
        }
        impl core::fmt::Debug for Mspmpusa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpusa")
                    .field("mspmpusa", &self.mspmpusa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpusa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mspmpusa {{ mspmpusa: {=u32:?} }}", self.mspmpusa())
            }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpuctl(pub u16);
        impl Pspmpuctl {
            #[doc = "SP_process monitor enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::PspmpuctlEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PspmpuctlEnable::from_bits(val as u8)
            }
            #[doc = "SP_process monitor enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::PspmpuctlEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u16) & 0x7f) << 1usize);
            }
            #[doc = "SP_process monitor error flag"]
            #[inline(always)]
            pub const fn error(&self) -> super::vals::PspmpuctlError {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PspmpuctlError::from_bits(val as u8)
            }
            #[doc = "SP_process monitor error flag"]
            #[inline(always)]
            pub fn set_error(&mut self, val: super::vals::PspmpuctlError) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Pspmpuctl {
            #[inline(always)]
            fn default() -> Pspmpuctl {
                Pspmpuctl(0)
            }
        }
        impl core::fmt::Debug for Pspmpuctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpuctl")
                    .field("enable", &self.enable())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("error", &self.error())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpuctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pspmpuctl {{ enable: {:?}, reserved_1_7: {=u8:?}, error: {:?}, reserved_9_15: {=u8:?} }}" , self . enable () , self . reserved_1_7 () , self . error () , self . reserved_9_15 ())
            }
        }
        #[doc = "Process Stack Pointer Monitor End Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpuea(pub u32);
        impl Pspmpuea {
            #[doc = "Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low,order 2 bits are fixed to 1."]
            #[inline(always)]
            pub const fn pspmpuea(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region end address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00003-0x200FFFFF The low,order 2 bits are fixed to 1."]
            #[inline(always)]
            pub fn set_pspmpuea(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Pspmpuea {
            #[inline(always)]
            fn default() -> Pspmpuea {
                Pspmpuea(0)
            }
        }
        impl core::fmt::Debug for Pspmpuea {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpuea")
                    .field("pspmpuea", &self.pspmpuea())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpuea {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pspmpuea {{ pspmpuea: {=u32:?} }}", self.pspmpuea())
            }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpuoad(pub u16);
        impl Pspmpuoad {
            #[doc = "Operation after detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::PspmpuoadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PspmpuoadOad::from_bits(val as u8)
            }
            #[doc = "Operation after detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::PspmpuoadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u16) & 0x7f) << 1usize);
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::PspmpuoadKey {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::PspmpuoadKey::from_bits(val as u8)
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::PspmpuoadKey) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Pspmpuoad {
            #[inline(always)]
            fn default() -> Pspmpuoad {
                Pspmpuoad(0)
            }
        }
        impl core::fmt::Debug for Pspmpuoad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpuoad")
                    .field("oad", &self.oad())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpuoad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pspmpuoad {{ oad: {:?}, reserved_1_7: {=u8:?}, key: {:?} }}",
                    self.oad(),
                    self.reserved_1_7(),
                    self.key()
                )
            }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpupt(pub u16);
        impl Pspmpupt {
            #[doc = "Protection of register (PSPMPUAC, PSPMPUSA and PSPMPUSE)"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::PspmpuptProtect {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PspmpuptProtect::from_bits(val as u8)
            }
            #[doc = "Protection of register (PSPMPUAC, PSPMPUSA and PSPMPUSE)"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::PspmpuptProtect) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u16) & 0x7f) << 1usize);
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::PspmpuptKey {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::PspmpuptKey::from_bits(val as u8)
            }
            #[doc = "Write Keyword The data written to these bits are not stored."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::PspmpuptKey) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Pspmpupt {
            #[inline(always)]
            fn default() -> Pspmpupt {
                Pspmpupt(0)
            }
        }
        impl core::fmt::Debug for Pspmpupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpupt")
                    .field("protect", &self.protect())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pspmpupt {{ protect: {:?}, reserved_1_7: {=u8:?}, key: {:?} }}",
                    self.protect(),
                    self.reserved_1_7(),
                    self.key()
                )
            }
        }
        #[doc = "Process Stack Pointer Monitor Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpusa(pub u32);
        impl Pspmpusa {
            #[doc = "Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low,order 2 bits are fixed to 0."]
            #[inline(always)]
            pub const fn pspmpusa(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region start address register Address where the region starts, for use in region determination.NOTE: Range: 0x1FF00000-0x200FFFFC The low,order 2 bits are fixed to 0."]
            #[inline(always)]
            pub fn set_pspmpusa(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Pspmpusa {
            #[inline(always)]
            fn default() -> Pspmpusa {
                Pspmpusa(0)
            }
        }
        impl core::fmt::Debug for Pspmpusa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpusa")
                    .field("pspmpusa", &self.pspmpusa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpusa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pspmpusa {{ pspmpusa: {=u32:?} }}", self.pspmpusa())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuctlEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuctlEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuctlEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuctlEnable {
            #[inline(always)]
            fn from(val: u8) -> MspmpuctlEnable {
                MspmpuctlEnable::from_bits(val)
            }
        }
        impl From<MspmpuctlEnable> for u8 {
            #[inline(always)]
            fn from(val: MspmpuctlEnable) -> u8 {
                MspmpuctlEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuctlError {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuctlError {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuctlError {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuctlError {
            #[inline(always)]
            fn from(val: u8) -> MspmpuctlError {
                MspmpuctlError::from_bits(val)
            }
        }
        impl From<MspmpuctlError> for u8 {
            #[inline(always)]
            fn from(val: MspmpuctlError) -> u8 {
                MspmpuctlError::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MspmpuoadKey(u8);
        impl MspmpuoadKey {}
        impl MspmpuoadKey {
            pub const fn from_bits(val: u8) -> MspmpuoadKey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for MspmpuoadKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MspmpuoadKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for MspmpuoadKey {
            #[inline(always)]
            fn from(val: u8) -> MspmpuoadKey {
                MspmpuoadKey::from_bits(val)
            }
        }
        impl From<MspmpuoadKey> for u8 {
            #[inline(always)]
            fn from(val: MspmpuoadKey) -> u8 {
                MspmpuoadKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuoadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuoadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuoadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuoadOad {
            #[inline(always)]
            fn from(val: u8) -> MspmpuoadOad {
                MspmpuoadOad::from_bits(val)
            }
        }
        impl From<MspmpuoadOad> for u8 {
            #[inline(always)]
            fn from(val: MspmpuoadOad) -> u8 {
                MspmpuoadOad::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct MspmpuptKey(u8);
        impl MspmpuptKey {}
        impl MspmpuptKey {
            pub const fn from_bits(val: u8) -> MspmpuptKey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for MspmpuptKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MspmpuptKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for MspmpuptKey {
            #[inline(always)]
            fn from(val: u8) -> MspmpuptKey {
                MspmpuptKey::from_bits(val)
            }
        }
        impl From<MspmpuptKey> for u8 {
            #[inline(always)]
            fn from(val: MspmpuptKey) -> u8 {
                MspmpuptKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuptProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuptProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuptProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuptProtect {
            #[inline(always)]
            fn from(val: u8) -> MspmpuptProtect {
                MspmpuptProtect::from_bits(val)
            }
        }
        impl From<MspmpuptProtect> for u8 {
            #[inline(always)]
            fn from(val: MspmpuptProtect) -> u8 {
                MspmpuptProtect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuctlEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuctlEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuctlEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuctlEnable {
            #[inline(always)]
            fn from(val: u8) -> PspmpuctlEnable {
                PspmpuctlEnable::from_bits(val)
            }
        }
        impl From<PspmpuctlEnable> for u8 {
            #[inline(always)]
            fn from(val: PspmpuctlEnable) -> u8 {
                PspmpuctlEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuctlError {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuctlError {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuctlError {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuctlError {
            #[inline(always)]
            fn from(val: u8) -> PspmpuctlError {
                PspmpuctlError::from_bits(val)
            }
        }
        impl From<PspmpuctlError> for u8 {
            #[inline(always)]
            fn from(val: PspmpuctlError) -> u8 {
                PspmpuctlError::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct PspmpuoadKey(u8);
        impl PspmpuoadKey {}
        impl PspmpuoadKey {
            pub const fn from_bits(val: u8) -> PspmpuoadKey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for PspmpuoadKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PspmpuoadKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for PspmpuoadKey {
            #[inline(always)]
            fn from(val: u8) -> PspmpuoadKey {
                PspmpuoadKey::from_bits(val)
            }
        }
        impl From<PspmpuoadKey> for u8 {
            #[inline(always)]
            fn from(val: PspmpuoadKey) -> u8 {
                PspmpuoadKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuoadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuoadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuoadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuoadOad {
            #[inline(always)]
            fn from(val: u8) -> PspmpuoadOad {
                PspmpuoadOad::from_bits(val)
            }
        }
        impl From<PspmpuoadOad> for u8 {
            #[inline(always)]
            fn from(val: PspmpuoadOad) -> u8 {
                PspmpuoadOad::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct PspmpuptKey(u8);
        impl PspmpuptKey {}
        impl PspmpuptKey {
            pub const fn from_bits(val: u8) -> PspmpuptKey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for PspmpuptKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PspmpuptKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for PspmpuptKey {
            #[inline(always)]
            fn from(val: u8) -> PspmpuptKey {
                PspmpuptKey::from_bits(val)
            }
        }
        impl From<PspmpuptKey> for u8 {
            #[inline(always)]
            fn from(val: PspmpuptKey) -> u8 {
                PspmpuptKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuptProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuptProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuptProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuptProtect {
            #[inline(always)]
            fn from(val: u8) -> PspmpuptProtect {
                PspmpuptProtect::from_bits(val)
            }
        }
        impl From<PspmpuptProtect> for u8 {
            #[inline(always)]
            fn from(val: PspmpuptProtect) -> u8 {
                PspmpuptProtect::to_bits(val)
            }
        }
    }
}
pub mod sram {
    #[doc = "SRAM Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sram {
        ptr: *mut u8,
    }
    unsafe impl Send for Sram {}
    unsafe impl Sync for Sram {}
    impl Sram {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SRAM Parity Error Operation After Detection Register"]
        #[inline(always)]
        pub const fn parioad(self) -> crate::common::Reg<regs::Parioad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SRAM Protection Register"]
        #[inline(always)]
        pub const fn sramprcr(self) -> crate::common::Reg<regs::Sramprcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "ECC Operating Mode Control Register"]
        #[inline(always)]
        pub const fn eccmode(self) -> crate::common::Reg<regs::Eccmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "ECC 2-Bit Error Status Register"]
        #[inline(always)]
        pub const fn ecc2sts(self) -> crate::common::Reg<regs::Ecc2sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc1usize) as _) }
        }
        #[doc = "ECC 1-Bit Error Information Update Enable Register"]
        #[inline(always)]
        pub const fn ecc1stsen(self) -> crate::common::Reg<regs::Ecc1stsen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc2usize) as _) }
        }
        #[doc = "ECC 1-Bit Error Status Register"]
        #[inline(always)]
        pub const fn ecc1sts(self) -> crate::common::Reg<regs::Ecc1sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc3usize) as _) }
        }
        #[doc = "ECC Protection Register"]
        #[inline(always)]
        pub const fn eccprcr(self) -> crate::common::Reg<regs::Eccprcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc4usize) as _) }
        }
        #[doc = "ECC Protection Register 2"]
        #[inline(always)]
        pub const fn eccprcr2(self) -> crate::common::Reg<regs::Eccprcr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
        }
        #[doc = "ECC Test Control Register"]
        #[inline(always)]
        pub const fn eccetst(self) -> crate::common::Reg<regs::Eccetst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
        }
        #[doc = "SRAM ECC Error Operation After Detection Register"]
        #[inline(always)]
        pub const fn eccoad(self) -> crate::common::Reg<regs::Eccoad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "ECC 1-Bit Error Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ecc1sts(pub u8);
        impl Ecc1sts {
            #[doc = "ECC 1-Bit Error Status"]
            #[inline(always)]
            pub const fn ecc1err(&self) -> super::vals::Ecc1err {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ecc1err::from_bits(val as u8)
            }
            #[doc = "ECC 1-Bit Error Status"]
            #[inline(always)]
            pub fn set_ecc1err(&mut self, val: super::vals::Ecc1err) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Ecc1sts {
            #[inline(always)]
            fn default() -> Ecc1sts {
                Ecc1sts(0)
            }
        }
        impl core::fmt::Debug for Ecc1sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ecc1sts")
                    .field("ecc1err", &self.ecc1err())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ecc1sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ecc1sts {{ ecc1err: {:?}, reserved_1_7: {=u8:?} }}",
                    self.ecc1err(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "ECC 1-Bit Error Information Update Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ecc1stsen(pub u8);
        impl Ecc1stsen {
            #[doc = "ECC 1-Bit Error Information Update Enable"]
            #[inline(always)]
            pub const fn e1stsen(&self) -> super::vals::E1stsen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::E1stsen::from_bits(val as u8)
            }
            #[doc = "ECC 1-Bit Error Information Update Enable"]
            #[inline(always)]
            pub fn set_e1stsen(&mut self, val: super::vals::E1stsen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Ecc1stsen {
            #[inline(always)]
            fn default() -> Ecc1stsen {
                Ecc1stsen(0)
            }
        }
        impl core::fmt::Debug for Ecc1stsen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ecc1stsen")
                    .field("e1stsen", &self.e1stsen())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ecc1stsen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ecc1stsen {{ e1stsen: {:?}, reserved_1_7: {=u8:?} }}",
                    self.e1stsen(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "ECC 2-Bit Error Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ecc2sts(pub u8);
        impl Ecc2sts {
            #[doc = "ECC 2-Bit Error Status"]
            #[inline(always)]
            pub const fn ecc2err(&self) -> super::vals::Ecc2err {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ecc2err::from_bits(val as u8)
            }
            #[doc = "ECC 2-Bit Error Status"]
            #[inline(always)]
            pub fn set_ecc2err(&mut self, val: super::vals::Ecc2err) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Ecc2sts {
            #[inline(always)]
            fn default() -> Ecc2sts {
                Ecc2sts(0)
            }
        }
        impl core::fmt::Debug for Ecc2sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ecc2sts")
                    .field("ecc2err", &self.ecc2err())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ecc2sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ecc2sts {{ ecc2err: {:?}, reserved_1_7: {=u8:?} }}",
                    self.ecc2err(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "ECC Test Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccetst(pub u8);
        impl Eccetst {
            #[doc = "ECC Bypass Select"]
            #[inline(always)]
            pub const fn tstbyp(&self) -> super::vals::Tstbyp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tstbyp::from_bits(val as u8)
            }
            #[doc = "ECC Bypass Select"]
            #[inline(always)]
            pub fn set_tstbyp(&mut self, val: super::vals::Tstbyp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Eccetst {
            #[inline(always)]
            fn default() -> Eccetst {
                Eccetst(0)
            }
        }
        impl core::fmt::Debug for Eccetst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccetst")
                    .field("tstbyp", &self.tstbyp())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccetst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Eccetst {{ tstbyp: {:?}, reserved_1_7: {=u8:?} }}",
                    self.tstbyp(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "ECC Operating Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccmode(pub u8);
        impl Eccmode {
            #[doc = "ECC Operating Mode Select"]
            #[inline(always)]
            pub const fn eccmod(&self) -> super::vals::Eccmod {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Eccmod::from_bits(val as u8)
            }
            #[doc = "ECC Operating Mode Select"]
            #[inline(always)]
            pub fn set_eccmod(&mut self, val: super::vals::Eccmod) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Eccmode {
            #[inline(always)]
            fn default() -> Eccmode {
                Eccmode(0)
            }
        }
        impl core::fmt::Debug for Eccmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccmode")
                    .field("eccmod", &self.eccmod())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccmode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Eccmode {{ eccmod: {:?}, reserved_2_7: {=u8:?} }}",
                    self.eccmod(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "SRAM ECC Error Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccoad(pub u8);
        impl Eccoad {
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::EccoadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EccoadOad::from_bits(val as u8)
            }
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::EccoadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Eccoad {
            #[inline(always)]
            fn default() -> Eccoad {
                Eccoad(0)
            }
        }
        impl core::fmt::Debug for Eccoad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccoad")
                    .field("oad", &self.oad())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccoad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Eccoad {{ oad: {:?}, reserved_1_7: {=u8:?} }}",
                    self.oad(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "ECC Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccprcr(pub u8);
        impl Eccprcr {
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub const fn eccprcr(&self) -> super::vals::Eccprcr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Eccprcr::from_bits(val as u8)
            }
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub fn set_eccprcr(&mut self, val: super::vals::Eccprcr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub const fn kw(&self) -> super::vals::EccprcrKw {
                let val = (self.0 >> 1usize) & 0x7f;
                super::vals::EccprcrKw::from_bits(val as u8)
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub fn set_kw(&mut self, val: super::vals::EccprcrKw) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val.to_bits() as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Eccprcr {
            #[inline(always)]
            fn default() -> Eccprcr {
                Eccprcr(0)
            }
        }
        impl core::fmt::Debug for Eccprcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccprcr")
                    .field("eccprcr", &self.eccprcr())
                    .field("kw", &self.kw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccprcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Eccprcr {{ eccprcr: {:?}, kw: {:?} }}",
                    self.eccprcr(),
                    self.kw()
                )
            }
        }
        #[doc = "ECC Protection Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccprcr2(pub u8);
        impl Eccprcr2 {
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub const fn eccprcr2(&self) -> super::vals::Eccprcr2 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Eccprcr2::from_bits(val as u8)
            }
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub fn set_eccprcr2(&mut self, val: super::vals::Eccprcr2) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub const fn kw(&self) -> super::vals::Eccprcr2Kw {
                let val = (self.0 >> 1usize) & 0x7f;
                super::vals::Eccprcr2Kw::from_bits(val as u8)
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub fn set_kw(&mut self, val: super::vals::Eccprcr2Kw) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val.to_bits() as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Eccprcr2 {
            #[inline(always)]
            fn default() -> Eccprcr2 {
                Eccprcr2(0)
            }
        }
        impl core::fmt::Debug for Eccprcr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccprcr2")
                    .field("eccprcr2", &self.eccprcr2())
                    .field("kw", &self.kw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccprcr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Eccprcr2 {{ eccprcr2: {:?}, kw: {:?} }}",
                    self.eccprcr2(),
                    self.kw()
                )
            }
        }
        #[doc = "SRAM Parity Error Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Parioad(pub u8);
        impl Parioad {
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::ParioadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ParioadOad::from_bits(val as u8)
            }
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::ParioadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Parioad {
            #[inline(always)]
            fn default() -> Parioad {
                Parioad(0)
            }
        }
        impl core::fmt::Debug for Parioad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Parioad")
                    .field("oad", &self.oad())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Parioad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Parioad {{ oad: {:?}, reserved_1_7: {=u8:?} }}",
                    self.oad(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "SRAM Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sramprcr(pub u8);
        impl Sramprcr {
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub const fn sramprcr(&self) -> super::vals::Sramprcr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sramprcr::from_bits(val as u8)
            }
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub fn set_sramprcr(&mut self, val: super::vals::Sramprcr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub const fn kw(&self) -> super::vals::SramprcrKw {
                let val = (self.0 >> 1usize) & 0x7f;
                super::vals::SramprcrKw::from_bits(val as u8)
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub fn set_kw(&mut self, val: super::vals::SramprcrKw) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val.to_bits() as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Sramprcr {
            #[inline(always)]
            fn default() -> Sramprcr {
                Sramprcr(0)
            }
        }
        impl core::fmt::Debug for Sramprcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sramprcr")
                    .field("sramprcr", &self.sramprcr())
                    .field("kw", &self.kw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sramprcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sramprcr {{ sramprcr: {:?}, kw: {:?} }}",
                    self.sramprcr(),
                    self.kw()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum E1stsen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl E1stsen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> E1stsen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for E1stsen {
            #[inline(always)]
            fn from(val: u8) -> E1stsen {
                E1stsen::from_bits(val)
            }
        }
        impl From<E1stsen> for u8 {
            #[inline(always)]
            fn from(val: E1stsen) -> u8 {
                E1stsen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ecc1err {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ecc1err {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ecc1err {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ecc1err {
            #[inline(always)]
            fn from(val: u8) -> Ecc1err {
                Ecc1err::from_bits(val)
            }
        }
        impl From<Ecc1err> for u8 {
            #[inline(always)]
            fn from(val: Ecc1err) -> u8 {
                Ecc1err::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ecc2err {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ecc2err {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ecc2err {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ecc2err {
            #[inline(always)]
            fn from(val: u8) -> Ecc2err {
                Ecc2err::from_bits(val)
            }
        }
        impl From<Ecc2err> for u8 {
            #[inline(always)]
            fn from(val: Ecc2err) -> u8 {
                Ecc2err::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eccmod {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Eccmod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eccmod {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eccmod {
            #[inline(always)]
            fn from(val: u8) -> Eccmod {
                Eccmod::from_bits(val)
            }
        }
        impl From<Eccmod> for u8 {
            #[inline(always)]
            fn from(val: Eccmod) -> u8 {
                Eccmod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EccoadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EccoadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EccoadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EccoadOad {
            #[inline(always)]
            fn from(val: u8) -> EccoadOad {
                EccoadOad::from_bits(val)
            }
        }
        impl From<EccoadOad> for u8 {
            #[inline(always)]
            fn from(val: EccoadOad) -> u8 {
                EccoadOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eccprcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eccprcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eccprcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eccprcr {
            #[inline(always)]
            fn from(val: u8) -> Eccprcr {
                Eccprcr::from_bits(val)
            }
        }
        impl From<Eccprcr> for u8 {
            #[inline(always)]
            fn from(val: Eccprcr) -> u8 {
                Eccprcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eccprcr2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eccprcr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eccprcr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eccprcr2 {
            #[inline(always)]
            fn from(val: u8) -> Eccprcr2 {
                Eccprcr2::from_bits(val)
            }
        }
        impl From<Eccprcr2> for u8 {
            #[inline(always)]
            fn from(val: Eccprcr2) -> u8 {
                Eccprcr2::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Eccprcr2Kw(u8);
        impl Eccprcr2Kw {}
        impl Eccprcr2Kw {
            pub const fn from_bits(val: u8) -> Eccprcr2Kw {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Eccprcr2Kw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccprcr2Kw {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Eccprcr2Kw {
            #[inline(always)]
            fn from(val: u8) -> Eccprcr2Kw {
                Eccprcr2Kw::from_bits(val)
            }
        }
        impl From<Eccprcr2Kw> for u8 {
            #[inline(always)]
            fn from(val: Eccprcr2Kw) -> u8 {
                Eccprcr2Kw::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EccprcrKw(u8);
        impl EccprcrKw {}
        impl EccprcrKw {
            pub const fn from_bits(val: u8) -> EccprcrKw {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for EccprcrKw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EccprcrKw {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for EccprcrKw {
            #[inline(always)]
            fn from(val: u8) -> EccprcrKw {
                EccprcrKw::from_bits(val)
            }
        }
        impl From<EccprcrKw> for u8 {
            #[inline(always)]
            fn from(val: EccprcrKw) -> u8 {
                EccprcrKw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ParioadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ParioadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ParioadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ParioadOad {
            #[inline(always)]
            fn from(val: u8) -> ParioadOad {
                ParioadOad::from_bits(val)
            }
        }
        impl From<ParioadOad> for u8 {
            #[inline(always)]
            fn from(val: ParioadOad) -> u8 {
                ParioadOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sramprcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sramprcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sramprcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sramprcr {
            #[inline(always)]
            fn from(val: u8) -> Sramprcr {
                Sramprcr::from_bits(val)
            }
        }
        impl From<Sramprcr> for u8 {
            #[inline(always)]
            fn from(val: Sramprcr) -> u8 {
                Sramprcr::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SramprcrKw(u8);
        impl SramprcrKw {}
        impl SramprcrKw {
            pub const fn from_bits(val: u8) -> SramprcrKw {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for SramprcrKw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SramprcrKw {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for SramprcrKw {
            #[inline(always)]
            fn from(val: u8) -> SramprcrKw {
                SramprcrKw::from_bits(val)
            }
        }
        impl From<SramprcrKw> for u8 {
            #[inline(always)]
            fn from(val: SramprcrKw) -> u8 {
                SramprcrKw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstbyp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstbyp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstbyp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstbyp {
            #[inline(always)]
            fn from(val: u8) -> Tstbyp {
                Tstbyp::from_bits(val)
            }
        }
        impl From<Tstbyp> for u8 {
            #[inline(always)]
            fn from(val: Tstbyp) -> u8 {
                Tstbyp::to_bits(val)
            }
        }
    }
}
pub mod system {
    #[doc = "System Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct System {
        ptr: *mut u8,
    }
    unsafe impl Send for System {}
    unsafe impl Sync for System {}
    impl System {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Standby Control Register"]
        #[inline(always)]
        pub const fn sbycr(self) -> crate::common::Reg<regs::Sbycr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Module Stop Control Register A"]
        #[inline(always)]
        pub const fn mstpcra(self) -> crate::common::Reg<regs::Mstpcra, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "System Clock Division Control Register"]
        #[inline(always)]
        pub const fn sckdivcr(self) -> crate::common::Reg<regs::Sckdivcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "System Clock Source Control Register"]
        #[inline(always)]
        pub const fn sckscr(self) -> crate::common::Reg<regs::Sckscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x26usize) as _) }
        }
        #[doc = "Memory Wait Cycle Control Register"]
        #[inline(always)]
        pub const fn memwait(self) -> crate::common::Reg<regs::Memwait, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x31usize) as _) }
        }
        #[doc = "Main Clock Oscillator Control Register"]
        #[inline(always)]
        pub const fn mosccr(self) -> crate::common::Reg<regs::Mosccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x32usize) as _) }
        }
        #[doc = "High,Speed On,Chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn hococr(self) -> crate::common::Reg<regs::Hococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x36usize) as _) }
        }
        #[doc = "Middle,Speed On,Chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn mococr(self) -> crate::common::Reg<regs::Mococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Oscillation Stabilization Flag Register"]
        #[inline(always)]
        pub const fn oscsf(self) -> crate::common::Reg<regs::Oscsf, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Clock Out Control Register"]
        #[inline(always)]
        pub const fn ckocr(self) -> crate::common::Reg<regs::Ckocr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3eusize) as _) }
        }
        #[doc = "Oscillation Stop Detection Control Register"]
        #[inline(always)]
        pub const fn ostdcr(self) -> crate::common::Reg<regs::Ostdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Oscillation Stop Detection Status Register"]
        #[inline(always)]
        pub const fn ostdsr(self) -> crate::common::Reg<regs::Ostdsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x41usize) as _) }
        }
        #[doc = "MOCO User Trimming Control Register"]
        #[inline(always)]
        pub const fn mocoutcr(self) -> crate::common::Reg<regs::Mocoutcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x61usize) as _) }
        }
        #[doc = "HOCO User Trimming Control Register"]
        #[inline(always)]
        pub const fn hocoutcr(self) -> crate::common::Reg<regs::Hocoutcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x62usize) as _) }
        }
        #[doc = "Snooze Control Register"]
        #[inline(always)]
        pub const fn snzcr(self) -> crate::common::Reg<regs::Snzcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x92usize) as _) }
        }
        #[doc = "Snooze End Control Register"]
        #[inline(always)]
        pub const fn snzedcr(self) -> crate::common::Reg<regs::Snzedcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Snooze Request Control Register"]
        #[inline(always)]
        pub const fn snzreqcr(self) -> crate::common::Reg<regs::Snzreqcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "Flash Operation Control Register"]
        #[inline(always)]
        pub const fn flstop(self) -> crate::common::Reg<regs::Flstop, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9eusize) as _) }
        }
        #[doc = "Operating Power Control Register"]
        #[inline(always)]
        pub const fn opccr(self) -> crate::common::Reg<regs::Opccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "Main Clock Oscillator Wait Control Register"]
        #[inline(always)]
        pub const fn moscwtcr(self) -> crate::common::Reg<regs::Moscwtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa2usize) as _) }
        }
        #[doc = "High,Speed On,Chip Oscillator Wait Control Register"]
        #[inline(always)]
        pub const fn hocowtcr(self) -> crate::common::Reg<regs::Hocowtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa5usize) as _) }
        }
        #[doc = "Sub Operating Power Control Register"]
        #[inline(always)]
        pub const fn sopccr(self) -> crate::common::Reg<regs::Sopccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xaausize) as _) }
        }
        #[doc = "Reset Status Register 1"]
        #[inline(always)]
        pub const fn rstsr1(self) -> crate::common::Reg<regs::Rstsr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "24-bit Sigma,Delta A/D Converter Clock Control Register"]
        #[inline(always)]
        pub const fn sdadcckcr(self) -> crate::common::Reg<regs::Sdadcckcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd1usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register 1"]
        #[inline(always)]
        pub const fn lvd1cr1(self) -> crate::common::Reg<regs::Lvd1cr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Status Register"]
        #[inline(always)]
        pub const fn lvd1sr(self) -> crate::common::Reg<regs::Lvd1sr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe1usize) as _) }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 1"]
        #[inline(always)]
        pub const fn lvd2cr1(self) -> crate::common::Reg<regs::Lvd2cr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe2usize) as _) }
        }
        #[doc = "Voltage Monitor 2 Circuit Status Register"]
        #[inline(always)]
        pub const fn lvd2sr(self) -> crate::common::Reg<regs::Lvd2sr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe3usize) as _) }
        }
        #[doc = "Protect Register"]
        #[inline(always)]
        pub const fn prcr(self) -> crate::common::Reg<regs::Prcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03feusize) as _) }
        }
        #[doc = "System Control OCD Control Register"]
        #[inline(always)]
        pub const fn syocdcr(self) -> crate::common::Reg<regs::Syocdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x040eusize) as _) }
        }
        #[doc = "Reset Status Register 0"]
        #[inline(always)]
        pub const fn rstsr0(self) -> crate::common::Reg<regs::Rstsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Reset Status Register 2"]
        #[inline(always)]
        pub const fn rstsr2(self) -> crate::common::Reg<regs::Rstsr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0411usize) as _) }
        }
        #[doc = "Main Clock Oscillator Mode Oscillation Control Register"]
        #[inline(always)]
        pub const fn momcr(self) -> crate::common::Reg<regs::Momcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0413usize) as _) }
        }
        #[doc = "Voltage Monitor Circuit Control Register"]
        #[inline(always)]
        pub const fn lvcmpcr(self) -> crate::common::Reg<regs::Lvcmpcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0417usize) as _) }
        }
        #[doc = "Voltage Detection Level Select Register"]
        #[inline(always)]
        pub const fn lvdlvlr(self) -> crate::common::Reg<regs::Lvdlvlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0418usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register 0"]
        #[inline(always)]
        pub const fn lvd1cr0(self) -> crate::common::Reg<regs::Lvd1cr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x041ausize) as _) }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 0"]
        #[inline(always)]
        pub const fn lvd2cr0(self) -> crate::common::Reg<regs::Lvd2cr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x041busize) as _) }
        }
        #[doc = "Sub,clock Oscillator Control Register"]
        #[inline(always)]
        pub const fn sosccr(self) -> crate::common::Reg<regs::Sosccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0480usize) as _) }
        }
        #[doc = "Sub,clock Oscillator Mode Control Register"]
        #[inline(always)]
        pub const fn somcr(self) -> crate::common::Reg<regs::Somcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0481usize) as _) }
        }
        #[doc = "Low,Speed On,Chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn lococr(self) -> crate::common::Reg<regs::Lococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0490usize) as _) }
        }
        #[doc = "LOCO User Trimming Control Register"]
        #[inline(always)]
        pub const fn locoutcr(self) -> crate::common::Reg<regs::Locoutcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0492usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Clock Out Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ckocr(pub u8);
        impl Ckocr {
            #[doc = "Clock out source select"]
            #[inline(always)]
            pub const fn ckosel(&self) -> super::vals::Ckosel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ckosel::from_bits(val as u8)
            }
            #[doc = "Clock out source select"]
            #[inline(always)]
            pub fn set_ckosel(&mut self, val: super::vals::Ckosel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_3_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_3_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Clock out input frequency Division Select"]
            #[inline(always)]
            pub const fn ckodiv(&self) -> super::vals::Ckodiv {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Ckodiv::from_bits(val as u8)
            }
            #[doc = "Clock out input frequency Division Select"]
            #[inline(always)]
            pub fn set_ckodiv(&mut self, val: super::vals::Ckodiv) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "Clock out enable"]
            #[inline(always)]
            pub const fn ckoen(&self) -> super::vals::Ckoen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ckoen::from_bits(val as u8)
            }
            #[doc = "Clock out enable"]
            #[inline(always)]
            pub fn set_ckoen(&mut self, val: super::vals::Ckoen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ckocr {
            #[inline(always)]
            fn default() -> Ckocr {
                Ckocr(0)
            }
        }
        impl core::fmt::Debug for Ckocr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ckocr")
                    .field("ckosel", &self.ckosel())
                    .field("reserved_3_3", &self.reserved_3_3())
                    .field("ckodiv", &self.ckodiv())
                    .field("ckoen", &self.ckoen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ckocr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ckocr {{ ckosel: {:?}, reserved_3_3: {=bool:?}, ckodiv: {:?}, ckoen: {:?} }}",
                    self.ckosel(),
                    self.reserved_3_3(),
                    self.ckodiv(),
                    self.ckoen()
                )
            }
        }
        #[doc = "Flash Operation Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Flstop(pub u8);
        impl Flstop {
            #[doc = "Selecting ON/OFF of the Flash Memory Operation"]
            #[inline(always)]
            pub const fn flstop(&self) -> super::vals::Flstop {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Flstop::from_bits(val as u8)
            }
            #[doc = "Selecting ON/OFF of the Flash Memory Operation"]
            #[inline(always)]
            pub fn set_flstop(&mut self, val: super::vals::Flstop) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_1_3(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_1_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "Flash Memory Operation Status Flag"]
            #[inline(always)]
            pub const fn flstpf(&self) -> super::vals::Flstpf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Flstpf::from_bits(val as u8)
            }
            #[doc = "Flash Memory Operation Status Flag"]
            #[inline(always)]
            pub fn set_flstpf(&mut self, val: super::vals::Flstpf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Flstop {
            #[inline(always)]
            fn default() -> Flstop {
                Flstop(0)
            }
        }
        impl core::fmt::Debug for Flstop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Flstop")
                    .field("flstop", &self.flstop())
                    .field("reserved_1_3", &self.reserved_1_3())
                    .field("flstpf", &self.flstpf())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Flstop {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Flstop {{ flstop: {:?}, reserved_1_3: {=u8:?}, flstpf: {:?}, reserved_5_7: {=u8:?} }}" , self . flstop () , self . reserved_1_3 () , self . flstpf () , self . reserved_5_7 ())
            }
        }
        #[doc = "High,Speed On,Chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hococr(pub u8);
        impl Hococr {
            #[doc = "HOCO Stop"]
            #[inline(always)]
            pub const fn hcstp(&self) -> super::vals::Hcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hcstp::from_bits(val as u8)
            }
            #[doc = "HOCO Stop"]
            #[inline(always)]
            pub fn set_hcstp(&mut self, val: super::vals::Hcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Hococr {
            #[inline(always)]
            fn default() -> Hococr {
                Hococr(0)
            }
        }
        impl core::fmt::Debug for Hococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hococr")
                    .field("hcstp", &self.hcstp())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hococr {{ hcstp: {:?}, reserved_1_7: {=u8:?} }}",
                    self.hcstp(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "HOCO User Trimming Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hocoutcr(pub u8);
        impl Hocoutcr {
            #[doc = "HOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original HOCO trimming bits"]
            #[inline(always)]
            pub const fn hocoutrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "HOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original HOCO trimming bits"]
            #[inline(always)]
            pub fn set_hocoutrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Hocoutcr {
            #[inline(always)]
            fn default() -> Hocoutcr {
                Hocoutcr(0)
            }
        }
        impl core::fmt::Debug for Hocoutcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hocoutcr")
                    .field("hocoutrm", &self.hocoutrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hocoutcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hocoutcr {{ hocoutrm: {=u8:?} }}", self.hocoutrm())
            }
        }
        #[doc = "High,Speed On,Chip Oscillator Wait Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hocowtcr(pub u8);
        impl Hocowtcr {
            #[doc = "HOCO wait time setting"]
            #[inline(always)]
            pub const fn hsts(&self) -> super::vals::Hsts {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Hsts::from_bits(val as u8)
            }
            #[doc = "HOCO wait time setting"]
            #[inline(always)]
            pub fn set_hsts(&mut self, val: super::vals::Hsts) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Hocowtcr {
            #[inline(always)]
            fn default() -> Hocowtcr {
                Hocowtcr(0)
            }
        }
        impl core::fmt::Debug for Hocowtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hocowtcr")
                    .field("hsts", &self.hsts())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hocowtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hocowtcr {{ hsts: {:?}, reserved_3_7: {=u8:?} }}",
                    self.hsts(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "Low,Speed On,Chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lococr(pub u8);
        impl Lococr {
            #[doc = "LOCO Stop"]
            #[inline(always)]
            pub const fn lcstp(&self) -> super::vals::Lcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lcstp::from_bits(val as u8)
            }
            #[doc = "LOCO Stop"]
            #[inline(always)]
            pub fn set_lcstp(&mut self, val: super::vals::Lcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Lococr {
            #[inline(always)]
            fn default() -> Lococr {
                Lococr(0)
            }
        }
        impl core::fmt::Debug for Lococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lococr")
                    .field("lcstp", &self.lcstp())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lococr {{ lcstp: {:?}, reserved_1_7: {=u8:?} }}",
                    self.lcstp(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "LOCO User Trimming Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Locoutcr(pub u8);
        impl Locoutcr {
            #[doc = "LOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original LOCO trimming bits"]
            #[inline(always)]
            pub const fn locoutrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "LOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original LOCO trimming bits"]
            #[inline(always)]
            pub fn set_locoutrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Locoutcr {
            #[inline(always)]
            fn default() -> Locoutcr {
                Locoutcr(0)
            }
        }
        impl core::fmt::Debug for Locoutcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Locoutcr")
                    .field("locoutrm", &self.locoutrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Locoutcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Locoutcr {{ locoutrm: {=u8:?} }}", self.locoutrm())
            }
        }
        #[doc = "Voltage Monitor Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvcmpcr(pub u8);
        impl Lvcmpcr {
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_0_4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_0_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
            #[doc = "Voltage Detection 1 Enable"]
            #[inline(always)]
            pub const fn lvd1e(&self) -> super::vals::Lvd1e {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Lvd1e::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 1 Enable"]
            #[inline(always)]
            pub fn set_lvd1e(&mut self, val: super::vals::Lvd1e) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Voltage Detection 2 Enable"]
            #[inline(always)]
            pub const fn lvd2e(&self) -> super::vals::Lvd2e {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd2e::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 2 Enable"]
            #[inline(always)]
            pub fn set_lvd2e(&mut self, val: super::vals::Lvd2e) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lvcmpcr {
            #[inline(always)]
            fn default() -> Lvcmpcr {
                Lvcmpcr(0)
            }
        }
        impl core::fmt::Debug for Lvcmpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvcmpcr")
                    .field("reserved_0_4", &self.reserved_0_4())
                    .field("lvd1e", &self.lvd1e())
                    .field("lvd2e", &self.lvd2e())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvcmpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Lvcmpcr {{ reserved_0_4: {=u8:?}, lvd1e: {:?}, lvd2e: {:?}, reserved_7_7: {=bool:?} }}" , self . reserved_0_4 () , self . lvd1e () , self . lvd2e () , self . reserved_7_7 ())
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1cr0(pub u8);
        impl Lvd1cr0 {
            #[doc = "Voltage Monitor 1 Interrupt/ Reset Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::Lvd1cr0Rie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd1cr0Rie::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt/ Reset Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::Lvd1cr0Rie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Voltage Monitor 1 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub const fn cmpe(&self) -> super::vals::Lvd1cr0Cmpe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1cr0Cmpe::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub fn set_cmpe(&mut self, val: super::vals::Lvd1cr0Cmpe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_3_5(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_3_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 3usize)) | (((val as u8) & 0x07) << 3usize);
            }
            #[doc = "Voltage Monitor 1 Circuit Mode Select"]
            #[inline(always)]
            pub const fn ri(&self) -> super::vals::Lvd1cr0Ri {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd1cr0Ri::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Circuit Mode Select"]
            #[inline(always)]
            pub fn set_ri(&mut self, val: super::vals::Lvd1cr0Ri) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Voltage Monitor 1 Reset Negate Select"]
            #[inline(always)]
            pub const fn rn(&self) -> super::vals::Lvd1cr0Rn {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lvd1cr0Rn::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Reset Negate Select"]
            #[inline(always)]
            pub fn set_rn(&mut self, val: super::vals::Lvd1cr0Rn) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lvd1cr0 {
            #[inline(always)]
            fn default() -> Lvd1cr0 {
                Lvd1cr0(0)
            }
        }
        impl core::fmt::Debug for Lvd1cr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1cr0")
                    .field("rie", &self.rie())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("cmpe", &self.cmpe())
                    .field("reserved_3_5", &self.reserved_3_5())
                    .field("ri", &self.ri())
                    .field("rn", &self.rn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1cr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Lvd1cr0 {{ rie: {:?}, reserved_1_1: {=bool:?}, cmpe: {:?}, reserved_3_5: {=u8:?}, ri: {:?}, rn: {:?} }}" , self . rie () , self . reserved_1_1 () , self . cmpe () , self . reserved_3_5 () , self . ri () , self . rn ())
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1cr1(pub u8);
        impl Lvd1cr1 {
            #[doc = "Voltage Monitor 1 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub const fn idtsel(&self) -> super::vals::Lvd1cr1Idtsel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lvd1cr1Idtsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub fn set_idtsel(&mut self, val: super::vals::Lvd1cr1Idtsel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Type Select"]
            #[inline(always)]
            pub const fn irqsel(&self) -> super::vals::Lvd1cr1Irqsel {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1cr1Irqsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Type Select"]
            #[inline(always)]
            pub fn set_irqsel(&mut self, val: super::vals::Lvd1cr1Irqsel) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Lvd1cr1 {
            #[inline(always)]
            fn default() -> Lvd1cr1 {
                Lvd1cr1(0)
            }
        }
        impl core::fmt::Debug for Lvd1cr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1cr1")
                    .field("idtsel", &self.idtsel())
                    .field("irqsel", &self.irqsel())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1cr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1cr1 {{ idtsel: {:?}, irqsel: {:?}, reserved_3_7: {=u8:?} }}",
                    self.idtsel(),
                    self.irqsel(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1sr(pub u8);
        impl Lvd1sr {
            #[doc = "Voltage Monitor 1 Voltage Change Detection Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::Lvd1srDet {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd1srDet::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Voltage Change Detection Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::Lvd1srDet) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Signal Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::Lvd1srMon {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd1srMon::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Signal Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::Lvd1srMon) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Lvd1sr {
            #[inline(always)]
            fn default() -> Lvd1sr {
                Lvd1sr(0)
            }
        }
        impl core::fmt::Debug for Lvd1sr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1sr")
                    .field("det", &self.det())
                    .field("mon", &self.mon())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1sr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1sr {{ det: {:?}, mon: {:?}, reserved_2_7: {=u8:?} }}",
                    self.det(),
                    self.mon(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd2cr0(pub u8);
        impl Lvd2cr0 {
            #[doc = "Voltage Monitor 2 Interrupt/Reset Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::Lvd2cr0Rie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd2cr0Rie::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt/Reset Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::Lvd2cr0Rie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Voltage Monitor 2 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub const fn cmpe(&self) -> super::vals::Lvd2cr0Cmpe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd2cr0Cmpe::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub fn set_cmpe(&mut self, val: super::vals::Lvd2cr0Cmpe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_3_5(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_3_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 3usize)) | (((val as u8) & 0x07) << 3usize);
            }
            #[doc = "Voltage Monitor 2 Circuit Mode Select"]
            #[inline(always)]
            pub const fn ri(&self) -> super::vals::Lvd2cr0Ri {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd2cr0Ri::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Circuit Mode Select"]
            #[inline(always)]
            pub fn set_ri(&mut self, val: super::vals::Lvd2cr0Ri) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Voltage Monitor 2 Reset Negate Select"]
            #[inline(always)]
            pub const fn rn(&self) -> super::vals::Lvd2cr0Rn {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lvd2cr0Rn::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Reset Negate Select"]
            #[inline(always)]
            pub fn set_rn(&mut self, val: super::vals::Lvd2cr0Rn) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lvd2cr0 {
            #[inline(always)]
            fn default() -> Lvd2cr0 {
                Lvd2cr0(0)
            }
        }
        impl core::fmt::Debug for Lvd2cr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd2cr0")
                    .field("rie", &self.rie())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("cmpe", &self.cmpe())
                    .field("reserved_3_5", &self.reserved_3_5())
                    .field("ri", &self.ri())
                    .field("rn", &self.rn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd2cr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Lvd2cr0 {{ rie: {:?}, reserved_1_1: {=bool:?}, cmpe: {:?}, reserved_3_5: {=u8:?}, ri: {:?}, rn: {:?} }}" , self . rie () , self . reserved_1_1 () , self . cmpe () , self . reserved_3_5 () , self . ri () , self . rn ())
            }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd2cr1(pub u8);
        impl Lvd2cr1 {
            #[doc = "Voltage Monitor 2 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub const fn idtsel(&self) -> super::vals::Lvd2cr1Idtsel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lvd2cr1Idtsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub fn set_idtsel(&mut self, val: super::vals::Lvd2cr1Idtsel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Voltage Monitor 2 Interrupt Type Select"]
            #[inline(always)]
            pub const fn irqsel(&self) -> super::vals::Lvd2cr1Irqsel {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd2cr1Irqsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Type Select"]
            #[inline(always)]
            pub fn set_irqsel(&mut self, val: super::vals::Lvd2cr1Irqsel) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Lvd2cr1 {
            #[inline(always)]
            fn default() -> Lvd2cr1 {
                Lvd2cr1(0)
            }
        }
        impl core::fmt::Debug for Lvd2cr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd2cr1")
                    .field("idtsel", &self.idtsel())
                    .field("irqsel", &self.irqsel())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd2cr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd2cr1 {{ idtsel: {:?}, irqsel: {:?}, reserved_3_7: {=u8:?} }}",
                    self.idtsel(),
                    self.irqsel(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "Voltage Monitor 2 Circuit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd2sr(pub u8);
        impl Lvd2sr {
            #[doc = "Voltage Monitor 2 Voltage Change Detection Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::Lvd2srDet {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd2srDet::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Voltage Change Detection Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::Lvd2srDet) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 2 Signal Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::Lvd2srMon {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd2srMon::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Signal Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::Lvd2srMon) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Lvd2sr {
            #[inline(always)]
            fn default() -> Lvd2sr {
                Lvd2sr(0)
            }
        }
        impl core::fmt::Debug for Lvd2sr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd2sr")
                    .field("det", &self.det())
                    .field("mon", &self.mon())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd2sr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd2sr {{ det: {:?}, mon: {:?}, reserved_2_7: {=u8:?} }}",
                    self.det(),
                    self.mon(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "Voltage Detection Level Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvdlvlr(pub u8);
        impl Lvdlvlr {
            #[doc = "Voltage Detection 1 Level Select (Standard voltage during drop in voltage)"]
            #[inline(always)]
            pub const fn lvd1lvl(&self) -> super::vals::Lvd1lvl {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Lvd1lvl::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 1 Level Select (Standard voltage during drop in voltage)"]
            #[inline(always)]
            pub fn set_lvd1lvl(&mut self, val: super::vals::Lvd1lvl) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u8) & 0x1f) << 0usize);
            }
            #[doc = "Voltage Detection 2 Level Select (Standard voltage during drop in voltage)"]
            #[inline(always)]
            pub const fn lvd2lvl(&self) -> super::vals::Lvd2lvl {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::Lvd2lvl::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 2 Level Select (Standard voltage during drop in voltage)"]
            #[inline(always)]
            pub fn set_lvd2lvl(&mut self, val: super::vals::Lvd2lvl) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Lvdlvlr {
            #[inline(always)]
            fn default() -> Lvdlvlr {
                Lvdlvlr(0)
            }
        }
        impl core::fmt::Debug for Lvdlvlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvdlvlr")
                    .field("lvd1lvl", &self.lvd1lvl())
                    .field("lvd2lvl", &self.lvd2lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvdlvlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvdlvlr {{ lvd1lvl: {:?}, lvd2lvl: {:?} }}",
                    self.lvd1lvl(),
                    self.lvd2lvl()
                )
            }
        }
        #[doc = "Memory Wait Cycle Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Memwait(pub u8);
        impl Memwait {
            #[doc = "Memory Wait Cycle Select"]
            #[inline(always)]
            pub const fn memwait(&self) -> super::vals::Memwait {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Memwait::from_bits(val as u8)
            }
            #[doc = "Memory Wait Cycle Select"]
            #[inline(always)]
            pub fn set_memwait(&mut self, val: super::vals::Memwait) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Memwait {
            #[inline(always)]
            fn default() -> Memwait {
                Memwait(0)
            }
        }
        impl core::fmt::Debug for Memwait {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Memwait")
                    .field("memwait", &self.memwait())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Memwait {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Memwait {{ memwait: {:?}, reserved_1_7: {=u8:?} }}",
                    self.memwait(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "Middle,Speed On,Chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mococr(pub u8);
        impl Mococr {
            #[doc = "MOCO Stop"]
            #[inline(always)]
            pub const fn mcstp(&self) -> super::vals::Mcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mcstp::from_bits(val as u8)
            }
            #[doc = "MOCO Stop"]
            #[inline(always)]
            pub fn set_mcstp(&mut self, val: super::vals::Mcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Mococr {
            #[inline(always)]
            fn default() -> Mococr {
                Mococr(0)
            }
        }
        impl core::fmt::Debug for Mococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mococr")
                    .field("mcstp", &self.mcstp())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mococr {{ mcstp: {:?}, reserved_1_7: {=u8:?} }}",
                    self.mcstp(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "MOCO User Trimming Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mocoutcr(pub u8);
        impl Mocoutcr {
            #[doc = "MOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original MOCO trimming bits"]
            #[inline(always)]
            pub const fn mocoutrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MOCO User Trimming 1000_0000 : -128 1000_0001 : -127 1000_0010 : -126 . . . 1111_1111 : -1 0000_0000 : Center Code 0000_0001 : +1 . . . 0111_1101 : +125 0111_1110 : +126 0111_1111 : +127These bits are added to original MOCO trimming bits"]
            #[inline(always)]
            pub fn set_mocoutrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Mocoutcr {
            #[inline(always)]
            fn default() -> Mocoutcr {
                Mocoutcr(0)
            }
        }
        impl core::fmt::Debug for Mocoutcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mocoutcr")
                    .field("mocoutrm", &self.mocoutrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mocoutcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mocoutcr {{ mocoutrm: {=u8:?} }}", self.mocoutrm())
            }
        }
        #[doc = "Main Clock Oscillator Mode Oscillation Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Momcr(pub u8);
        impl Momcr {
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_0_2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_0_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u8) & 0x07) << 0usize);
            }
            #[doc = "Main Clock Oscillator Drive Capability 1 Switching"]
            #[inline(always)]
            pub const fn modrv1(&self) -> super::vals::Modrv1 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Modrv1::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Drive Capability 1 Switching"]
            #[inline(always)]
            pub fn set_modrv1(&mut self, val: super::vals::Modrv1) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_4_5(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_4_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "Main Clock Oscillator Switching"]
            #[inline(always)]
            pub const fn mosel(&self) -> super::vals::Mosel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mosel::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Switching"]
            #[inline(always)]
            pub fn set_mosel(&mut self, val: super::vals::Mosel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Momcr {
            #[inline(always)]
            fn default() -> Momcr {
                Momcr(0)
            }
        }
        impl core::fmt::Debug for Momcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Momcr")
                    .field("reserved_0_2", &self.reserved_0_2())
                    .field("modrv1", &self.modrv1())
                    .field("reserved_4_5", &self.reserved_4_5())
                    .field("mosel", &self.mosel())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Momcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Momcr {{ reserved_0_2: {=u8:?}, modrv1: {:?}, reserved_4_5: {=u8:?}, mosel: {:?}, reserved_7_7: {=bool:?} }}" , self . reserved_0_2 () , self . modrv1 () , self . reserved_4_5 () , self . mosel () , self . reserved_7_7 ())
            }
        }
        #[doc = "Main Clock Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mosccr(pub u8);
        impl Mosccr {
            #[doc = "Main Clock Oscillator Stop"]
            #[inline(always)]
            pub const fn mostp(&self) -> super::vals::Mostp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mostp::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Stop"]
            #[inline(always)]
            pub fn set_mostp(&mut self, val: super::vals::Mostp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Mosccr {
            #[inline(always)]
            fn default() -> Mosccr {
                Mosccr(0)
            }
        }
        impl core::fmt::Debug for Mosccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mosccr")
                    .field("mostp", &self.mostp())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mosccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mosccr {{ mostp: {:?}, reserved_1_7: {=u8:?} }}",
                    self.mostp(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "Main Clock Oscillator Wait Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Moscwtcr(pub u8);
        impl Moscwtcr {
            #[doc = "Main clock oscillator wait time setting"]
            #[inline(always)]
            pub const fn msts(&self) -> super::vals::Msts {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Msts::from_bits(val as u8)
            }
            #[doc = "Main clock oscillator wait time setting"]
            #[inline(always)]
            pub fn set_msts(&mut self, val: super::vals::Msts) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u8) & 0x0f) << 0usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u8) & 0x0f) << 4usize);
            }
        }
        impl Default for Moscwtcr {
            #[inline(always)]
            fn default() -> Moscwtcr {
                Moscwtcr(0)
            }
        }
        impl core::fmt::Debug for Moscwtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Moscwtcr")
                    .field("msts", &self.msts())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Moscwtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Moscwtcr {{ msts: {:?}, reserved_4_7: {=u8:?} }}",
                    self.msts(),
                    self.reserved_4_7()
                )
            }
        }
        #[doc = "Module Stop Control Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcra(pub u32);
        impl Mstpcra {
            #[doc = "These bits are read as 1111111111111111111111. The write value should be 1111111111111111111111."]
            #[inline(always)]
            pub const fn reserved_0_21(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x003f_ffff;
                val as u32
            }
            #[doc = "These bits are read as 1111111111111111111111. The write value should be 1111111111111111111111."]
            #[inline(always)]
            pub fn set_reserved_0_21(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x003f_ffff << 0usize)) | (((val as u32) & 0x003f_ffff) << 0usize);
            }
            #[doc = "Data Transfer Controller Module Stop"]
            #[inline(always)]
            pub const fn mstpa22(&self) -> super::vals::Mstpa22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Mstpa22::from_bits(val as u8)
            }
            #[doc = "Data Transfer Controller Module Stop"]
            #[inline(always)]
            pub fn set_mstpa22(&mut self, val: super::vals::Mstpa22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "These bits are read as 111111111. The write value should be 111111111."]
            #[inline(always)]
            pub const fn reserved_23_31(&self) -> u16 {
                let val = (self.0 >> 23usize) & 0x01ff;
                val as u16
            }
            #[doc = "These bits are read as 111111111. The write value should be 111111111."]
            #[inline(always)]
            pub fn set_reserved_23_31(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 23usize)) | (((val as u32) & 0x01ff) << 23usize);
            }
        }
        impl Default for Mstpcra {
            #[inline(always)]
            fn default() -> Mstpcra {
                Mstpcra(0)
            }
        }
        impl core::fmt::Debug for Mstpcra {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcra")
                    .field("reserved_0_21", &self.reserved_0_21())
                    .field("mstpa22", &self.mstpa22())
                    .field("reserved_23_31", &self.reserved_23_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcra {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mstpcra {{ reserved_0_21: {=u32:?}, mstpa22: {:?}, reserved_23_31: {=u16:?} }}" , self . reserved_0_21 () , self . mstpa22 () , self . reserved_23_31 ())
            }
        }
        #[doc = "Operating Power Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opccr(pub u8);
        impl Opccr {
            #[doc = "Operating Power Control Mode Select"]
            #[inline(always)]
            pub const fn opcm(&self) -> super::vals::Opcm {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Opcm::from_bits(val as u8)
            }
            #[doc = "Operating Power Control Mode Select"]
            #[inline(always)]
            pub fn set_opcm(&mut self, val: super::vals::Opcm) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_2_3(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_2_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub const fn opcmtsf(&self) -> super::vals::Opcmtsf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Opcmtsf::from_bits(val as u8)
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub fn set_opcmtsf(&mut self, val: super::vals::Opcmtsf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Opccr {
            #[inline(always)]
            fn default() -> Opccr {
                Opccr(0)
            }
        }
        impl core::fmt::Debug for Opccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opccr")
                    .field("opcm", &self.opcm())
                    .field("reserved_2_3", &self.reserved_2_3())
                    .field("opcmtsf", &self.opcmtsf())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opccr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Opccr {{ opcm: {:?}, reserved_2_3: {=u8:?}, opcmtsf: {:?}, reserved_5_7: {=u8:?} }}" , self . opcm () , self . reserved_2_3 () , self . opcmtsf () , self . reserved_5_7 ())
            }
        }
        #[doc = "Oscillation Stabilization Flag Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oscsf(pub u8);
        impl Oscsf {
            #[doc = "HOCO Clock Oscillation Stabilization FlagNOTE: The HOCOSF bit value after a reset is 1 when the OFS1.HOCOEN bit is 0. It is 0 when the OFS1.HOCOEN bit is 1."]
            #[inline(always)]
            pub const fn hocosf(&self) -> super::vals::Hocosf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hocosf::from_bits(val as u8)
            }
            #[doc = "HOCO Clock Oscillation Stabilization FlagNOTE: The HOCOSF bit value after a reset is 1 when the OFS1.HOCOEN bit is 0. It is 0 when the OFS1.HOCOEN bit is 1."]
            #[inline(always)]
            pub fn set_hocosf(&mut self, val: super::vals::Hocosf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub const fn reserved_1_2(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00."]
            #[inline(always)]
            pub fn set_reserved_1_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u8) & 0x03) << 1usize);
            }
            #[doc = "Main Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub const fn moscsf(&self) -> super::vals::Moscsf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Moscsf::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub fn set_moscsf(&mut self, val: super::vals::Moscsf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u8) & 0x0f) << 4usize);
            }
        }
        impl Default for Oscsf {
            #[inline(always)]
            fn default() -> Oscsf {
                Oscsf(0)
            }
        }
        impl core::fmt::Debug for Oscsf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oscsf")
                    .field("hocosf", &self.hocosf())
                    .field("reserved_1_2", &self.reserved_1_2())
                    .field("moscsf", &self.moscsf())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oscsf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Oscsf {{ hocosf: {:?}, reserved_1_2: {=u8:?}, moscsf: {:?}, reserved_4_7: {=u8:?} }}" , self . hocosf () , self . reserved_1_2 () , self . moscsf () , self . reserved_4_7 ())
            }
        }
        #[doc = "Oscillation Stop Detection Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ostdcr(pub u8);
        impl Ostdcr {
            #[doc = "Oscillation Stop Detection Interrupt Enable"]
            #[inline(always)]
            pub const fn ostdie(&self) -> super::vals::Ostdie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ostdie::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Interrupt Enable"]
            #[inline(always)]
            pub fn set_ostdie(&mut self, val: super::vals::Ostdie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_1_6(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_1_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 1usize)) | (((val as u8) & 0x3f) << 1usize);
            }
            #[doc = "Oscillation Stop Detection Function Enable"]
            #[inline(always)]
            pub const fn ostde(&self) -> super::vals::Ostde {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ostde::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Function Enable"]
            #[inline(always)]
            pub fn set_ostde(&mut self, val: super::vals::Ostde) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ostdcr {
            #[inline(always)]
            fn default() -> Ostdcr {
                Ostdcr(0)
            }
        }
        impl core::fmt::Debug for Ostdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ostdcr")
                    .field("ostdie", &self.ostdie())
                    .field("reserved_1_6", &self.reserved_1_6())
                    .field("ostde", &self.ostde())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ostdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ostdcr {{ ostdie: {:?}, reserved_1_6: {=u8:?}, ostde: {:?} }}",
                    self.ostdie(),
                    self.reserved_1_6(),
                    self.ostde()
                )
            }
        }
        #[doc = "Oscillation Stop Detection Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ostdsr(pub u8);
        impl Ostdsr {
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub const fn ostdf(&self) -> super::vals::Ostdf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ostdf::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub fn set_ostdf(&mut self, val: super::vals::Ostdf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Ostdsr {
            #[inline(always)]
            fn default() -> Ostdsr {
                Ostdsr(0)
            }
        }
        impl core::fmt::Debug for Ostdsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ostdsr")
                    .field("ostdf", &self.ostdf())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ostdsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ostdsr {{ ostdf: {:?}, reserved_1_7: {=u8:?} }}",
                    self.ostdf(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "Protect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prcr(pub u16);
        impl Prcr {
            #[doc = "Enables writing to the registers related to the clock generation circuit."]
            #[inline(always)]
            pub const fn prc0(&self) -> super::vals::Prc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Prc0::from_bits(val as u8)
            }
            #[doc = "Enables writing to the registers related to the clock generation circuit."]
            #[inline(always)]
            pub fn set_prc0(&mut self, val: super::vals::Prc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Enables writing to the registers related to the operating modes, the low power consumption modes and the battery backup function."]
            #[inline(always)]
            pub const fn prc1(&self) -> super::vals::Prc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Prc1::from_bits(val as u8)
            }
            #[doc = "Enables writing to the registers related to the operating modes, the low power consumption modes and the battery backup function."]
            #[inline(always)]
            pub fn set_prc1(&mut self, val: super::vals::Prc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_2_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_2_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u16) & 0x01) << 2usize);
            }
            #[doc = "Enables writing to the registers related to the LVD."]
            #[inline(always)]
            pub const fn prc3(&self) -> super::vals::Prc3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Prc3::from_bits(val as u8)
            }
            #[doc = "Enables writing to the registers related to the LVD."]
            #[inline(always)]
            pub fn set_prc3(&mut self, val: super::vals::Prc3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u16) & 0x0f) << 4usize);
            }
            #[doc = "PRKEY Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> super::vals::Prkey {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::Prkey::from_bits(val as u8)
            }
            #[doc = "PRKEY Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: super::vals::Prkey) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Prcr {
            #[inline(always)]
            fn default() -> Prcr {
                Prcr(0)
            }
        }
        impl core::fmt::Debug for Prcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prcr")
                    .field("prc0", &self.prc0())
                    .field("prc1", &self.prc1())
                    .field("reserved_2_2", &self.reserved_2_2())
                    .field("prc3", &self.prc3())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .field("prkey", &self.prkey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Prcr {{ prc0: {:?}, prc1: {:?}, reserved_2_2: {=bool:?}, prc3: {:?}, reserved_4_7: {=u8:?}, prkey: {:?} }}" , self . prc0 () , self . prc1 () , self . reserved_2_2 () , self . prc3 () , self . reserved_4_7 () , self . prkey ())
            }
        }
        #[doc = "Reset Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstsr0(pub u8);
        impl Rstsr0 {
            #[doc = "Power,On Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn porf(&self) -> super::vals::Porf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Porf::from_bits(val as u8)
            }
            #[doc = "Power,On Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_porf(&mut self, val: super::vals::Porf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 0 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn lvd0rf(&self) -> super::vals::Lvd0rf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd0rf::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 0 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_lvd0rf(&mut self, val: super::vals::Lvd0rf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Voltage Monitor 1 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn lvd1rf(&self) -> super::vals::Lvd1rf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1rf::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_lvd1rf(&mut self, val: super::vals::Lvd1rf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 2 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn lvd2rf(&self) -> super::vals::Lvd2rf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2rf::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written with 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_lvd2rf(&mut self, val: super::vals::Lvd2rf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_4_7(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_4_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u8) & 0x0f) << 4usize);
            }
        }
        impl Default for Rstsr0 {
            #[inline(always)]
            fn default() -> Rstsr0 {
                Rstsr0(0)
            }
        }
        impl core::fmt::Debug for Rstsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstsr0")
                    .field("porf", &self.porf())
                    .field("lvd0rf", &self.lvd0rf())
                    .field("lvd1rf", &self.lvd1rf())
                    .field("lvd2rf", &self.lvd2rf())
                    .field("reserved_4_7", &self.reserved_4_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rstsr0 {{ porf: {:?}, lvd0rf: {:?}, lvd1rf: {:?}, lvd2rf: {:?}, reserved_4_7: {=u8:?} }}" , self . porf () , self . lvd0rf () , self . lvd1rf () , self . lvd2rf () , self . reserved_4_7 ())
            }
        }
        #[doc = "Reset Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstsr1(pub u16);
        impl Rstsr1 {
            #[doc = "Independent Watchdog Timer Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn iwdtrf(&self) -> super::vals::Iwdtrf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtrf::from_bits(val as u8)
            }
            #[doc = "Independent Watchdog Timer Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_iwdtrf(&mut self, val: super::vals::Iwdtrf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Watchdog Timer Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn wdtrf(&self) -> super::vals::Wdtrf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtrf::from_bits(val as u8)
            }
            #[doc = "Watchdog Timer Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_wdtrf(&mut self, val: super::vals::Wdtrf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Software Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn swrf(&self) -> super::vals::Swrf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Swrf::from_bits(val as u8)
            }
            #[doc = "Software Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_swrf(&mut self, val: super::vals::Swrf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u16) & 0x1f) << 3usize);
            }
            #[doc = "RAM Parity Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn rperf(&self) -> super::vals::Rperf {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rperf::from_bits(val as u8)
            }
            #[doc = "RAM Parity Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_rperf(&mut self, val: super::vals::Rperf) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "RAM ECC Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn reerf(&self) -> super::vals::Reerf {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Reerf::from_bits(val as u8)
            }
            #[doc = "RAM ECC Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_reerf(&mut self, val: super::vals::Reerf) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Bus Slave MPU Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn bussrf(&self) -> super::vals::Bussrf {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussrf::from_bits(val as u8)
            }
            #[doc = "Bus Slave MPU Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_bussrf(&mut self, val: super::vals::Bussrf) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus Master MPU Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn busmrf(&self) -> super::vals::Busmrf {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmrf::from_bits(val as u8)
            }
            #[doc = "Bus Master MPU Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_busmrf(&mut self, val: super::vals::Busmrf) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "SP Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub const fn sperf(&self) -> super::vals::Sperf {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Sperf::from_bits(val as u8)
            }
            #[doc = "SP Error Reset Detect FlagNote: Only 0 can be written to clear the flag. The reset flag must be written as 0 after the reset flag is read as 1."]
            #[inline(always)]
            pub fn set_sperf(&mut self, val: super::vals::Sperf) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_13_15(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_13_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u16) & 0x07) << 13usize);
            }
        }
        impl Default for Rstsr1 {
            #[inline(always)]
            fn default() -> Rstsr1 {
                Rstsr1(0)
            }
        }
        impl core::fmt::Debug for Rstsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstsr1")
                    .field("iwdtrf", &self.iwdtrf())
                    .field("wdtrf", &self.wdtrf())
                    .field("swrf", &self.swrf())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .field("rperf", &self.rperf())
                    .field("reerf", &self.reerf())
                    .field("bussrf", &self.bussrf())
                    .field("busmrf", &self.busmrf())
                    .field("sperf", &self.sperf())
                    .field("reserved_13_15", &self.reserved_13_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rstsr1 {{ iwdtrf: {:?}, wdtrf: {:?}, swrf: {:?}, reserved_3_7: {=u8:?}, rperf: {:?}, reerf: {:?}, bussrf: {:?}, busmrf: {:?}, sperf: {:?}, reserved_13_15: {=u8:?} }}" , self . iwdtrf () , self . wdtrf () , self . swrf () , self . reserved_3_7 () , self . rperf () , self . reerf () , self . bussrf () , self . busmrf () , self . sperf () , self . reserved_13_15 ())
            }
        }
        #[doc = "Reset Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstsr2(pub u8);
        impl Rstsr2 {
            #[doc = "Cold/Warm Start Determination FlagNote: Only 1 can be written to set the flag."]
            #[inline(always)]
            pub const fn cwsf(&self) -> super::vals::Cwsf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cwsf::from_bits(val as u8)
            }
            #[doc = "Cold/Warm Start Determination FlagNote: Only 1 can be written to set the flag."]
            #[inline(always)]
            pub fn set_cwsf(&mut self, val: super::vals::Cwsf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Rstsr2 {
            #[inline(always)]
            fn default() -> Rstsr2 {
                Rstsr2(0)
            }
        }
        impl core::fmt::Debug for Rstsr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstsr2")
                    .field("cwsf", &self.cwsf())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstsr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rstsr2 {{ cwsf: {:?}, reserved_1_7: {=u8:?} }}",
                    self.cwsf(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "Standby Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sbycr(pub u16);
        impl Sbycr {
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub const fn reserved_0_14(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_0_14(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u16) & 0x7fff) << 0usize);
            }
            #[doc = "Software Standby"]
            #[inline(always)]
            pub const fn ssby(&self) -> super::vals::Ssby {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ssby::from_bits(val as u8)
            }
            #[doc = "Software Standby"]
            #[inline(always)]
            pub fn set_ssby(&mut self, val: super::vals::Ssby) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Sbycr {
            #[inline(always)]
            fn default() -> Sbycr {
                Sbycr(0)
            }
        }
        impl core::fmt::Debug for Sbycr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sbycr")
                    .field("reserved_0_14", &self.reserved_0_14())
                    .field("ssby", &self.ssby())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sbycr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sbycr {{ reserved_0_14: {=u16:?}, ssby: {:?} }}",
                    self.reserved_0_14(),
                    self.ssby()
                )
            }
        }
        #[doc = "System Clock Division Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sckdivcr(pub u32);
        impl Sckdivcr {
            #[doc = "Peripheral Module Clock D (PCLKD) Select"]
            #[inline(always)]
            pub const fn pckd(&self) -> super::vals::Pckd {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Pckd::from_bits(val as u8)
            }
            #[doc = "Peripheral Module Clock D (PCLKD) Select"]
            #[inline(always)]
            pub fn set_pckd(&mut self, val: super::vals::Pckd) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u32) & 0x1f) << 3usize);
            }
            #[doc = "Peripheral Module Clock B (PCLKB) Select"]
            #[inline(always)]
            pub const fn pckb(&self) -> super::vals::Pckb {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Pckb::from_bits(val as u8)
            }
            #[doc = "Peripheral Module Clock B (PCLKB) Select"]
            #[inline(always)]
            pub fn set_pckb(&mut self, val: super::vals::Pckb) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "These bits are read as 0000000000000. The write value should be 0000000000000."]
            #[inline(always)]
            pub const fn reserved_11_23(&self) -> u16 {
                let val = (self.0 >> 11usize) & 0x1fff;
                val as u16
            }
            #[doc = "These bits are read as 0000000000000. The write value should be 0000000000000."]
            #[inline(always)]
            pub fn set_reserved_11_23(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 11usize)) | (((val as u32) & 0x1fff) << 11usize);
            }
            #[doc = "System Clock (ICLK) Select"]
            #[inline(always)]
            pub const fn ick(&self) -> super::vals::Ick {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Ick::from_bits(val as u8)
            }
            #[doc = "System Clock (ICLK) Select"]
            #[inline(always)]
            pub fn set_ick(&mut self, val: super::vals::Ick) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
            #[doc = "Flash IF Clock (FCLK) Select"]
            #[inline(always)]
            pub const fn fck(&self) -> super::vals::Fck {
                let val = (self.0 >> 28usize) & 0x07;
                super::vals::Fck::from_bits(val as u8)
            }
            #[doc = "Flash IF Clock (FCLK) Select"]
            #[inline(always)]
            pub fn set_fck(&mut self, val: super::vals::Fck) {
                self.0 =
                    (self.0 & !(0x07 << 28usize)) | (((val.to_bits() as u32) & 0x07) << 28usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_31_31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_31_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Sckdivcr {
            #[inline(always)]
            fn default() -> Sckdivcr {
                Sckdivcr(0)
            }
        }
        impl core::fmt::Debug for Sckdivcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sckdivcr")
                    .field("pckd", &self.pckd())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .field("pckb", &self.pckb())
                    .field("reserved_11_23", &self.reserved_11_23())
                    .field("ick", &self.ick())
                    .field("fck", &self.fck())
                    .field("reserved_31_31", &self.reserved_31_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sckdivcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sckdivcr {{ pckd: {:?}, reserved_3_7: {=u8:?}, pckb: {:?}, reserved_11_23: {=u16:?}, ick: {:?}, fck: {:?}, reserved_31_31: {=bool:?} }}" , self . pckd () , self . reserved_3_7 () , self . pckb () , self . reserved_11_23 () , self . ick () , self . fck () , self . reserved_31_31 ())
            }
        }
        #[doc = "System Clock Source Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sckscr(pub u8);
        impl Sckscr {
            #[doc = "Clock Source Select"]
            #[inline(always)]
            pub const fn cksel(&self) -> super::vals::Cksel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Cksel::from_bits(val as u8)
            }
            #[doc = "Clock Source Select"]
            #[inline(always)]
            pub fn set_cksel(&mut self, val: super::vals::Cksel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Sckscr {
            #[inline(always)]
            fn default() -> Sckscr {
                Sckscr(0)
            }
        }
        impl core::fmt::Debug for Sckscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sckscr")
                    .field("cksel", &self.cksel())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sckscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sckscr {{ cksel: {:?}, reserved_3_7: {=u8:?} }}",
                    self.cksel(),
                    self.reserved_3_7()
                )
            }
        }
        #[doc = "24-bit Sigma,Delta A/D Converter Clock Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadcckcr(pub u8);
        impl Sdadcckcr {
            #[doc = "24-bit Sigma,Delta A/D Converter Clock Enable"]
            #[inline(always)]
            pub const fn sdadccksel(&self) -> super::vals::Sdadccksel {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sdadccksel::from_bits(val as u8)
            }
            #[doc = "24-bit Sigma,Delta A/D Converter Clock Enable"]
            #[inline(always)]
            pub fn set_sdadccksel(&mut self, val: super::vals::Sdadccksel) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_1_6(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_1_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 1usize)) | (((val as u8) & 0x3f) << 1usize);
            }
            #[doc = "24-bit Sigma,Delta A/D Converter Clock Select"]
            #[inline(always)]
            pub const fn sdadccken(&self) -> super::vals::Sdadccken {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sdadccken::from_bits(val as u8)
            }
            #[doc = "24-bit Sigma,Delta A/D Converter Clock Select"]
            #[inline(always)]
            pub fn set_sdadccken(&mut self, val: super::vals::Sdadccken) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Sdadcckcr {
            #[inline(always)]
            fn default() -> Sdadcckcr {
                Sdadcckcr(0)
            }
        }
        impl core::fmt::Debug for Sdadcckcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadcckcr")
                    .field("sdadccksel", &self.sdadccksel())
                    .field("reserved_1_6", &self.reserved_1_6())
                    .field("sdadccken", &self.sdadccken())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadcckcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sdadcckcr {{ sdadccksel: {:?}, reserved_1_6: {=u8:?}, sdadccken: {:?} }}",
                    self.sdadccksel(),
                    self.reserved_1_6(),
                    self.sdadccken()
                )
            }
        }
        #[doc = "Snooze Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snzcr(pub u8);
        impl Snzcr {
            #[doc = "RXD0 Snooze Request Enable NOTE: Do not set to 1 other than in asynchronous mode."]
            #[inline(always)]
            pub const fn rxdreqen(&self) -> super::vals::Rxdreqen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rxdreqen::from_bits(val as u8)
            }
            #[doc = "RXD0 Snooze Request Enable NOTE: Do not set to 1 other than in asynchronous mode."]
            #[inline(always)]
            pub fn set_rxdreqen(&mut self, val: super::vals::Rxdreqen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "DTC Enable in Snooze Mode"]
            #[inline(always)]
            pub const fn snzdtcen(&self) -> super::vals::Snzdtcen {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Snzdtcen::from_bits(val as u8)
            }
            #[doc = "DTC Enable in Snooze Mode"]
            #[inline(always)]
            pub fn set_snzdtcen(&mut self, val: super::vals::Snzdtcen) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_2_6(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_2_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 2usize)) | (((val as u8) & 0x1f) << 2usize);
            }
            #[doc = "Snooze Mode Enable"]
            #[inline(always)]
            pub const fn snze(&self) -> super::vals::Snze {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Snze::from_bits(val as u8)
            }
            #[doc = "Snooze Mode Enable"]
            #[inline(always)]
            pub fn set_snze(&mut self, val: super::vals::Snze) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Snzcr {
            #[inline(always)]
            fn default() -> Snzcr {
                Snzcr(0)
            }
        }
        impl core::fmt::Debug for Snzcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snzcr")
                    .field("rxdreqen", &self.rxdreqen())
                    .field("snzdtcen", &self.snzdtcen())
                    .field("reserved_2_6", &self.reserved_2_6())
                    .field("snze", &self.snze())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snzcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Snzcr {{ rxdreqen: {:?}, snzdtcen: {:?}, reserved_2_6: {=u8:?}, snze: {:?} }}",
                    self.rxdreqen(),
                    self.snzdtcen(),
                    self.reserved_2_6(),
                    self.snze()
                )
            }
        }
        #[doc = "Snooze End Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snzedcr(pub u8);
        impl Snzedcr {
            #[doc = "AGT1 underflow Snooze End Enable"]
            #[inline(always)]
            pub const fn agtunfed(&self) -> super::vals::Agtunfed {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Agtunfed::from_bits(val as u8)
            }
            #[doc = "AGT1 underflow Snooze End Enable"]
            #[inline(always)]
            pub fn set_agtunfed(&mut self, val: super::vals::Agtunfed) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Last DTC transmission completion Snooze End Enable"]
            #[inline(always)]
            pub const fn dtczred(&self) -> super::vals::Dtczred {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Dtczred::from_bits(val as u8)
            }
            #[doc = "Last DTC transmission completion Snooze End Enable"]
            #[inline(always)]
            pub fn set_dtczred(&mut self, val: super::vals::Dtczred) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Not Last DTC transmission completion Snooze End Enable"]
            #[inline(always)]
            pub const fn dtcnzred(&self) -> super::vals::Dtcnzred {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dtcnzred::from_bits(val as u8)
            }
            #[doc = "Not Last DTC transmission completion Snooze End Enable"]
            #[inline(always)]
            pub fn set_dtcnzred(&mut self, val: super::vals::Dtcnzred) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "AD compare match 0 Snooze End Enable"]
            #[inline(always)]
            pub const fn ad0mated(&self) -> super::vals::Ad0mated {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ad0mated::from_bits(val as u8)
            }
            #[doc = "AD compare match 0 Snooze End Enable"]
            #[inline(always)]
            pub fn set_ad0mated(&mut self, val: super::vals::Ad0mated) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "AD compare mismatch 0 Snooze End Enable"]
            #[inline(always)]
            pub const fn ad0umted(&self) -> super::vals::Ad0umted {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ad0umted::from_bits(val as u8)
            }
            #[doc = "AD compare mismatch 0 Snooze End Enable"]
            #[inline(always)]
            pub fn set_ad0umted(&mut self, val: super::vals::Ad0umted) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_5_6(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_5_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u8) & 0x03) << 5usize);
            }
            #[doc = "SCI0 address unmatch Snooze End EnableNote: Do not set to 1 other than in asynchronous mode."]
            #[inline(always)]
            pub const fn sci0umted(&self) -> super::vals::Sci0umted {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sci0umted::from_bits(val as u8)
            }
            #[doc = "SCI0 address unmatch Snooze End EnableNote: Do not set to 1 other than in asynchronous mode."]
            #[inline(always)]
            pub fn set_sci0umted(&mut self, val: super::vals::Sci0umted) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Snzedcr {
            #[inline(always)]
            fn default() -> Snzedcr {
                Snzedcr(0)
            }
        }
        impl core::fmt::Debug for Snzedcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snzedcr")
                    .field("agtunfed", &self.agtunfed())
                    .field("dtczred", &self.dtczred())
                    .field("dtcnzred", &self.dtcnzred())
                    .field("ad0mated", &self.ad0mated())
                    .field("ad0umted", &self.ad0umted())
                    .field("reserved_5_6", &self.reserved_5_6())
                    .field("sci0umted", &self.sci0umted())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snzedcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Snzedcr {{ agtunfed: {:?}, dtczred: {:?}, dtcnzred: {:?}, ad0mated: {:?}, ad0umted: {:?}, reserved_5_6: {=u8:?}, sci0umted: {:?} }}" , self . agtunfed () , self . dtczred () , self . dtcnzred () , self . ad0mated () , self . ad0umted () , self . reserved_5_6 () , self . sci0umted ())
            }
        }
        #[doc = "Snooze Request Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snzreqcr(pub u32);
        impl Snzreqcr {
            #[doc = "Snooze Request Enable 0Enable IRQ0 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen0(&self) -> super::vals::Snzreqen0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Snzreqen0::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 0Enable IRQ0 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen0(&mut self, val: super::vals::Snzreqen0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Snooze Request Enable 1Enable IRQ1 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen1(&self) -> super::vals::Snzreqen1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Snzreqen1::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 1Enable IRQ1 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen1(&mut self, val: super::vals::Snzreqen1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Snooze Request Enable 2Enable IRQ2 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen2(&self) -> super::vals::Snzreqen2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Snzreqen2::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 2Enable IRQ2 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen2(&mut self, val: super::vals::Snzreqen2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Snooze Request Enable 3Enable IRQ3 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen3(&self) -> super::vals::Snzreqen3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Snzreqen3::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 3Enable IRQ3 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen3(&mut self, val: super::vals::Snzreqen3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Snooze Request Enable 4Enable IRQ4 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen4(&self) -> super::vals::Snzreqen4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Snzreqen4::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 4Enable IRQ4 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen4(&mut self, val: super::vals::Snzreqen4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Snooze Request Enable 5Enable IRQ5 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen5(&self) -> super::vals::Snzreqen5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Snzreqen5::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 5Enable IRQ5 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen5(&mut self, val: super::vals::Snzreqen5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Snooze Request Enable 6Enable IRQ6 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen6(&self) -> super::vals::Snzreqen6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Snzreqen6::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 6Enable IRQ6 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen6(&mut self, val: super::vals::Snzreqen6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Snooze Request Enable 7Enable IRQ7 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen7(&self) -> super::vals::Snzreqen7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Snzreqen7::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 7Enable IRQ7 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen7(&mut self, val: super::vals::Snzreqen7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "These bits are read as 000000000. The write value should be 000000000."]
            #[inline(always)]
            pub const fn reserved_8_16(&self) -> u16 {
                let val = (self.0 >> 8usize) & 0x01ff;
                val as u16
            }
            #[doc = "These bits are read as 000000000. The write value should be 000000000."]
            #[inline(always)]
            pub fn set_reserved_8_16(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 8usize)) | (((val as u32) & 0x01ff) << 8usize);
            }
            #[doc = "Snooze Request Enable 17Enable KINT snooze request"]
            #[inline(always)]
            pub const fn snzreqen17(&self) -> super::vals::Snzreqen17 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Snzreqen17::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 17Enable KINT snooze request"]
            #[inline(always)]
            pub fn set_snzreqen17(&mut self, val: super::vals::Snzreqen17) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_18_22(&self) -> u8 {
                let val = (self.0 >> 18usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_18_22(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 18usize)) | (((val as u32) & 0x1f) << 18usize);
            }
            #[doc = "Snooze Request Enable 24Enable RTC alarm snooze request"]
            #[inline(always)]
            pub const fn snzreqen23(&self) -> super::vals::Snzreqen23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Snzreqen23::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 24Enable RTC alarm snooze request"]
            #[inline(always)]
            pub fn set_snzreqen23(&mut self, val: super::vals::Snzreqen23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Snooze Request Enable 24Enable RTC alarm snooze request"]
            #[inline(always)]
            pub const fn snzreqen24(&self) -> super::vals::Snzreqen24 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Snzreqen24::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 24Enable RTC alarm snooze request"]
            #[inline(always)]
            pub fn set_snzreqen24(&mut self, val: super::vals::Snzreqen24) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Snooze Request Enable 25Enable RTC period snooze request"]
            #[inline(always)]
            pub const fn snzreqen25(&self) -> super::vals::Snzreqen25 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Snzreqen25::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 25Enable RTC period snooze request"]
            #[inline(always)]
            pub fn set_snzreqen25(&mut self, val: super::vals::Snzreqen25) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_26_27(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_26_27(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 26usize)) | (((val as u32) & 0x03) << 26usize);
            }
            #[doc = "Snooze Request Enable 28Enable AGT1 underflow snooze request"]
            #[inline(always)]
            pub const fn snzreqen28(&self) -> super::vals::Snzreqen28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Snzreqen28::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 28Enable AGT1 underflow snooze request"]
            #[inline(always)]
            pub fn set_snzreqen28(&mut self, val: super::vals::Snzreqen28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Snooze Request Enable 29Enable AGT1 compare match A snooze request"]
            #[inline(always)]
            pub const fn snzreqen29(&self) -> super::vals::Snzreqen29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Snzreqen29::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 29Enable AGT1 compare match A snooze request"]
            #[inline(always)]
            pub fn set_snzreqen29(&mut self, val: super::vals::Snzreqen29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Snooze Request Enable 30Enable AGT1 compare match B snooze request"]
            #[inline(always)]
            pub const fn snzreqen30(&self) -> super::vals::Snzreqen30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Snzreqen30::from_bits(val as u8)
            }
            #[doc = "Snooze Request Enable 30Enable AGT1 compare match B snooze request"]
            #[inline(always)]
            pub fn set_snzreqen30(&mut self, val: super::vals::Snzreqen30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_31_31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_31_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Snzreqcr {
            #[inline(always)]
            fn default() -> Snzreqcr {
                Snzreqcr(0)
            }
        }
        impl core::fmt::Debug for Snzreqcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snzreqcr")
                    .field("snzreqen0", &self.snzreqen0())
                    .field("snzreqen1", &self.snzreqen1())
                    .field("snzreqen2", &self.snzreqen2())
                    .field("snzreqen3", &self.snzreqen3())
                    .field("snzreqen4", &self.snzreqen4())
                    .field("snzreqen5", &self.snzreqen5())
                    .field("snzreqen6", &self.snzreqen6())
                    .field("snzreqen7", &self.snzreqen7())
                    .field("reserved_8_16", &self.reserved_8_16())
                    .field("snzreqen17", &self.snzreqen17())
                    .field("reserved_18_22", &self.reserved_18_22())
                    .field("snzreqen23", &self.snzreqen23())
                    .field("snzreqen24", &self.snzreqen24())
                    .field("snzreqen25", &self.snzreqen25())
                    .field("reserved_26_27", &self.reserved_26_27())
                    .field("snzreqen28", &self.snzreqen28())
                    .field("snzreqen29", &self.snzreqen29())
                    .field("snzreqen30", &self.snzreqen30())
                    .field("reserved_31_31", &self.reserved_31_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snzreqcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Snzreqcr {{ snzreqen0: {:?}, snzreqen1: {:?}, snzreqen2: {:?}, snzreqen3: {:?}, snzreqen4: {:?}, snzreqen5: {:?}, snzreqen6: {:?}, snzreqen7: {:?}, reserved_8_16: {=u16:?}, snzreqen17: {:?}, reserved_18_22: {=u8:?}, snzreqen23: {:?}, snzreqen24: {:?}, snzreqen25: {:?}, reserved_26_27: {=u8:?}, snzreqen28: {:?}, snzreqen29: {:?}, snzreqen30: {:?}, reserved_31_31: {=bool:?} }}" , self . snzreqen0 () , self . snzreqen1 () , self . snzreqen2 () , self . snzreqen3 () , self . snzreqen4 () , self . snzreqen5 () , self . snzreqen6 () , self . snzreqen7 () , self . reserved_8_16 () , self . snzreqen17 () , self . reserved_18_22 () , self . snzreqen23 () , self . snzreqen24 () , self . snzreqen25 () , self . reserved_26_27 () , self . snzreqen28 () , self . snzreqen29 () , self . snzreqen30 () , self . reserved_31_31 ())
            }
        }
        #[doc = "Sub,clock Oscillator Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Somcr(pub u8);
        impl Somcr {
            #[doc = "Sub Clock Oscillator Drive Capability Switching"]
            #[inline(always)]
            pub const fn sodrv(&self) -> super::vals::Sodrv {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Sodrv::from_bits(val as u8)
            }
            #[doc = "Sub Clock Oscillator Drive Capability Switching"]
            #[inline(always)]
            pub fn set_sodrv(&mut self, val: super::vals::Sodrv) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_2_7(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_2_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for Somcr {
            #[inline(always)]
            fn default() -> Somcr {
                Somcr(0)
            }
        }
        impl core::fmt::Debug for Somcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Somcr")
                    .field("sodrv", &self.sodrv())
                    .field("reserved_2_7", &self.reserved_2_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Somcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Somcr {{ sodrv: {:?}, reserved_2_7: {=u8:?} }}",
                    self.sodrv(),
                    self.reserved_2_7()
                )
            }
        }
        #[doc = "Sub Operating Power Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sopccr(pub u8);
        impl Sopccr {
            #[doc = "Sub Operating Power Control Mode Select"]
            #[inline(always)]
            pub const fn sopcm(&self) -> super::vals::Sopcm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sopcm::from_bits(val as u8)
            }
            #[doc = "Sub Operating Power Control Mode Select"]
            #[inline(always)]
            pub fn set_sopcm(&mut self, val: super::vals::Sopcm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_1_3(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_1_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "Sub Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub const fn sopcmtsf(&self) -> super::vals::Sopcmtsf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sopcmtsf::from_bits(val as u8)
            }
            #[doc = "Sub Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub fn set_sopcmtsf(&mut self, val: super::vals::Sopcmtsf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Sopccr {
            #[inline(always)]
            fn default() -> Sopccr {
                Sopccr(0)
            }
        }
        impl core::fmt::Debug for Sopccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sopccr")
                    .field("sopcm", &self.sopcm())
                    .field("reserved_1_3", &self.reserved_1_3())
                    .field("sopcmtsf", &self.sopcmtsf())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sopccr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sopccr {{ sopcm: {:?}, reserved_1_3: {=u8:?}, sopcmtsf: {:?}, reserved_5_7: {=u8:?} }}" , self . sopcm () , self . reserved_1_3 () , self . sopcmtsf () , self . reserved_5_7 ())
            }
        }
        #[doc = "Sub,clock Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sosccr(pub u8);
        impl Sosccr {
            #[doc = "Sub,Clock Oscillator Stop"]
            #[inline(always)]
            pub const fn sostp(&self) -> super::vals::Sostp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sostp::from_bits(val as u8)
            }
            #[doc = "Sub,Clock Oscillator Stop"]
            #[inline(always)]
            pub fn set_sostp(&mut self, val: super::vals::Sostp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_1_7(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_1_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Sosccr {
            #[inline(always)]
            fn default() -> Sosccr {
                Sosccr(0)
            }
        }
        impl core::fmt::Debug for Sosccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sosccr")
                    .field("sostp", &self.sostp())
                    .field("reserved_1_7", &self.reserved_1_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sosccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sosccr {{ sostp: {:?}, reserved_1_7: {=u8:?} }}",
                    self.sostp(),
                    self.reserved_1_7()
                )
            }
        }
        #[doc = "System Control OCD Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syocdcr(pub u8);
        impl Syocdcr {
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_0_6(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_0_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u8) & 0x7f) << 0usize);
            }
            #[doc = "Debugger Enable"]
            #[inline(always)]
            pub const fn dbgen(&self) -> super::vals::Dbgen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dbgen::from_bits(val as u8)
            }
            #[doc = "Debugger Enable"]
            #[inline(always)]
            pub fn set_dbgen(&mut self, val: super::vals::Dbgen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Syocdcr {
            #[inline(always)]
            fn default() -> Syocdcr {
                Syocdcr(0)
            }
        }
        impl core::fmt::Debug for Syocdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syocdcr")
                    .field("reserved_0_6", &self.reserved_0_6())
                    .field("dbgen", &self.dbgen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syocdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Syocdcr {{ reserved_0_6: {=u8:?}, dbgen: {:?} }}",
                    self.reserved_0_6(),
                    self.dbgen()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ad0mated {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ad0mated {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ad0mated {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ad0mated {
            #[inline(always)]
            fn from(val: u8) -> Ad0mated {
                Ad0mated::from_bits(val)
            }
        }
        impl From<Ad0mated> for u8 {
            #[inline(always)]
            fn from(val: Ad0mated) -> u8 {
                Ad0mated::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ad0umted {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ad0umted {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ad0umted {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ad0umted {
            #[inline(always)]
            fn from(val: u8) -> Ad0umted {
                Ad0umted::from_bits(val)
            }
        }
        impl From<Ad0umted> for u8 {
            #[inline(always)]
            fn from(val: Ad0umted) -> u8 {
                Ad0umted::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agtunfed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agtunfed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agtunfed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agtunfed {
            #[inline(always)]
            fn from(val: u8) -> Agtunfed {
                Agtunfed::from_bits(val)
            }
        }
        impl From<Agtunfed> for u8 {
            #[inline(always)]
            fn from(val: Agtunfed) -> u8 {
                Agtunfed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmrf {
            #[inline(always)]
            fn from(val: u8) -> Busmrf {
                Busmrf::from_bits(val)
            }
        }
        impl From<Busmrf> for u8 {
            #[inline(always)]
            fn from(val: Busmrf) -> u8 {
                Busmrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussrf {
            #[inline(always)]
            fn from(val: u8) -> Bussrf {
                Bussrf::from_bits(val)
            }
        }
        impl From<Bussrf> for u8 {
            #[inline(always)]
            fn from(val: Bussrf) -> u8 {
                Bussrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckodiv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ckodiv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckodiv {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckodiv {
            #[inline(always)]
            fn from(val: u8) -> Ckodiv {
                Ckodiv::from_bits(val)
            }
        }
        impl From<Ckodiv> for u8 {
            #[inline(always)]
            fn from(val: Ckodiv) -> u8 {
                Ckodiv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckoen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckoen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckoen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckoen {
            #[inline(always)]
            fn from(val: u8) -> Ckoen {
                Ckoen::from_bits(val)
            }
        }
        impl From<Ckoen> for u8 {
            #[inline(always)]
            fn from(val: Ckoen) -> u8 {
                Ckoen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckosel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ckosel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckosel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckosel {
            #[inline(always)]
            fn from(val: u8) -> Ckosel {
                Ckosel::from_bits(val)
            }
        }
        impl From<Ckosel> for u8 {
            #[inline(always)]
            fn from(val: Ckosel) -> u8 {
                Ckosel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cksel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cksel {
            #[inline(always)]
            fn from(val: u8) -> Cksel {
                Cksel::from_bits(val)
            }
        }
        impl From<Cksel> for u8 {
            #[inline(always)]
            fn from(val: Cksel) -> u8 {
                Cksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cwsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cwsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cwsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cwsf {
            #[inline(always)]
            fn from(val: u8) -> Cwsf {
                Cwsf::from_bits(val)
            }
        }
        impl From<Cwsf> for u8 {
            #[inline(always)]
            fn from(val: Cwsf) -> u8 {
                Cwsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dbgen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dbgen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dbgen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dbgen {
            #[inline(always)]
            fn from(val: u8) -> Dbgen {
                Dbgen::from_bits(val)
            }
        }
        impl From<Dbgen> for u8 {
            #[inline(always)]
            fn from(val: Dbgen) -> u8 {
                Dbgen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtcnzred {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtcnzred {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtcnzred {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtcnzred {
            #[inline(always)]
            fn from(val: u8) -> Dtcnzred {
                Dtcnzred::from_bits(val)
            }
        }
        impl From<Dtcnzred> for u8 {
            #[inline(always)]
            fn from(val: Dtcnzred) -> u8 {
                Dtcnzred::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtczred {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtczred {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtczred {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtczred {
            #[inline(always)]
            fn from(val: u8) -> Dtczred {
                Dtczred::from_bits(val)
            }
        }
        impl From<Dtczred> for u8 {
            #[inline(always)]
            fn from(val: Dtczred) -> u8 {
                Dtczred::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fck {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fck {
            #[inline(always)]
            fn from(val: u8) -> Fck {
                Fck::from_bits(val)
            }
        }
        impl From<Fck> for u8 {
            #[inline(always)]
            fn from(val: Fck) -> u8 {
                Fck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flstop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Flstop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flstop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flstop {
            #[inline(always)]
            fn from(val: u8) -> Flstop {
                Flstop::from_bits(val)
            }
        }
        impl From<Flstop> for u8 {
            #[inline(always)]
            fn from(val: Flstop) -> u8 {
                Flstop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flstpf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Flstpf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flstpf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flstpf {
            #[inline(always)]
            fn from(val: u8) -> Flstpf {
                Flstpf::from_bits(val)
            }
        }
        impl From<Flstpf> for u8 {
            #[inline(always)]
            fn from(val: Flstpf) -> u8 {
                Flstpf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hcstp {
            #[inline(always)]
            fn from(val: u8) -> Hcstp {
                Hcstp::from_bits(val)
            }
        }
        impl From<Hcstp> for u8 {
            #[inline(always)]
            fn from(val: Hcstp) -> u8 {
                Hcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hocosf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hocosf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hocosf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hocosf {
            #[inline(always)]
            fn from(val: u8) -> Hocosf {
                Hocosf::from_bits(val)
            }
        }
        impl From<Hocosf> for u8 {
            #[inline(always)]
            fn from(val: Hocosf) -> u8 {
                Hocosf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hsts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Hsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hsts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hsts {
            #[inline(always)]
            fn from(val: u8) -> Hsts {
                Hsts::from_bits(val)
            }
        }
        impl From<Hsts> for u8 {
            #[inline(always)]
            fn from(val: Hsts) -> u8 {
                Hsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ick {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ick {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ick {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ick {
            #[inline(always)]
            fn from(val: u8) -> Ick {
                Ick::from_bits(val)
            }
        }
        impl From<Ick> for u8 {
            #[inline(always)]
            fn from(val: Ick) -> u8 {
                Ick::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtrf {
            #[inline(always)]
            fn from(val: u8) -> Iwdtrf {
                Iwdtrf::from_bits(val)
            }
        }
        impl From<Iwdtrf> for u8 {
            #[inline(always)]
            fn from(val: Iwdtrf) -> u8 {
                Iwdtrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcstp {
            #[inline(always)]
            fn from(val: u8) -> Lcstp {
                Lcstp::from_bits(val)
            }
        }
        impl From<Lcstp> for u8 {
            #[inline(always)]
            fn from(val: Lcstp) -> u8 {
                Lcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd0rf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd0rf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd0rf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd0rf {
            #[inline(always)]
            fn from(val: u8) -> Lvd0rf {
                Lvd0rf::from_bits(val)
            }
        }
        impl From<Lvd0rf> for u8 {
            #[inline(always)]
            fn from(val: Lvd0rf) -> u8 {
                Lvd0rf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Cmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Cmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Cmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Cmpe {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Cmpe {
                Lvd1cr0Cmpe::from_bits(val)
            }
        }
        impl From<Lvd1cr0Cmpe> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Cmpe) -> u8 {
                Lvd1cr0Cmpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Ri {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Ri {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Ri {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Ri {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Ri {
                Lvd1cr0Ri::from_bits(val)
            }
        }
        impl From<Lvd1cr0Ri> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Ri) -> u8 {
                Lvd1cr0Ri::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Rie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Rie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Rie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Rie {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Rie {
                Lvd1cr0Rie::from_bits(val)
            }
        }
        impl From<Lvd1cr0Rie> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Rie) -> u8 {
                Lvd1cr0Rie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Rn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Rn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Rn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Rn {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Rn {
                Lvd1cr0Rn::from_bits(val)
            }
        }
        impl From<Lvd1cr0Rn> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Rn) -> u8 {
                Lvd1cr0Rn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr1Idtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lvd1cr1Idtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr1Idtsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr1Idtsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr1Idtsel {
                Lvd1cr1Idtsel::from_bits(val)
            }
        }
        impl From<Lvd1cr1Idtsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr1Idtsel) -> u8 {
                Lvd1cr1Idtsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr1Irqsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr1Irqsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr1Irqsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr1Irqsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr1Irqsel {
                Lvd1cr1Irqsel::from_bits(val)
            }
        }
        impl From<Lvd1cr1Irqsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr1Irqsel) -> u8 {
                Lvd1cr1Irqsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1e {
            #[inline(always)]
            fn from(val: u8) -> Lvd1e {
                Lvd1e::from_bits(val)
            }
        }
        impl From<Lvd1e> for u8 {
            #[inline(always)]
            fn from(val: Lvd1e) -> u8 {
                Lvd1e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1lvl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Lvd1lvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1lvl {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1lvl {
            #[inline(always)]
            fn from(val: u8) -> Lvd1lvl {
                Lvd1lvl::from_bits(val)
            }
        }
        impl From<Lvd1lvl> for u8 {
            #[inline(always)]
            fn from(val: Lvd1lvl) -> u8 {
                Lvd1lvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1rf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1rf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1rf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1rf {
            #[inline(always)]
            fn from(val: u8) -> Lvd1rf {
                Lvd1rf::from_bits(val)
            }
        }
        impl From<Lvd1rf> for u8 {
            #[inline(always)]
            fn from(val: Lvd1rf) -> u8 {
                Lvd1rf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1srDet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1srDet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1srDet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1srDet {
            #[inline(always)]
            fn from(val: u8) -> Lvd1srDet {
                Lvd1srDet::from_bits(val)
            }
        }
        impl From<Lvd1srDet> for u8 {
            #[inline(always)]
            fn from(val: Lvd1srDet) -> u8 {
                Lvd1srDet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1srMon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1srMon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1srMon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1srMon {
            #[inline(always)]
            fn from(val: u8) -> Lvd1srMon {
                Lvd1srMon::from_bits(val)
            }
        }
        impl From<Lvd1srMon> for u8 {
            #[inline(always)]
            fn from(val: Lvd1srMon) -> u8 {
                Lvd1srMon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Cmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Cmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Cmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Cmpe {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Cmpe {
                Lvd2cr0Cmpe::from_bits(val)
            }
        }
        impl From<Lvd2cr0Cmpe> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Cmpe) -> u8 {
                Lvd2cr0Cmpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Ri {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Ri {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Ri {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Ri {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Ri {
                Lvd2cr0Ri::from_bits(val)
            }
        }
        impl From<Lvd2cr0Ri> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Ri) -> u8 {
                Lvd2cr0Ri::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Rie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Rie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Rie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Rie {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Rie {
                Lvd2cr0Rie::from_bits(val)
            }
        }
        impl From<Lvd2cr0Rie> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Rie) -> u8 {
                Lvd2cr0Rie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Rn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Rn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Rn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Rn {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Rn {
                Lvd2cr0Rn::from_bits(val)
            }
        }
        impl From<Lvd2cr0Rn> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Rn) -> u8 {
                Lvd2cr0Rn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr1Idtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lvd2cr1Idtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr1Idtsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr1Idtsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr1Idtsel {
                Lvd2cr1Idtsel::from_bits(val)
            }
        }
        impl From<Lvd2cr1Idtsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr1Idtsel) -> u8 {
                Lvd2cr1Idtsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr1Irqsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr1Irqsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr1Irqsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr1Irqsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr1Irqsel {
                Lvd2cr1Irqsel::from_bits(val)
            }
        }
        impl From<Lvd2cr1Irqsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr1Irqsel) -> u8 {
                Lvd2cr1Irqsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2e {
            #[inline(always)]
            fn from(val: u8) -> Lvd2e {
                Lvd2e::from_bits(val)
            }
        }
        impl From<Lvd2e> for u8 {
            #[inline(always)]
            fn from(val: Lvd2e) -> u8 {
                Lvd2e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2lvl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Lvd2lvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2lvl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2lvl {
            #[inline(always)]
            fn from(val: u8) -> Lvd2lvl {
                Lvd2lvl::from_bits(val)
            }
        }
        impl From<Lvd2lvl> for u8 {
            #[inline(always)]
            fn from(val: Lvd2lvl) -> u8 {
                Lvd2lvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2rf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2rf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2rf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2rf {
            #[inline(always)]
            fn from(val: u8) -> Lvd2rf {
                Lvd2rf::from_bits(val)
            }
        }
        impl From<Lvd2rf> for u8 {
            #[inline(always)]
            fn from(val: Lvd2rf) -> u8 {
                Lvd2rf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2srDet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2srDet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2srDet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2srDet {
            #[inline(always)]
            fn from(val: u8) -> Lvd2srDet {
                Lvd2srDet::from_bits(val)
            }
        }
        impl From<Lvd2srDet> for u8 {
            #[inline(always)]
            fn from(val: Lvd2srDet) -> u8 {
                Lvd2srDet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2srMon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2srMon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2srMon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2srMon {
            #[inline(always)]
            fn from(val: u8) -> Lvd2srMon {
                Lvd2srMon::from_bits(val)
            }
        }
        impl From<Lvd2srMon> for u8 {
            #[inline(always)]
            fn from(val: Lvd2srMon) -> u8 {
                Lvd2srMon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mcstp {
            #[inline(always)]
            fn from(val: u8) -> Mcstp {
                Mcstp::from_bits(val)
            }
        }
        impl From<Mcstp> for u8 {
            #[inline(always)]
            fn from(val: Mcstp) -> u8 {
                Mcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Memwait {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Memwait {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Memwait {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Memwait {
            #[inline(always)]
            fn from(val: u8) -> Memwait {
                Memwait::from_bits(val)
            }
        }
        impl From<Memwait> for u8 {
            #[inline(always)]
            fn from(val: Memwait) -> u8 {
                Memwait::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modrv1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Modrv1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modrv1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modrv1 {
            #[inline(always)]
            fn from(val: u8) -> Modrv1 {
                Modrv1::from_bits(val)
            }
        }
        impl From<Modrv1> for u8 {
            #[inline(always)]
            fn from(val: Modrv1) -> u8 {
                Modrv1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moscsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moscsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moscsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moscsf {
            #[inline(always)]
            fn from(val: u8) -> Moscsf {
                Moscsf::from_bits(val)
            }
        }
        impl From<Moscsf> for u8 {
            #[inline(always)]
            fn from(val: Moscsf) -> u8 {
                Moscsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mosel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mosel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mosel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mosel {
            #[inline(always)]
            fn from(val: u8) -> Mosel {
                Mosel::from_bits(val)
            }
        }
        impl From<Mosel> for u8 {
            #[inline(always)]
            fn from(val: Mosel) -> u8 {
                Mosel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mostp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mostp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mostp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mostp {
            #[inline(always)]
            fn from(val: u8) -> Mostp {
                Mostp::from_bits(val)
            }
        }
        impl From<Mostp> for u8 {
            #[inline(always)]
            fn from(val: Mostp) -> u8 {
                Mostp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpa22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpa22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpa22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpa22 {
            #[inline(always)]
            fn from(val: u8) -> Mstpa22 {
                Mstpa22::from_bits(val)
            }
        }
        impl From<Mstpa22> for u8 {
            #[inline(always)]
            fn from(val: Mstpa22) -> u8 {
                Mstpa22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Msts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Msts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Msts {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Msts {
            #[inline(always)]
            fn from(val: u8) -> Msts {
                Msts::from_bits(val)
            }
        }
        impl From<Msts> for u8 {
            #[inline(always)]
            fn from(val: Msts) -> u8 {
                Msts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opcm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Opcm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opcm {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opcm {
            #[inline(always)]
            fn from(val: u8) -> Opcm {
                Opcm::from_bits(val)
            }
        }
        impl From<Opcm> for u8 {
            #[inline(always)]
            fn from(val: Opcm) -> u8 {
                Opcm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opcmtsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Opcmtsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opcmtsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opcmtsf {
            #[inline(always)]
            fn from(val: u8) -> Opcmtsf {
                Opcmtsf::from_bits(val)
            }
        }
        impl From<Opcmtsf> for u8 {
            #[inline(always)]
            fn from(val: Opcmtsf) -> u8 {
                Opcmtsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostde {
            #[inline(always)]
            fn from(val: u8) -> Ostde {
                Ostde::from_bits(val)
            }
        }
        impl From<Ostde> for u8 {
            #[inline(always)]
            fn from(val: Ostde) -> u8 {
                Ostde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostdf {
            #[inline(always)]
            fn from(val: u8) -> Ostdf {
                Ostdf::from_bits(val)
            }
        }
        impl From<Ostdf> for u8 {
            #[inline(always)]
            fn from(val: Ostdf) -> u8 {
                Ostdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostdie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostdie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostdie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostdie {
            #[inline(always)]
            fn from(val: u8) -> Ostdie {
                Ostdie::from_bits(val)
            }
        }
        impl From<Ostdie> for u8 {
            #[inline(always)]
            fn from(val: Ostdie) -> u8 {
                Ostdie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pckb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Pckb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pckb {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pckb {
            #[inline(always)]
            fn from(val: u8) -> Pckb {
                Pckb::from_bits(val)
            }
        }
        impl From<Pckb> for u8 {
            #[inline(always)]
            fn from(val: Pckb) -> u8 {
                Pckb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pckd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Pckd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pckd {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pckd {
            #[inline(always)]
            fn from(val: u8) -> Pckd {
                Pckd::from_bits(val)
            }
        }
        impl From<Pckd> for u8 {
            #[inline(always)]
            fn from(val: Pckd) -> u8 {
                Pckd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porf {
            #[inline(always)]
            fn from(val: u8) -> Porf {
                Porf::from_bits(val)
            }
        }
        impl From<Porf> for u8 {
            #[inline(always)]
            fn from(val: Porf) -> u8 {
                Porf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc0 {
            #[inline(always)]
            fn from(val: u8) -> Prc0 {
                Prc0::from_bits(val)
            }
        }
        impl From<Prc0> for u8 {
            #[inline(always)]
            fn from(val: Prc0) -> u8 {
                Prc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc1 {
            #[inline(always)]
            fn from(val: u8) -> Prc1 {
                Prc1::from_bits(val)
            }
        }
        impl From<Prc1> for u8 {
            #[inline(always)]
            fn from(val: Prc1) -> u8 {
                Prc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc3 {
            #[inline(always)]
            fn from(val: u8) -> Prc3 {
                Prc3::from_bits(val)
            }
        }
        impl From<Prc3> for u8 {
            #[inline(always)]
            fn from(val: Prc3) -> u8 {
                Prc3::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Prkey(u8);
        impl Prkey {}
        impl Prkey {
            pub const fn from_bits(val: u8) -> Prkey {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Prkey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prkey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Prkey {
            #[inline(always)]
            fn from(val: u8) -> Prkey {
                Prkey::from_bits(val)
            }
        }
        impl From<Prkey> for u8 {
            #[inline(always)]
            fn from(val: Prkey) -> u8 {
                Prkey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reerf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Reerf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reerf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reerf {
            #[inline(always)]
            fn from(val: u8) -> Reerf {
                Reerf::from_bits(val)
            }
        }
        impl From<Reerf> for u8 {
            #[inline(always)]
            fn from(val: Reerf) -> u8 {
                Reerf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rperf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rperf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rperf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rperf {
            #[inline(always)]
            fn from(val: u8) -> Rperf {
                Rperf::from_bits(val)
            }
        }
        impl From<Rperf> for u8 {
            #[inline(always)]
            fn from(val: Rperf) -> u8 {
                Rperf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdreqen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdreqen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdreqen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdreqen {
            #[inline(always)]
            fn from(val: u8) -> Rxdreqen {
                Rxdreqen::from_bits(val)
            }
        }
        impl From<Rxdreqen> for u8 {
            #[inline(always)]
            fn from(val: Rxdreqen) -> u8 {
                Rxdreqen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sci0umted {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sci0umted {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sci0umted {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sci0umted {
            #[inline(always)]
            fn from(val: u8) -> Sci0umted {
                Sci0umted::from_bits(val)
            }
        }
        impl From<Sci0umted> for u8 {
            #[inline(always)]
            fn from(val: Sci0umted) -> u8 {
                Sci0umted::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadccken {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdadccken {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadccken {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadccken {
            #[inline(always)]
            fn from(val: u8) -> Sdadccken {
                Sdadccken::from_bits(val)
            }
        }
        impl From<Sdadccken> for u8 {
            #[inline(always)]
            fn from(val: Sdadccken) -> u8 {
                Sdadccken::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadccksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdadccksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadccksel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadccksel {
            #[inline(always)]
            fn from(val: u8) -> Sdadccksel {
                Sdadccksel::from_bits(val)
            }
        }
        impl From<Sdadccksel> for u8 {
            #[inline(always)]
            fn from(val: Sdadccksel) -> u8 {
                Sdadccksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzdtcen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzdtcen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzdtcen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzdtcen {
            #[inline(always)]
            fn from(val: u8) -> Snzdtcen {
                Snzdtcen::from_bits(val)
            }
        }
        impl From<Snzdtcen> for u8 {
            #[inline(always)]
            fn from(val: Snzdtcen) -> u8 {
                Snzdtcen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snze {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snze {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snze {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snze {
            #[inline(always)]
            fn from(val: u8) -> Snze {
                Snze::from_bits(val)
            }
        }
        impl From<Snze> for u8 {
            #[inline(always)]
            fn from(val: Snze) -> u8 {
                Snze::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen0 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen0 {
                Snzreqen0::from_bits(val)
            }
        }
        impl From<Snzreqen0> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen0) -> u8 {
                Snzreqen0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen1 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen1 {
                Snzreqen1::from_bits(val)
            }
        }
        impl From<Snzreqen1> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen1) -> u8 {
                Snzreqen1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen17 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen17 {
                Snzreqen17::from_bits(val)
            }
        }
        impl From<Snzreqen17> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen17) -> u8 {
                Snzreqen17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen2 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen2 {
                Snzreqen2::from_bits(val)
            }
        }
        impl From<Snzreqen2> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen2) -> u8 {
                Snzreqen2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen23 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen23 {
                Snzreqen23::from_bits(val)
            }
        }
        impl From<Snzreqen23> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen23) -> u8 {
                Snzreqen23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen24 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen24 {
                Snzreqen24::from_bits(val)
            }
        }
        impl From<Snzreqen24> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen24) -> u8 {
                Snzreqen24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen25 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen25 {
                Snzreqen25::from_bits(val)
            }
        }
        impl From<Snzreqen25> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen25) -> u8 {
                Snzreqen25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen28 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen28 {
                Snzreqen28::from_bits(val)
            }
        }
        impl From<Snzreqen28> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen28) -> u8 {
                Snzreqen28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen29 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen29 {
                Snzreqen29::from_bits(val)
            }
        }
        impl From<Snzreqen29> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen29) -> u8 {
                Snzreqen29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen3 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen3 {
                Snzreqen3::from_bits(val)
            }
        }
        impl From<Snzreqen3> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen3) -> u8 {
                Snzreqen3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen30 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen30 {
                Snzreqen30::from_bits(val)
            }
        }
        impl From<Snzreqen30> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen30) -> u8 {
                Snzreqen30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen4 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen4 {
                Snzreqen4::from_bits(val)
            }
        }
        impl From<Snzreqen4> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen4) -> u8 {
                Snzreqen4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen5 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen5 {
                Snzreqen5::from_bits(val)
            }
        }
        impl From<Snzreqen5> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen5) -> u8 {
                Snzreqen5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen6 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen6 {
                Snzreqen6::from_bits(val)
            }
        }
        impl From<Snzreqen6> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen6) -> u8 {
                Snzreqen6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen7 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen7 {
                Snzreqen7::from_bits(val)
            }
        }
        impl From<Snzreqen7> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen7) -> u8 {
                Snzreqen7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sodrv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sodrv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sodrv {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sodrv {
            #[inline(always)]
            fn from(val: u8) -> Sodrv {
                Sodrv::from_bits(val)
            }
        }
        impl From<Sodrv> for u8 {
            #[inline(always)]
            fn from(val: Sodrv) -> u8 {
                Sodrv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sopcm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sopcm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sopcm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sopcm {
            #[inline(always)]
            fn from(val: u8) -> Sopcm {
                Sopcm::from_bits(val)
            }
        }
        impl From<Sopcm> for u8 {
            #[inline(always)]
            fn from(val: Sopcm) -> u8 {
                Sopcm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sopcmtsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sopcmtsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sopcmtsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sopcmtsf {
            #[inline(always)]
            fn from(val: u8) -> Sopcmtsf {
                Sopcmtsf::from_bits(val)
            }
        }
        impl From<Sopcmtsf> for u8 {
            #[inline(always)]
            fn from(val: Sopcmtsf) -> u8 {
                Sopcmtsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sostp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sostp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sostp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sostp {
            #[inline(always)]
            fn from(val: u8) -> Sostp {
                Sostp::from_bits(val)
            }
        }
        impl From<Sostp> for u8 {
            #[inline(always)]
            fn from(val: Sostp) -> u8 {
                Sostp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sperf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sperf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sperf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sperf {
            #[inline(always)]
            fn from(val: u8) -> Sperf {
                Sperf::from_bits(val)
            }
        }
        impl From<Sperf> for u8 {
            #[inline(always)]
            fn from(val: Sperf) -> u8 {
                Sperf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssby {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssby {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssby {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssby {
            #[inline(always)]
            fn from(val: u8) -> Ssby {
                Ssby::from_bits(val)
            }
        }
        impl From<Ssby> for u8 {
            #[inline(always)]
            fn from(val: Ssby) -> u8 {
                Ssby::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Swrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swrf {
            #[inline(always)]
            fn from(val: u8) -> Swrf {
                Swrf::from_bits(val)
            }
        }
        impl From<Swrf> for u8 {
            #[inline(always)]
            fn from(val: Swrf) -> u8 {
                Swrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtrf {
            #[inline(always)]
            fn from(val: u8) -> Wdtrf {
                Wdtrf::from_bits(val)
            }
        }
        impl From<Wdtrf> for u8 {
            #[inline(always)]
            fn from(val: Wdtrf) -> u8 {
                Wdtrf::to_bits(val)
            }
        }
    }
}
pub mod tsn {
    #[doc = "Temperature Sensor"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tsn {
        ptr: *mut u8,
    }
    unsafe impl Send for Tsn {}
    unsafe impl Sync for Tsn {}
    impl Tsn {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Temperature Sensor Calibration Data Register L"]
        #[inline(always)]
        pub const fn tscdrl(self) -> crate::common::Reg<regs::Tscdrl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0228usize) as _) }
        }
        #[doc = "Temperature Sensor Calibration Data Register H"]
        #[inline(always)]
        pub const fn tscdrh(self) -> crate::common::Reg<regs::Tscdrh, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0229usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Temperature Sensor Calibration Data Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tscdrh(pub u8);
        impl Tscdrh {
            #[doc = "The calibration data stores the higher 8 bits of the convertedvalue."]
            #[inline(always)]
            pub const fn tscdrh(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The calibration data stores the higher 8 bits of the convertedvalue."]
            #[inline(always)]
            pub fn set_tscdrh(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Tscdrh {
            #[inline(always)]
            fn default() -> Tscdrh {
                Tscdrh(0)
            }
        }
        impl core::fmt::Debug for Tscdrh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tscdrh")
                    .field("tscdrh", &self.tscdrh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tscdrh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tscdrh {{ tscdrh: {=u8:?} }}", self.tscdrh())
            }
        }
        #[doc = "Temperature Sensor Calibration Data Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tscdrl(pub u8);
        impl Tscdrl {
            #[doc = "The calibration data stores the lower 8 bits of the convertedvalue."]
            #[inline(always)]
            pub const fn tscdrl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The calibration data stores the lower 8 bits of the convertedvalue."]
            #[inline(always)]
            pub fn set_tscdrl(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Tscdrl {
            #[inline(always)]
            fn default() -> Tscdrl {
                Tscdrl(0)
            }
        }
        impl core::fmt::Debug for Tscdrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tscdrl")
                    .field("tscdrl", &self.tscdrl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tscdrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tscdrl {{ tscdrl: {=u8:?} }}", self.tscdrl())
            }
        }
    }
}
pub mod usbfs {
    #[doc = "USB 2.0 FS Module"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Usbfs {
        ptr: *mut u8,
    }
    unsafe impl Send for Usbfs {}
    unsafe impl Sync for Usbfs {}
    impl Usbfs {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "System Configuration Control Register"]
        #[inline(always)]
        pub const fn syscfg(self) -> crate::common::Reg<regs::Syscfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "System Configuration Status Register 0"]
        #[inline(always)]
        pub const fn syssts0(self) -> crate::common::Reg<regs::Syssts0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Device State Control Register 0"]
        #[inline(always)]
        pub const fn dvstctr0(self) -> crate::common::Reg<regs::Dvstctr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CFIFO Port Register"]
        #[inline(always)]
        pub const fn cfifo(self) -> crate::common::Reg<regs::Cfifo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "CFIFO Port Register L"]
        #[inline(always)]
        pub const fn cfifol(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "CFIFO Port Select Register"]
        #[inline(always)]
        pub const fn cfifosel(self) -> crate::common::Reg<regs::Cfifosel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "CFIFO Port Control Register"]
        #[inline(always)]
        pub const fn cfifoctr(self) -> crate::common::Reg<regs::Cfifoctr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x22usize) as _) }
        }
        #[doc = "Interrupt Enable Register 0"]
        #[inline(always)]
        pub const fn intenb0(self) -> crate::common::Reg<regs::Intenb0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "BRDY Interrupt Enable Register"]
        #[inline(always)]
        pub const fn brdyenb(self) -> crate::common::Reg<regs::Brdyenb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x36usize) as _) }
        }
        #[doc = "NRDY Interrupt Enable Register"]
        #[inline(always)]
        pub const fn nrdyenb(self) -> crate::common::Reg<regs::Nrdyenb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "BEMP Interrupt Enable Register"]
        #[inline(always)]
        pub const fn bempenb(self) -> crate::common::Reg<regs::Bempenb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3ausize) as _) }
        }
        #[doc = "SOF Output Configuration Register"]
        #[inline(always)]
        pub const fn sofcfg(self) -> crate::common::Reg<regs::Sofcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Interrupt Status Register 0"]
        #[inline(always)]
        pub const fn intsts0(self) -> crate::common::Reg<regs::Intsts0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "BRDY Interrupt Status Register"]
        #[inline(always)]
        pub const fn brdysts(self) -> crate::common::Reg<regs::Brdysts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x46usize) as _) }
        }
        #[doc = "NRDY Interrupt Status Register"]
        #[inline(always)]
        pub const fn nrdysts(self) -> crate::common::Reg<regs::Nrdysts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "BEMP Interrupt Status Register"]
        #[inline(always)]
        pub const fn bempsts(self) -> crate::common::Reg<regs::Bempsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4ausize) as _) }
        }
        #[doc = "Frame Number Register"]
        #[inline(always)]
        pub const fn frmnum(self) -> crate::common::Reg<regs::Frmnum, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "USB Request Type Register"]
        #[inline(always)]
        pub const fn usbreq(self) -> crate::common::Reg<regs::Usbreq, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "USB Request Value Register"]
        #[inline(always)]
        pub const fn usbval(self) -> crate::common::Reg<regs::Usbval, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x56usize) as _) }
        }
        #[doc = "USB Request Index Register"]
        #[inline(always)]
        pub const fn usbindx(self) -> crate::common::Reg<regs::Usbindx, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "USB Request Length Register"]
        #[inline(always)]
        pub const fn usbleng(self) -> crate::common::Reg<regs::Usbleng, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5ausize) as _) }
        }
        #[doc = "DCP Configuration Register"]
        #[inline(always)]
        pub const fn dcpcfg(self) -> crate::common::Reg<regs::Dcpcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "DCP Maximum Packet Size Register"]
        #[inline(always)]
        pub const fn dcpmaxp(self) -> crate::common::Reg<regs::Dcpmaxp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5eusize) as _) }
        }
        #[doc = "DCP Control Register"]
        #[inline(always)]
        pub const fn dcpctr(self) -> crate::common::Reg<regs::Dcpctr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Pipe Window Select Register"]
        #[inline(always)]
        pub const fn pipesel(self) -> crate::common::Reg<regs::Pipesel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "Pipe Configuration Register"]
        #[inline(always)]
        pub const fn pipecfg(self) -> crate::common::Reg<regs::Pipecfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "Pipe Maximum Packet Size Register"]
        #[inline(always)]
        pub const fn pipemaxp(self) -> crate::common::Reg<regs::Pipemaxp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6cusize) as _) }
        }
        #[doc = "Pipe %s Control Register"]
        #[inline(always)]
        pub const fn pipectr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Pipectr, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x76usize + n * 2usize) as _) }
        }
        #[doc = "Pipe %s Control Register"]
        #[inline(always)]
        pub const fn pipectr_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Pipectr1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7ausize + n * 2usize) as _) }
        }
        #[doc = "Pipe %s Transaction Counter Enable Register"]
        #[inline(always)]
        pub const fn pipetre(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Pipetre, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize + n * 4usize) as _) }
        }
        #[doc = "Pipe %s Transaction Counter Register"]
        #[inline(always)]
        pub const fn pipetrn(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Pipetrn, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9eusize + n * 4usize) as _) }
        }
        #[doc = "BC Control Register 0"]
        #[inline(always)]
        pub const fn usbbcctrl0(self) -> crate::common::Reg<regs::Usbbcctrl0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize) as _) }
        }
        #[doc = "USB Clock Selection Register"]
        #[inline(always)]
        pub const fn ucksel(self) -> crate::common::Reg<regs::Ucksel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc4usize) as _) }
        }
        #[doc = "USB Module Control Register"]
        #[inline(always)]
        pub const fn usbmc(self) -> crate::common::Reg<regs::Usbmc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xccusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "BEMP Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bempenb(pub u16);
        impl Bempenb {
            #[doc = "BEMP Interrupt Enable for PIPE0"]
            #[inline(always)]
            pub const fn pipe0bempe(&self) -> super::vals::Pipe0bempe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pipe0bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE0"]
            #[inline(always)]
            pub fn set_pipe0bempe(&mut self, val: super::vals::Pipe0bempe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "BEMP Interrupt Enable for PIPE1"]
            #[inline(always)]
            pub const fn pipe1bempe(&self) -> super::vals::Pipe1bempe {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pipe1bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE1"]
            #[inline(always)]
            pub fn set_pipe1bempe(&mut self, val: super::vals::Pipe1bempe) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "BEMP Interrupt Enable for PIPE2"]
            #[inline(always)]
            pub const fn pipe2bempe(&self) -> super::vals::Pipe2bempe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pipe2bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE2"]
            #[inline(always)]
            pub fn set_pipe2bempe(&mut self, val: super::vals::Pipe2bempe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "BEMP Interrupt Enable for PIPE3"]
            #[inline(always)]
            pub const fn pipe3bempe(&self) -> super::vals::Pipe3bempe {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pipe3bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE3"]
            #[inline(always)]
            pub fn set_pipe3bempe(&mut self, val: super::vals::Pipe3bempe) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "BEMP Interrupt Enable for PIPE4"]
            #[inline(always)]
            pub const fn pipe4bempe(&self) -> super::vals::Pipe4bempe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pipe4bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE4"]
            #[inline(always)]
            pub fn set_pipe4bempe(&mut self, val: super::vals::Pipe4bempe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "BEMP Interrupt Enable for PIPE5"]
            #[inline(always)]
            pub const fn pipe5bempe(&self) -> super::vals::Pipe5bempe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pipe5bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE5"]
            #[inline(always)]
            pub fn set_pipe5bempe(&mut self, val: super::vals::Pipe5bempe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "BEMP Interrupt Enable for PIPE6"]
            #[inline(always)]
            pub const fn pipe6bempe(&self) -> super::vals::Pipe6bempe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pipe6bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE6"]
            #[inline(always)]
            pub fn set_pipe6bempe(&mut self, val: super::vals::Pipe6bempe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "BEMP Interrupt Enable for PIPE7"]
            #[inline(always)]
            pub const fn pipe7bempe(&self) -> super::vals::Pipe7bempe {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pipe7bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE7"]
            #[inline(always)]
            pub fn set_pipe7bempe(&mut self, val: super::vals::Pipe7bempe) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "BEMP Interrupt Enable for PIPE8"]
            #[inline(always)]
            pub const fn pipe8bempe(&self) -> super::vals::Pipe8bempe {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pipe8bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE8"]
            #[inline(always)]
            pub fn set_pipe8bempe(&mut self, val: super::vals::Pipe8bempe) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "BEMP Interrupt Enable for PIPE9"]
            #[inline(always)]
            pub const fn pipe9bempe(&self) -> super::vals::Pipe9bempe {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pipe9bempe::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Enable for PIPE9"]
            #[inline(always)]
            pub fn set_pipe9bempe(&mut self, val: super::vals::Pipe9bempe) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Bempenb {
            #[inline(always)]
            fn default() -> Bempenb {
                Bempenb(0)
            }
        }
        impl core::fmt::Debug for Bempenb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bempenb")
                    .field("pipe0bempe", &self.pipe0bempe())
                    .field("pipe1bempe", &self.pipe1bempe())
                    .field("pipe2bempe", &self.pipe2bempe())
                    .field("pipe3bempe", &self.pipe3bempe())
                    .field("pipe4bempe", &self.pipe4bempe())
                    .field("pipe5bempe", &self.pipe5bempe())
                    .field("pipe6bempe", &self.pipe6bempe())
                    .field("pipe7bempe", &self.pipe7bempe())
                    .field("pipe8bempe", &self.pipe8bempe())
                    .field("pipe9bempe", &self.pipe9bempe())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bempenb {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bempenb {{ pipe0bempe: {:?}, pipe1bempe: {:?}, pipe2bempe: {:?}, pipe3bempe: {:?}, pipe4bempe: {:?}, pipe5bempe: {:?}, pipe6bempe: {:?}, pipe7bempe: {:?}, pipe8bempe: {:?}, pipe9bempe: {:?}, reserved_10_15: {=u8:?} }}" , self . pipe0bempe () , self . pipe1bempe () , self . pipe2bempe () , self . pipe3bempe () , self . pipe4bempe () , self . pipe5bempe () , self . pipe6bempe () , self . pipe7bempe () , self . pipe8bempe () , self . pipe9bempe () , self . reserved_10_15 ())
            }
        }
        #[doc = "BEMP Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bempsts(pub u16);
        impl Bempsts {
            #[doc = "BEMP Interrupt Status for PIPE0"]
            #[inline(always)]
            pub const fn pipe0bemp(&self) -> super::vals::Pipe0bemp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pipe0bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE0"]
            #[inline(always)]
            pub fn set_pipe0bemp(&mut self, val: super::vals::Pipe0bemp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "BEMP Interrupt Status for PIPE1"]
            #[inline(always)]
            pub const fn pipe1bemp(&self) -> super::vals::Pipe1bemp {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pipe1bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE1"]
            #[inline(always)]
            pub fn set_pipe1bemp(&mut self, val: super::vals::Pipe1bemp) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "BEMP Interrupt Status for PIPE2"]
            #[inline(always)]
            pub const fn pipe2bemp(&self) -> super::vals::Pipe2bemp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pipe2bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE2"]
            #[inline(always)]
            pub fn set_pipe2bemp(&mut self, val: super::vals::Pipe2bemp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "BEMP Interrupt Status for PIPE3"]
            #[inline(always)]
            pub const fn pipe3bemp(&self) -> super::vals::Pipe3bemp {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pipe3bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE3"]
            #[inline(always)]
            pub fn set_pipe3bemp(&mut self, val: super::vals::Pipe3bemp) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "BEMP Interrupt Status for PIPE4"]
            #[inline(always)]
            pub const fn pipe4bemp(&self) -> super::vals::Pipe4bemp {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pipe4bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE4"]
            #[inline(always)]
            pub fn set_pipe4bemp(&mut self, val: super::vals::Pipe4bemp) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "BEMP Interrupt Status for PIPE5"]
            #[inline(always)]
            pub const fn pipe5bemp(&self) -> super::vals::Pipe5bemp {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pipe5bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE5"]
            #[inline(always)]
            pub fn set_pipe5bemp(&mut self, val: super::vals::Pipe5bemp) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "BEMP Interrupt Status for PIPE6"]
            #[inline(always)]
            pub const fn pipe6bemp(&self) -> super::vals::Pipe6bemp {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pipe6bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE6"]
            #[inline(always)]
            pub fn set_pipe6bemp(&mut self, val: super::vals::Pipe6bemp) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "BEMP Interrupt Status for PIPE7"]
            #[inline(always)]
            pub const fn pipe7bemp(&self) -> super::vals::Pipe7bemp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pipe7bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE7"]
            #[inline(always)]
            pub fn set_pipe7bemp(&mut self, val: super::vals::Pipe7bemp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "BEMP Interrupt Status for PIPE8"]
            #[inline(always)]
            pub const fn pipe8bemp(&self) -> super::vals::Pipe8bemp {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pipe8bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE8"]
            #[inline(always)]
            pub fn set_pipe8bemp(&mut self, val: super::vals::Pipe8bemp) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "BEMP Interrupt Status for PIPE9"]
            #[inline(always)]
            pub const fn pipe9bemp(&self) -> super::vals::Pipe9bemp {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pipe9bemp::from_bits(val as u8)
            }
            #[doc = "BEMP Interrupt Status for PIPE9"]
            #[inline(always)]
            pub fn set_pipe9bemp(&mut self, val: super::vals::Pipe9bemp) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Bempsts {
            #[inline(always)]
            fn default() -> Bempsts {
                Bempsts(0)
            }
        }
        impl core::fmt::Debug for Bempsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bempsts")
                    .field("pipe0bemp", &self.pipe0bemp())
                    .field("pipe1bemp", &self.pipe1bemp())
                    .field("pipe2bemp", &self.pipe2bemp())
                    .field("pipe3bemp", &self.pipe3bemp())
                    .field("pipe4bemp", &self.pipe4bemp())
                    .field("pipe5bemp", &self.pipe5bemp())
                    .field("pipe6bemp", &self.pipe6bemp())
                    .field("pipe7bemp", &self.pipe7bemp())
                    .field("pipe8bemp", &self.pipe8bemp())
                    .field("pipe9bemp", &self.pipe9bemp())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bempsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bempsts {{ pipe0bemp: {:?}, pipe1bemp: {:?}, pipe2bemp: {:?}, pipe3bemp: {:?}, pipe4bemp: {:?}, pipe5bemp: {:?}, pipe6bemp: {:?}, pipe7bemp: {:?}, pipe8bemp: {:?}, pipe9bemp: {:?}, reserved_10_15: {=u8:?} }}" , self . pipe0bemp () , self . pipe1bemp () , self . pipe2bemp () , self . pipe3bemp () , self . pipe4bemp () , self . pipe5bemp () , self . pipe6bemp () , self . pipe7bemp () , self . pipe8bemp () , self . pipe9bemp () , self . reserved_10_15 ())
            }
        }
        #[doc = "BRDY Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Brdyenb(pub u16);
        impl Brdyenb {
            #[doc = "BRDY Interrupt Enable for PIPE0"]
            #[inline(always)]
            pub const fn pipe0brdye(&self) -> super::vals::Pipe0brdye {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pipe0brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE0"]
            #[inline(always)]
            pub fn set_pipe0brdye(&mut self, val: super::vals::Pipe0brdye) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "BRDY Interrupt Enable for PIPE1"]
            #[inline(always)]
            pub const fn pipe1brdye(&self) -> super::vals::Pipe1brdye {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pipe1brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE1"]
            #[inline(always)]
            pub fn set_pipe1brdye(&mut self, val: super::vals::Pipe1brdye) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "BRDY Interrupt Enable for PIPE2"]
            #[inline(always)]
            pub const fn pipe2brdye(&self) -> super::vals::Pipe2brdye {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pipe2brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE2"]
            #[inline(always)]
            pub fn set_pipe2brdye(&mut self, val: super::vals::Pipe2brdye) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "BRDY Interrupt Enable for PIPE3"]
            #[inline(always)]
            pub const fn pipe3brdye(&self) -> super::vals::Pipe3brdye {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pipe3brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE3"]
            #[inline(always)]
            pub fn set_pipe3brdye(&mut self, val: super::vals::Pipe3brdye) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "BRDY Interrupt Enable for PIPE4"]
            #[inline(always)]
            pub const fn pipe4brdye(&self) -> super::vals::Pipe4brdye {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pipe4brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE4"]
            #[inline(always)]
            pub fn set_pipe4brdye(&mut self, val: super::vals::Pipe4brdye) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "BRDY Interrupt Enable for PIPE5"]
            #[inline(always)]
            pub const fn pipe5brdye(&self) -> super::vals::Pipe5brdye {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pipe5brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE5"]
            #[inline(always)]
            pub fn set_pipe5brdye(&mut self, val: super::vals::Pipe5brdye) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "BRDY Interrupt Enable for PIPE6"]
            #[inline(always)]
            pub const fn pipe6brdye(&self) -> super::vals::Pipe6brdye {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pipe6brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE6"]
            #[inline(always)]
            pub fn set_pipe6brdye(&mut self, val: super::vals::Pipe6brdye) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "BRDY Interrupt Enable for PIPE7"]
            #[inline(always)]
            pub const fn pipe7brdye(&self) -> super::vals::Pipe7brdye {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pipe7brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE7"]
            #[inline(always)]
            pub fn set_pipe7brdye(&mut self, val: super::vals::Pipe7brdye) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "BRDY Interrupt Enable for PIPE8"]
            #[inline(always)]
            pub const fn pipe8brdye(&self) -> super::vals::Pipe8brdye {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pipe8brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE8"]
            #[inline(always)]
            pub fn set_pipe8brdye(&mut self, val: super::vals::Pipe8brdye) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "BRDY Interrupt Enable for PIPE9"]
            #[inline(always)]
            pub const fn pipe9brdye(&self) -> super::vals::Pipe9brdye {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pipe9brdye::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Enable for PIPE9"]
            #[inline(always)]
            pub fn set_pipe9brdye(&mut self, val: super::vals::Pipe9brdye) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Brdyenb {
            #[inline(always)]
            fn default() -> Brdyenb {
                Brdyenb(0)
            }
        }
        impl core::fmt::Debug for Brdyenb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Brdyenb")
                    .field("pipe0brdye", &self.pipe0brdye())
                    .field("pipe1brdye", &self.pipe1brdye())
                    .field("pipe2brdye", &self.pipe2brdye())
                    .field("pipe3brdye", &self.pipe3brdye())
                    .field("pipe4brdye", &self.pipe4brdye())
                    .field("pipe5brdye", &self.pipe5brdye())
                    .field("pipe6brdye", &self.pipe6brdye())
                    .field("pipe7brdye", &self.pipe7brdye())
                    .field("pipe8brdye", &self.pipe8brdye())
                    .field("pipe9brdye", &self.pipe9brdye())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Brdyenb {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Brdyenb {{ pipe0brdye: {:?}, pipe1brdye: {:?}, pipe2brdye: {:?}, pipe3brdye: {:?}, pipe4brdye: {:?}, pipe5brdye: {:?}, pipe6brdye: {:?}, pipe7brdye: {:?}, pipe8brdye: {:?}, pipe9brdye: {:?}, reserved_10_15: {=u8:?} }}" , self . pipe0brdye () , self . pipe1brdye () , self . pipe2brdye () , self . pipe3brdye () , self . pipe4brdye () , self . pipe5brdye () , self . pipe6brdye () , self . pipe7brdye () , self . pipe8brdye () , self . pipe9brdye () , self . reserved_10_15 ())
            }
        }
        #[doc = "BRDY Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Brdysts(pub u16);
        impl Brdysts {
            #[doc = "BRDY Interrupt Status for PIPE0"]
            #[inline(always)]
            pub const fn pipe0brdy(&self) -> super::vals::Pipe0brdy {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pipe0brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE0"]
            #[inline(always)]
            pub fn set_pipe0brdy(&mut self, val: super::vals::Pipe0brdy) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "BRDY Interrupt Status for PIPE1"]
            #[inline(always)]
            pub const fn pipe1brdy(&self) -> super::vals::Pipe1brdy {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pipe1brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE1"]
            #[inline(always)]
            pub fn set_pipe1brdy(&mut self, val: super::vals::Pipe1brdy) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "BRDY Interrupt Status for PIPE2"]
            #[inline(always)]
            pub const fn pipe2brdy(&self) -> super::vals::Pipe2brdy {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pipe2brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE2"]
            #[inline(always)]
            pub fn set_pipe2brdy(&mut self, val: super::vals::Pipe2brdy) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "BRDY Interrupt Status for PIPE3"]
            #[inline(always)]
            pub const fn pipe3brdy(&self) -> super::vals::Pipe3brdy {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pipe3brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE3"]
            #[inline(always)]
            pub fn set_pipe3brdy(&mut self, val: super::vals::Pipe3brdy) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "BRDY Interrupt Status for PIPE4"]
            #[inline(always)]
            pub const fn pipe4brdy(&self) -> super::vals::Pipe4brdy {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pipe4brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE4"]
            #[inline(always)]
            pub fn set_pipe4brdy(&mut self, val: super::vals::Pipe4brdy) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "BRDY Interrupt Status for PIPE5"]
            #[inline(always)]
            pub const fn pipe5brdy(&self) -> super::vals::Pipe5brdy {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pipe5brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE5"]
            #[inline(always)]
            pub fn set_pipe5brdy(&mut self, val: super::vals::Pipe5brdy) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "BRDY Interrupt Status for PIPE6"]
            #[inline(always)]
            pub const fn pipe6brdy(&self) -> super::vals::Pipe6brdy {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pipe6brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE6"]
            #[inline(always)]
            pub fn set_pipe6brdy(&mut self, val: super::vals::Pipe6brdy) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "BRDY Interrupt Status for PIPE7"]
            #[inline(always)]
            pub const fn pipe7brdy(&self) -> super::vals::Pipe7brdy {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pipe7brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE7"]
            #[inline(always)]
            pub fn set_pipe7brdy(&mut self, val: super::vals::Pipe7brdy) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "BRDY Interrupt Status for PIPE8"]
            #[inline(always)]
            pub const fn pipe8brdy(&self) -> super::vals::Pipe8brdy {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pipe8brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE8"]
            #[inline(always)]
            pub fn set_pipe8brdy(&mut self, val: super::vals::Pipe8brdy) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "BRDY Interrupt Status for PIPE9"]
            #[inline(always)]
            pub const fn pipe9brdy(&self) -> super::vals::Pipe9brdy {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pipe9brdy::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status for PIPE9"]
            #[inline(always)]
            pub fn set_pipe9brdy(&mut self, val: super::vals::Pipe9brdy) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Brdysts {
            #[inline(always)]
            fn default() -> Brdysts {
                Brdysts(0)
            }
        }
        impl core::fmt::Debug for Brdysts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Brdysts")
                    .field("pipe0brdy", &self.pipe0brdy())
                    .field("pipe1brdy", &self.pipe1brdy())
                    .field("pipe2brdy", &self.pipe2brdy())
                    .field("pipe3brdy", &self.pipe3brdy())
                    .field("pipe4brdy", &self.pipe4brdy())
                    .field("pipe5brdy", &self.pipe5brdy())
                    .field("pipe6brdy", &self.pipe6brdy())
                    .field("pipe7brdy", &self.pipe7brdy())
                    .field("pipe8brdy", &self.pipe8brdy())
                    .field("pipe9brdy", &self.pipe9brdy())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Brdysts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Brdysts {{ pipe0brdy: {:?}, pipe1brdy: {:?}, pipe2brdy: {:?}, pipe3brdy: {:?}, pipe4brdy: {:?}, pipe5brdy: {:?}, pipe6brdy: {:?}, pipe7brdy: {:?}, pipe8brdy: {:?}, pipe9brdy: {:?}, reserved_10_15: {=u8:?} }}" , self . pipe0brdy () , self . pipe1brdy () , self . pipe2brdy () , self . pipe3brdy () , self . pipe4brdy () , self . pipe5brdy () , self . pipe6brdy () , self . pipe7brdy () , self . pipe8brdy () , self . pipe9brdy () , self . reserved_10_15 ())
            }
        }
        #[doc = "CFIFO Port Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfifo(pub u16);
        impl Cfifo {
            #[doc = "FIFO PortRead receive data from the FIFO buffer or write transmit data to the FIFO buffer by accessing these bits."]
            #[inline(always)]
            pub const fn fifoport(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "FIFO PortRead receive data from the FIFO buffer or write transmit data to the FIFO buffer by accessing these bits."]
            #[inline(always)]
            pub fn set_fifoport(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Cfifo {
            #[inline(always)]
            fn default() -> Cfifo {
                Cfifo(0)
            }
        }
        impl core::fmt::Debug for Cfifo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfifo")
                    .field("fifoport", &self.fifoport())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfifo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cfifo {{ fifoport: {=u16:?} }}", self.fifoport())
            }
        }
        #[doc = "CFIFO Port Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfifoctr(pub u16);
        impl Cfifoctr {
            #[doc = "Receive Data LengthIndicates the length of the receive data."]
            #[inline(always)]
            pub const fn dtln(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Receive Data LengthIndicates the length of the receive data."]
            #[inline(always)]
            pub fn set_dtln(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_9_12(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_9_12(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 9usize)) | (((val as u16) & 0x0f) << 9usize);
            }
            #[doc = "FIFO Port Ready"]
            #[inline(always)]
            pub const fn frdy(&self) -> super::vals::Frdy {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Frdy::from_bits(val as u8)
            }
            #[doc = "FIFO Port Ready"]
            #[inline(always)]
            pub fn set_frdy(&mut self, val: super::vals::Frdy) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "CPU Buffer Clear"]
            #[inline(always)]
            pub const fn bclr(&self) -> super::vals::Bclr {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Bclr::from_bits(val as u8)
            }
            #[doc = "CPU Buffer Clear"]
            #[inline(always)]
            pub fn set_bclr(&mut self, val: super::vals::Bclr) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Buffer Memory Valid Flag"]
            #[inline(always)]
            pub const fn bval(&self) -> super::vals::Bval {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Bval::from_bits(val as u8)
            }
            #[doc = "Buffer Memory Valid Flag"]
            #[inline(always)]
            pub fn set_bval(&mut self, val: super::vals::Bval) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Cfifoctr {
            #[inline(always)]
            fn default() -> Cfifoctr {
                Cfifoctr(0)
            }
        }
        impl core::fmt::Debug for Cfifoctr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfifoctr")
                    .field("dtln", &self.dtln())
                    .field("reserved_9_12", &self.reserved_9_12())
                    .field("frdy", &self.frdy())
                    .field("bclr", &self.bclr())
                    .field("bval", &self.bval())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfifoctr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cfifoctr {{ dtln: {=u16:?}, reserved_9_12: {=u8:?}, frdy: {:?}, bclr: {:?}, bval: {:?} }}" , self . dtln () , self . reserved_9_12 () , self . frdy () , self . bclr () , self . bval ())
            }
        }
        #[doc = "CFIFO Port Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfifosel(pub u16);
        impl Cfifosel {
            #[doc = "CFIFO Port Access Pipe Specification"]
            #[inline(always)]
            pub const fn curpipe(&self) -> super::vals::Curpipe {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Curpipe::from_bits(val as u8)
            }
            #[doc = "CFIFO Port Access Pipe Specification"]
            #[inline(always)]
            pub fn set_curpipe(&mut self, val: super::vals::Curpipe) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_4_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_4_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u16) & 0x01) << 4usize);
            }
            #[doc = "CFIFO Port Access Direction When DCP is Selected"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::Isel {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Isel::from_bits(val as u8)
            }
            #[doc = "CFIFO Port Access Direction When DCP is Selected"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::Isel) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_6_7(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_6_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u16) & 0x03) << 6usize);
            }
            #[doc = "CFIFO Port Endian Control"]
            #[inline(always)]
            pub const fn bigend(&self) -> super::vals::Bigend {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Bigend::from_bits(val as u8)
            }
            #[doc = "CFIFO Port Endian Control"]
            #[inline(always)]
            pub fn set_bigend(&mut self, val: super::vals::Bigend) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_9_9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_9_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u16) & 0x01) << 9usize);
            }
            #[doc = "CFIFO Port Access Bit Width"]
            #[inline(always)]
            pub const fn mbw(&self) -> super::vals::Mbw {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Mbw::from_bits(val as u8)
            }
            #[doc = "CFIFO Port Access Bit Width"]
            #[inline(always)]
            pub fn set_mbw(&mut self, val: super::vals::Mbw) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_11_13(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_11_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 11usize)) | (((val as u16) & 0x07) << 11usize);
            }
            #[doc = "Buffer Pointer Rewind"]
            #[inline(always)]
            pub const fn rew(&self) -> super::vals::Rew {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Rew::from_bits(val as u8)
            }
            #[doc = "Buffer Pointer Rewind"]
            #[inline(always)]
            pub fn set_rew(&mut self, val: super::vals::Rew) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Read Count Mode"]
            #[inline(always)]
            pub const fn rcnt(&self) -> super::vals::Rcnt {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Rcnt::from_bits(val as u8)
            }
            #[doc = "Read Count Mode"]
            #[inline(always)]
            pub fn set_rcnt(&mut self, val: super::vals::Rcnt) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Cfifosel {
            #[inline(always)]
            fn default() -> Cfifosel {
                Cfifosel(0)
            }
        }
        impl core::fmt::Debug for Cfifosel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfifosel")
                    .field("curpipe", &self.curpipe())
                    .field("reserved_4_4", &self.reserved_4_4())
                    .field("isel", &self.isel())
                    .field("reserved_6_7", &self.reserved_6_7())
                    .field("bigend", &self.bigend())
                    .field("reserved_9_9", &self.reserved_9_9())
                    .field("mbw", &self.mbw())
                    .field("reserved_11_13", &self.reserved_11_13())
                    .field("rew", &self.rew())
                    .field("rcnt", &self.rcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfifosel {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cfifosel {{ curpipe: {:?}, reserved_4_4: {=bool:?}, isel: {:?}, reserved_6_7: {=u8:?}, bigend: {:?}, reserved_9_9: {=bool:?}, mbw: {:?}, reserved_11_13: {=u8:?}, rew: {:?}, rcnt: {:?} }}" , self . curpipe () , self . reserved_4_4 () , self . isel () , self . reserved_6_7 () , self . bigend () , self . reserved_9_9 () , self . mbw () , self . reserved_11_13 () , self . rew () , self . rcnt ())
            }
        }
        #[doc = "DCP Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcpcfg(pub u16);
        impl Dcpcfg {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "Transfer Direction"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::DcpcfgDir {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::DcpcfgDir::from_bits(val as u8)
            }
            #[doc = "Transfer Direction"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::DcpcfgDir) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_5_6(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_5_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u16) & 0x03) << 5usize);
            }
            #[doc = "Pipe Disabled at End of Transfer"]
            #[inline(always)]
            pub const fn shtnak(&self) -> super::vals::DcpcfgShtnak {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::DcpcfgShtnak::from_bits(val as u8)
            }
            #[doc = "Pipe Disabled at End of Transfer"]
            #[inline(always)]
            pub fn set_shtnak(&mut self, val: super::vals::DcpcfgShtnak) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Dcpcfg {
            #[inline(always)]
            fn default() -> Dcpcfg {
                Dcpcfg(0)
            }
        }
        impl core::fmt::Debug for Dcpcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcpcfg")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("dir", &self.dir())
                    .field("reserved_5_6", &self.reserved_5_6())
                    .field("shtnak", &self.shtnak())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcpcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dcpcfg {{ reserved_0_3: {=u8:?}, dir: {:?}, reserved_5_6: {=u8:?}, shtnak: {:?}, reserved_8_15: {=u8:?} }}" , self . reserved_0_3 () , self . dir () , self . reserved_5_6 () , self . shtnak () , self . reserved_8_15 ())
            }
        }
        #[doc = "DCP Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcpctr(pub u16);
        impl Dcpctr {
            #[doc = "Response PID"]
            #[inline(always)]
            pub const fn pid(&self) -> super::vals::DcpctrPid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::DcpctrPid::from_bits(val as u8)
            }
            #[doc = "Response PID"]
            #[inline(always)]
            pub fn set_pid(&mut self, val: super::vals::DcpctrPid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Control Transfer End Enable"]
            #[inline(always)]
            pub const fn ccpl(&self) -> super::vals::Ccpl {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ccpl::from_bits(val as u8)
            }
            #[doc = "Control Transfer End Enable"]
            #[inline(always)]
            pub fn set_ccpl(&mut self, val: super::vals::Ccpl) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_3_4(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_3_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val as u16) & 0x03) << 3usize);
            }
            #[doc = "Pipe Busy"]
            #[inline(always)]
            pub const fn pbusy(&self) -> super::vals::DcpctrPbusy {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::DcpctrPbusy::from_bits(val as u8)
            }
            #[doc = "Pipe Busy"]
            #[inline(always)]
            pub fn set_pbusy(&mut self, val: super::vals::DcpctrPbusy) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Sequence Toggle Bit Monitor"]
            #[inline(always)]
            pub const fn sqmon(&self) -> super::vals::DcpctrSqmon {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::DcpctrSqmon::from_bits(val as u8)
            }
            #[doc = "Sequence Toggle Bit Monitor"]
            #[inline(always)]
            pub fn set_sqmon(&mut self, val: super::vals::DcpctrSqmon) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Sequence Toggle Bit Set"]
            #[inline(always)]
            pub const fn sqset(&self) -> super::vals::DcpctrSqset {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::DcpctrSqset::from_bits(val as u8)
            }
            #[doc = "Sequence Toggle Bit Set"]
            #[inline(always)]
            pub fn set_sqset(&mut self, val: super::vals::DcpctrSqset) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Sequence Toggle Bit Clear"]
            #[inline(always)]
            pub const fn sqclr(&self) -> super::vals::DcpctrSqclr {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::DcpctrSqclr::from_bits(val as u8)
            }
            #[doc = "Sequence Toggle Bit Clear"]
            #[inline(always)]
            pub fn set_sqclr(&mut self, val: super::vals::DcpctrSqclr) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_9_10(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_9_10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 9usize)) | (((val as u16) & 0x03) << 9usize);
            }
            #[doc = "SUREQ Bit Clear"]
            #[inline(always)]
            pub const fn sureqclr(&self) -> super::vals::Sureqclr {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Sureqclr::from_bits(val as u8)
            }
            #[doc = "SUREQ Bit Clear"]
            #[inline(always)]
            pub fn set_sureqclr(&mut self, val: super::vals::Sureqclr) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_12_13(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_12_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u16) & 0x03) << 12usize);
            }
            #[doc = "Setup Token Transmission"]
            #[inline(always)]
            pub const fn sureq(&self) -> super::vals::Sureq {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Sureq::from_bits(val as u8)
            }
            #[doc = "Setup Token Transmission"]
            #[inline(always)]
            pub fn set_sureq(&mut self, val: super::vals::Sureq) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Buffer Status"]
            #[inline(always)]
            pub const fn bsts(&self) -> super::vals::DcpctrBsts {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::DcpctrBsts::from_bits(val as u8)
            }
            #[doc = "Buffer Status"]
            #[inline(always)]
            pub fn set_bsts(&mut self, val: super::vals::DcpctrBsts) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Dcpctr {
            #[inline(always)]
            fn default() -> Dcpctr {
                Dcpctr(0)
            }
        }
        impl core::fmt::Debug for Dcpctr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcpctr")
                    .field("pid", &self.pid())
                    .field("ccpl", &self.ccpl())
                    .field("reserved_3_4", &self.reserved_3_4())
                    .field("pbusy", &self.pbusy())
                    .field("sqmon", &self.sqmon())
                    .field("sqset", &self.sqset())
                    .field("sqclr", &self.sqclr())
                    .field("reserved_9_10", &self.reserved_9_10())
                    .field("sureqclr", &self.sureqclr())
                    .field("reserved_12_13", &self.reserved_12_13())
                    .field("sureq", &self.sureq())
                    .field("bsts", &self.bsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcpctr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dcpctr {{ pid: {:?}, ccpl: {:?}, reserved_3_4: {=u8:?}, pbusy: {:?}, sqmon: {:?}, sqset: {:?}, sqclr: {:?}, reserved_9_10: {=u8:?}, sureqclr: {:?}, reserved_12_13: {=u8:?}, sureq: {:?}, bsts: {:?} }}" , self . pid () , self . ccpl () , self . reserved_3_4 () , self . pbusy () , self . sqmon () , self . sqset () , self . sqclr () , self . reserved_9_10 () , self . sureqclr () , self . reserved_12_13 () , self . sureq () , self . bsts ())
            }
        }
        #[doc = "DCP Maximum Packet Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcpmaxp(pub u16);
        impl Dcpmaxp {
            #[doc = "Maximum Packet SizeThese bits set the maximum amount of data (maximum packet size) in payloads for the DCP."]
            #[inline(always)]
            pub const fn mxps(&self) -> super::vals::Mxps {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Mxps::from_bits(val as u8)
            }
            #[doc = "Maximum Packet SizeThese bits set the maximum amount of data (maximum packet size) in payloads for the DCP."]
            #[inline(always)]
            pub fn set_mxps(&mut self, val: super::vals::Mxps) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u16) & 0x7f) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_7_11(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_7_11(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 7usize)) | (((val as u16) & 0x1f) << 7usize);
            }
            #[doc = "Device Select"]
            #[inline(always)]
            pub const fn devsel(&self) -> super::vals::DcpmaxpDevsel {
                let val = (self.0 >> 12usize) & 0x0f;
                super::vals::DcpmaxpDevsel::from_bits(val as u8)
            }
            #[doc = "Device Select"]
            #[inline(always)]
            pub fn set_devsel(&mut self, val: super::vals::DcpmaxpDevsel) {
                self.0 =
                    (self.0 & !(0x0f << 12usize)) | (((val.to_bits() as u16) & 0x0f) << 12usize);
            }
        }
        impl Default for Dcpmaxp {
            #[inline(always)]
            fn default() -> Dcpmaxp {
                Dcpmaxp(0)
            }
        }
        impl core::fmt::Debug for Dcpmaxp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcpmaxp")
                    .field("mxps", &self.mxps())
                    .field("reserved_7_11", &self.reserved_7_11())
                    .field("devsel", &self.devsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcpmaxp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dcpmaxp {{ mxps: {:?}, reserved_7_11: {=u8:?}, devsel: {:?} }}",
                    self.mxps(),
                    self.reserved_7_11(),
                    self.devsel()
                )
            }
        }
        #[doc = "Device State Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dvstctr0(pub u16);
        impl Dvstctr0 {
            #[doc = "USB Bus Reset Status"]
            #[inline(always)]
            pub const fn rhst(&self) -> super::vals::Rhst {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Rhst::from_bits(val as u8)
            }
            #[doc = "USB Bus Reset Status"]
            #[inline(always)]
            pub fn set_rhst(&mut self, val: super::vals::Rhst) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u16) & 0x07) << 0usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_3_7(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_3_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val as u16) & 0x1f) << 3usize);
            }
            #[doc = "Wakeup Detection Enable"]
            #[inline(always)]
            pub const fn wkup(&self) -> super::vals::Wkup {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Wkup::from_bits(val as u8)
            }
            #[doc = "Wakeup Detection Enable"]
            #[inline(always)]
            pub fn set_wkup(&mut self, val: super::vals::Wkup) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Dvstctr0 {
            #[inline(always)]
            fn default() -> Dvstctr0 {
                Dvstctr0(0)
            }
        }
        impl core::fmt::Debug for Dvstctr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dvstctr0")
                    .field("rhst", &self.rhst())
                    .field("reserved_3_7", &self.reserved_3_7())
                    .field("wkup", &self.wkup())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dvstctr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dvstctr0 {{ rhst: {:?}, reserved_3_7: {=u8:?}, wkup: {:?}, reserved_9_15: {=u8:?} }}" , self . rhst () , self . reserved_3_7 () , self . wkup () , self . reserved_9_15 ())
            }
        }
        #[doc = "Frame Number Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frmnum(pub u16);
        impl Frmnum {
            #[doc = "Frame NumberLatest frame number"]
            #[inline(always)]
            pub const fn frnm(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Frame NumberLatest frame number"]
            #[inline(always)]
            pub fn set_frnm(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u16) & 0x07ff) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_11_13(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_11_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 11usize)) | (((val as u16) & 0x07) << 11usize);
            }
            #[doc = "Receive Data Error"]
            #[inline(always)]
            pub const fn crce(&self) -> super::vals::Crce {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Crce::from_bits(val as u8)
            }
            #[doc = "Receive Data Error"]
            #[inline(always)]
            pub fn set_crce(&mut self, val: super::vals::Crce) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Overrun/Underrun Detection Status"]
            #[inline(always)]
            pub const fn ovrn(&self) -> super::vals::Ovrn {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ovrn::from_bits(val as u8)
            }
            #[doc = "Overrun/Underrun Detection Status"]
            #[inline(always)]
            pub fn set_ovrn(&mut self, val: super::vals::Ovrn) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Frmnum {
            #[inline(always)]
            fn default() -> Frmnum {
                Frmnum(0)
            }
        }
        impl core::fmt::Debug for Frmnum {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frmnum")
                    .field("frnm", &self.frnm())
                    .field("reserved_11_13", &self.reserved_11_13())
                    .field("crce", &self.crce())
                    .field("ovrn", &self.ovrn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frmnum {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Frmnum {{ frnm: {=u16:?}, reserved_11_13: {=u8:?}, crce: {:?}, ovrn: {:?} }}",
                    self.frnm(),
                    self.reserved_11_13(),
                    self.crce(),
                    self.ovrn()
                )
            }
        }
        #[doc = "Interrupt Enable Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intenb0(pub u16);
        impl Intenb0 {
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_0_7(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_0_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "Buffer Ready Interrupt Enable"]
            #[inline(always)]
            pub const fn brdye(&self) -> super::vals::Brdye {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Brdye::from_bits(val as u8)
            }
            #[doc = "Buffer Ready Interrupt Enable"]
            #[inline(always)]
            pub fn set_brdye(&mut self, val: super::vals::Brdye) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Buffer Not Ready Response Interrupt Enable"]
            #[inline(always)]
            pub const fn nrdye(&self) -> super::vals::Nrdye {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Nrdye::from_bits(val as u8)
            }
            #[doc = "Buffer Not Ready Response Interrupt Enable"]
            #[inline(always)]
            pub fn set_nrdye(&mut self, val: super::vals::Nrdye) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub const fn bempe(&self) -> super::vals::Bempe {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bempe::from_bits(val as u8)
            }
            #[doc = "Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub fn set_bempe(&mut self, val: super::vals::Bempe) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Control Transfer Stage Transition Interrupt Enable"]
            #[inline(always)]
            pub const fn ctre(&self) -> super::vals::Ctre {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ctre::from_bits(val as u8)
            }
            #[doc = "Control Transfer Stage Transition Interrupt Enable"]
            #[inline(always)]
            pub fn set_ctre(&mut self, val: super::vals::Ctre) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Device State Transition Interrupt Enable"]
            #[inline(always)]
            pub const fn dvse(&self) -> super::vals::Dvse {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Dvse::from_bits(val as u8)
            }
            #[doc = "Device State Transition Interrupt Enable"]
            #[inline(always)]
            pub fn set_dvse(&mut self, val: super::vals::Dvse) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Frame Number Update Interrupt Enable"]
            #[inline(always)]
            pub const fn sofe(&self) -> super::vals::Sofe {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Sofe::from_bits(val as u8)
            }
            #[doc = "Frame Number Update Interrupt Enable"]
            #[inline(always)]
            pub fn set_sofe(&mut self, val: super::vals::Sofe) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Resume Interrupt Enable"]
            #[inline(always)]
            pub const fn rsme(&self) -> super::vals::Rsme {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Rsme::from_bits(val as u8)
            }
            #[doc = "Resume Interrupt Enable"]
            #[inline(always)]
            pub fn set_rsme(&mut self, val: super::vals::Rsme) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "VBUS Interrupt Enable"]
            #[inline(always)]
            pub const fn vbse(&self) -> super::vals::Vbse {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Vbse::from_bits(val as u8)
            }
            #[doc = "VBUS Interrupt Enable"]
            #[inline(always)]
            pub fn set_vbse(&mut self, val: super::vals::Vbse) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Intenb0 {
            #[inline(always)]
            fn default() -> Intenb0 {
                Intenb0(0)
            }
        }
        impl core::fmt::Debug for Intenb0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intenb0")
                    .field("reserved_0_7", &self.reserved_0_7())
                    .field("brdye", &self.brdye())
                    .field("nrdye", &self.nrdye())
                    .field("bempe", &self.bempe())
                    .field("ctre", &self.ctre())
                    .field("dvse", &self.dvse())
                    .field("sofe", &self.sofe())
                    .field("rsme", &self.rsme())
                    .field("vbse", &self.vbse())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intenb0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intenb0 {{ reserved_0_7: {=u8:?}, brdye: {:?}, nrdye: {:?}, bempe: {:?}, ctre: {:?}, dvse: {:?}, sofe: {:?}, rsme: {:?}, vbse: {:?} }}" , self . reserved_0_7 () , self . brdye () , self . nrdye () , self . bempe () , self . ctre () , self . dvse () , self . sofe () , self . rsme () , self . vbse ())
            }
        }
        #[doc = "Interrupt Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intsts0(pub u16);
        impl Intsts0 {
            #[doc = "Control Transfer Stage"]
            #[inline(always)]
            pub const fn ctsq(&self) -> super::vals::Ctsq {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ctsq::from_bits(val as u8)
            }
            #[doc = "Control Transfer Stage"]
            #[inline(always)]
            pub fn set_ctsq(&mut self, val: super::vals::Ctsq) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u16) & 0x07) << 0usize);
            }
            #[doc = "USB Request Reception"]
            #[inline(always)]
            pub const fn valid(&self) -> super::vals::Valid {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Valid::from_bits(val as u8)
            }
            #[doc = "USB Request Reception"]
            #[inline(always)]
            pub fn set_valid(&mut self, val: super::vals::Valid) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Device State"]
            #[inline(always)]
            pub const fn dvsq(&self) -> super::vals::Dvsq {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Dvsq::from_bits(val as u8)
            }
            #[doc = "Device State"]
            #[inline(always)]
            pub fn set_dvsq(&mut self, val: super::vals::Dvsq) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u16) & 0x07) << 4usize);
            }
            #[doc = "VBUS Input Status"]
            #[inline(always)]
            pub const fn vbsts(&self) -> super::vals::Vbsts {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Vbsts::from_bits(val as u8)
            }
            #[doc = "VBUS Input Status"]
            #[inline(always)]
            pub fn set_vbsts(&mut self, val: super::vals::Vbsts) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Buffer Ready Interrupt Status"]
            #[inline(always)]
            pub const fn brdy(&self) -> super::vals::Brdy {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Brdy::from_bits(val as u8)
            }
            #[doc = "Buffer Ready Interrupt Status"]
            #[inline(always)]
            pub fn set_brdy(&mut self, val: super::vals::Brdy) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Buffer Not Ready Interrupt Status"]
            #[inline(always)]
            pub const fn nrdy(&self) -> super::vals::Nrdy {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Nrdy::from_bits(val as u8)
            }
            #[doc = "Buffer Not Ready Interrupt Status"]
            #[inline(always)]
            pub fn set_nrdy(&mut self, val: super::vals::Nrdy) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Buffer Empty Interrupt Status"]
            #[inline(always)]
            pub const fn bemp(&self) -> super::vals::Bemp {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bemp::from_bits(val as u8)
            }
            #[doc = "Buffer Empty Interrupt Status"]
            #[inline(always)]
            pub fn set_bemp(&mut self, val: super::vals::Bemp) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Control Transfer Stage Transition Interrupt Status"]
            #[inline(always)]
            pub const fn ctrt(&self) -> super::vals::Ctrt {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ctrt::from_bits(val as u8)
            }
            #[doc = "Control Transfer Stage Transition Interrupt Status"]
            #[inline(always)]
            pub fn set_ctrt(&mut self, val: super::vals::Ctrt) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Device State Transition Interrupt Status"]
            #[inline(always)]
            pub const fn dvst(&self) -> super::vals::Dvst {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Dvst::from_bits(val as u8)
            }
            #[doc = "Device State Transition Interrupt Status"]
            #[inline(always)]
            pub fn set_dvst(&mut self, val: super::vals::Dvst) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Frame Number Refresh Interrupt Status"]
            #[inline(always)]
            pub const fn sofr(&self) -> super::vals::Sofr {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Sofr::from_bits(val as u8)
            }
            #[doc = "Frame Number Refresh Interrupt Status"]
            #[inline(always)]
            pub fn set_sofr(&mut self, val: super::vals::Sofr) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Resume Interrupt Status"]
            #[inline(always)]
            pub const fn resm(&self) -> super::vals::Resm {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Resm::from_bits(val as u8)
            }
            #[doc = "Resume Interrupt Status"]
            #[inline(always)]
            pub fn set_resm(&mut self, val: super::vals::Resm) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "VBUS Interrupt Status"]
            #[inline(always)]
            pub const fn vbint(&self) -> super::vals::Vbint {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Vbint::from_bits(val as u8)
            }
            #[doc = "VBUS Interrupt Status"]
            #[inline(always)]
            pub fn set_vbint(&mut self, val: super::vals::Vbint) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Intsts0 {
            #[inline(always)]
            fn default() -> Intsts0 {
                Intsts0(0)
            }
        }
        impl core::fmt::Debug for Intsts0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intsts0")
                    .field("ctsq", &self.ctsq())
                    .field("valid", &self.valid())
                    .field("dvsq", &self.dvsq())
                    .field("vbsts", &self.vbsts())
                    .field("brdy", &self.brdy())
                    .field("nrdy", &self.nrdy())
                    .field("bemp", &self.bemp())
                    .field("ctrt", &self.ctrt())
                    .field("dvst", &self.dvst())
                    .field("sofr", &self.sofr())
                    .field("resm", &self.resm())
                    .field("vbint", &self.vbint())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intsts0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intsts0 {{ ctsq: {:?}, valid: {:?}, dvsq: {:?}, vbsts: {:?}, brdy: {:?}, nrdy: {:?}, bemp: {:?}, ctrt: {:?}, dvst: {:?}, sofr: {:?}, resm: {:?}, vbint: {:?} }}" , self . ctsq () , self . valid () , self . dvsq () , self . vbsts () , self . brdy () , self . nrdy () , self . bemp () , self . ctrt () , self . dvst () , self . sofr () , self . resm () , self . vbint ())
            }
        }
        #[doc = "NRDY Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nrdyenb(pub u16);
        impl Nrdyenb {
            #[doc = "NRDY Interrupt Enable for PIPE0"]
            #[inline(always)]
            pub const fn pipe0nrdye(&self) -> super::vals::Pipe0nrdye {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pipe0nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE0"]
            #[inline(always)]
            pub fn set_pipe0nrdye(&mut self, val: super::vals::Pipe0nrdye) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "NRDY Interrupt Enable for PIPE1"]
            #[inline(always)]
            pub const fn pipe1nrdye(&self) -> super::vals::Pipe1nrdye {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pipe1nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE1"]
            #[inline(always)]
            pub fn set_pipe1nrdye(&mut self, val: super::vals::Pipe1nrdye) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "NRDY Interrupt Enable for PIPE2"]
            #[inline(always)]
            pub const fn pipe2nrdye(&self) -> super::vals::Pipe2nrdye {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pipe2nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE2"]
            #[inline(always)]
            pub fn set_pipe2nrdye(&mut self, val: super::vals::Pipe2nrdye) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "NRDY Interrupt Enable for PIPE3"]
            #[inline(always)]
            pub const fn pipe3nrdye(&self) -> super::vals::Pipe3nrdye {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pipe3nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE3"]
            #[inline(always)]
            pub fn set_pipe3nrdye(&mut self, val: super::vals::Pipe3nrdye) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "NRDY Interrupt Enable for PIPE4"]
            #[inline(always)]
            pub const fn pipe4nrdye(&self) -> super::vals::Pipe4nrdye {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pipe4nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE4"]
            #[inline(always)]
            pub fn set_pipe4nrdye(&mut self, val: super::vals::Pipe4nrdye) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "NRDY Interrupt Enable for PIPE5"]
            #[inline(always)]
            pub const fn pipe5nrdye(&self) -> super::vals::Pipe5nrdye {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pipe5nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE5"]
            #[inline(always)]
            pub fn set_pipe5nrdye(&mut self, val: super::vals::Pipe5nrdye) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "NRDY Interrupt Enable for PIPE6"]
            #[inline(always)]
            pub const fn pipe6nrdye(&self) -> super::vals::Pipe6nrdye {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pipe6nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE6"]
            #[inline(always)]
            pub fn set_pipe6nrdye(&mut self, val: super::vals::Pipe6nrdye) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "NRDY Interrupt Enable for PIPE7"]
            #[inline(always)]
            pub const fn pipe7nrdye(&self) -> super::vals::Pipe7nrdye {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pipe7nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE7"]
            #[inline(always)]
            pub fn set_pipe7nrdye(&mut self, val: super::vals::Pipe7nrdye) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "NRDY Interrupt Enable for PIPE8"]
            #[inline(always)]
            pub const fn pipe8nrdye(&self) -> super::vals::Pipe8nrdye {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pipe8nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE8"]
            #[inline(always)]
            pub fn set_pipe8nrdye(&mut self, val: super::vals::Pipe8nrdye) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "NRDY Interrupt Enable for PIPE9"]
            #[inline(always)]
            pub const fn pipe9nrdye(&self) -> super::vals::Pipe9nrdye {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pipe9nrdye::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Enable for PIPE9"]
            #[inline(always)]
            pub fn set_pipe9nrdye(&mut self, val: super::vals::Pipe9nrdye) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Nrdyenb {
            #[inline(always)]
            fn default() -> Nrdyenb {
                Nrdyenb(0)
            }
        }
        impl core::fmt::Debug for Nrdyenb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nrdyenb")
                    .field("pipe0nrdye", &self.pipe0nrdye())
                    .field("pipe1nrdye", &self.pipe1nrdye())
                    .field("pipe2nrdye", &self.pipe2nrdye())
                    .field("pipe3nrdye", &self.pipe3nrdye())
                    .field("pipe4nrdye", &self.pipe4nrdye())
                    .field("pipe5nrdye", &self.pipe5nrdye())
                    .field("pipe6nrdye", &self.pipe6nrdye())
                    .field("pipe7nrdye", &self.pipe7nrdye())
                    .field("pipe8nrdye", &self.pipe8nrdye())
                    .field("pipe9nrdye", &self.pipe9nrdye())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nrdyenb {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nrdyenb {{ pipe0nrdye: {:?}, pipe1nrdye: {:?}, pipe2nrdye: {:?}, pipe3nrdye: {:?}, pipe4nrdye: {:?}, pipe5nrdye: {:?}, pipe6nrdye: {:?}, pipe7nrdye: {:?}, pipe8nrdye: {:?}, pipe9nrdye: {:?}, reserved_10_15: {=u8:?} }}" , self . pipe0nrdye () , self . pipe1nrdye () , self . pipe2nrdye () , self . pipe3nrdye () , self . pipe4nrdye () , self . pipe5nrdye () , self . pipe6nrdye () , self . pipe7nrdye () , self . pipe8nrdye () , self . pipe9nrdye () , self . reserved_10_15 ())
            }
        }
        #[doc = "NRDY Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nrdysts(pub u16);
        impl Nrdysts {
            #[doc = "NRDY Interrupt Status for PIPE0"]
            #[inline(always)]
            pub const fn pipe0nrdy(&self) -> super::vals::Pipe0nrdy {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pipe0nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE0"]
            #[inline(always)]
            pub fn set_pipe0nrdy(&mut self, val: super::vals::Pipe0nrdy) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "NRDY Interrupt Status for PIPE1"]
            #[inline(always)]
            pub const fn pipe1nrdy(&self) -> super::vals::Pipe1nrdy {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pipe1nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE1"]
            #[inline(always)]
            pub fn set_pipe1nrdy(&mut self, val: super::vals::Pipe1nrdy) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "NRDY Interrupt Status for PIPE2"]
            #[inline(always)]
            pub const fn pipe2nrdy(&self) -> super::vals::Pipe2nrdy {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pipe2nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE2"]
            #[inline(always)]
            pub fn set_pipe2nrdy(&mut self, val: super::vals::Pipe2nrdy) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "NRDY Interrupt Status for PIPE3"]
            #[inline(always)]
            pub const fn pipe3nrdy(&self) -> super::vals::Pipe3nrdy {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pipe3nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE3"]
            #[inline(always)]
            pub fn set_pipe3nrdy(&mut self, val: super::vals::Pipe3nrdy) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "NRDY Interrupt Status for PIPE4"]
            #[inline(always)]
            pub const fn pipe4nrdy(&self) -> super::vals::Pipe4nrdy {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pipe4nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE4"]
            #[inline(always)]
            pub fn set_pipe4nrdy(&mut self, val: super::vals::Pipe4nrdy) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "NRDY Interrupt Status for PIPE5"]
            #[inline(always)]
            pub const fn pipe5nrdy(&self) -> super::vals::Pipe5nrdy {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pipe5nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE5"]
            #[inline(always)]
            pub fn set_pipe5nrdy(&mut self, val: super::vals::Pipe5nrdy) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "NRDY Interrupt Status for PIPE6"]
            #[inline(always)]
            pub const fn pipe6nrdy(&self) -> super::vals::Pipe6nrdy {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pipe6nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE6"]
            #[inline(always)]
            pub fn set_pipe6nrdy(&mut self, val: super::vals::Pipe6nrdy) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "NRDY Interrupt Status for PIPE7"]
            #[inline(always)]
            pub const fn pipe7nrdy(&self) -> super::vals::Pipe7nrdy {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pipe7nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE7"]
            #[inline(always)]
            pub fn set_pipe7nrdy(&mut self, val: super::vals::Pipe7nrdy) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "NRDY Interrupt Status for PIPE8"]
            #[inline(always)]
            pub const fn pipe8nrdy(&self) -> super::vals::Pipe8nrdy {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pipe8nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE8"]
            #[inline(always)]
            pub fn set_pipe8nrdy(&mut self, val: super::vals::Pipe8nrdy) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "NRDY Interrupt Status for PIPE9"]
            #[inline(always)]
            pub const fn pipe9nrdy(&self) -> super::vals::Pipe9nrdy {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pipe9nrdy::from_bits(val as u8)
            }
            #[doc = "NRDY Interrupt Status for PIPE9"]
            #[inline(always)]
            pub fn set_pipe9nrdy(&mut self, val: super::vals::Pipe9nrdy) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Nrdysts {
            #[inline(always)]
            fn default() -> Nrdysts {
                Nrdysts(0)
            }
        }
        impl core::fmt::Debug for Nrdysts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nrdysts")
                    .field("pipe0nrdy", &self.pipe0nrdy())
                    .field("pipe1nrdy", &self.pipe1nrdy())
                    .field("pipe2nrdy", &self.pipe2nrdy())
                    .field("pipe3nrdy", &self.pipe3nrdy())
                    .field("pipe4nrdy", &self.pipe4nrdy())
                    .field("pipe5nrdy", &self.pipe5nrdy())
                    .field("pipe6nrdy", &self.pipe6nrdy())
                    .field("pipe7nrdy", &self.pipe7nrdy())
                    .field("pipe8nrdy", &self.pipe8nrdy())
                    .field("pipe9nrdy", &self.pipe9nrdy())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nrdysts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nrdysts {{ pipe0nrdy: {:?}, pipe1nrdy: {:?}, pipe2nrdy: {:?}, pipe3nrdy: {:?}, pipe4nrdy: {:?}, pipe5nrdy: {:?}, pipe6nrdy: {:?}, pipe7nrdy: {:?}, pipe8nrdy: {:?}, pipe9nrdy: {:?}, reserved_10_15: {=u8:?} }}" , self . pipe0nrdy () , self . pipe1nrdy () , self . pipe2nrdy () , self . pipe3nrdy () , self . pipe4nrdy () , self . pipe5nrdy () , self . pipe6nrdy () , self . pipe7nrdy () , self . pipe8nrdy () , self . pipe9nrdy () , self . reserved_10_15 ())
            }
        }
        #[doc = "Pipe Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pipecfg(pub u16);
        impl Pipecfg {
            #[doc = "Endpoint NumberThese bits specify the endpoint number for the selected pipe.Setting 0000b means unused pipe."]
            #[inline(always)]
            pub const fn epnum(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Endpoint NumberThese bits specify the endpoint number for the selected pipe.Setting 0000b means unused pipe."]
            #[inline(always)]
            pub fn set_epnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "Transfer Direction"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::PipecfgDir {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PipecfgDir::from_bits(val as u8)
            }
            #[doc = "Transfer Direction"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::PipecfgDir) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u16) & 0x01) << 5usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u16) & 0x01) << 6usize);
            }
            #[doc = "Pipe Disabled at End of Transfer"]
            #[inline(always)]
            pub const fn shtnak(&self) -> super::vals::PipecfgShtnak {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PipecfgShtnak::from_bits(val as u8)
            }
            #[doc = "Pipe Disabled at End of Transfer"]
            #[inline(always)]
            pub fn set_shtnak(&mut self, val: super::vals::PipecfgShtnak) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_8_8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_8_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u16) & 0x01) << 8usize);
            }
            #[doc = "Double Buffer Mode"]
            #[inline(always)]
            pub const fn dblb(&self) -> super::vals::Dblb {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Dblb::from_bits(val as u8)
            }
            #[doc = "Double Buffer Mode"]
            #[inline(always)]
            pub fn set_dblb(&mut self, val: super::vals::Dblb) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "BRDY Interrupt Operation Specification"]
            #[inline(always)]
            pub const fn bfre(&self) -> super::vals::Bfre {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bfre::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Operation Specification"]
            #[inline(always)]
            pub fn set_bfre(&mut self, val: super::vals::Bfre) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_11_13(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_11_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 11usize)) | (((val as u16) & 0x07) << 11usize);
            }
            #[doc = "Transfer Type"]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::Type {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Type::from_bits(val as u8)
            }
            #[doc = "Transfer Type"]
            #[inline(always)]
            pub fn set_type_(&mut self, val: super::vals::Type) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Pipecfg {
            #[inline(always)]
            fn default() -> Pipecfg {
                Pipecfg(0)
            }
        }
        impl core::fmt::Debug for Pipecfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pipecfg")
                    .field("epnum", &self.epnum())
                    .field("dir", &self.dir())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("shtnak", &self.shtnak())
                    .field("reserved_8_8", &self.reserved_8_8())
                    .field("dblb", &self.dblb())
                    .field("bfre", &self.bfre())
                    .field("reserved_11_13", &self.reserved_11_13())
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pipecfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pipecfg {{ epnum: {=u8:?}, dir: {:?}, reserved_5_5: {=bool:?}, reserved_6_6: {=bool:?}, shtnak: {:?}, reserved_8_8: {=bool:?}, dblb: {:?}, bfre: {:?}, reserved_11_13: {=u8:?}, type_: {:?} }}" , self . epnum () , self . dir () , self . reserved_5_5 () , self . reserved_6_6 () , self . shtnak () , self . reserved_8_8 () , self . dblb () , self . bfre () , self . reserved_11_13 () , self . type_ ())
            }
        }
        #[doc = "Pipe %s Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pipectr(pub u16);
        impl Pipectr {
            #[doc = "Response PID"]
            #[inline(always)]
            pub const fn pid(&self) -> super::vals::PipectrPid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::PipectrPid::from_bits(val as u8)
            }
            #[doc = "Response PID"]
            #[inline(always)]
            pub fn set_pid(&mut self, val: super::vals::PipectrPid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_2_4(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_2_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val as u16) & 0x07) << 2usize);
            }
            #[doc = "Pipe Busy"]
            #[inline(always)]
            pub const fn pbusy(&self) -> super::vals::PipectrPbusy {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PipectrPbusy::from_bits(val as u8)
            }
            #[doc = "Pipe Busy"]
            #[inline(always)]
            pub fn set_pbusy(&mut self, val: super::vals::PipectrPbusy) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Sequence Toggle Bit Confirmation"]
            #[inline(always)]
            pub const fn sqmon(&self) -> super::vals::PipectrSqmon {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PipectrSqmon::from_bits(val as u8)
            }
            #[doc = "Sequence Toggle Bit Confirmation"]
            #[inline(always)]
            pub fn set_sqmon(&mut self, val: super::vals::PipectrSqmon) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Sequence Toggle Bit Set"]
            #[inline(always)]
            pub const fn sqset(&self) -> super::vals::PipectrSqset {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PipectrSqset::from_bits(val as u8)
            }
            #[doc = "Sequence Toggle Bit Set"]
            #[inline(always)]
            pub fn set_sqset(&mut self, val: super::vals::PipectrSqset) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Sequence Toggle Bit Clear"]
            #[inline(always)]
            pub const fn sqclr(&self) -> super::vals::PipectrSqclr {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PipectrSqclr::from_bits(val as u8)
            }
            #[doc = "Sequence Toggle Bit Clear"]
            #[inline(always)]
            pub fn set_sqclr(&mut self, val: super::vals::PipectrSqclr) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Auto Buffer Clear Mode"]
            #[inline(always)]
            pub const fn aclrm(&self) -> super::vals::PipectrAclrm {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PipectrAclrm::from_bits(val as u8)
            }
            #[doc = "Auto Buffer Clear Mode"]
            #[inline(always)]
            pub fn set_aclrm(&mut self, val: super::vals::PipectrAclrm) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Auto Response Mode"]
            #[inline(always)]
            pub const fn atrepm(&self) -> super::vals::Atrepm {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Atrepm::from_bits(val as u8)
            }
            #[doc = "Auto Response Mode"]
            #[inline(always)]
            pub fn set_atrepm(&mut self, val: super::vals::Atrepm) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_11_13(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_11_13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 11usize)) | (((val as u16) & 0x07) << 11usize);
            }
            #[doc = "Transmit Buffer Monitor"]
            #[inline(always)]
            pub const fn inbufm(&self) -> super::vals::Inbufm {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Inbufm::from_bits(val as u8)
            }
            #[doc = "Transmit Buffer Monitor"]
            #[inline(always)]
            pub fn set_inbufm(&mut self, val: super::vals::Inbufm) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Buffer Status"]
            #[inline(always)]
            pub const fn bsts(&self) -> super::vals::PipectrBsts {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PipectrBsts::from_bits(val as u8)
            }
            #[doc = "Buffer Status"]
            #[inline(always)]
            pub fn set_bsts(&mut self, val: super::vals::PipectrBsts) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pipectr {
            #[inline(always)]
            fn default() -> Pipectr {
                Pipectr(0)
            }
        }
        impl core::fmt::Debug for Pipectr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pipectr")
                    .field("pid", &self.pid())
                    .field("reserved_2_4", &self.reserved_2_4())
                    .field("pbusy", &self.pbusy())
                    .field("sqmon", &self.sqmon())
                    .field("sqset", &self.sqset())
                    .field("sqclr", &self.sqclr())
                    .field("aclrm", &self.aclrm())
                    .field("atrepm", &self.atrepm())
                    .field("reserved_11_13", &self.reserved_11_13())
                    .field("inbufm", &self.inbufm())
                    .field("bsts", &self.bsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pipectr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pipectr {{ pid: {:?}, reserved_2_4: {=u8:?}, pbusy: {:?}, sqmon: {:?}, sqset: {:?}, sqclr: {:?}, aclrm: {:?}, atrepm: {:?}, reserved_11_13: {=u8:?}, inbufm: {:?}, bsts: {:?} }}" , self . pid () , self . reserved_2_4 () , self . pbusy () , self . sqmon () , self . sqset () , self . sqclr () , self . aclrm () , self . atrepm () , self . reserved_11_13 () , self . inbufm () , self . bsts ())
            }
        }
        #[doc = "Pipe %s Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pipectr1(pub u16);
        impl Pipectr1 {
            #[doc = "Response PID"]
            #[inline(always)]
            pub const fn pid(&self) -> super::vals::Pipectr1Pid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Pipectr1Pid::from_bits(val as u8)
            }
            #[doc = "Response PID"]
            #[inline(always)]
            pub fn set_pid(&mut self, val: super::vals::Pipectr1Pid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_2_4(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_2_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val as u16) & 0x07) << 2usize);
            }
            #[doc = "Pipe Busy"]
            #[inline(always)]
            pub const fn pbusy(&self) -> super::vals::Pipectr1Pbusy {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pipectr1Pbusy::from_bits(val as u8)
            }
            #[doc = "Pipe Busy"]
            #[inline(always)]
            pub fn set_pbusy(&mut self, val: super::vals::Pipectr1Pbusy) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Sequence Toggle Bit Confirmation"]
            #[inline(always)]
            pub const fn sqmon(&self) -> super::vals::Pipectr1Sqmon {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pipectr1Sqmon::from_bits(val as u8)
            }
            #[doc = "Sequence Toggle Bit Confirmation"]
            #[inline(always)]
            pub fn set_sqmon(&mut self, val: super::vals::Pipectr1Sqmon) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Sequence Toggle Bit Set"]
            #[inline(always)]
            pub const fn sqset(&self) -> super::vals::Pipectr1Sqset {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pipectr1Sqset::from_bits(val as u8)
            }
            #[doc = "Sequence Toggle Bit Set"]
            #[inline(always)]
            pub fn set_sqset(&mut self, val: super::vals::Pipectr1Sqset) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Sequence Toggle Bit Clear"]
            #[inline(always)]
            pub const fn sqclr(&self) -> super::vals::Pipectr1Sqclr {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pipectr1Sqclr::from_bits(val as u8)
            }
            #[doc = "Sequence Toggle Bit Clear"]
            #[inline(always)]
            pub fn set_sqclr(&mut self, val: super::vals::Pipectr1Sqclr) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Auto Buffer Clear Mode"]
            #[inline(always)]
            pub const fn aclrm(&self) -> super::vals::Pipectr1Aclrm {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pipectr1Aclrm::from_bits(val as u8)
            }
            #[doc = "Auto Buffer Clear Mode"]
            #[inline(always)]
            pub fn set_aclrm(&mut self, val: super::vals::Pipectr1Aclrm) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_10_14(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_10_14(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 10usize)) | (((val as u16) & 0x1f) << 10usize);
            }
            #[doc = "Buffer Status"]
            #[inline(always)]
            pub const fn bsts(&self) -> super::vals::Pipectr1Bsts {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pipectr1Bsts::from_bits(val as u8)
            }
            #[doc = "Buffer Status"]
            #[inline(always)]
            pub fn set_bsts(&mut self, val: super::vals::Pipectr1Bsts) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pipectr1 {
            #[inline(always)]
            fn default() -> Pipectr1 {
                Pipectr1(0)
            }
        }
        impl core::fmt::Debug for Pipectr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pipectr1")
                    .field("pid", &self.pid())
                    .field("reserved_2_4", &self.reserved_2_4())
                    .field("pbusy", &self.pbusy())
                    .field("sqmon", &self.sqmon())
                    .field("sqset", &self.sqset())
                    .field("sqclr", &self.sqclr())
                    .field("aclrm", &self.aclrm())
                    .field("reserved_10_14", &self.reserved_10_14())
                    .field("bsts", &self.bsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pipectr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pipectr1 {{ pid: {:?}, reserved_2_4: {=u8:?}, pbusy: {:?}, sqmon: {:?}, sqset: {:?}, sqclr: {:?}, aclrm: {:?}, reserved_10_14: {=u8:?}, bsts: {:?} }}" , self . pid () , self . reserved_2_4 () , self . pbusy () , self . sqmon () , self . sqset () , self . sqclr () , self . aclrm () , self . reserved_10_14 () , self . bsts ())
            }
        }
        #[doc = "Pipe Maximum Packet Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pipemaxp(pub u16);
        impl Pipemaxp {
            #[doc = "Maximum Packet SizePIPE1 and PIPE2: 1 byte (001h) to 256 bytes (100h)PIPE3 to PIPE5: 8 bytes (008h), 16 bytes (010h), 32 bytes (020h), 64 bytes (040h) (Bits \\[8:7\\] and \\[2:0\\] are not provided.)PIPE6 to PIPE9: 1 byte (001h) to 64 bytes (040h) (Bits \\[8:7\\] are not provided.)"]
            #[inline(always)]
            pub const fn mxps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Maximum Packet SizePIPE1 and PIPE2: 1 byte (001h) to 256 bytes (100h)PIPE3 to PIPE5: 8 bytes (008h), 16 bytes (010h), 32 bytes (020h), 64 bytes (040h) (Bits \\[8:7\\] and \\[2:0\\] are not provided.)PIPE6 to PIPE9: 1 byte (001h) to 64 bytes (040h) (Bits \\[8:7\\] are not provided.)"]
            #[inline(always)]
            pub fn set_mxps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_9_11(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_9_11(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 9usize)) | (((val as u16) & 0x07) << 9usize);
            }
            #[doc = "Device Select"]
            #[inline(always)]
            pub const fn devsel(&self) -> super::vals::PipemaxpDevsel {
                let val = (self.0 >> 12usize) & 0x0f;
                super::vals::PipemaxpDevsel::from_bits(val as u8)
            }
            #[doc = "Device Select"]
            #[inline(always)]
            pub fn set_devsel(&mut self, val: super::vals::PipemaxpDevsel) {
                self.0 =
                    (self.0 & !(0x0f << 12usize)) | (((val.to_bits() as u16) & 0x0f) << 12usize);
            }
        }
        impl Default for Pipemaxp {
            #[inline(always)]
            fn default() -> Pipemaxp {
                Pipemaxp(0)
            }
        }
        impl core::fmt::Debug for Pipemaxp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pipemaxp")
                    .field("mxps", &self.mxps())
                    .field("reserved_9_11", &self.reserved_9_11())
                    .field("devsel", &self.devsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pipemaxp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pipemaxp {{ mxps: {=u16:?}, reserved_9_11: {=u8:?}, devsel: {:?} }}",
                    self.mxps(),
                    self.reserved_9_11(),
                    self.devsel()
                )
            }
        }
        #[doc = "Pipe Window Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pipesel(pub u16);
        impl Pipesel {
            #[doc = "Pipe Window Select"]
            #[inline(always)]
            pub const fn pipesel(&self) -> super::vals::Pipesel {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Pipesel::from_bits(val as u8)
            }
            #[doc = "Pipe Window Select"]
            #[inline(always)]
            pub fn set_pipesel(&mut self, val: super::vals::Pipesel) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u16) & 0x0f) << 0usize);
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub const fn reserved_4_15(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000. The write value should be 000000000000."]
            #[inline(always)]
            pub fn set_reserved_4_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u16) & 0x0fff) << 4usize);
            }
        }
        impl Default for Pipesel {
            #[inline(always)]
            fn default() -> Pipesel {
                Pipesel(0)
            }
        }
        impl core::fmt::Debug for Pipesel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pipesel")
                    .field("pipesel", &self.pipesel())
                    .field("reserved_4_15", &self.reserved_4_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pipesel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pipesel {{ pipesel: {:?}, reserved_4_15: {=u16:?} }}",
                    self.pipesel(),
                    self.reserved_4_15()
                )
            }
        }
        #[doc = "Pipe %s Transaction Counter Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pipetre(pub u16);
        impl Pipetre {
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_0_7(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_0_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "Transaction Counter Clear"]
            #[inline(always)]
            pub const fn trclr(&self) -> super::vals::Trclr {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Trclr::from_bits(val as u8)
            }
            #[doc = "Transaction Counter Clear"]
            #[inline(always)]
            pub fn set_trclr(&mut self, val: super::vals::Trclr) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Transaction Counter Enable"]
            #[inline(always)]
            pub const fn trenb(&self) -> super::vals::Trenb {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Trenb::from_bits(val as u8)
            }
            #[doc = "Transaction Counter Enable"]
            #[inline(always)]
            pub fn set_trenb(&mut self, val: super::vals::Trenb) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Pipetre {
            #[inline(always)]
            fn default() -> Pipetre {
                Pipetre(0)
            }
        }
        impl core::fmt::Debug for Pipetre {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pipetre")
                    .field("reserved_0_7", &self.reserved_0_7())
                    .field("trclr", &self.trclr())
                    .field("trenb", &self.trenb())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pipetre {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pipetre {{ reserved_0_7: {=u8:?}, trclr: {:?}, trenb: {:?}, reserved_10_15: {=u8:?} }}" , self . reserved_0_7 () , self . trclr () , self . trenb () , self . reserved_10_15 ())
            }
        }
        #[doc = "Pipe %s Transaction Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pipetrn(pub u16);
        impl Pipetrn {
            #[doc = "Transaction Counter"]
            #[inline(always)]
            pub const fn trncnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Transaction Counter"]
            #[inline(always)]
            pub fn set_trncnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Pipetrn {
            #[inline(always)]
            fn default() -> Pipetrn {
                Pipetrn(0)
            }
        }
        impl core::fmt::Debug for Pipetrn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pipetrn")
                    .field("trncnt", &self.trncnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pipetrn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pipetrn {{ trncnt: {=u16:?} }}", self.trncnt())
            }
        }
        #[doc = "SOF Output Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sofcfg(pub u16);
        impl Sofcfg {
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub const fn reserved_0_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits are read as 0000. The write value should be 0000."]
            #[inline(always)]
            pub fn set_reserved_0_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "Edge Interrupt Output Status Monitor"]
            #[inline(always)]
            pub const fn edgests(&self) -> super::vals::Edgests {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Edgests::from_bits(val as u8)
            }
            #[doc = "Edge Interrupt Output Status Monitor"]
            #[inline(always)]
            pub fn set_edgests(&mut self, val: super::vals::Edgests) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_5_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_5_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u16) & 0x01) << 5usize);
            }
            #[doc = "BRDY Interrupt Status Clear Timing"]
            #[inline(always)]
            pub const fn brdym(&self) -> super::vals::Brdym {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Brdym::from_bits(val as u8)
            }
            #[doc = "BRDY Interrupt Status Clear Timing"]
            #[inline(always)]
            pub fn set_brdym(&mut self, val: super::vals::Brdym) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_7_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_7_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u16) & 0x01) << 7usize);
            }
            #[doc = "Transaction,Enabled Time Select"]
            #[inline(always)]
            pub const fn trnensel(&self) -> super::vals::Trnensel {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Trnensel::from_bits(val as u8)
            }
            #[doc = "Transaction,Enabled Time Select"]
            #[inline(always)]
            pub fn set_trnensel(&mut self, val: super::vals::Trnensel) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_9_15(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_9_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u16) & 0x7f) << 9usize);
            }
        }
        impl Default for Sofcfg {
            #[inline(always)]
            fn default() -> Sofcfg {
                Sofcfg(0)
            }
        }
        impl core::fmt::Debug for Sofcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sofcfg")
                    .field("reserved_0_3", &self.reserved_0_3())
                    .field("edgests", &self.edgests())
                    .field("reserved_5_5", &self.reserved_5_5())
                    .field("brdym", &self.brdym())
                    .field("reserved_7_7", &self.reserved_7_7())
                    .field("trnensel", &self.trnensel())
                    .field("reserved_9_15", &self.reserved_9_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sofcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sofcfg {{ reserved_0_3: {=u8:?}, edgests: {:?}, reserved_5_5: {=bool:?}, brdym: {:?}, reserved_7_7: {=bool:?}, trnensel: {:?}, reserved_9_15: {=u8:?} }}" , self . reserved_0_3 () , self . edgests () , self . reserved_5_5 () , self . brdym () , self . reserved_7_7 () , self . trnensel () , self . reserved_9_15 ())
            }
        }
        #[doc = "System Configuration Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syscfg(pub u16);
        impl Syscfg {
            #[doc = "USB Operation Enable"]
            #[inline(always)]
            pub const fn usbe(&self) -> super::vals::Usbe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Usbe::from_bits(val as u8)
            }
            #[doc = "USB Operation Enable"]
            #[inline(always)]
            pub fn set_usbe(&mut self, val: super::vals::Usbe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_1_2(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_1_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u16) & 0x03) << 1usize);
            }
            #[doc = "D- Line Resistor Control"]
            #[inline(always)]
            pub const fn dmrpu(&self) -> super::vals::Dmrpu {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dmrpu::from_bits(val as u8)
            }
            #[doc = "D- Line Resistor Control"]
            #[inline(always)]
            pub fn set_dmrpu(&mut self, val: super::vals::Dmrpu) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "D+ Line Resistor Control"]
            #[inline(always)]
            pub const fn dprpu(&self) -> super::vals::Dprpu {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dprpu::from_bits(val as u8)
            }
            #[doc = "D+ Line Resistor Control"]
            #[inline(always)]
            pub fn set_dprpu(&mut self, val: super::vals::Dprpu) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub const fn reserved_5_7(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "These bits are read as 000. The write value should be 000."]
            #[inline(always)]
            pub fn set_reserved_5_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u16) & 0x07) << 5usize);
            }
            #[doc = "CNEN Single End Receiver Enable"]
            #[inline(always)]
            pub const fn cnen(&self) -> super::vals::Cnen {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cnen::from_bits(val as u8)
            }
            #[doc = "CNEN Single End Receiver Enable"]
            #[inline(always)]
            pub fn set_cnen(&mut self, val: super::vals::Cnen) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_9_9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_9_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u16) & 0x01) << 9usize);
            }
            #[doc = "USB Clock Enable"]
            #[inline(always)]
            pub const fn scke(&self) -> super::vals::Scke {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Scke::from_bits(val as u8)
            }
            #[doc = "USB Clock Enable"]
            #[inline(always)]
            pub fn set_scke(&mut self, val: super::vals::Scke) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_11_15(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_11_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 11usize)) | (((val as u16) & 0x1f) << 11usize);
            }
        }
        impl Default for Syscfg {
            #[inline(always)]
            fn default() -> Syscfg {
                Syscfg(0)
            }
        }
        impl core::fmt::Debug for Syscfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syscfg")
                    .field("usbe", &self.usbe())
                    .field("reserved_1_2", &self.reserved_1_2())
                    .field("dmrpu", &self.dmrpu())
                    .field("dprpu", &self.dprpu())
                    .field("reserved_5_7", &self.reserved_5_7())
                    .field("cnen", &self.cnen())
                    .field("reserved_9_9", &self.reserved_9_9())
                    .field("scke", &self.scke())
                    .field("reserved_11_15", &self.reserved_11_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syscfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Syscfg {{ usbe: {:?}, reserved_1_2: {=u8:?}, dmrpu: {:?}, dprpu: {:?}, reserved_5_7: {=u8:?}, cnen: {:?}, reserved_9_9: {=bool:?}, scke: {:?}, reserved_11_15: {=u8:?} }}" , self . usbe () , self . reserved_1_2 () , self . dmrpu () , self . dprpu () , self . reserved_5_7 () , self . cnen () , self . reserved_9_9 () , self . scke () , self . reserved_11_15 ())
            }
        }
        #[doc = "System Configuration Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syssts0(pub u16);
        impl Syssts0 {
            #[doc = "USB Data Line Status Monitor"]
            #[inline(always)]
            pub const fn lnst(&self) -> super::vals::Lnst {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lnst::from_bits(val as u8)
            }
            #[doc = "USB Data Line Status Monitor"]
            #[inline(always)]
            pub fn set_lnst(&mut self, val: super::vals::Lnst) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 00000000000000."]
            #[inline(always)]
            pub const fn reserved_2_15(&self) -> u16 {
                let val = (self.0 >> 2usize) & 0x3fff;
                val as u16
            }
            #[doc = "These bits are read as 00000000000000."]
            #[inline(always)]
            pub fn set_reserved_2_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 2usize)) | (((val as u16) & 0x3fff) << 2usize);
            }
        }
        impl Default for Syssts0 {
            #[inline(always)]
            fn default() -> Syssts0 {
                Syssts0(0)
            }
        }
        impl core::fmt::Debug for Syssts0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syssts0")
                    .field("lnst", &self.lnst())
                    .field("reserved_2_15", &self.reserved_2_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syssts0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Syssts0 {{ lnst: {:?}, reserved_2_15: {=u16:?} }}",
                    self.lnst(),
                    self.reserved_2_15()
                )
            }
        }
        #[doc = "USB Clock Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ucksel(pub u16);
        impl Ucksel {
            #[doc = "USB Clock Selection"]
            #[inline(always)]
            pub const fn uckselc(&self) -> super::vals::Uckselc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Uckselc::from_bits(val as u8)
            }
            #[doc = "USB Clock Selection"]
            #[inline(always)]
            pub fn set_uckselc(&mut self, val: super::vals::Uckselc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub const fn reserved_1_15(&self) -> u16 {
                let val = (self.0 >> 1usize) & 0x7fff;
                val as u16
            }
            #[doc = "These bits are read as 000000000000000. The write value should be 000000000000000."]
            #[inline(always)]
            pub fn set_reserved_1_15(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 1usize)) | (((val as u16) & 0x7fff) << 1usize);
            }
        }
        impl Default for Ucksel {
            #[inline(always)]
            fn default() -> Ucksel {
                Ucksel(0)
            }
        }
        impl core::fmt::Debug for Ucksel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ucksel")
                    .field("uckselc", &self.uckselc())
                    .field("reserved_1_15", &self.reserved_1_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ucksel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ucksel {{ uckselc: {:?}, reserved_1_15: {=u16:?} }}",
                    self.uckselc(),
                    self.reserved_1_15()
                )
            }
        }
        #[doc = "BC Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Usbbcctrl0(pub u16);
        impl Usbbcctrl0 {
            #[doc = "D- Pin Pull,Down Control"]
            #[inline(always)]
            pub const fn rpdme0(&self) -> super::vals::Rpdme0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rpdme0::from_bits(val as u8)
            }
            #[doc = "D- Pin Pull,Down Control"]
            #[inline(always)]
            pub fn set_rpdme0(&mut self, val: super::vals::Rpdme0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "D+ Pin IDPSRC Output Control"]
            #[inline(always)]
            pub const fn idpsrce0(&self) -> super::vals::Idpsrce0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Idpsrce0::from_bits(val as u8)
            }
            #[doc = "D+ Pin IDPSRC Output Control"]
            #[inline(always)]
            pub fn set_idpsrce0(&mut self, val: super::vals::Idpsrce0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "D- Pin 0.6 V Input Detection (Comparator and Sink) Control"]
            #[inline(always)]
            pub const fn idmsinke0(&self) -> super::vals::Idmsinke0 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Idmsinke0::from_bits(val as u8)
            }
            #[doc = "D- Pin 0.6 V Input Detection (Comparator and Sink) Control"]
            #[inline(always)]
            pub fn set_idmsinke0(&mut self, val: super::vals::Idmsinke0) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "D+ Pin VDPSRC (0.6 V) Output Control"]
            #[inline(always)]
            pub const fn vdpsrce0(&self) -> super::vals::Vdpsrce0 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Vdpsrce0::from_bits(val as u8)
            }
            #[doc = "D+ Pin VDPSRC (0.6 V) Output Control"]
            #[inline(always)]
            pub fn set_vdpsrce0(&mut self, val: super::vals::Vdpsrce0) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "D+ Pin 0.6 V Input Detection (Comparator and Sink) Control"]
            #[inline(always)]
            pub const fn idpsinke0(&self) -> super::vals::Idpsinke0 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Idpsinke0::from_bits(val as u8)
            }
            #[doc = "D+ Pin 0.6 V Input Detection (Comparator and Sink) Control"]
            #[inline(always)]
            pub fn set_idpsinke0(&mut self, val: super::vals::Idpsinke0) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "D- Pin VDMSRC (0.6 V) Output Control"]
            #[inline(always)]
            pub const fn vdmsrce0(&self) -> super::vals::Vdmsrce0 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Vdmsrce0::from_bits(val as u8)
            }
            #[doc = "D- Pin VDMSRC (0.6 V) Output Control"]
            #[inline(always)]
            pub fn set_vdmsrce0(&mut self, val: super::vals::Vdmsrce0) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub const fn reserved_6_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 0. The write value should be 0."]
            #[inline(always)]
            pub fn set_reserved_6_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u16) & 0x01) << 6usize);
            }
            #[doc = "BC (Battery Charger) Function General Enable Control"]
            #[inline(always)]
            pub const fn batchge0(&self) -> super::vals::Batchge0 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Batchge0::from_bits(val as u8)
            }
            #[doc = "BC (Battery Charger) Function General Enable Control"]
            #[inline(always)]
            pub fn set_batchge0(&mut self, val: super::vals::Batchge0) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "D- Pin 0.6 V Input Detection Status"]
            #[inline(always)]
            pub const fn chgdetsts0(&self) -> super::vals::Chgdetsts0 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Chgdetsts0::from_bits(val as u8)
            }
            #[doc = "D- Pin 0.6 V Input Detection Status"]
            #[inline(always)]
            pub fn set_chgdetsts0(&mut self, val: super::vals::Chgdetsts0) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "D+ Pin 0.6 V Input Detection Status"]
            #[inline(always)]
            pub const fn pddetsts0(&self) -> super::vals::Pddetsts0 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pddetsts0::from_bits(val as u8)
            }
            #[doc = "D+ Pin 0.6 V Input Detection Status"]
            #[inline(always)]
            pub fn set_pddetsts0(&mut self, val: super::vals::Pddetsts0) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub const fn reserved_10_15(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x3f;
                val as u8
            }
            #[doc = "These bits are read as 000000. The write value should be 000000."]
            #[inline(always)]
            pub fn set_reserved_10_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u16) & 0x3f) << 10usize);
            }
        }
        impl Default for Usbbcctrl0 {
            #[inline(always)]
            fn default() -> Usbbcctrl0 {
                Usbbcctrl0(0)
            }
        }
        impl core::fmt::Debug for Usbbcctrl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Usbbcctrl0")
                    .field("rpdme0", &self.rpdme0())
                    .field("idpsrce0", &self.idpsrce0())
                    .field("idmsinke0", &self.idmsinke0())
                    .field("vdpsrce0", &self.vdpsrce0())
                    .field("idpsinke0", &self.idpsinke0())
                    .field("vdmsrce0", &self.vdmsrce0())
                    .field("reserved_6_6", &self.reserved_6_6())
                    .field("batchge0", &self.batchge0())
                    .field("chgdetsts0", &self.chgdetsts0())
                    .field("pddetsts0", &self.pddetsts0())
                    .field("reserved_10_15", &self.reserved_10_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Usbbcctrl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Usbbcctrl0 {{ rpdme0: {:?}, idpsrce0: {:?}, idmsinke0: {:?}, vdpsrce0: {:?}, idpsinke0: {:?}, vdmsrce0: {:?}, reserved_6_6: {=bool:?}, batchge0: {:?}, chgdetsts0: {:?}, pddetsts0: {:?}, reserved_10_15: {=u8:?} }}" , self . rpdme0 () , self . idpsrce0 () , self . idmsinke0 () , self . vdpsrce0 () , self . idpsinke0 () , self . vdmsrce0 () , self . reserved_6_6 () , self . batchge0 () , self . chgdetsts0 () , self . pddetsts0 () , self . reserved_10_15 ())
            }
        }
        #[doc = "USB Request Index Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Usbindx(pub u16);
        impl Usbindx {
            #[doc = "IndexThese bits store the USB request wIndex value."]
            #[inline(always)]
            pub const fn windex(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IndexThese bits store the USB request wIndex value."]
            #[inline(always)]
            pub fn set_windex(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Usbindx {
            #[inline(always)]
            fn default() -> Usbindx {
                Usbindx(0)
            }
        }
        impl core::fmt::Debug for Usbindx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Usbindx")
                    .field("windex", &self.windex())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Usbindx {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Usbindx {{ windex: {=u16:?} }}", self.windex())
            }
        }
        #[doc = "USB Request Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Usbleng(pub u16);
        impl Usbleng {
            #[doc = "LengthThese bits store the USB request wLength value."]
            #[inline(always)]
            pub const fn wlengtuh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "LengthThese bits store the USB request wLength value."]
            #[inline(always)]
            pub fn set_wlengtuh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Usbleng {
            #[inline(always)]
            fn default() -> Usbleng {
                Usbleng(0)
            }
        }
        impl core::fmt::Debug for Usbleng {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Usbleng")
                    .field("wlengtuh", &self.wlengtuh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Usbleng {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Usbleng {{ wlengtuh: {=u16:?} }}", self.wlengtuh())
            }
        }
        #[doc = "USB Module Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Usbmc(pub u16);
        impl Usbmc {
            #[doc = "USB Reference Power Supply Circuit On/Off Control"]
            #[inline(always)]
            pub const fn vddusbe(&self) -> super::vals::Vddusbe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Vddusbe::from_bits(val as u8)
            }
            #[doc = "USB Reference Power Supply Circuit On/Off Control"]
            #[inline(always)]
            pub fn set_vddusbe(&mut self, val: super::vals::Vddusbe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub const fn reserved_1_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is read as 1. The write value should be 1."]
            #[inline(always)]
            pub fn set_reserved_1_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u16) & 0x01) << 1usize);
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub const fn reserved_2_6(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits are read as 00000. The write value should be 00000."]
            #[inline(always)]
            pub fn set_reserved_2_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 2usize)) | (((val as u16) & 0x1f) << 2usize);
            }
            #[doc = "USB Regulator On/Off Control"]
            #[inline(always)]
            pub const fn vdcen(&self) -> super::vals::Vdcen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Vdcen::from_bits(val as u8)
            }
            #[doc = "USB Regulator On/Off Control"]
            #[inline(always)]
            pub fn set_vdcen(&mut self, val: super::vals::Vdcen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub const fn reserved_8_15(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits are read as 00000000. The write value should be 00000000."]
            #[inline(always)]
            pub fn set_reserved_8_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Usbmc {
            #[inline(always)]
            fn default() -> Usbmc {
                Usbmc(0)
            }
        }
        impl core::fmt::Debug for Usbmc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Usbmc")
                    .field("vddusbe", &self.vddusbe())
                    .field("reserved_1_1", &self.reserved_1_1())
                    .field("reserved_2_6", &self.reserved_2_6())
                    .field("vdcen", &self.vdcen())
                    .field("reserved_8_15", &self.reserved_8_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Usbmc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Usbmc {{ vddusbe: {:?}, reserved_1_1: {=bool:?}, reserved_2_6: {=u8:?}, vdcen: {:?}, reserved_8_15: {=u8:?} }}" , self . vddusbe () , self . reserved_1_1 () , self . reserved_2_6 () , self . vdcen () , self . reserved_8_15 ())
            }
        }
        #[doc = "USB Request Type Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Usbreq(pub u16);
        impl Usbreq {
            #[doc = "Request TypeThese bits store the USB request bmRequestType value."]
            #[inline(always)]
            pub const fn bmrequesttype(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Request TypeThese bits store the USB request bmRequestType value."]
            #[inline(always)]
            pub fn set_bmrequesttype(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "RequestThese bits store the USB request bRequest value."]
            #[inline(always)]
            pub const fn brequest(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "RequestThese bits store the USB request bRequest value."]
            #[inline(always)]
            pub fn set_brequest(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Usbreq {
            #[inline(always)]
            fn default() -> Usbreq {
                Usbreq(0)
            }
        }
        impl core::fmt::Debug for Usbreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Usbreq")
                    .field("bmrequesttype", &self.bmrequesttype())
                    .field("brequest", &self.brequest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Usbreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Usbreq {{ bmrequesttype: {=u8:?}, brequest: {=u8:?} }}",
                    self.bmrequesttype(),
                    self.brequest()
                )
            }
        }
        #[doc = "USB Request Value Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Usbval(pub u16);
        impl Usbval {
            #[doc = "ValueThese bits store the USB request wValue value."]
            #[inline(always)]
            pub const fn wvalue(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "ValueThese bits store the USB request wValue value."]
            #[inline(always)]
            pub fn set_wvalue(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Usbval {
            #[inline(always)]
            fn default() -> Usbval {
                Usbval(0)
            }
        }
        impl core::fmt::Debug for Usbval {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Usbval")
                    .field("wvalue", &self.wvalue())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Usbval {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Usbval {{ wvalue: {=u16:?} }}", self.wvalue())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atrepm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Atrepm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atrepm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atrepm {
            #[inline(always)]
            fn from(val: u8) -> Atrepm {
                Atrepm::from_bits(val)
            }
        }
        impl From<Atrepm> for u8 {
            #[inline(always)]
            fn from(val: Atrepm) -> u8 {
                Atrepm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Batchge0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Batchge0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Batchge0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Batchge0 {
            #[inline(always)]
            fn from(val: u8) -> Batchge0 {
                Batchge0::from_bits(val)
            }
        }
        impl From<Batchge0> for u8 {
            #[inline(always)]
            fn from(val: Batchge0) -> u8 {
                Batchge0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bclr {
            #[inline(always)]
            fn from(val: u8) -> Bclr {
                Bclr::from_bits(val)
            }
        }
        impl From<Bclr> for u8 {
            #[inline(always)]
            fn from(val: Bclr) -> u8 {
                Bclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bemp {
            #[inline(always)]
            fn from(val: u8) -> Bemp {
                Bemp::from_bits(val)
            }
        }
        impl From<Bemp> for u8 {
            #[inline(always)]
            fn from(val: Bemp) -> u8 {
                Bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bempe {
            #[inline(always)]
            fn from(val: u8) -> Bempe {
                Bempe::from_bits(val)
            }
        }
        impl From<Bempe> for u8 {
            #[inline(always)]
            fn from(val: Bempe) -> u8 {
                Bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bfre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bfre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bfre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bfre {
            #[inline(always)]
            fn from(val: u8) -> Bfre {
                Bfre::from_bits(val)
            }
        }
        impl From<Bfre> for u8 {
            #[inline(always)]
            fn from(val: Bfre) -> u8 {
                Bfre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bigend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bigend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bigend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bigend {
            #[inline(always)]
            fn from(val: u8) -> Bigend {
                Bigend::from_bits(val)
            }
        }
        impl From<Bigend> for u8 {
            #[inline(always)]
            fn from(val: Bigend) -> u8 {
                Bigend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brdy {
            #[inline(always)]
            fn from(val: u8) -> Brdy {
                Brdy::from_bits(val)
            }
        }
        impl From<Brdy> for u8 {
            #[inline(always)]
            fn from(val: Brdy) -> u8 {
                Brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brdye {
            #[inline(always)]
            fn from(val: u8) -> Brdye {
                Brdye::from_bits(val)
            }
        }
        impl From<Brdye> for u8 {
            #[inline(always)]
            fn from(val: Brdye) -> u8 {
                Brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brdym {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Brdym {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brdym {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brdym {
            #[inline(always)]
            fn from(val: u8) -> Brdym {
                Brdym::from_bits(val)
            }
        }
        impl From<Brdym> for u8 {
            #[inline(always)]
            fn from(val: Brdym) -> u8 {
                Brdym::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bval {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bval {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bval {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bval {
            #[inline(always)]
            fn from(val: u8) -> Bval {
                Bval::from_bits(val)
            }
        }
        impl From<Bval> for u8 {
            #[inline(always)]
            fn from(val: Bval) -> u8 {
                Bval::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccpl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ccpl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccpl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccpl {
            #[inline(always)]
            fn from(val: u8) -> Ccpl {
                Ccpl::from_bits(val)
            }
        }
        impl From<Ccpl> for u8 {
            #[inline(always)]
            fn from(val: Ccpl) -> u8 {
                Ccpl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chgdetsts0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chgdetsts0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chgdetsts0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chgdetsts0 {
            #[inline(always)]
            fn from(val: u8) -> Chgdetsts0 {
                Chgdetsts0::from_bits(val)
            }
        }
        impl From<Chgdetsts0> for u8 {
            #[inline(always)]
            fn from(val: Chgdetsts0) -> u8 {
                Chgdetsts0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cnen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cnen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cnen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cnen {
            #[inline(always)]
            fn from(val: u8) -> Cnen {
                Cnen::from_bits(val)
            }
        }
        impl From<Cnen> for u8 {
            #[inline(always)]
            fn from(val: Cnen) -> u8 {
                Cnen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Crce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crce {
            #[inline(always)]
            fn from(val: u8) -> Crce {
                Crce::from_bits(val)
            }
        }
        impl From<Crce> for u8 {
            #[inline(always)]
            fn from(val: Crce) -> u8 {
                Crce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctre {
            #[inline(always)]
            fn from(val: u8) -> Ctre {
                Ctre::from_bits(val)
            }
        }
        impl From<Ctre> for u8 {
            #[inline(always)]
            fn from(val: Ctre) -> u8 {
                Ctre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctrt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrt {
            #[inline(always)]
            fn from(val: u8) -> Ctrt {
                Ctrt::from_bits(val)
            }
        }
        impl From<Ctrt> for u8 {
            #[inline(always)]
            fn from(val: Ctrt) -> u8 {
                Ctrt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctsq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctsq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctsq {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctsq {
            #[inline(always)]
            fn from(val: u8) -> Ctsq {
                Ctsq::from_bits(val)
            }
        }
        impl From<Ctsq> for u8 {
            #[inline(always)]
            fn from(val: Ctsq) -> u8 {
                Ctsq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Curpipe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Curpipe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Curpipe {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Curpipe {
            #[inline(always)]
            fn from(val: u8) -> Curpipe {
                Curpipe::from_bits(val)
            }
        }
        impl From<Curpipe> for u8 {
            #[inline(always)]
            fn from(val: Curpipe) -> u8 {
                Curpipe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dblb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dblb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dblb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dblb {
            #[inline(always)]
            fn from(val: u8) -> Dblb {
                Dblb::from_bits(val)
            }
        }
        impl From<Dblb> for u8 {
            #[inline(always)]
            fn from(val: Dblb) -> u8 {
                Dblb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DcpcfgDir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DcpcfgDir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DcpcfgDir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DcpcfgDir {
            #[inline(always)]
            fn from(val: u8) -> DcpcfgDir {
                DcpcfgDir::from_bits(val)
            }
        }
        impl From<DcpcfgDir> for u8 {
            #[inline(always)]
            fn from(val: DcpcfgDir) -> u8 {
                DcpcfgDir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DcpcfgShtnak {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DcpcfgShtnak {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DcpcfgShtnak {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DcpcfgShtnak {
            #[inline(always)]
            fn from(val: u8) -> DcpcfgShtnak {
                DcpcfgShtnak::from_bits(val)
            }
        }
        impl From<DcpcfgShtnak> for u8 {
            #[inline(always)]
            fn from(val: DcpcfgShtnak) -> u8 {
                DcpcfgShtnak::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DcpctrBsts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DcpctrBsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DcpctrBsts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DcpctrBsts {
            #[inline(always)]
            fn from(val: u8) -> DcpctrBsts {
                DcpctrBsts::from_bits(val)
            }
        }
        impl From<DcpctrBsts> for u8 {
            #[inline(always)]
            fn from(val: DcpctrBsts) -> u8 {
                DcpctrBsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DcpctrPbusy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DcpctrPbusy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DcpctrPbusy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DcpctrPbusy {
            #[inline(always)]
            fn from(val: u8) -> DcpctrPbusy {
                DcpctrPbusy::from_bits(val)
            }
        }
        impl From<DcpctrPbusy> for u8 {
            #[inline(always)]
            fn from(val: DcpctrPbusy) -> u8 {
                DcpctrPbusy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DcpctrPid {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl DcpctrPid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DcpctrPid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DcpctrPid {
            #[inline(always)]
            fn from(val: u8) -> DcpctrPid {
                DcpctrPid::from_bits(val)
            }
        }
        impl From<DcpctrPid> for u8 {
            #[inline(always)]
            fn from(val: DcpctrPid) -> u8 {
                DcpctrPid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DcpctrSqclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DcpctrSqclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DcpctrSqclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DcpctrSqclr {
            #[inline(always)]
            fn from(val: u8) -> DcpctrSqclr {
                DcpctrSqclr::from_bits(val)
            }
        }
        impl From<DcpctrSqclr> for u8 {
            #[inline(always)]
            fn from(val: DcpctrSqclr) -> u8 {
                DcpctrSqclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DcpctrSqmon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DcpctrSqmon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DcpctrSqmon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DcpctrSqmon {
            #[inline(always)]
            fn from(val: u8) -> DcpctrSqmon {
                DcpctrSqmon::from_bits(val)
            }
        }
        impl From<DcpctrSqmon> for u8 {
            #[inline(always)]
            fn from(val: DcpctrSqmon) -> u8 {
                DcpctrSqmon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DcpctrSqset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DcpctrSqset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DcpctrSqset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DcpctrSqset {
            #[inline(always)]
            fn from(val: u8) -> DcpctrSqset {
                DcpctrSqset::from_bits(val)
            }
        }
        impl From<DcpctrSqset> for u8 {
            #[inline(always)]
            fn from(val: DcpctrSqset) -> u8 {
                DcpctrSqset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DcpmaxpDevsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl DcpmaxpDevsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DcpmaxpDevsel {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DcpmaxpDevsel {
            #[inline(always)]
            fn from(val: u8) -> DcpmaxpDevsel {
                DcpmaxpDevsel::from_bits(val)
            }
        }
        impl From<DcpmaxpDevsel> for u8 {
            #[inline(always)]
            fn from(val: DcpmaxpDevsel) -> u8 {
                DcpmaxpDevsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dmrpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dmrpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dmrpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dmrpu {
            #[inline(always)]
            fn from(val: u8) -> Dmrpu {
                Dmrpu::from_bits(val)
            }
        }
        impl From<Dmrpu> for u8 {
            #[inline(always)]
            fn from(val: Dmrpu) -> u8 {
                Dmrpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dprpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dprpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dprpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dprpu {
            #[inline(always)]
            fn from(val: u8) -> Dprpu {
                Dprpu::from_bits(val)
            }
        }
        impl From<Dprpu> for u8 {
            #[inline(always)]
            fn from(val: Dprpu) -> u8 {
                Dprpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dvse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dvse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dvse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dvse {
            #[inline(always)]
            fn from(val: u8) -> Dvse {
                Dvse::from_bits(val)
            }
        }
        impl From<Dvse> for u8 {
            #[inline(always)]
            fn from(val: Dvse) -> u8 {
                Dvse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dvsq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Dvsq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dvsq {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dvsq {
            #[inline(always)]
            fn from(val: u8) -> Dvsq {
                Dvsq::from_bits(val)
            }
        }
        impl From<Dvsq> for u8 {
            #[inline(always)]
            fn from(val: Dvsq) -> u8 {
                Dvsq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dvst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dvst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dvst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dvst {
            #[inline(always)]
            fn from(val: u8) -> Dvst {
                Dvst::from_bits(val)
            }
        }
        impl From<Dvst> for u8 {
            #[inline(always)]
            fn from(val: Dvst) -> u8 {
                Dvst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edgests {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Edgests {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edgests {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edgests {
            #[inline(always)]
            fn from(val: u8) -> Edgests {
                Edgests::from_bits(val)
            }
        }
        impl From<Edgests> for u8 {
            #[inline(always)]
            fn from(val: Edgests) -> u8 {
                Edgests::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Frdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Frdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Frdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Frdy {
            #[inline(always)]
            fn from(val: u8) -> Frdy {
                Frdy::from_bits(val)
            }
        }
        impl From<Frdy> for u8 {
            #[inline(always)]
            fn from(val: Frdy) -> u8 {
                Frdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idmsinke0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idmsinke0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idmsinke0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idmsinke0 {
            #[inline(always)]
            fn from(val: u8) -> Idmsinke0 {
                Idmsinke0::from_bits(val)
            }
        }
        impl From<Idmsinke0> for u8 {
            #[inline(always)]
            fn from(val: Idmsinke0) -> u8 {
                Idmsinke0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idpsinke0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idpsinke0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idpsinke0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idpsinke0 {
            #[inline(always)]
            fn from(val: u8) -> Idpsinke0 {
                Idpsinke0::from_bits(val)
            }
        }
        impl From<Idpsinke0> for u8 {
            #[inline(always)]
            fn from(val: Idpsinke0) -> u8 {
                Idpsinke0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idpsrce0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idpsrce0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idpsrce0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idpsrce0 {
            #[inline(always)]
            fn from(val: u8) -> Idpsrce0 {
                Idpsrce0::from_bits(val)
            }
        }
        impl From<Idpsrce0> for u8 {
            #[inline(always)]
            fn from(val: Idpsrce0) -> u8 {
                Idpsrce0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inbufm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Inbufm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inbufm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inbufm {
            #[inline(always)]
            fn from(val: u8) -> Inbufm {
                Inbufm::from_bits(val)
            }
        }
        impl From<Inbufm> for u8 {
            #[inline(always)]
            fn from(val: Inbufm) -> u8 {
                Inbufm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Isel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Isel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Isel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Isel {
            #[inline(always)]
            fn from(val: u8) -> Isel {
                Isel::from_bits(val)
            }
        }
        impl From<Isel> for u8 {
            #[inline(always)]
            fn from(val: Isel) -> u8 {
                Isel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lnst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lnst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lnst {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lnst {
            #[inline(always)]
            fn from(val: u8) -> Lnst {
                Lnst::from_bits(val)
            }
        }
        impl From<Lnst> for u8 {
            #[inline(always)]
            fn from(val: Lnst) -> u8 {
                Lnst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mbw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mbw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mbw {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mbw {
            #[inline(always)]
            fn from(val: u8) -> Mbw {
                Mbw::from_bits(val)
            }
        }
        impl From<Mbw> for u8 {
            #[inline(always)]
            fn from(val: Mbw) -> u8 {
                Mbw::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Mxps(u8);
        impl Mxps {}
        impl Mxps {
            pub const fn from_bits(val: u8) -> Mxps {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Mxps {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mxps {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Mxps {
            #[inline(always)]
            fn from(val: u8) -> Mxps {
                Mxps::from_bits(val)
            }
        }
        impl From<Mxps> for u8 {
            #[inline(always)]
            fn from(val: Mxps) -> u8 {
                Mxps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nrdy {
            #[inline(always)]
            fn from(val: u8) -> Nrdy {
                Nrdy::from_bits(val)
            }
        }
        impl From<Nrdy> for u8 {
            #[inline(always)]
            fn from(val: Nrdy) -> u8 {
                Nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nrdye {
            #[inline(always)]
            fn from(val: u8) -> Nrdye {
                Nrdye::from_bits(val)
            }
        }
        impl From<Nrdye> for u8 {
            #[inline(always)]
            fn from(val: Nrdye) -> u8 {
                Nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovrn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovrn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovrn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovrn {
            #[inline(always)]
            fn from(val: u8) -> Ovrn {
                Ovrn::from_bits(val)
            }
        }
        impl From<Ovrn> for u8 {
            #[inline(always)]
            fn from(val: Ovrn) -> u8 {
                Ovrn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pddetsts0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pddetsts0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pddetsts0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pddetsts0 {
            #[inline(always)]
            fn from(val: u8) -> Pddetsts0 {
                Pddetsts0::from_bits(val)
            }
        }
        impl From<Pddetsts0> for u8 {
            #[inline(always)]
            fn from(val: Pddetsts0) -> u8 {
                Pddetsts0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe0bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe0bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe0bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe0bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe0bemp {
                Pipe0bemp::from_bits(val)
            }
        }
        impl From<Pipe0bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe0bemp) -> u8 {
                Pipe0bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe0bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe0bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe0bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe0bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe0bempe {
                Pipe0bempe::from_bits(val)
            }
        }
        impl From<Pipe0bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe0bempe) -> u8 {
                Pipe0bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe0brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe0brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe0brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe0brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe0brdy {
                Pipe0brdy::from_bits(val)
            }
        }
        impl From<Pipe0brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe0brdy) -> u8 {
                Pipe0brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe0brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe0brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe0brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe0brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe0brdye {
                Pipe0brdye::from_bits(val)
            }
        }
        impl From<Pipe0brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe0brdye) -> u8 {
                Pipe0brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe0nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe0nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe0nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe0nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe0nrdy {
                Pipe0nrdy::from_bits(val)
            }
        }
        impl From<Pipe0nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe0nrdy) -> u8 {
                Pipe0nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe0nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe0nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe0nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe0nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe0nrdye {
                Pipe0nrdye::from_bits(val)
            }
        }
        impl From<Pipe0nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe0nrdye) -> u8 {
                Pipe0nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe1bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe1bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe1bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe1bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe1bemp {
                Pipe1bemp::from_bits(val)
            }
        }
        impl From<Pipe1bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe1bemp) -> u8 {
                Pipe1bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe1bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe1bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe1bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe1bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe1bempe {
                Pipe1bempe::from_bits(val)
            }
        }
        impl From<Pipe1bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe1bempe) -> u8 {
                Pipe1bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe1brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe1brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe1brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe1brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe1brdy {
                Pipe1brdy::from_bits(val)
            }
        }
        impl From<Pipe1brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe1brdy) -> u8 {
                Pipe1brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe1brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe1brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe1brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe1brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe1brdye {
                Pipe1brdye::from_bits(val)
            }
        }
        impl From<Pipe1brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe1brdye) -> u8 {
                Pipe1brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe1nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe1nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe1nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe1nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe1nrdy {
                Pipe1nrdy::from_bits(val)
            }
        }
        impl From<Pipe1nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe1nrdy) -> u8 {
                Pipe1nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe1nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe1nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe1nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe1nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe1nrdye {
                Pipe1nrdye::from_bits(val)
            }
        }
        impl From<Pipe1nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe1nrdye) -> u8 {
                Pipe1nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe2bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe2bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe2bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe2bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe2bemp {
                Pipe2bemp::from_bits(val)
            }
        }
        impl From<Pipe2bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe2bemp) -> u8 {
                Pipe2bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe2bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe2bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe2bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe2bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe2bempe {
                Pipe2bempe::from_bits(val)
            }
        }
        impl From<Pipe2bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe2bempe) -> u8 {
                Pipe2bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe2brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe2brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe2brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe2brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe2brdy {
                Pipe2brdy::from_bits(val)
            }
        }
        impl From<Pipe2brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe2brdy) -> u8 {
                Pipe2brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe2brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe2brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe2brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe2brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe2brdye {
                Pipe2brdye::from_bits(val)
            }
        }
        impl From<Pipe2brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe2brdye) -> u8 {
                Pipe2brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe2nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe2nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe2nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe2nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe2nrdy {
                Pipe2nrdy::from_bits(val)
            }
        }
        impl From<Pipe2nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe2nrdy) -> u8 {
                Pipe2nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe2nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe2nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe2nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe2nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe2nrdye {
                Pipe2nrdye::from_bits(val)
            }
        }
        impl From<Pipe2nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe2nrdye) -> u8 {
                Pipe2nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe3bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe3bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe3bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe3bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe3bemp {
                Pipe3bemp::from_bits(val)
            }
        }
        impl From<Pipe3bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe3bemp) -> u8 {
                Pipe3bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe3bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe3bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe3bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe3bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe3bempe {
                Pipe3bempe::from_bits(val)
            }
        }
        impl From<Pipe3bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe3bempe) -> u8 {
                Pipe3bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe3brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe3brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe3brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe3brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe3brdy {
                Pipe3brdy::from_bits(val)
            }
        }
        impl From<Pipe3brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe3brdy) -> u8 {
                Pipe3brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe3brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe3brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe3brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe3brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe3brdye {
                Pipe3brdye::from_bits(val)
            }
        }
        impl From<Pipe3brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe3brdye) -> u8 {
                Pipe3brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe3nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe3nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe3nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe3nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe3nrdy {
                Pipe3nrdy::from_bits(val)
            }
        }
        impl From<Pipe3nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe3nrdy) -> u8 {
                Pipe3nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe3nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe3nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe3nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe3nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe3nrdye {
                Pipe3nrdye::from_bits(val)
            }
        }
        impl From<Pipe3nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe3nrdye) -> u8 {
                Pipe3nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe4bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe4bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe4bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe4bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe4bemp {
                Pipe4bemp::from_bits(val)
            }
        }
        impl From<Pipe4bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe4bemp) -> u8 {
                Pipe4bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe4bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe4bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe4bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe4bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe4bempe {
                Pipe4bempe::from_bits(val)
            }
        }
        impl From<Pipe4bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe4bempe) -> u8 {
                Pipe4bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe4brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe4brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe4brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe4brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe4brdy {
                Pipe4brdy::from_bits(val)
            }
        }
        impl From<Pipe4brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe4brdy) -> u8 {
                Pipe4brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe4brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe4brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe4brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe4brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe4brdye {
                Pipe4brdye::from_bits(val)
            }
        }
        impl From<Pipe4brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe4brdye) -> u8 {
                Pipe4brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe4nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe4nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe4nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe4nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe4nrdy {
                Pipe4nrdy::from_bits(val)
            }
        }
        impl From<Pipe4nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe4nrdy) -> u8 {
                Pipe4nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe4nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe4nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe4nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe4nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe4nrdye {
                Pipe4nrdye::from_bits(val)
            }
        }
        impl From<Pipe4nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe4nrdye) -> u8 {
                Pipe4nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe5bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe5bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe5bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe5bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe5bemp {
                Pipe5bemp::from_bits(val)
            }
        }
        impl From<Pipe5bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe5bemp) -> u8 {
                Pipe5bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe5bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe5bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe5bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe5bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe5bempe {
                Pipe5bempe::from_bits(val)
            }
        }
        impl From<Pipe5bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe5bempe) -> u8 {
                Pipe5bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe5brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe5brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe5brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe5brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe5brdy {
                Pipe5brdy::from_bits(val)
            }
        }
        impl From<Pipe5brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe5brdy) -> u8 {
                Pipe5brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe5brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe5brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe5brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe5brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe5brdye {
                Pipe5brdye::from_bits(val)
            }
        }
        impl From<Pipe5brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe5brdye) -> u8 {
                Pipe5brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe5nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe5nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe5nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe5nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe5nrdy {
                Pipe5nrdy::from_bits(val)
            }
        }
        impl From<Pipe5nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe5nrdy) -> u8 {
                Pipe5nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe5nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe5nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe5nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe5nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe5nrdye {
                Pipe5nrdye::from_bits(val)
            }
        }
        impl From<Pipe5nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe5nrdye) -> u8 {
                Pipe5nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe6bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe6bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe6bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe6bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe6bemp {
                Pipe6bemp::from_bits(val)
            }
        }
        impl From<Pipe6bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe6bemp) -> u8 {
                Pipe6bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe6bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe6bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe6bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe6bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe6bempe {
                Pipe6bempe::from_bits(val)
            }
        }
        impl From<Pipe6bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe6bempe) -> u8 {
                Pipe6bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe6brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe6brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe6brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe6brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe6brdy {
                Pipe6brdy::from_bits(val)
            }
        }
        impl From<Pipe6brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe6brdy) -> u8 {
                Pipe6brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe6brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe6brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe6brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe6brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe6brdye {
                Pipe6brdye::from_bits(val)
            }
        }
        impl From<Pipe6brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe6brdye) -> u8 {
                Pipe6brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe6nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe6nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe6nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe6nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe6nrdy {
                Pipe6nrdy::from_bits(val)
            }
        }
        impl From<Pipe6nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe6nrdy) -> u8 {
                Pipe6nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe6nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe6nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe6nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe6nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe6nrdye {
                Pipe6nrdye::from_bits(val)
            }
        }
        impl From<Pipe6nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe6nrdye) -> u8 {
                Pipe6nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe7bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe7bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe7bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe7bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe7bemp {
                Pipe7bemp::from_bits(val)
            }
        }
        impl From<Pipe7bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe7bemp) -> u8 {
                Pipe7bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe7bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe7bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe7bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe7bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe7bempe {
                Pipe7bempe::from_bits(val)
            }
        }
        impl From<Pipe7bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe7bempe) -> u8 {
                Pipe7bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe7brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe7brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe7brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe7brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe7brdy {
                Pipe7brdy::from_bits(val)
            }
        }
        impl From<Pipe7brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe7brdy) -> u8 {
                Pipe7brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe7brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe7brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe7brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe7brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe7brdye {
                Pipe7brdye::from_bits(val)
            }
        }
        impl From<Pipe7brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe7brdye) -> u8 {
                Pipe7brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe7nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe7nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe7nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe7nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe7nrdy {
                Pipe7nrdy::from_bits(val)
            }
        }
        impl From<Pipe7nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe7nrdy) -> u8 {
                Pipe7nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe7nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe7nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe7nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe7nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe7nrdye {
                Pipe7nrdye::from_bits(val)
            }
        }
        impl From<Pipe7nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe7nrdye) -> u8 {
                Pipe7nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe8bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe8bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe8bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe8bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe8bemp {
                Pipe8bemp::from_bits(val)
            }
        }
        impl From<Pipe8bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe8bemp) -> u8 {
                Pipe8bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe8bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe8bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe8bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe8bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe8bempe {
                Pipe8bempe::from_bits(val)
            }
        }
        impl From<Pipe8bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe8bempe) -> u8 {
                Pipe8bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe8brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe8brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe8brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe8brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe8brdy {
                Pipe8brdy::from_bits(val)
            }
        }
        impl From<Pipe8brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe8brdy) -> u8 {
                Pipe8brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe8brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe8brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe8brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe8brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe8brdye {
                Pipe8brdye::from_bits(val)
            }
        }
        impl From<Pipe8brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe8brdye) -> u8 {
                Pipe8brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe8nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe8nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe8nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe8nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe8nrdy {
                Pipe8nrdy::from_bits(val)
            }
        }
        impl From<Pipe8nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe8nrdy) -> u8 {
                Pipe8nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe8nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe8nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe8nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe8nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe8nrdye {
                Pipe8nrdye::from_bits(val)
            }
        }
        impl From<Pipe8nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe8nrdye) -> u8 {
                Pipe8nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe9bemp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe9bemp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe9bemp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe9bemp {
            #[inline(always)]
            fn from(val: u8) -> Pipe9bemp {
                Pipe9bemp::from_bits(val)
            }
        }
        impl From<Pipe9bemp> for u8 {
            #[inline(always)]
            fn from(val: Pipe9bemp) -> u8 {
                Pipe9bemp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe9bempe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe9bempe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe9bempe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe9bempe {
            #[inline(always)]
            fn from(val: u8) -> Pipe9bempe {
                Pipe9bempe::from_bits(val)
            }
        }
        impl From<Pipe9bempe> for u8 {
            #[inline(always)]
            fn from(val: Pipe9bempe) -> u8 {
                Pipe9bempe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe9brdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe9brdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe9brdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe9brdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe9brdy {
                Pipe9brdy::from_bits(val)
            }
        }
        impl From<Pipe9brdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe9brdy) -> u8 {
                Pipe9brdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe9brdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe9brdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe9brdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe9brdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe9brdye {
                Pipe9brdye::from_bits(val)
            }
        }
        impl From<Pipe9brdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe9brdye) -> u8 {
                Pipe9brdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe9nrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe9nrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe9nrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe9nrdy {
            #[inline(always)]
            fn from(val: u8) -> Pipe9nrdy {
                Pipe9nrdy::from_bits(val)
            }
        }
        impl From<Pipe9nrdy> for u8 {
            #[inline(always)]
            fn from(val: Pipe9nrdy) -> u8 {
                Pipe9nrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipe9nrdye {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipe9nrdye {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipe9nrdye {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipe9nrdye {
            #[inline(always)]
            fn from(val: u8) -> Pipe9nrdye {
                Pipe9nrdye::from_bits(val)
            }
        }
        impl From<Pipe9nrdye> for u8 {
            #[inline(always)]
            fn from(val: Pipe9nrdye) -> u8 {
                Pipe9nrdye::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipecfgDir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PipecfgDir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipecfgDir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipecfgDir {
            #[inline(always)]
            fn from(val: u8) -> PipecfgDir {
                PipecfgDir::from_bits(val)
            }
        }
        impl From<PipecfgDir> for u8 {
            #[inline(always)]
            fn from(val: PipecfgDir) -> u8 {
                PipecfgDir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipecfgShtnak {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PipecfgShtnak {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipecfgShtnak {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipecfgShtnak {
            #[inline(always)]
            fn from(val: u8) -> PipecfgShtnak {
                PipecfgShtnak::from_bits(val)
            }
        }
        impl From<PipecfgShtnak> for u8 {
            #[inline(always)]
            fn from(val: PipecfgShtnak) -> u8 {
                PipecfgShtnak::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipectr1Aclrm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipectr1Aclrm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipectr1Aclrm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipectr1Aclrm {
            #[inline(always)]
            fn from(val: u8) -> Pipectr1Aclrm {
                Pipectr1Aclrm::from_bits(val)
            }
        }
        impl From<Pipectr1Aclrm> for u8 {
            #[inline(always)]
            fn from(val: Pipectr1Aclrm) -> u8 {
                Pipectr1Aclrm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipectr1Bsts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipectr1Bsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipectr1Bsts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipectr1Bsts {
            #[inline(always)]
            fn from(val: u8) -> Pipectr1Bsts {
                Pipectr1Bsts::from_bits(val)
            }
        }
        impl From<Pipectr1Bsts> for u8 {
            #[inline(always)]
            fn from(val: Pipectr1Bsts) -> u8 {
                Pipectr1Bsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipectr1Pbusy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipectr1Pbusy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipectr1Pbusy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipectr1Pbusy {
            #[inline(always)]
            fn from(val: u8) -> Pipectr1Pbusy {
                Pipectr1Pbusy::from_bits(val)
            }
        }
        impl From<Pipectr1Pbusy> for u8 {
            #[inline(always)]
            fn from(val: Pipectr1Pbusy) -> u8 {
                Pipectr1Pbusy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipectr1Pid {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Pipectr1Pid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipectr1Pid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipectr1Pid {
            #[inline(always)]
            fn from(val: u8) -> Pipectr1Pid {
                Pipectr1Pid::from_bits(val)
            }
        }
        impl From<Pipectr1Pid> for u8 {
            #[inline(always)]
            fn from(val: Pipectr1Pid) -> u8 {
                Pipectr1Pid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipectr1Sqclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipectr1Sqclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipectr1Sqclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipectr1Sqclr {
            #[inline(always)]
            fn from(val: u8) -> Pipectr1Sqclr {
                Pipectr1Sqclr::from_bits(val)
            }
        }
        impl From<Pipectr1Sqclr> for u8 {
            #[inline(always)]
            fn from(val: Pipectr1Sqclr) -> u8 {
                Pipectr1Sqclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipectr1Sqmon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipectr1Sqmon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipectr1Sqmon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipectr1Sqmon {
            #[inline(always)]
            fn from(val: u8) -> Pipectr1Sqmon {
                Pipectr1Sqmon::from_bits(val)
            }
        }
        impl From<Pipectr1Sqmon> for u8 {
            #[inline(always)]
            fn from(val: Pipectr1Sqmon) -> u8 {
                Pipectr1Sqmon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipectr1Sqset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pipectr1Sqset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipectr1Sqset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipectr1Sqset {
            #[inline(always)]
            fn from(val: u8) -> Pipectr1Sqset {
                Pipectr1Sqset::from_bits(val)
            }
        }
        impl From<Pipectr1Sqset> for u8 {
            #[inline(always)]
            fn from(val: Pipectr1Sqset) -> u8 {
                Pipectr1Sqset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipectrAclrm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PipectrAclrm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipectrAclrm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipectrAclrm {
            #[inline(always)]
            fn from(val: u8) -> PipectrAclrm {
                PipectrAclrm::from_bits(val)
            }
        }
        impl From<PipectrAclrm> for u8 {
            #[inline(always)]
            fn from(val: PipectrAclrm) -> u8 {
                PipectrAclrm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipectrBsts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PipectrBsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipectrBsts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipectrBsts {
            #[inline(always)]
            fn from(val: u8) -> PipectrBsts {
                PipectrBsts::from_bits(val)
            }
        }
        impl From<PipectrBsts> for u8 {
            #[inline(always)]
            fn from(val: PipectrBsts) -> u8 {
                PipectrBsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipectrPbusy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PipectrPbusy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipectrPbusy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipectrPbusy {
            #[inline(always)]
            fn from(val: u8) -> PipectrPbusy {
                PipectrPbusy::from_bits(val)
            }
        }
        impl From<PipectrPbusy> for u8 {
            #[inline(always)]
            fn from(val: PipectrPbusy) -> u8 {
                PipectrPbusy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipectrPid {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PipectrPid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipectrPid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipectrPid {
            #[inline(always)]
            fn from(val: u8) -> PipectrPid {
                PipectrPid::from_bits(val)
            }
        }
        impl From<PipectrPid> for u8 {
            #[inline(always)]
            fn from(val: PipectrPid) -> u8 {
                PipectrPid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipectrSqclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PipectrSqclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipectrSqclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipectrSqclr {
            #[inline(always)]
            fn from(val: u8) -> PipectrSqclr {
                PipectrSqclr::from_bits(val)
            }
        }
        impl From<PipectrSqclr> for u8 {
            #[inline(always)]
            fn from(val: PipectrSqclr) -> u8 {
                PipectrSqclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipectrSqmon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PipectrSqmon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipectrSqmon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipectrSqmon {
            #[inline(always)]
            fn from(val: u8) -> PipectrSqmon {
                PipectrSqmon::from_bits(val)
            }
        }
        impl From<PipectrSqmon> for u8 {
            #[inline(always)]
            fn from(val: PipectrSqmon) -> u8 {
                PipectrSqmon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipectrSqset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PipectrSqset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipectrSqset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipectrSqset {
            #[inline(always)]
            fn from(val: u8) -> PipectrSqset {
                PipectrSqset::from_bits(val)
            }
        }
        impl From<PipectrSqset> for u8 {
            #[inline(always)]
            fn from(val: PipectrSqset) -> u8 {
                PipectrSqset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PipemaxpDevsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl PipemaxpDevsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PipemaxpDevsel {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PipemaxpDevsel {
            #[inline(always)]
            fn from(val: u8) -> PipemaxpDevsel {
                PipemaxpDevsel::from_bits(val)
            }
        }
        impl From<PipemaxpDevsel> for u8 {
            #[inline(always)]
            fn from(val: PipemaxpDevsel) -> u8 {
                PipemaxpDevsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pipesel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Pipesel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pipesel {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pipesel {
            #[inline(always)]
            fn from(val: u8) -> Pipesel {
                Pipesel::from_bits(val)
            }
        }
        impl From<Pipesel> for u8 {
            #[inline(always)]
            fn from(val: Pipesel) -> u8 {
                Pipesel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcnt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcnt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcnt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcnt {
            #[inline(always)]
            fn from(val: u8) -> Rcnt {
                Rcnt::from_bits(val)
            }
        }
        impl From<Rcnt> for u8 {
            #[inline(always)]
            fn from(val: Rcnt) -> u8 {
                Rcnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Resm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Resm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Resm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Resm {
            #[inline(always)]
            fn from(val: u8) -> Resm {
                Resm::from_bits(val)
            }
        }
        impl From<Resm> for u8 {
            #[inline(always)]
            fn from(val: Resm) -> u8 {
                Resm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rew {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rew {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rew {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rew {
            #[inline(always)]
            fn from(val: u8) -> Rew {
                Rew::from_bits(val)
            }
        }
        impl From<Rew> for u8 {
            #[inline(always)]
            fn from(val: Rew) -> u8 {
                Rew::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rhst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rhst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rhst {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rhst {
            #[inline(always)]
            fn from(val: u8) -> Rhst {
                Rhst::from_bits(val)
            }
        }
        impl From<Rhst> for u8 {
            #[inline(always)]
            fn from(val: Rhst) -> u8 {
                Rhst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpdme0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpdme0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpdme0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpdme0 {
            #[inline(always)]
            fn from(val: u8) -> Rpdme0 {
                Rpdme0::from_bits(val)
            }
        }
        impl From<Rpdme0> for u8 {
            #[inline(always)]
            fn from(val: Rpdme0) -> u8 {
                Rpdme0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rsme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rsme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rsme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rsme {
            #[inline(always)]
            fn from(val: u8) -> Rsme {
                Rsme::from_bits(val)
            }
        }
        impl From<Rsme> for u8 {
            #[inline(always)]
            fn from(val: Rsme) -> u8 {
                Rsme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scke {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scke {
            #[inline(always)]
            fn from(val: u8) -> Scke {
                Scke::from_bits(val)
            }
        }
        impl From<Scke> for u8 {
            #[inline(always)]
            fn from(val: Scke) -> u8 {
                Scke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sofe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sofe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sofe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sofe {
            #[inline(always)]
            fn from(val: u8) -> Sofe {
                Sofe::from_bits(val)
            }
        }
        impl From<Sofe> for u8 {
            #[inline(always)]
            fn from(val: Sofe) -> u8 {
                Sofe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sofr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sofr {
            #[inline(always)]
            fn from(val: u8) -> Sofr {
                Sofr::from_bits(val)
            }
        }
        impl From<Sofr> for u8 {
            #[inline(always)]
            fn from(val: Sofr) -> u8 {
                Sofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sureq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sureq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sureq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sureq {
            #[inline(always)]
            fn from(val: u8) -> Sureq {
                Sureq::from_bits(val)
            }
        }
        impl From<Sureq> for u8 {
            #[inline(always)]
            fn from(val: Sureq) -> u8 {
                Sureq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sureqclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sureqclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sureqclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sureqclr {
            #[inline(always)]
            fn from(val: u8) -> Sureqclr {
                Sureqclr::from_bits(val)
            }
        }
        impl From<Sureqclr> for u8 {
            #[inline(always)]
            fn from(val: Sureqclr) -> u8 {
                Sureqclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trclr {
            #[inline(always)]
            fn from(val: u8) -> Trclr {
                Trclr::from_bits(val)
            }
        }
        impl From<Trclr> for u8 {
            #[inline(always)]
            fn from(val: Trclr) -> u8 {
                Trclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trenb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trenb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trenb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trenb {
            #[inline(always)]
            fn from(val: u8) -> Trenb {
                Trenb::from_bits(val)
            }
        }
        impl From<Trenb> for u8 {
            #[inline(always)]
            fn from(val: Trenb) -> u8 {
                Trenb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trnensel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trnensel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trnensel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trnensel {
            #[inline(always)]
            fn from(val: u8) -> Trnensel {
                Trnensel::from_bits(val)
            }
        }
        impl From<Trnensel> for u8 {
            #[inline(always)]
            fn from(val: Trnensel) -> u8 {
                Trnensel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Type {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Type {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Type {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Type {
            #[inline(always)]
            fn from(val: u8) -> Type {
                Type::from_bits(val)
            }
        }
        impl From<Type> for u8 {
            #[inline(always)]
            fn from(val: Type) -> u8 {
                Type::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uckselc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uckselc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uckselc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uckselc {
            #[inline(always)]
            fn from(val: u8) -> Uckselc {
                Uckselc::from_bits(val)
            }
        }
        impl From<Uckselc> for u8 {
            #[inline(always)]
            fn from(val: Uckselc) -> u8 {
                Uckselc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usbe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usbe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usbe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usbe {
            #[inline(always)]
            fn from(val: u8) -> Usbe {
                Usbe::from_bits(val)
            }
        }
        impl From<Usbe> for u8 {
            #[inline(always)]
            fn from(val: Usbe) -> u8 {
                Usbe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Valid {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Valid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Valid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Valid {
            #[inline(always)]
            fn from(val: u8) -> Valid {
                Valid::from_bits(val)
            }
        }
        impl From<Valid> for u8 {
            #[inline(always)]
            fn from(val: Valid) -> u8 {
                Valid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vbint {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vbint {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vbint {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vbint {
            #[inline(always)]
            fn from(val: u8) -> Vbint {
                Vbint::from_bits(val)
            }
        }
        impl From<Vbint> for u8 {
            #[inline(always)]
            fn from(val: Vbint) -> u8 {
                Vbint::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vbse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vbse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vbse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vbse {
            #[inline(always)]
            fn from(val: u8) -> Vbse {
                Vbse::from_bits(val)
            }
        }
        impl From<Vbse> for u8 {
            #[inline(always)]
            fn from(val: Vbse) -> u8 {
                Vbse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vbsts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vbsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vbsts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vbsts {
            #[inline(always)]
            fn from(val: u8) -> Vbsts {
                Vbsts::from_bits(val)
            }
        }
        impl From<Vbsts> for u8 {
            #[inline(always)]
            fn from(val: Vbsts) -> u8 {
                Vbsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vdcen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vdcen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vdcen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vdcen {
            #[inline(always)]
            fn from(val: u8) -> Vdcen {
                Vdcen::from_bits(val)
            }
        }
        impl From<Vdcen> for u8 {
            #[inline(always)]
            fn from(val: Vdcen) -> u8 {
                Vdcen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vddusbe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vddusbe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vddusbe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vddusbe {
            #[inline(always)]
            fn from(val: u8) -> Vddusbe {
                Vddusbe::from_bits(val)
            }
        }
        impl From<Vddusbe> for u8 {
            #[inline(always)]
            fn from(val: Vddusbe) -> u8 {
                Vddusbe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vdmsrce0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vdmsrce0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vdmsrce0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vdmsrce0 {
            #[inline(always)]
            fn from(val: u8) -> Vdmsrce0 {
                Vdmsrce0::from_bits(val)
            }
        }
        impl From<Vdmsrce0> for u8 {
            #[inline(always)]
            fn from(val: Vdmsrce0) -> u8 {
                Vdmsrce0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vdpsrce0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vdpsrce0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vdpsrce0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vdpsrce0 {
            #[inline(always)]
            fn from(val: u8) -> Vdpsrce0 {
                Vdpsrce0::from_bits(val)
            }
        }
        impl From<Vdpsrce0> for u8 {
            #[inline(always)]
            fn from(val: Vdpsrce0) -> u8 {
                Vdpsrce0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wkup {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wkup {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wkup {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wkup {
            #[inline(always)]
            fn from(val: u8) -> Wkup {
                Wkup::from_bits(val)
            }
        }
        impl From<Wkup> for u8 {
            #[inline(always)]
            fn from(val: Wkup) -> u8 {
                Wkup::to_bits(val)
            }
        }
    }
}
pub mod wdt {
    #[doc = "Watchdog Timer"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "WDT Refresh Register"]
        #[inline(always)]
        pub const fn wdtrr(self) -> crate::common::Reg<regs::Wdtrr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "WDT Control Register"]
        #[inline(always)]
        pub const fn wdtcr(self) -> crate::common::Reg<regs::Wdtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "WDT Status Register"]
        #[inline(always)]
        pub const fn wdtsr(self) -> crate::common::Reg<regs::Wdtsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "WDT Reset Control Register"]
        #[inline(always)]
        pub const fn wdtrcr(self) -> crate::common::Reg<regs::Wdtrcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "WDT Count Stop Control Register"]
        #[inline(always)]
        pub const fn wdtcstpr(self) -> crate::common::Reg<regs::Wdtcstpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "WDT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtcr(pub u16);
        impl Wdtcr {
            #[doc = "Timeout Period Selection"]
            #[inline(always)]
            pub const fn tops(&self) -> super::vals::Tops {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Tops::from_bits(val as u8)
            }
            #[doc = "Timeout Period Selection"]
            #[inline(always)]
            pub fn set_tops(&mut self, val: super::vals::Tops) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_2_3(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_2_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u16) & 0x03) << 2usize);
            }
            #[doc = "Clock Division Ratio Selection"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Cks {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Cks::from_bits(val as u8)
            }
            #[doc = "Clock Division Ratio Selection"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Cks) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u16) & 0x0f) << 4usize);
            }
            #[doc = "Window End Position Selection"]
            #[inline(always)]
            pub const fn rpes(&self) -> super::vals::Rpes {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Rpes::from_bits(val as u8)
            }
            #[doc = "Window End Position Selection"]
            #[inline(always)]
            pub fn set_rpes(&mut self, val: super::vals::Rpes) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_10_11(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_10_11(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val as u16) & 0x03) << 10usize);
            }
            #[doc = "Window Start Position Selection"]
            #[inline(always)]
            pub const fn rpss(&self) -> super::vals::Rpss {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Rpss::from_bits(val as u8)
            }
            #[doc = "Window Start Position Selection"]
            #[inline(always)]
            pub fn set_rpss(&mut self, val: super::vals::Rpss) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub const fn reserved_14_15(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are read as 00. The write value should be 00."]
            #[inline(always)]
            pub fn set_reserved_14_15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 14usize)) | (((val as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Wdtcr {
            #[inline(always)]
            fn default() -> Wdtcr {
                Wdtcr(0)
            }
        }
        impl core::fmt::Debug for Wdtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtcr")
                    .field("tops", &self.tops())
                    .field("reserved_2_3", &self.reserved_2_3())
                    .field("cks", &self.cks())
                    .field("rpes", &self.rpes())
                    .field("reserved_10_11", &self.reserved_10_11())
                    .field("rpss", &self.rpss())
                    .field("reserved_14_15", &self.reserved_14_15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Wdtcr {{ tops: {:?}, reserved_2_3: {=u8:?}, cks: {:?}, rpes: {:?}, reserved_10_11: {=u8:?}, rpss: {:?}, reserved_14_15: {=u8:?} }}" , self . tops () , self . reserved_2_3 () , self . cks () , self . rpes () , self . reserved_10_11 () , self . rpss () , self . reserved_14_15 ())
            }
        }
        #[doc = "WDT Count Stop Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtcstpr(pub u8);
        impl Wdtcstpr {
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub const fn reserved_0_6(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits are read as 0000000. The write value should be 0000000."]
            #[inline(always)]
            pub fn set_reserved_0_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u8) & 0x7f) << 0usize);
            }
            #[doc = "Sleep,Mode Count Stop Control"]
            #[inline(always)]
            pub const fn slcstp(&self) -> super::vals::Slcstp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Slcstp::from_bits(val as u8)
            }
            #[doc = "Sleep,Mode Count Stop Control"]
            #[inline(always)]
            pub fn set_slcstp(&mut self, val: super::vals::Slcstp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Wdtcstpr {
            #[inline(always)]
            fn default() -> Wdtcstpr {
                Wdtcstpr(0)
            }
        }
        impl core::fmt::Debug for Wdtcstpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtcstpr")
                    .field("reserved_0_6", &self.reserved_0_6())
                    .field("slcstp", &self.slcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtcstpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Wdtcstpr {{ reserved_0_6: {=u8:?}, slcstp: {:?} }}",
                    self.reserved_0_6(),
                    self.slcstp()
                )
            }
        }
        #[doc = "WDT Reset Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtrcr(pub u8);
        impl Wdtrcr {
            #[doc = "Reset Interrupt Request Selection"]
            #[inline(always)]
            pub const fn rstirqs(&self) -> super::vals::Rstirqs {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rstirqs::from_bits(val as u8)
            }
            #[doc = "Reset Interrupt Request Selection"]
            #[inline(always)]
            pub fn set_rstirqs(&mut self, val: super::vals::Rstirqs) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Wdtrcr {
            #[inline(always)]
            fn default() -> Wdtrcr {
                Wdtrcr(0)
            }
        }
        impl core::fmt::Debug for Wdtrcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtrcr")
                    .field("rstirqs", &self.rstirqs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtrcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Wdtrcr {{ rstirqs: {:?} }}", self.rstirqs())
            }
        }
        #[doc = "WDT Refresh Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtrr(pub u8);
        impl Wdtrr {
            #[doc = "WDTRR is an 8-bit register that refreshes the down,counter of the WDT."]
            #[inline(always)]
            pub const fn wdtrr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "WDTRR is an 8-bit register that refreshes the down,counter of the WDT."]
            #[inline(always)]
            pub fn set_wdtrr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Wdtrr {
            #[inline(always)]
            fn default() -> Wdtrr {
                Wdtrr(0)
            }
        }
        impl core::fmt::Debug for Wdtrr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtrr")
                    .field("wdtrr", &self.wdtrr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtrr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Wdtrr {{ wdtrr: {=u8:?} }}", self.wdtrr())
            }
        }
        #[doc = "WDT Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtsr(pub u16);
        impl Wdtsr {
            #[doc = "Down,Counter ValueValue counted by the down,counter"]
            #[inline(always)]
            pub const fn cntval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Down,Counter ValueValue counted by the down,counter"]
            #[inline(always)]
            pub fn set_cntval(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u16) & 0x3fff) << 0usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn undff(&self) -> super::vals::Undff {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Undff::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_undff(&mut self, val: super::vals::Undff) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub const fn refef(&self) -> super::vals::Refef {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Refef::from_bits(val as u8)
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub fn set_refef(&mut self, val: super::vals::Refef) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Wdtsr {
            #[inline(always)]
            fn default() -> Wdtsr {
                Wdtsr(0)
            }
        }
        impl core::fmt::Debug for Wdtsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtsr")
                    .field("cntval", &self.cntval())
                    .field("undff", &self.undff())
                    .field("refef", &self.refef())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Wdtsr {{ cntval: {=u16:?}, undff: {:?}, refef: {:?} }}",
                    self.cntval(),
                    self.undff(),
                    self.refef()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cks {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cks {
            #[inline(always)]
            fn from(val: u8) -> Cks {
                Cks::from_bits(val)
            }
        }
        impl From<Cks> for u8 {
            #[inline(always)]
            fn from(val: Cks) -> u8 {
                Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Refef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refef {
            #[inline(always)]
            fn from(val: u8) -> Refef {
                Refef::from_bits(val)
            }
        }
        impl From<Refef> for u8 {
            #[inline(always)]
            fn from(val: Refef) -> u8 {
                Refef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpes {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rpes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpes {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpes {
            #[inline(always)]
            fn from(val: u8) -> Rpes {
                Rpes::from_bits(val)
            }
        }
        impl From<Rpes> for u8 {
            #[inline(always)]
            fn from(val: Rpes) -> u8 {
                Rpes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rpss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpss {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpss {
            #[inline(always)]
            fn from(val: u8) -> Rpss {
                Rpss::from_bits(val)
            }
        }
        impl From<Rpss> for u8 {
            #[inline(always)]
            fn from(val: Rpss) -> u8 {
                Rpss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rstirqs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rstirqs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rstirqs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rstirqs {
            #[inline(always)]
            fn from(val: u8) -> Rstirqs {
                Rstirqs::from_bits(val)
            }
        }
        impl From<Rstirqs> for u8 {
            #[inline(always)]
            fn from(val: Rstirqs) -> u8 {
                Rstirqs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Slcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slcstp {
            #[inline(always)]
            fn from(val: u8) -> Slcstp {
                Slcstp::from_bits(val)
            }
        }
        impl From<Slcstp> for u8 {
            #[inline(always)]
            fn from(val: Slcstp) -> u8 {
                Slcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tops {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tops {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tops {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tops {
            #[inline(always)]
            fn from(val: u8) -> Tops {
                Tops::from_bits(val)
            }
        }
        impl From<Tops> for u8 {
            #[inline(always)]
            fn from(val: Tops) -> u8 {
                Tops::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Undff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Undff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Undff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Undff {
            #[inline(always)]
            fn from(val: u8) -> Undff {
                Undff::from_bits(val)
            }
        }
        impl From<Undff> for u8 {
            #[inline(always)]
            fn from(val: Undff) -> u8 {
                Undff::to_bits(val)
            }
        }
    }
}
