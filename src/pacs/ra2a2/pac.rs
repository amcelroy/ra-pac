#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![doc = "Peripheral access API (generated using chiptool v0.1.0 (d771c7b 2025-03-27))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "0 - ICU Interrupt 0"]
    IEL0 = 0,
    #[doc = "1 - ICU Interrupt 1"]
    IEL1 = 1,
    #[doc = "2 - ICU Interrupt 2"]
    IEL2 = 2,
    #[doc = "3 - ICU Interrupt 3"]
    IEL3 = 3,
    #[doc = "4 - ICU Interrupt 4"]
    IEL4 = 4,
    #[doc = "5 - ICU Interrupt 5"]
    IEL5 = 5,
    #[doc = "6 - ICU Interrupt 6"]
    IEL6 = 6,
    #[doc = "7 - ICU Interrupt 7"]
    IEL7 = 7,
    #[doc = "8 - ICU Interrupt 8"]
    IEL8 = 8,
    #[doc = "9 - ICU Interrupt 9"]
    IEL9 = 9,
    #[doc = "10 - ICU Interrupt 10"]
    IEL10 = 10,
    #[doc = "11 - ICU Interrupt 11"]
    IEL11 = 11,
    #[doc = "12 - ICU Interrupt 12"]
    IEL12 = 12,
    #[doc = "13 - ICU Interrupt 13"]
    IEL13 = 13,
    #[doc = "14 - ICU Interrupt 14"]
    IEL14 = 14,
    #[doc = "15 - ICU Interrupt 15"]
    IEL15 = 15,
    #[doc = "16 - ICU Interrupt 16"]
    IEL16 = 16,
    #[doc = "17 - ICU Interrupt 17"]
    IEL17 = 17,
    #[doc = "18 - ICU Interrupt 18"]
    IEL18 = 18,
    #[doc = "19 - ICU Interrupt 19"]
    IEL19 = 19,
    #[doc = "20 - ICU Interrupt 20"]
    IEL20 = 20,
    #[doc = "21 - ICU Interrupt 21"]
    IEL21 = 21,
    #[doc = "22 - ICU Interrupt 22"]
    IEL22 = 22,
    #[doc = "23 - ICU Interrupt 23"]
    IEL23 = 23,
    #[doc = "24 - ICU Interrupt 24"]
    IEL24 = 24,
    #[doc = "25 - ICU Interrupt 25"]
    IEL25 = 25,
    #[doc = "26 - ICU Interrupt 26"]
    IEL26 = 26,
    #[doc = "27 - ICU Interrupt 27"]
    IEL27 = 27,
    #[doc = "28 - ICU Interrupt 28"]
    IEL28 = 28,
    #[doc = "29 - ICU Interrupt 29"]
    IEL29 = 29,
    #[doc = "30 - ICU Interrupt 30"]
    IEL30 = 30,
    #[doc = "31 - ICU Interrupt 31"]
    IEL31 = 31,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    extern "C" {
        fn IEL0();
        fn IEL1();
        fn IEL2();
        fn IEL3();
        fn IEL4();
        fn IEL5();
        fn IEL6();
        fn IEL7();
        fn IEL8();
        fn IEL9();
        fn IEL10();
        fn IEL11();
        fn IEL12();
        fn IEL13();
        fn IEL14();
        fn IEL15();
        fn IEL16();
        fn IEL17();
        fn IEL18();
        fn IEL19();
        fn IEL20();
        fn IEL21();
        fn IEL22();
        fn IEL23();
        fn IEL24();
        fn IEL25();
        fn IEL26();
        fn IEL27();
        fn IEL28();
        fn IEL29();
        fn IEL30();
        fn IEL31();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    pub static __INTERRUPTS: [Vector; 32] = [
        Vector { _handler: IEL0 },
        Vector { _handler: IEL1 },
        Vector { _handler: IEL2 },
        Vector { _handler: IEL3 },
        Vector { _handler: IEL4 },
        Vector { _handler: IEL5 },
        Vector { _handler: IEL6 },
        Vector { _handler: IEL7 },
        Vector { _handler: IEL8 },
        Vector { _handler: IEL9 },
        Vector { _handler: IEL10 },
        Vector { _handler: IEL11 },
        Vector { _handler: IEL12 },
        Vector { _handler: IEL13 },
        Vector { _handler: IEL14 },
        Vector { _handler: IEL15 },
        Vector { _handler: IEL16 },
        Vector { _handler: IEL17 },
        Vector { _handler: IEL18 },
        Vector { _handler: IEL19 },
        Vector { _handler: IEL20 },
        Vector { _handler: IEL21 },
        Vector { _handler: IEL22 },
        Vector { _handler: IEL23 },
        Vector { _handler: IEL24 },
        Vector { _handler: IEL25 },
        Vector { _handler: IEL26 },
        Vector { _handler: IEL27 },
        Vector { _handler: IEL28 },
        Vector { _handler: IEL29 },
        Vector { _handler: IEL30 },
        Vector { _handler: IEL31 },
    ];
}
#[doc = "Renesas Memory Protection Unit"]
pub const RMPU: rmpu::Rmpu = unsafe { rmpu::Rmpu::from_ptr(0x4000_0000usize as _) };
#[doc = "Memory Mirror Function"]
pub const MMF: mmf::Mmf = unsafe { mmf::Mmf::from_ptr(0x4000_1000usize as _) };
#[doc = "SRAM Control"]
pub const SRAM: sram::Sram = unsafe { sram::Sram::from_ptr(0x4000_2000usize as _) };
#[doc = "BUS Control"]
pub const BUS: bus::Bus = unsafe { bus::Bus::from_ptr(0x4000_3000usize as _) };
#[doc = "Data Transfer Controller"]
pub const DTC: dtc::Dtc = unsafe { dtc::Dtc::from_ptr(0x4000_5400usize as _) };
#[doc = "ICU for CPU"]
pub const ICU: icu::Icu = unsafe { icu::Icu::from_ptr(0x4000_6000usize as _) };
#[doc = "Debug Function"]
pub const DBG: dbg::Dbg = unsafe { dbg::Dbg::from_ptr(0x4001_b000usize as _) };
#[doc = "System Control"]
pub const SYSC: sysc::Sysc = unsafe { sysc::Sysc::from_ptr(0x4001_e000usize as _) };
#[doc = "Port 0 Control Registers"]
pub const PORT0: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0000usize as _) };
#[doc = "Port 1 Control Registers"]
pub const PORT1: port1::Port1 = unsafe { port1::Port1::from_ptr(0x4004_0020usize as _) };
#[doc = "Port 2 Control Registers"]
pub const PORT2: port1::Port1 = unsafe { port1::Port1::from_ptr(0x4004_0040usize as _) };
#[doc = "Port 3 Control Registers"]
pub const PORT3: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0060usize as _) };
#[doc = "Port 4 Control Registers"]
pub const PORT4: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0080usize as _) };
#[doc = "Port 5 Control Registers"]
pub const PORT5: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_00a0usize as _) };
#[doc = "Port 6 Control Registers"]
pub const PORT6: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_00c0usize as _) };
#[doc = "Pmn Pin Function Control Register"]
pub const PFS: pfs::Pfs = unsafe { pfs::Pfs::from_ptr(0x4004_0800usize as _) };
#[doc = "Event Link Controller"]
pub const ELC: elc::Elc = unsafe { elc::Elc::from_ptr(0x4004_1000usize as _) };
#[doc = "Port Output Enable Module for GPT"]
pub const POEG: poeg::Poeg = unsafe { poeg::Poeg::from_ptr(0x4004_2000usize as _) };
#[doc = "Realtime Clock"]
pub const RTC: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x4004_4000usize as _) };
#[doc = "Watchdog Timer"]
pub const WDT: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4004_4200usize as _) };
#[doc = "Independent Watchdog Timer"]
pub const IWDT: iwdt::Iwdt = unsafe { iwdt::Iwdt::from_ptr(0x4004_4400usize as _) };
#[doc = "Clock Frequency Accuracy Measurement Circuit"]
pub const CAC: cac::Cac = unsafe { cac::Cac::from_ptr(0x4004_4600usize as _) };
#[doc = "Module Stop Control A, B, C, D"]
pub const MSTP: mstp::Mstp = unsafe { mstp::Mstp::from_ptr(0x4004_7000usize as _) };
#[doc = "Inter,Integrated Circuit 0"]
pub const IIC0: iic0::Iic0 = unsafe { iic0::Iic0::from_ptr(0x4005_3000usize as _) };
#[doc = "Inter,Integrated Circuit 0 Wake,up Unit"]
pub const IIC0WU: iic0wu::Iic0wu = unsafe { iic0wu::Iic0wu::from_ptr(0x4005_3014usize as _) };
#[doc = "Inter,Integrated Circuit 1"]
pub const IIC1: iic0::Iic0 = unsafe { iic0::Iic0::from_ptr(0x4005_3100usize as _) };
#[doc = "Data Operation Circuit"]
pub const DOC: doc::Doc = unsafe { doc::Doc::from_ptr(0x4005_4100usize as _) };
#[doc = "12-bit A/D Converter"]
pub const ADC120: adc120::Adc120 = unsafe { adc120::Adc120::from_ptr(0x4005_c000usize as _) };
#[doc = "Serial Communication Interface 0"]
pub const SCI0: sci0::Sci0 = unsafe { sci0::Sci0::from_ptr(0x4007_0000usize as _) };
#[doc = "Serial Communication Interface 1"]
pub const SCI1: sci1::Sci1 = unsafe { sci1::Sci1::from_ptr(0x4007_0020usize as _) };
#[doc = "Serial Communication Interface 2"]
pub const SCI2: sci1::Sci1 = unsafe { sci1::Sci1::from_ptr(0x4007_0040usize as _) };
#[doc = "Serial Communication Interface 3"]
pub const SCI3: sci1::Sci1 = unsafe { sci1::Sci1::from_ptr(0x4007_0060usize as _) };
#[doc = "Serial Communication Interface 9"]
pub const SCI9: sci1::Sci1 = unsafe { sci1::Sci1::from_ptr(0x4007_0120usize as _) };
#[doc = "Serial Peripheral Interface"]
pub const SPI0: spi0::Spi0 = unsafe { spi0::Spi0::from_ptr(0x4007_2000usize as _) };
#[doc = "Cyclic Redundancy Check Calculator"]
pub const CRC: crc::Crc = unsafe { crc::Crc::from_ptr(0x4007_4000usize as _) };
#[doc = "General PWM 16-bit Timer 4"]
pub const GPT164: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8400usize as _) };
#[doc = "General PWM 16-bit Timer 5"]
pub const GPT165: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8500usize as _) };
#[doc = "General PWM 16-bit Timer 6"]
pub const GPT166: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8600usize as _) };
#[doc = "General PWM 16-bit Timer 7"]
pub const GPT167: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8700usize as _) };
#[doc = "General PWM 16-bit Timer 8"]
pub const GPT168: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8800usize as _) };
#[doc = "General PWM 16-bit Timer 9"]
pub const GPT169: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8900usize as _) };
#[doc = "Output Phase Switching Controller"]
pub const GPT_OPS: gpt_ops::GptOps = unsafe { gpt_ops::GptOps::from_ptr(0x4007_8ff0usize as _) };
#[doc = "Segment LCD Controller"]
pub const SLCDC: slcdc::Slcdc = unsafe { slcdc::Slcdc::from_ptr(0x4008_2000usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 0"]
pub const AGTW0: agtw0::Agtw0 = unsafe { agtw0::Agtw0::from_ptr(0x4008_4000usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 1"]
pub const AGTW1: agtw0::Agtw0 = unsafe { agtw0::Agtw0::from_ptr(0x4008_4100usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 0"]
pub const AGT0: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4200usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 1"]
pub const AGT1: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4300usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 2"]
pub const AGT2: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4400usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 3"]
pub const AGT3: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4500usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 4"]
pub const AGT4: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4600usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 5"]
pub const AGT5: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4700usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 6"]
pub const AGT6: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4800usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 7"]
pub const AGT7: agt0::Agt0 = unsafe { agt0::Agt0::from_ptr(0x4008_4900usize as _) };
#[doc = "24-Bit Sigma,Delta A/D Converter B"]
pub const SDADC24_B: sdadc24_b::Sdadc24B =
    unsafe { sdadc24_b::Sdadc24B::from_ptr(0x4009_c000usize as _) };
#[doc = "32-bit Multiply,Accumulator"]
pub const MACL: macl::Macl = unsafe { macl::Macl::from_ptr(0x400a_0000usize as _) };
#[doc = "Flash I/O Registers"]
pub const FLCN: flcn::Flcn = unsafe { flcn::Flcn::from_ptr(0x407e_c000usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
#[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
pub mod adc120 {
    #[doc = "12-bit A/D Converter"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Adc120 {
        ptr: *mut u8,
    }
    unsafe impl Send for Adc120 {}
    unsafe impl Sync for Adc120 {}
    impl Adc120 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A/D Control Register"]
        #[inline(always)]
        pub const fn adcsr(self) -> crate::common::Reg<regs::Adcsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "A/D Channel Select Register A0"]
        #[inline(always)]
        pub const fn adansa0(self) -> crate::common::Reg<regs::Adansa0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "A/D,Converted Value Addition/Average Channel Select Register 0"]
        #[inline(always)]
        pub const fn adads0(self) -> crate::common::Reg<regs::Adads0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "A/D,Converted Value Addition/Average Count Select Register"]
        #[inline(always)]
        pub const fn adadc(self) -> crate::common::Reg<regs::Adadc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "A/D Control Extended Register"]
        #[inline(always)]
        pub const fn adcer(self) -> crate::common::Reg<regs::Adcer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "A/D Conversion Start Trigger Select Register"]
        #[inline(always)]
        pub const fn adstrgr(self) -> crate::common::Reg<regs::Adstrgr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "A/D Conversion Extended Input Control Registers"]
        #[inline(always)]
        pub const fn adexicr(self) -> crate::common::Reg<regs::Adexicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "A/D Channel Select Register B0"]
        #[inline(always)]
        pub const fn adansb0(self) -> crate::common::Reg<regs::Adansb0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "A/D Data Duplexing Register"]
        #[inline(always)]
        pub const fn addbldr(self) -> crate::common::Reg<regs::Addbldr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "A/D Temperature Sensor Data Register"]
        #[inline(always)]
        pub const fn adtsdr(self) -> crate::common::Reg<regs::Adtsdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "A/D Internal Reference Voltage Data Register"]
        #[inline(always)]
        pub const fn adocdr(self) -> crate::common::Reg<regs::Adocdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "A/D Self,Diagnosis Data Register"]
        #[inline(always)]
        pub const fn adrd(self) -> crate::common::Reg<regs::Adrd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1eusize) as _) }
        }
        #[doc = "A/D Data Registers %s"]
        #[inline(always)]
        pub const fn addr(self, n: usize) -> crate::common::Reg<regs::Addr, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 2usize) as _) }
        }
        #[doc = "A/D Disconnection Detection Control Register"]
        #[inline(always)]
        pub const fn addiscr(self) -> crate::common::Reg<regs::Addiscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7ausize) as _) }
        }
        #[doc = "A/D Conversion Operation Mode Select Register"]
        #[inline(always)]
        pub const fn adacsr(self) -> crate::common::Reg<regs::Adacsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7eusize) as _) }
        }
        #[doc = "A/D Group Scan Priority Control Register"]
        #[inline(always)]
        pub const fn adgspcr(self) -> crate::common::Reg<regs::Adgspcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "A/D Data Duplexing Register A"]
        #[inline(always)]
        pub const fn addbldra(self) -> crate::common::Reg<regs::Addbldra, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "A/D Data Duplexing Register B"]
        #[inline(always)]
        pub const fn addbldrb(self) -> crate::common::Reg<regs::Addbldrb, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x86usize) as _) }
        }
        #[doc = "A/D High,Potential/Low,Potential Reference Voltage Control Register"]
        #[inline(always)]
        pub const fn adhvrefcnt(self) -> crate::common::Reg<regs::Adhvrefcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8ausize) as _) }
        }
        #[doc = "A/D Compare Function Window A/B Status Monitor Register"]
        #[inline(always)]
        pub const fn adwinmon(self) -> crate::common::Reg<regs::Adwinmon, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "A/D Compare Function Control Register"]
        #[inline(always)]
        pub const fn adcmpcr(self) -> crate::common::Reg<regs::Adcmpcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Extended Input Select Register"]
        #[inline(always)]
        pub const fn adcmpanser(self) -> crate::common::Reg<regs::Adcmpanser, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x92usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Extended Input Comparison Condition Setting Register"]
        #[inline(always)]
        pub const fn adcmpler(self) -> crate::common::Reg<regs::Adcmpler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x93usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 0"]
        #[inline(always)]
        pub const fn adcmpansr0(self) -> crate::common::Reg<regs::Adcmpansr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 0"]
        #[inline(always)]
        pub const fn adcmplr0(self) -> crate::common::Reg<regs::Adcmplr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Lower,Side/Upper,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adcmpdr(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize + n * 2usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register 0"]
        #[inline(always)]
        pub const fn adcmpsr0(self) -> crate::common::Reg<regs::Adcmpsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Extended Input Channel Status Register"]
        #[inline(always)]
        pub const fn adcmpser(self) -> crate::common::Reg<regs::Adcmpser, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "A/D Compare Function Window B Channel Select Register"]
        #[inline(always)]
        pub const fn adcmpbnsr(self) -> crate::common::Reg<regs::Adcmpbnsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa6usize) as _) }
        }
        #[doc = "A/D Compare Function Window B Lower,Side/Upper,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adwinllb(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "A/D Compare Function Window B Lower,Side/Upper,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adwinulb(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xaausize) as _) }
        }
        #[doc = "A/D Compare Function Window B Status Register"]
        #[inline(always)]
        pub const fn adcmpbsr(self) -> crate::common::Reg<regs::Adcmpbsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xacusize) as _) }
        }
        #[doc = "A/D Sampling State Register"]
        #[inline(always)]
        pub const fn adsstrt(self) -> crate::common::Reg<regs::Adsstrt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdeusize) as _) }
        }
        #[doc = "A/D Sampling State Register"]
        #[inline(always)]
        pub const fn adsstro(self) -> crate::common::Reg<regs::Adsstro, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdfusize) as _) }
        }
        #[doc = "A/D Sampling State Register"]
        #[inline(always)]
        pub const fn adsstr(self, n: usize) -> crate::common::Reg<regs::Adsstr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize + n * 1usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "A/D Conversion Operation Mode Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adacsr(pub u8);
        impl Adacsr {
            #[doc = "Successive Approximation Control Setting"]
            #[inline(always)]
            pub const fn adsac(&self) -> super::vals::Adsac {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Adsac::from_bits(val as u8)
            }
            #[doc = "Successive Approximation Control Setting"]
            #[inline(always)]
            pub fn set_adsac(&mut self, val: super::vals::Adsac) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Adacsr {
            #[inline(always)]
            fn default() -> Adacsr {
                Adacsr(0)
            }
        }
        impl core::fmt::Debug for Adacsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adacsr")
                    .field("adsac", &self.adsac())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adacsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adacsr {{ adsac: {:?} }}", self.adsac())
            }
        }
        #[doc = "A/D,Converted Value Addition/Average Count Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adadc(pub u8);
        impl Adadc {
            #[doc = "Addition/Average Count Select"]
            #[inline(always)]
            pub const fn adc(&self) -> super::vals::Adc {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Adc::from_bits(val as u8)
            }
            #[doc = "Addition/Average Count Select"]
            #[inline(always)]
            pub fn set_adc(&mut self, val: super::vals::Adc) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Average Mode Select"]
            #[inline(always)]
            pub const fn avee(&self) -> super::vals::Avee {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Avee::from_bits(val as u8)
            }
            #[doc = "Average Mode Select"]
            #[inline(always)]
            pub fn set_avee(&mut self, val: super::vals::Avee) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Adadc {
            #[inline(always)]
            fn default() -> Adadc {
                Adadc(0)
            }
        }
        impl core::fmt::Debug for Adadc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adadc")
                    .field("adc", &self.adc())
                    .field("avee", &self.avee())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adadc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adadc {{ adc: {:?}, avee: {:?} }}",
                    self.adc(),
                    self.avee()
                )
            }
        }
        #[doc = "A/D,Converted Value Addition/Average Channel Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adads0(pub u16);
        impl Adads0 {
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads0(&self) -> super::vals::Ads0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ads0::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads0(&mut self, val: super::vals::Ads0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads1(&self) -> super::vals::Ads1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ads1::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads1(&mut self, val: super::vals::Ads1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads2(&self) -> super::vals::Ads2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ads2::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads2(&mut self, val: super::vals::Ads2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads3(&self) -> super::vals::Ads3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ads3::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads3(&mut self, val: super::vals::Ads3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Adads0 {
            #[inline(always)]
            fn default() -> Adads0 {
                Adads0(0)
            }
        }
        impl core::fmt::Debug for Adads0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adads0")
                    .field("ads0", &self.ads0())
                    .field("ads1", &self.ads1())
                    .field("ads2", &self.ads2())
                    .field("ads3", &self.ads3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adads0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adads0 {{ ads0: {:?}, ads1: {:?}, ads2: {:?}, ads3: {:?} }}",
                    self.ads0(),
                    self.ads1(),
                    self.ads2(),
                    self.ads3()
                )
            }
        }
        #[doc = "A/D Channel Select Register A0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansa0(pub u16);
        impl Adansa0 {
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa0(&self) -> super::vals::Ansa0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansa0::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa0(&mut self, val: super::vals::Ansa0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa1(&self) -> super::vals::Ansa1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansa1::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa1(&mut self, val: super::vals::Ansa1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa2(&self) -> super::vals::Ansa2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansa2::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa2(&mut self, val: super::vals::Ansa2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa3(&self) -> super::vals::Ansa3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansa3::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa3(&mut self, val: super::vals::Ansa3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Adansa0 {
            #[inline(always)]
            fn default() -> Adansa0 {
                Adansa0(0)
            }
        }
        impl core::fmt::Debug for Adansa0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansa0")
                    .field("ansa0", &self.ansa0())
                    .field("ansa1", &self.ansa1())
                    .field("ansa2", &self.ansa2())
                    .field("ansa3", &self.ansa3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansa0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adansa0 {{ ansa0: {:?}, ansa1: {:?}, ansa2: {:?}, ansa3: {:?} }}",
                    self.ansa0(),
                    self.ansa1(),
                    self.ansa2(),
                    self.ansa3()
                )
            }
        }
        #[doc = "A/D Channel Select Register B0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansb0(pub u16);
        impl Adansb0 {
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb0(&self) -> super::vals::Ansb0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansb0::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb0(&mut self, val: super::vals::Ansb0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb1(&self) -> super::vals::Ansb1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansb1::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb1(&mut self, val: super::vals::Ansb1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb2(&self) -> super::vals::Ansb2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansb2::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb2(&mut self, val: super::vals::Ansb2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb3(&self) -> super::vals::Ansb3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansb3::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb3(&mut self, val: super::vals::Ansb3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Adansb0 {
            #[inline(always)]
            fn default() -> Adansb0 {
                Adansb0(0)
            }
        }
        impl core::fmt::Debug for Adansb0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansb0")
                    .field("ansb0", &self.ansb0())
                    .field("ansb1", &self.ansb1())
                    .field("ansb2", &self.ansb2())
                    .field("ansb3", &self.ansb3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansb0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adansb0 {{ ansb0: {:?}, ansb1: {:?}, ansb2: {:?}, ansb3: {:?} }}",
                    self.ansb0(),
                    self.ansb1(),
                    self.ansb2(),
                    self.ansb3()
                )
            }
        }
        #[doc = "A/D Control Extended Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcer(pub u16);
        impl Adcer {
            #[doc = "A/D Data Register Automatic Clearing Enable"]
            #[inline(always)]
            pub const fn ace(&self) -> super::vals::Ace {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ace::from_bits(val as u8)
            }
            #[doc = "A/D Data Register Automatic Clearing Enable"]
            #[inline(always)]
            pub fn set_ace(&mut self, val: super::vals::Ace) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Self,Diagnosis Conversion Voltage Select"]
            #[inline(always)]
            pub const fn diagval(&self) -> super::vals::Diagval {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Diagval::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Conversion Voltage Select"]
            #[inline(always)]
            pub fn set_diagval(&mut self, val: super::vals::Diagval) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Self,Diagnosis Mode Select"]
            #[inline(always)]
            pub const fn diagld(&self) -> super::vals::Diagld {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Diagld::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Mode Select"]
            #[inline(always)]
            pub fn set_diagld(&mut self, val: super::vals::Diagld) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Self,Diagnosis Enable"]
            #[inline(always)]
            pub const fn diagm(&self) -> super::vals::Diagm {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Diagm::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Enable"]
            #[inline(always)]
            pub fn set_diagm(&mut self, val: super::vals::Diagm) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "A/D Data Register Format Select"]
            #[inline(always)]
            pub const fn adrfmt(&self) -> super::vals::Adrfmt {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Adrfmt::from_bits(val as u8)
            }
            #[doc = "A/D Data Register Format Select"]
            #[inline(always)]
            pub fn set_adrfmt(&mut self, val: super::vals::Adrfmt) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcer {
            #[inline(always)]
            fn default() -> Adcer {
                Adcer(0)
            }
        }
        impl core::fmt::Debug for Adcer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcer")
                    .field("ace", &self.ace())
                    .field("diagval", &self.diagval())
                    .field("diagld", &self.diagld())
                    .field("diagm", &self.diagm())
                    .field("adrfmt", &self.adrfmt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcer {{ ace: {:?}, diagval: {:?}, diagld: {:?}, diagm: {:?}, adrfmt: {:?} }}",
                    self.ace(),
                    self.diagval(),
                    self.diagld(),
                    self.diagm(),
                    self.adrfmt()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Extended Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpanser(pub u8);
        impl Adcmpanser {
            #[doc = "Temperature Sensor Output Compare Select"]
            #[inline(always)]
            pub const fn cmptsa(&self) -> super::vals::Cmptsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmptsa::from_bits(val as u8)
            }
            #[doc = "Temperature Sensor Output Compare Select"]
            #[inline(always)]
            pub fn set_cmptsa(&mut self, val: super::vals::Cmptsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Internal Reference Voltage Compare Select"]
            #[inline(always)]
            pub const fn cmpoca(&self) -> super::vals::Cmpoca {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpoca::from_bits(val as u8)
            }
            #[doc = "Internal Reference Voltage Compare Select"]
            #[inline(always)]
            pub fn set_cmpoca(&mut self, val: super::vals::Cmpoca) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Adcmpanser {
            #[inline(always)]
            fn default() -> Adcmpanser {
                Adcmpanser(0)
            }
        }
        impl core::fmt::Debug for Adcmpanser {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpanser")
                    .field("cmptsa", &self.cmptsa())
                    .field("cmpoca", &self.cmpoca())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpanser {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpanser {{ cmptsa: {:?}, cmpoca: {:?} }}",
                    self.cmptsa(),
                    self.cmpoca()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpansr0(pub u16);
        impl Adcmpansr0 {
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha0(&self) -> super::vals::Cmpcha0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpcha0::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha0(&mut self, val: super::vals::Cmpcha0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha1(&self) -> super::vals::Cmpcha1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpcha1::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha1(&mut self, val: super::vals::Cmpcha1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha2(&self) -> super::vals::Cmpcha2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpcha2::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha2(&mut self, val: super::vals::Cmpcha2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha3(&self) -> super::vals::Cmpcha3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpcha3::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha3(&mut self, val: super::vals::Cmpcha3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Adcmpansr0 {
            #[inline(always)]
            fn default() -> Adcmpansr0 {
                Adcmpansr0(0)
            }
        }
        impl core::fmt::Debug for Adcmpansr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpansr0")
                    .field("cmpcha0", &self.cmpcha0())
                    .field("cmpcha1", &self.cmpcha1())
                    .field("cmpcha2", &self.cmpcha2())
                    .field("cmpcha3", &self.cmpcha3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpansr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpansr0 {{ cmpcha0: {:?}, cmpcha1: {:?}, cmpcha2: {:?}, cmpcha3: {:?} }}",
                    self.cmpcha0(),
                    self.cmpcha1(),
                    self.cmpcha2(),
                    self.cmpcha3()
                )
            }
        }
        #[doc = "A/D Compare Function Window B Channel Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpbnsr(pub u8);
        impl Adcmpbnsr {
            #[doc = "Compare Window B Channel Select"]
            #[inline(always)]
            pub const fn cmpchb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Compare Window B Channel Select"]
            #[inline(always)]
            pub fn set_cmpchb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "Compare Window B Comparison Condition Setting"]
            #[inline(always)]
            pub const fn cmplb(&self) -> super::vals::Cmplb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmplb::from_bits(val as u8)
            }
            #[doc = "Compare Window B Comparison Condition Setting"]
            #[inline(always)]
            pub fn set_cmplb(&mut self, val: super::vals::Cmplb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Adcmpbnsr {
            #[inline(always)]
            fn default() -> Adcmpbnsr {
                Adcmpbnsr(0)
            }
        }
        impl core::fmt::Debug for Adcmpbnsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpbnsr")
                    .field("cmpchb", &self.cmpchb())
                    .field("cmplb", &self.cmplb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpbnsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpbnsr {{ cmpchb: {=u8:?}, cmplb: {:?} }}",
                    self.cmpchb(),
                    self.cmplb()
                )
            }
        }
        #[doc = "A/D Compare Function Window B Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpbsr(pub u8);
        impl Adcmpbsr {
            #[doc = "Compare Window B Flag"]
            #[inline(always)]
            pub const fn cmpstb(&self) -> super::vals::Cmpstb {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpstb::from_bits(val as u8)
            }
            #[doc = "Compare Window B Flag"]
            #[inline(always)]
            pub fn set_cmpstb(&mut self, val: super::vals::Cmpstb) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Adcmpbsr {
            #[inline(always)]
            fn default() -> Adcmpbsr {
                Adcmpbsr(0)
            }
        }
        impl core::fmt::Debug for Adcmpbsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpbsr")
                    .field("cmpstb", &self.cmpstb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpbsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adcmpbsr {{ cmpstb: {:?} }}", self.cmpstb())
            }
        }
        #[doc = "A/D Compare Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpcr(pub u16);
        impl Adcmpcr {
            #[doc = "Window A/B Composite Conditions Setting"]
            #[inline(always)]
            pub const fn cmpab(&self) -> super::vals::Cmpab {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Cmpab::from_bits(val as u8)
            }
            #[doc = "Window A/B Composite Conditions Setting"]
            #[inline(always)]
            pub fn set_cmpab(&mut self, val: super::vals::Cmpab) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Compare Window B Operation Enable"]
            #[inline(always)]
            pub const fn cmpbe(&self) -> super::vals::Cmpbe {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cmpbe::from_bits(val as u8)
            }
            #[doc = "Compare Window B Operation Enable"]
            #[inline(always)]
            pub fn set_cmpbe(&mut self, val: super::vals::Cmpbe) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Compare Window A Operation Enable"]
            #[inline(always)]
            pub const fn cmpae(&self) -> super::vals::Cmpae {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cmpae::from_bits(val as u8)
            }
            #[doc = "Compare Window A Operation Enable"]
            #[inline(always)]
            pub fn set_cmpae(&mut self, val: super::vals::Cmpae) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Compare B Interrupt Enable"]
            #[inline(always)]
            pub const fn cmpbie(&self) -> super::vals::Cmpbie {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cmpbie::from_bits(val as u8)
            }
            #[doc = "Compare B Interrupt Enable"]
            #[inline(always)]
            pub fn set_cmpbie(&mut self, val: super::vals::Cmpbie) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Window Function Setting"]
            #[inline(always)]
            pub const fn wcmpe(&self) -> super::vals::Wcmpe {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Wcmpe::from_bits(val as u8)
            }
            #[doc = "Window Function Setting"]
            #[inline(always)]
            pub fn set_wcmpe(&mut self, val: super::vals::Wcmpe) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Compare A Interrupt Enable"]
            #[inline(always)]
            pub const fn cmpaie(&self) -> super::vals::Cmpaie {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cmpaie::from_bits(val as u8)
            }
            #[doc = "Compare A Interrupt Enable"]
            #[inline(always)]
            pub fn set_cmpaie(&mut self, val: super::vals::Cmpaie) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcmpcr {
            #[inline(always)]
            fn default() -> Adcmpcr {
                Adcmpcr(0)
            }
        }
        impl core::fmt::Debug for Adcmpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpcr")
                    .field("cmpab", &self.cmpab())
                    .field("cmpbe", &self.cmpbe())
                    .field("cmpae", &self.cmpae())
                    .field("cmpbie", &self.cmpbie())
                    .field("wcmpe", &self.wcmpe())
                    .field("cmpaie", &self.cmpaie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpcr {{ cmpab: {:?}, cmpbe: {:?}, cmpae: {:?}, cmpbie: {:?}, wcmpe: {:?}, cmpaie: {:?} }}" , self . cmpab () , self . cmpbe () , self . cmpae () , self . cmpbie () , self . wcmpe () , self . cmpaie ())
            }
        }
        #[doc = "A/D Compare Function Window A Extended Input Comparison Condition Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpler(pub u8);
        impl Adcmpler {
            #[doc = "Compare Window A Temperature Sensor Output Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmpltsa(&self) -> super::vals::Cmpltsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpltsa::from_bits(val as u8)
            }
            #[doc = "Compare Window A Temperature Sensor Output Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmpltsa(&mut self, val: super::vals::Cmpltsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Internal Reference Voltage Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmploca(&self) -> super::vals::Cmploca {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmploca::from_bits(val as u8)
            }
            #[doc = "Compare Window A Internal Reference Voltage Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmploca(&mut self, val: super::vals::Cmploca) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Adcmpler {
            #[inline(always)]
            fn default() -> Adcmpler {
                Adcmpler(0)
            }
        }
        impl core::fmt::Debug for Adcmpler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpler")
                    .field("cmpltsa", &self.cmpltsa())
                    .field("cmploca", &self.cmploca())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpler {{ cmpltsa: {:?}, cmploca: {:?} }}",
                    self.cmpltsa(),
                    self.cmploca()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmplr0(pub u16);
        impl Adcmplr0 {
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha0(&self) -> super::vals::Cmplcha0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmplcha0::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha0(&mut self, val: super::vals::Cmplcha0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha1(&self) -> super::vals::Cmplcha1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmplcha1::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha1(&mut self, val: super::vals::Cmplcha1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha2(&self) -> super::vals::Cmplcha2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmplcha2::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha2(&mut self, val: super::vals::Cmplcha2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha3(&self) -> super::vals::Cmplcha3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmplcha3::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha3(&mut self, val: super::vals::Cmplcha3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Adcmplr0 {
            #[inline(always)]
            fn default() -> Adcmplr0 {
                Adcmplr0(0)
            }
        }
        impl core::fmt::Debug for Adcmplr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmplr0")
                    .field("cmplcha0", &self.cmplcha0())
                    .field("cmplcha1", &self.cmplcha1())
                    .field("cmplcha2", &self.cmplcha2())
                    .field("cmplcha3", &self.cmplcha3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmplr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmplr0 {{ cmplcha0: {:?}, cmplcha1: {:?}, cmplcha2: {:?}, cmplcha3: {:?} }}",
                    self.cmplcha0(),
                    self.cmplcha1(),
                    self.cmplcha2(),
                    self.cmplcha3()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Extended Input Channel Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpser(pub u8);
        impl Adcmpser {
            #[doc = "Compare Window A Temperature Sensor Output Compare Flag"]
            #[inline(always)]
            pub const fn cmpsttsa(&self) -> super::vals::Cmpsttsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpsttsa::from_bits(val as u8)
            }
            #[doc = "Compare Window A Temperature Sensor Output Compare Flag"]
            #[inline(always)]
            pub fn set_cmpsttsa(&mut self, val: super::vals::Cmpsttsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Internal Reference Voltage Compare Flag"]
            #[inline(always)]
            pub const fn cmpstoca(&self) -> super::vals::Cmpstoca {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpstoca::from_bits(val as u8)
            }
            #[doc = "Compare Window A Internal Reference Voltage Compare Flag"]
            #[inline(always)]
            pub fn set_cmpstoca(&mut self, val: super::vals::Cmpstoca) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Adcmpser {
            #[inline(always)]
            fn default() -> Adcmpser {
                Adcmpser(0)
            }
        }
        impl core::fmt::Debug for Adcmpser {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpser")
                    .field("cmpsttsa", &self.cmpsttsa())
                    .field("cmpstoca", &self.cmpstoca())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpser {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpser {{ cmpsttsa: {:?}, cmpstoca: {:?} }}",
                    self.cmpsttsa(),
                    self.cmpstoca()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpsr0(pub u16);
        impl Adcmpsr0 {
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha0(&self) -> super::vals::Cmpstcha0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpstcha0::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha0(&mut self, val: super::vals::Cmpstcha0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha1(&self) -> super::vals::Cmpstcha1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpstcha1::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha1(&mut self, val: super::vals::Cmpstcha1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha2(&self) -> super::vals::Cmpstcha2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpstcha2::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha2(&mut self, val: super::vals::Cmpstcha2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha3(&self) -> super::vals::Cmpstcha3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpstcha3::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha3(&mut self, val: super::vals::Cmpstcha3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Adcmpsr0 {
            #[inline(always)]
            fn default() -> Adcmpsr0 {
                Adcmpsr0(0)
            }
        }
        impl core::fmt::Debug for Adcmpsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpsr0")
                    .field("cmpstcha0", &self.cmpstcha0())
                    .field("cmpstcha1", &self.cmpstcha1())
                    .field("cmpstcha2", &self.cmpstcha2())
                    .field("cmpstcha3", &self.cmpstcha3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpsr0 {{ cmpstcha0: {:?}, cmpstcha1: {:?}, cmpstcha2: {:?}, cmpstcha3: {:?} }}" , self . cmpstcha0 () , self . cmpstcha1 () , self . cmpstcha2 () , self . cmpstcha3 ())
            }
        }
        #[doc = "A/D Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcsr(pub u16);
        impl Adcsr {
            #[doc = "Double Trigger Channel Select"]
            #[inline(always)]
            pub const fn dblans(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Double Trigger Channel Select"]
            #[inline(always)]
            pub fn set_dblans(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u16) & 0x03) << 0usize);
            }
            #[doc = "Group B Scan End Interrupt and ELC Event Enable"]
            #[inline(always)]
            pub const fn gbadie(&self) -> super::vals::Gbadie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Gbadie::from_bits(val as u8)
            }
            #[doc = "Group B Scan End Interrupt and ELC Event Enable"]
            #[inline(always)]
            pub fn set_gbadie(&mut self, val: super::vals::Gbadie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Double Trigger Mode Select"]
            #[inline(always)]
            pub const fn dble(&self) -> super::vals::Dble {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dble::from_bits(val as u8)
            }
            #[doc = "Double Trigger Mode Select"]
            #[inline(always)]
            pub fn set_dble(&mut self, val: super::vals::Dble) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Trigger Select"]
            #[inline(always)]
            pub const fn extrg(&self) -> super::vals::Extrg {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Extrg::from_bits(val as u8)
            }
            #[doc = "Trigger Select"]
            #[inline(always)]
            pub fn set_extrg(&mut self, val: super::vals::Extrg) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Trigger Start Enable"]
            #[inline(always)]
            pub const fn trge(&self) -> super::vals::Trge {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Trge::from_bits(val as u8)
            }
            #[doc = "Trigger Start Enable"]
            #[inline(always)]
            pub fn set_trge(&mut self, val: super::vals::Trge) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "A/D Conversion Mode Select"]
            #[inline(always)]
            pub const fn adhsc(&self) -> super::vals::Adhsc {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Adhsc::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Mode Select"]
            #[inline(always)]
            pub fn set_adhsc(&mut self, val: super::vals::Adhsc) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Scan Mode Select"]
            #[inline(always)]
            pub const fn adcs(&self) -> super::vals::Adcs {
                let val = (self.0 >> 13usize) & 0x03;
                super::vals::Adcs::from_bits(val as u8)
            }
            #[doc = "Scan Mode Select"]
            #[inline(always)]
            pub fn set_adcs(&mut self, val: super::vals::Adcs) {
                self.0 =
                    (self.0 & !(0x03 << 13usize)) | (((val.to_bits() as u16) & 0x03) << 13usize);
            }
            #[doc = "A/D Conversion Start"]
            #[inline(always)]
            pub const fn adst(&self) -> super::vals::Adst {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Adst::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Start"]
            #[inline(always)]
            pub fn set_adst(&mut self, val: super::vals::Adst) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcsr {
            #[inline(always)]
            fn default() -> Adcsr {
                Adcsr(0)
            }
        }
        impl core::fmt::Debug for Adcsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcsr")
                    .field("dblans", &self.dblans())
                    .field("gbadie", &self.gbadie())
                    .field("dble", &self.dble())
                    .field("extrg", &self.extrg())
                    .field("trge", &self.trge())
                    .field("adhsc", &self.adhsc())
                    .field("adcs", &self.adcs())
                    .field("adst", &self.adst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcsr {{ dblans: {=u8:?}, gbadie: {:?}, dble: {:?}, extrg: {:?}, trge: {:?}, adhsc: {:?}, adcs: {:?}, adst: {:?} }}" , self . dblans () , self . gbadie () , self . dble () , self . extrg () , self . trge () , self . adhsc () , self . adcs () , self . adst ())
            }
        }
        #[doc = "A/D Data Duplexing Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addbldr(pub u16);
        impl Addbldr {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addbldr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addbldr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addbldr {
            #[inline(always)]
            fn default() -> Addbldr {
                Addbldr(0)
            }
        }
        impl core::fmt::Debug for Addbldr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addbldr")
                    .field("addbldr", &self.addbldr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addbldr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addbldr {{ addbldr: {=u16:?} }}", self.addbldr())
            }
        }
        #[doc = "A/D Data Duplexing Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addbldra(pub u16);
        impl Addbldra {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addbldr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addbldr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addbldra {
            #[inline(always)]
            fn default() -> Addbldra {
                Addbldra(0)
            }
        }
        impl core::fmt::Debug for Addbldra {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addbldra")
                    .field("addbldr", &self.addbldr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addbldra {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addbldra {{ addbldr: {=u16:?} }}", self.addbldr())
            }
        }
        #[doc = "A/D Data Duplexing Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addbldrb(pub u16);
        impl Addbldrb {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addbldr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addbldr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addbldrb {
            #[inline(always)]
            fn default() -> Addbldrb {
                Addbldrb(0)
            }
        }
        impl core::fmt::Debug for Addbldrb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addbldrb")
                    .field("addbldr", &self.addbldr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addbldrb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addbldrb {{ addbldr: {=u16:?} }}", self.addbldr())
            }
        }
        #[doc = "A/D Disconnection Detection Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addiscr(pub u8);
        impl Addiscr {
            #[doc = "Disconnection Detection Assist Setting"]
            #[inline(always)]
            pub const fn adndis(&self) -> super::vals::Adndis {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Adndis::from_bits(val as u8)
            }
            #[doc = "Disconnection Detection Assist Setting"]
            #[inline(always)]
            pub fn set_adndis(&mut self, val: super::vals::Adndis) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u8) & 0x0f) << 0usize);
            }
            #[doc = "Precharge/discharge select"]
            #[inline(always)]
            pub const fn pchg(&self) -> super::vals::Pchg {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pchg::from_bits(val as u8)
            }
            #[doc = "Precharge/discharge select"]
            #[inline(always)]
            pub fn set_pchg(&mut self, val: super::vals::Pchg) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Addiscr {
            #[inline(always)]
            fn default() -> Addiscr {
                Addiscr(0)
            }
        }
        impl core::fmt::Debug for Addiscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addiscr")
                    .field("adndis", &self.adndis())
                    .field("pchg", &self.pchg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addiscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Addiscr {{ adndis: {:?}, pchg: {:?} }}",
                    self.adndis(),
                    self.pchg()
                )
            }
        }
        #[doc = "A/D Data Registers %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addr(pub u16);
        impl Addr {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addr {
            #[inline(always)]
            fn default() -> Addr {
                Addr(0)
            }
        }
        impl core::fmt::Debug for Addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addr").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addr {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "A/D Conversion Extended Input Control Registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adexicr(pub u16);
        impl Adexicr {
            #[doc = "Temperature Sensor Output A/D,Converted Value Addition/Average Mode Select"]
            #[inline(always)]
            pub const fn tssad(&self) -> super::vals::Tssad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tssad::from_bits(val as u8)
            }
            #[doc = "Temperature Sensor Output A/D,Converted Value Addition/Average Mode Select"]
            #[inline(always)]
            pub fn set_tssad(&mut self, val: super::vals::Tssad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Internal Reference Voltage A/D,Converted Value Addition/Average Mode Select"]
            #[inline(always)]
            pub const fn ocsad(&self) -> super::vals::Ocsad {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ocsad::from_bits(val as u8)
            }
            #[doc = "Internal Reference Voltage A/D,Converted Value Addition/Average Mode Select"]
            #[inline(always)]
            pub fn set_ocsad(&mut self, val: super::vals::Ocsad) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Temperature Sensor Output A/D Conversion Select"]
            #[inline(always)]
            pub const fn tssa(&self) -> super::vals::Tssa {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Tssa::from_bits(val as u8)
            }
            #[doc = "Temperature Sensor Output A/D Conversion Select"]
            #[inline(always)]
            pub fn set_tssa(&mut self, val: super::vals::Tssa) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Internal Reference Voltage A/D Conversion Select"]
            #[inline(always)]
            pub const fn ocsa(&self) -> super::vals::Ocsa {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ocsa::from_bits(val as u8)
            }
            #[doc = "Internal Reference Voltage A/D Conversion Select"]
            #[inline(always)]
            pub fn set_ocsa(&mut self, val: super::vals::Ocsa) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
        }
        impl Default for Adexicr {
            #[inline(always)]
            fn default() -> Adexicr {
                Adexicr(0)
            }
        }
        impl core::fmt::Debug for Adexicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adexicr")
                    .field("tssad", &self.tssad())
                    .field("ocsad", &self.ocsad())
                    .field("tssa", &self.tssa())
                    .field("ocsa", &self.ocsa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adexicr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adexicr {{ tssad: {:?}, ocsad: {:?}, tssa: {:?}, ocsa: {:?} }}",
                    self.tssad(),
                    self.ocsad(),
                    self.tssa(),
                    self.ocsa()
                )
            }
        }
        #[doc = "A/D Group Scan Priority Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adgspcr(pub u16);
        impl Adgspcr {
            #[doc = "Group Priority Operation Setting"]
            #[inline(always)]
            pub const fn pgs(&self) -> super::vals::Pgs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pgs::from_bits(val as u8)
            }
            #[doc = "Group Priority Operation Setting"]
            #[inline(always)]
            pub fn set_pgs(&mut self, val: super::vals::Pgs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Lower,Priority Group Restart Setting"]
            #[inline(always)]
            pub const fn gbrscn(&self) -> super::vals::Gbrscn {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Gbrscn::from_bits(val as u8)
            }
            #[doc = "Lower,Priority Group Restart Setting"]
            #[inline(always)]
            pub fn set_gbrscn(&mut self, val: super::vals::Gbrscn) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Single Scan Continuous Start"]
            #[inline(always)]
            pub const fn gbrp(&self) -> super::vals::Gbrp {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Gbrp::from_bits(val as u8)
            }
            #[doc = "Single Scan Continuous Start"]
            #[inline(always)]
            pub fn set_gbrp(&mut self, val: super::vals::Gbrp) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adgspcr {
            #[inline(always)]
            fn default() -> Adgspcr {
                Adgspcr(0)
            }
        }
        impl core::fmt::Debug for Adgspcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adgspcr")
                    .field("pgs", &self.pgs())
                    .field("gbrscn", &self.gbrscn())
                    .field("gbrp", &self.gbrp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adgspcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adgspcr {{ pgs: {:?}, gbrscn: {:?}, gbrp: {:?} }}",
                    self.pgs(),
                    self.gbrscn(),
                    self.gbrp()
                )
            }
        }
        #[doc = "A/D High,Potential/Low,Potential Reference Voltage Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adhvrefcnt(pub u8);
        impl Adhvrefcnt {
            #[doc = "High,Potential Reference Voltage Select"]
            #[inline(always)]
            pub const fn hvsel(&self) -> super::vals::Hvsel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Hvsel::from_bits(val as u8)
            }
            #[doc = "High,Potential Reference Voltage Select"]
            #[inline(always)]
            pub fn set_hvsel(&mut self, val: super::vals::Hvsel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Low,Potential Reference Voltage Select"]
            #[inline(always)]
            pub const fn lvsel(&self) -> super::vals::Lvsel {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Lvsel::from_bits(val as u8)
            }
            #[doc = "Low,Potential Reference Voltage Select"]
            #[inline(always)]
            pub fn set_lvsel(&mut self, val: super::vals::Lvsel) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Sleep"]
            #[inline(always)]
            pub const fn adslp(&self) -> super::vals::Adslp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Adslp::from_bits(val as u8)
            }
            #[doc = "Sleep"]
            #[inline(always)]
            pub fn set_adslp(&mut self, val: super::vals::Adslp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Adhvrefcnt {
            #[inline(always)]
            fn default() -> Adhvrefcnt {
                Adhvrefcnt(0)
            }
        }
        impl core::fmt::Debug for Adhvrefcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adhvrefcnt")
                    .field("hvsel", &self.hvsel())
                    .field("lvsel", &self.lvsel())
                    .field("adslp", &self.adslp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adhvrefcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adhvrefcnt {{ hvsel: {:?}, lvsel: {:?}, adslp: {:?} }}",
                    self.hvsel(),
                    self.lvsel(),
                    self.adslp()
                )
            }
        }
        #[doc = "A/D Internal Reference Voltage Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adocdr(pub u16);
        impl Adocdr {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn adocdr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_adocdr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adocdr {
            #[inline(always)]
            fn default() -> Adocdr {
                Adocdr(0)
            }
        }
        impl core::fmt::Debug for Adocdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adocdr")
                    .field("adocdr", &self.adocdr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adocdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adocdr {{ adocdr: {=u16:?} }}", self.adocdr())
            }
        }
        #[doc = "A/D Self,Diagnosis Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adrd(pub u16);
        impl Adrd {
            #[doc = "Converted Value 11 to 0"]
            #[inline(always)]
            pub const fn ad(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Converted Value 11 to 0"]
            #[inline(always)]
            pub fn set_ad(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u16) & 0x0fff) << 0usize);
            }
            #[doc = "Self,Diagnosis Status"]
            #[inline(always)]
            pub const fn diagst(&self) -> super::vals::Diagst {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Diagst::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Status"]
            #[inline(always)]
            pub fn set_diagst(&mut self, val: super::vals::Diagst) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Adrd {
            #[inline(always)]
            fn default() -> Adrd {
                Adrd(0)
            }
        }
        impl core::fmt::Debug for Adrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adrd")
                    .field("ad", &self.ad())
                    .field("diagst", &self.diagst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adrd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adrd {{ ad: {=u16:?}, diagst: {:?} }}",
                    self.ad(),
                    self.diagst()
                )
            }
        }
        #[doc = "A/D Sampling State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstr(pub u8);
        impl Adsstr {
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstr {
            #[inline(always)]
            fn default() -> Adsstr {
                Adsstr(0)
            }
        }
        impl core::fmt::Debug for Adsstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstr").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstr {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Sampling State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstro(pub u8);
        impl Adsstro {
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstro {
            #[inline(always)]
            fn default() -> Adsstro {
                Adsstro(0)
            }
        }
        impl core::fmt::Debug for Adsstro {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstro").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstro {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstro {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Sampling State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstrt(pub u8);
        impl Adsstrt {
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstrt {
            #[inline(always)]
            fn default() -> Adsstrt {
                Adsstrt(0)
            }
        }
        impl core::fmt::Debug for Adsstrt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstrt").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstrt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstrt {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Conversion Start Trigger Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adstrgr(pub u16);
        impl Adstrgr {
            #[doc = "A/D Conversion Start Trigger Select for Group B"]
            #[inline(always)]
            pub const fn trsb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "A/D Conversion Start Trigger Select for Group B"]
            #[inline(always)]
            pub fn set_trsb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u16) & 0x3f) << 0usize);
            }
            #[doc = "A/D Conversion Start Trigger Select"]
            #[inline(always)]
            pub const fn trsa(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "A/D Conversion Start Trigger Select"]
            #[inline(always)]
            pub fn set_trsa(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u16) & 0x3f) << 8usize);
            }
        }
        impl Default for Adstrgr {
            #[inline(always)]
            fn default() -> Adstrgr {
                Adstrgr(0)
            }
        }
        impl core::fmt::Debug for Adstrgr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adstrgr")
                    .field("trsb", &self.trsb())
                    .field("trsa", &self.trsa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adstrgr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adstrgr {{ trsb: {=u8:?}, trsa: {=u8:?} }}",
                    self.trsb(),
                    self.trsa()
                )
            }
        }
        #[doc = "A/D Temperature Sensor Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adtsdr(pub u16);
        impl Adtsdr {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn adtsdr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_adtsdr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adtsdr {
            #[inline(always)]
            fn default() -> Adtsdr {
                Adtsdr(0)
            }
        }
        impl core::fmt::Debug for Adtsdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adtsdr")
                    .field("adtsdr", &self.adtsdr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adtsdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adtsdr {{ adtsdr: {=u16:?} }}", self.adtsdr())
            }
        }
        #[doc = "A/D Compare Function Window A/B Status Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adwinmon(pub u8);
        impl Adwinmon {
            #[doc = "Combination Result Monitor"]
            #[inline(always)]
            pub const fn moncomb(&self) -> super::vals::Moncomb {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Moncomb::from_bits(val as u8)
            }
            #[doc = "Combination Result Monitor"]
            #[inline(always)]
            pub fn set_moncomb(&mut self, val: super::vals::Moncomb) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Comparison Result Monitor A"]
            #[inline(always)]
            pub const fn moncmpa(&self) -> super::vals::Moncmpa {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Moncmpa::from_bits(val as u8)
            }
            #[doc = "Comparison Result Monitor A"]
            #[inline(always)]
            pub fn set_moncmpa(&mut self, val: super::vals::Moncmpa) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Comparison Result Monitor B"]
            #[inline(always)]
            pub const fn moncmpb(&self) -> super::vals::Moncmpb {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Moncmpb::from_bits(val as u8)
            }
            #[doc = "Comparison Result Monitor B"]
            #[inline(always)]
            pub fn set_moncmpb(&mut self, val: super::vals::Moncmpb) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Adwinmon {
            #[inline(always)]
            fn default() -> Adwinmon {
                Adwinmon(0)
            }
        }
        impl core::fmt::Debug for Adwinmon {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adwinmon")
                    .field("moncomb", &self.moncomb())
                    .field("moncmpa", &self.moncmpa())
                    .field("moncmpb", &self.moncmpb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adwinmon {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adwinmon {{ moncomb: {:?}, moncmpa: {:?}, moncmpb: {:?} }}",
                    self.moncomb(),
                    self.moncmpa(),
                    self.moncmpb()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ace {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ace {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ace {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ace {
            #[inline(always)]
            fn from(val: u8) -> Ace {
                Ace::from_bits(val)
            }
        }
        impl From<Ace> for u8 {
            #[inline(always)]
            fn from(val: Ace) -> u8 {
                Ace::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Adc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adc {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adc {
            #[inline(always)]
            fn from(val: u8) -> Adc {
                Adc::from_bits(val)
            }
        }
        impl From<Adc> for u8 {
            #[inline(always)]
            fn from(val: Adc) -> u8 {
                Adc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Adcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adcs {
            #[inline(always)]
            fn from(val: u8) -> Adcs {
                Adcs::from_bits(val)
            }
        }
        impl From<Adcs> for u8 {
            #[inline(always)]
            fn from(val: Adcs) -> u8 {
                Adcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adhsc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adhsc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adhsc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adhsc {
            #[inline(always)]
            fn from(val: u8) -> Adhsc {
                Adhsc::from_bits(val)
            }
        }
        impl From<Adhsc> for u8 {
            #[inline(always)]
            fn from(val: Adhsc) -> u8 {
                Adhsc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adndis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Adndis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adndis {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adndis {
            #[inline(always)]
            fn from(val: u8) -> Adndis {
                Adndis::from_bits(val)
            }
        }
        impl From<Adndis> for u8 {
            #[inline(always)]
            fn from(val: Adndis) -> u8 {
                Adndis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adrfmt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adrfmt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adrfmt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adrfmt {
            #[inline(always)]
            fn from(val: u8) -> Adrfmt {
                Adrfmt::from_bits(val)
            }
        }
        impl From<Adrfmt> for u8 {
            #[inline(always)]
            fn from(val: Adrfmt) -> u8 {
                Adrfmt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads0 {
            #[inline(always)]
            fn from(val: u8) -> Ads0 {
                Ads0::from_bits(val)
            }
        }
        impl From<Ads0> for u8 {
            #[inline(always)]
            fn from(val: Ads0) -> u8 {
                Ads0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads1 {
            #[inline(always)]
            fn from(val: u8) -> Ads1 {
                Ads1::from_bits(val)
            }
        }
        impl From<Ads1> for u8 {
            #[inline(always)]
            fn from(val: Ads1) -> u8 {
                Ads1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads2 {
            #[inline(always)]
            fn from(val: u8) -> Ads2 {
                Ads2::from_bits(val)
            }
        }
        impl From<Ads2> for u8 {
            #[inline(always)]
            fn from(val: Ads2) -> u8 {
                Ads2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads3 {
            #[inline(always)]
            fn from(val: u8) -> Ads3 {
                Ads3::from_bits(val)
            }
        }
        impl From<Ads3> for u8 {
            #[inline(always)]
            fn from(val: Ads3) -> u8 {
                Ads3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adsac {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adsac {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adsac {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adsac {
            #[inline(always)]
            fn from(val: u8) -> Adsac {
                Adsac::from_bits(val)
            }
        }
        impl From<Adsac> for u8 {
            #[inline(always)]
            fn from(val: Adsac) -> u8 {
                Adsac::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adslp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adslp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adslp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adslp {
            #[inline(always)]
            fn from(val: u8) -> Adslp {
                Adslp::from_bits(val)
            }
        }
        impl From<Adslp> for u8 {
            #[inline(always)]
            fn from(val: Adslp) -> u8 {
                Adslp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adst {
            #[inline(always)]
            fn from(val: u8) -> Adst {
                Adst::from_bits(val)
            }
        }
        impl From<Adst> for u8 {
            #[inline(always)]
            fn from(val: Adst) -> u8 {
                Adst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa0 {
            #[inline(always)]
            fn from(val: u8) -> Ansa0 {
                Ansa0::from_bits(val)
            }
        }
        impl From<Ansa0> for u8 {
            #[inline(always)]
            fn from(val: Ansa0) -> u8 {
                Ansa0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa1 {
            #[inline(always)]
            fn from(val: u8) -> Ansa1 {
                Ansa1::from_bits(val)
            }
        }
        impl From<Ansa1> for u8 {
            #[inline(always)]
            fn from(val: Ansa1) -> u8 {
                Ansa1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa2 {
            #[inline(always)]
            fn from(val: u8) -> Ansa2 {
                Ansa2::from_bits(val)
            }
        }
        impl From<Ansa2> for u8 {
            #[inline(always)]
            fn from(val: Ansa2) -> u8 {
                Ansa2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa3 {
            #[inline(always)]
            fn from(val: u8) -> Ansa3 {
                Ansa3::from_bits(val)
            }
        }
        impl From<Ansa3> for u8 {
            #[inline(always)]
            fn from(val: Ansa3) -> u8 {
                Ansa3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb0 {
            #[inline(always)]
            fn from(val: u8) -> Ansb0 {
                Ansb0::from_bits(val)
            }
        }
        impl From<Ansb0> for u8 {
            #[inline(always)]
            fn from(val: Ansb0) -> u8 {
                Ansb0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb1 {
            #[inline(always)]
            fn from(val: u8) -> Ansb1 {
                Ansb1::from_bits(val)
            }
        }
        impl From<Ansb1> for u8 {
            #[inline(always)]
            fn from(val: Ansb1) -> u8 {
                Ansb1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb2 {
            #[inline(always)]
            fn from(val: u8) -> Ansb2 {
                Ansb2::from_bits(val)
            }
        }
        impl From<Ansb2> for u8 {
            #[inline(always)]
            fn from(val: Ansb2) -> u8 {
                Ansb2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb3 {
            #[inline(always)]
            fn from(val: u8) -> Ansb3 {
                Ansb3::from_bits(val)
            }
        }
        impl From<Ansb3> for u8 {
            #[inline(always)]
            fn from(val: Ansb3) -> u8 {
                Ansb3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Avee {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Avee {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Avee {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Avee {
            #[inline(always)]
            fn from(val: u8) -> Avee {
                Avee::from_bits(val)
            }
        }
        impl From<Avee> for u8 {
            #[inline(always)]
            fn from(val: Avee) -> u8 {
                Avee::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpab {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cmpab {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpab {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpab {
            #[inline(always)]
            fn from(val: u8) -> Cmpab {
                Cmpab::from_bits(val)
            }
        }
        impl From<Cmpab> for u8 {
            #[inline(always)]
            fn from(val: Cmpab) -> u8 {
                Cmpab::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpae {
            #[inline(always)]
            fn from(val: u8) -> Cmpae {
                Cmpae::from_bits(val)
            }
        }
        impl From<Cmpae> for u8 {
            #[inline(always)]
            fn from(val: Cmpae) -> u8 {
                Cmpae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpaie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpaie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpaie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpaie {
            #[inline(always)]
            fn from(val: u8) -> Cmpaie {
                Cmpaie::from_bits(val)
            }
        }
        impl From<Cmpaie> for u8 {
            #[inline(always)]
            fn from(val: Cmpaie) -> u8 {
                Cmpaie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpbe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpbe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpbe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpbe {
            #[inline(always)]
            fn from(val: u8) -> Cmpbe {
                Cmpbe::from_bits(val)
            }
        }
        impl From<Cmpbe> for u8 {
            #[inline(always)]
            fn from(val: Cmpbe) -> u8 {
                Cmpbe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpbie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpbie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpbie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpbie {
            #[inline(always)]
            fn from(val: u8) -> Cmpbie {
                Cmpbie::from_bits(val)
            }
        }
        impl From<Cmpbie> for u8 {
            #[inline(always)]
            fn from(val: Cmpbie) -> u8 {
                Cmpbie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha0 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha0 {
                Cmpcha0::from_bits(val)
            }
        }
        impl From<Cmpcha0> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha0) -> u8 {
                Cmpcha0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha1 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha1 {
                Cmpcha1::from_bits(val)
            }
        }
        impl From<Cmpcha1> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha1) -> u8 {
                Cmpcha1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha2 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha2 {
                Cmpcha2::from_bits(val)
            }
        }
        impl From<Cmpcha2> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha2) -> u8 {
                Cmpcha2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha3 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha3 {
                Cmpcha3::from_bits(val)
            }
        }
        impl From<Cmpcha3> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha3) -> u8 {
                Cmpcha3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplb {
            #[inline(always)]
            fn from(val: u8) -> Cmplb {
                Cmplb::from_bits(val)
            }
        }
        impl From<Cmplb> for u8 {
            #[inline(always)]
            fn from(val: Cmplb) -> u8 {
                Cmplb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha0 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha0 {
                Cmplcha0::from_bits(val)
            }
        }
        impl From<Cmplcha0> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha0) -> u8 {
                Cmplcha0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha1 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha1 {
                Cmplcha1::from_bits(val)
            }
        }
        impl From<Cmplcha1> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha1) -> u8 {
                Cmplcha1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha2 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha2 {
                Cmplcha2::from_bits(val)
            }
        }
        impl From<Cmplcha2> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha2) -> u8 {
                Cmplcha2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha3 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha3 {
                Cmplcha3::from_bits(val)
            }
        }
        impl From<Cmplcha3> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha3) -> u8 {
                Cmplcha3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmploca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmploca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmploca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmploca {
            #[inline(always)]
            fn from(val: u8) -> Cmploca {
                Cmploca::from_bits(val)
            }
        }
        impl From<Cmploca> for u8 {
            #[inline(always)]
            fn from(val: Cmploca) -> u8 {
                Cmploca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpltsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpltsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpltsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpltsa {
            #[inline(always)]
            fn from(val: u8) -> Cmpltsa {
                Cmpltsa::from_bits(val)
            }
        }
        impl From<Cmpltsa> for u8 {
            #[inline(always)]
            fn from(val: Cmpltsa) -> u8 {
                Cmpltsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpoca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpoca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpoca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpoca {
            #[inline(always)]
            fn from(val: u8) -> Cmpoca {
                Cmpoca::from_bits(val)
            }
        }
        impl From<Cmpoca> for u8 {
            #[inline(always)]
            fn from(val: Cmpoca) -> u8 {
                Cmpoca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstb {
            #[inline(always)]
            fn from(val: u8) -> Cmpstb {
                Cmpstb::from_bits(val)
            }
        }
        impl From<Cmpstb> for u8 {
            #[inline(always)]
            fn from(val: Cmpstb) -> u8 {
                Cmpstb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha0 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha0 {
                Cmpstcha0::from_bits(val)
            }
        }
        impl From<Cmpstcha0> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha0) -> u8 {
                Cmpstcha0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha1 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha1 {
                Cmpstcha1::from_bits(val)
            }
        }
        impl From<Cmpstcha1> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha1) -> u8 {
                Cmpstcha1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha2 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha2 {
                Cmpstcha2::from_bits(val)
            }
        }
        impl From<Cmpstcha2> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha2) -> u8 {
                Cmpstcha2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha3 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha3 {
                Cmpstcha3::from_bits(val)
            }
        }
        impl From<Cmpstcha3> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha3) -> u8 {
                Cmpstcha3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstoca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstoca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstoca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstoca {
            #[inline(always)]
            fn from(val: u8) -> Cmpstoca {
                Cmpstoca::from_bits(val)
            }
        }
        impl From<Cmpstoca> for u8 {
            #[inline(always)]
            fn from(val: Cmpstoca) -> u8 {
                Cmpstoca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpsttsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpsttsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpsttsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpsttsa {
            #[inline(always)]
            fn from(val: u8) -> Cmpsttsa {
                Cmpsttsa::from_bits(val)
            }
        }
        impl From<Cmpsttsa> for u8 {
            #[inline(always)]
            fn from(val: Cmpsttsa) -> u8 {
                Cmpsttsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmptsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmptsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmptsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmptsa {
            #[inline(always)]
            fn from(val: u8) -> Cmptsa {
                Cmptsa::from_bits(val)
            }
        }
        impl From<Cmptsa> for u8 {
            #[inline(always)]
            fn from(val: Cmptsa) -> u8 {
                Cmptsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dble {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dble {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dble {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dble {
            #[inline(always)]
            fn from(val: u8) -> Dble {
                Dble::from_bits(val)
            }
        }
        impl From<Dble> for u8 {
            #[inline(always)]
            fn from(val: Dble) -> u8 {
                Dble::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Diagld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagld {
            #[inline(always)]
            fn from(val: u8) -> Diagld {
                Diagld::from_bits(val)
            }
        }
        impl From<Diagld> for u8 {
            #[inline(always)]
            fn from(val: Diagld) -> u8 {
                Diagld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Diagm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagm {
            #[inline(always)]
            fn from(val: u8) -> Diagm {
                Diagm::from_bits(val)
            }
        }
        impl From<Diagm> for u8 {
            #[inline(always)]
            fn from(val: Diagm) -> u8 {
                Diagm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Diagst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagst {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagst {
            #[inline(always)]
            fn from(val: u8) -> Diagst {
                Diagst::from_bits(val)
            }
        }
        impl From<Diagst> for u8 {
            #[inline(always)]
            fn from(val: Diagst) -> u8 {
                Diagst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagval {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Diagval {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagval {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagval {
            #[inline(always)]
            fn from(val: u8) -> Diagval {
                Diagval::from_bits(val)
            }
        }
        impl From<Diagval> for u8 {
            #[inline(always)]
            fn from(val: Diagval) -> u8 {
                Diagval::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extrg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Extrg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extrg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extrg {
            #[inline(always)]
            fn from(val: u8) -> Extrg {
                Extrg::from_bits(val)
            }
        }
        impl From<Extrg> for u8 {
            #[inline(always)]
            fn from(val: Extrg) -> u8 {
                Extrg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gbadie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gbadie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gbadie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gbadie {
            #[inline(always)]
            fn from(val: u8) -> Gbadie {
                Gbadie::from_bits(val)
            }
        }
        impl From<Gbadie> for u8 {
            #[inline(always)]
            fn from(val: Gbadie) -> u8 {
                Gbadie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gbrp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gbrp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gbrp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gbrp {
            #[inline(always)]
            fn from(val: u8) -> Gbrp {
                Gbrp::from_bits(val)
            }
        }
        impl From<Gbrp> for u8 {
            #[inline(always)]
            fn from(val: Gbrp) -> u8 {
                Gbrp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gbrscn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gbrscn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gbrscn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gbrscn {
            #[inline(always)]
            fn from(val: u8) -> Gbrscn {
                Gbrscn::from_bits(val)
            }
        }
        impl From<Gbrscn> for u8 {
            #[inline(always)]
            fn from(val: Gbrscn) -> u8 {
                Gbrscn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hvsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Hvsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hvsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hvsel {
            #[inline(always)]
            fn from(val: u8) -> Hvsel {
                Hvsel::from_bits(val)
            }
        }
        impl From<Hvsel> for u8 {
            #[inline(always)]
            fn from(val: Hvsel) -> u8 {
                Hvsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvsel {
            #[inline(always)]
            fn from(val: u8) -> Lvsel {
                Lvsel::from_bits(val)
            }
        }
        impl From<Lvsel> for u8 {
            #[inline(always)]
            fn from(val: Lvsel) -> u8 {
                Lvsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moncmpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moncmpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moncmpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moncmpa {
            #[inline(always)]
            fn from(val: u8) -> Moncmpa {
                Moncmpa::from_bits(val)
            }
        }
        impl From<Moncmpa> for u8 {
            #[inline(always)]
            fn from(val: Moncmpa) -> u8 {
                Moncmpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moncmpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moncmpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moncmpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moncmpb {
            #[inline(always)]
            fn from(val: u8) -> Moncmpb {
                Moncmpb::from_bits(val)
            }
        }
        impl From<Moncmpb> for u8 {
            #[inline(always)]
            fn from(val: Moncmpb) -> u8 {
                Moncmpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moncomb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moncomb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moncomb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moncomb {
            #[inline(always)]
            fn from(val: u8) -> Moncomb {
                Moncomb::from_bits(val)
            }
        }
        impl From<Moncomb> for u8 {
            #[inline(always)]
            fn from(val: Moncomb) -> u8 {
                Moncomb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ocsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ocsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ocsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ocsa {
            #[inline(always)]
            fn from(val: u8) -> Ocsa {
                Ocsa::from_bits(val)
            }
        }
        impl From<Ocsa> for u8 {
            #[inline(always)]
            fn from(val: Ocsa) -> u8 {
                Ocsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ocsad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ocsad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ocsad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ocsad {
            #[inline(always)]
            fn from(val: u8) -> Ocsad {
                Ocsad::from_bits(val)
            }
        }
        impl From<Ocsad> for u8 {
            #[inline(always)]
            fn from(val: Ocsad) -> u8 {
                Ocsad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pchg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pchg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pchg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pchg {
            #[inline(always)]
            fn from(val: u8) -> Pchg {
                Pchg::from_bits(val)
            }
        }
        impl From<Pchg> for u8 {
            #[inline(always)]
            fn from(val: Pchg) -> u8 {
                Pchg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgs {
            #[inline(always)]
            fn from(val: u8) -> Pgs {
                Pgs::from_bits(val)
            }
        }
        impl From<Pgs> for u8 {
            #[inline(always)]
            fn from(val: Pgs) -> u8 {
                Pgs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trge {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trge {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trge {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trge {
            #[inline(always)]
            fn from(val: u8) -> Trge {
                Trge::from_bits(val)
            }
        }
        impl From<Trge> for u8 {
            #[inline(always)]
            fn from(val: Trge) -> u8 {
                Trge::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tssa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tssa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tssa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tssa {
            #[inline(always)]
            fn from(val: u8) -> Tssa {
                Tssa::from_bits(val)
            }
        }
        impl From<Tssa> for u8 {
            #[inline(always)]
            fn from(val: Tssa) -> u8 {
                Tssa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tssad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tssad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tssad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tssad {
            #[inline(always)]
            fn from(val: u8) -> Tssad {
                Tssad::from_bits(val)
            }
        }
        impl From<Tssad> for u8 {
            #[inline(always)]
            fn from(val: Tssad) -> u8 {
                Tssad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wcmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wcmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wcmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wcmpe {
            #[inline(always)]
            fn from(val: u8) -> Wcmpe {
                Wcmpe::from_bits(val)
            }
        }
        impl From<Wcmpe> for u8 {
            #[inline(always)]
            fn from(val: Wcmpe) -> u8 {
                Wcmpe::to_bits(val)
            }
        }
    }
}
pub mod agt0 {
    #[doc = "Low Power Asynchronous General Purpose Timer 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Agt0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Agt0 {}
    unsafe impl Sync for Agt0 {}
    impl Agt0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "AGT Counter Register"]
        #[inline(always)]
        pub const fn agt(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "AGT Compare Match A Register"]
        #[inline(always)]
        pub const fn agtcma(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "AGT Compare Match B Register"]
        #[inline(always)]
        pub const fn agtcmb(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "AGT Control Register"]
        #[inline(always)]
        pub const fn agtcr(self) -> crate::common::Reg<regs::Agtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "AGT Mode Register 1"]
        #[inline(always)]
        pub const fn agtmr1(self) -> crate::common::Reg<regs::Agtmr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "AGT Mode Register 2"]
        #[inline(always)]
        pub const fn agtmr2(self) -> crate::common::Reg<regs::Agtmr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "AGT I/O Control Register"]
        #[inline(always)]
        pub const fn agtioc(self) -> crate::common::Reg<regs::Agtioc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "AGT Event Pin Select Register"]
        #[inline(always)]
        pub const fn agtisr(self) -> crate::common::Reg<regs::Agtisr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "AGT Compare Match Function Select Register"]
        #[inline(always)]
        pub const fn agtcmsr(self) -> crate::common::Reg<regs::Agtcmsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "AGT Pin Select Register"]
        #[inline(always)]
        pub const fn agtiosel(self) -> crate::common::Reg<regs::Agtiosel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "AGT Compare Match Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcmsr(pub u8);
        impl Agtcmsr {
            #[doc = "AGT Compare Match A Register Enable"]
            #[inline(always)]
            pub const fn tcmea(&self) -> super::vals::Tcmea {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tcmea::from_bits(val as u8)
            }
            #[doc = "AGT Compare Match A Register Enable"]
            #[inline(always)]
            pub fn set_tcmea(&mut self, val: super::vals::Tcmea) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AGTOAn Pin Output Enable"]
            #[inline(always)]
            pub const fn toea(&self) -> super::vals::Toea {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Toea::from_bits(val as u8)
            }
            #[doc = "AGTOAn Pin Output Enable"]
            #[inline(always)]
            pub fn set_toea(&mut self, val: super::vals::Toea) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AGTOAn Pin Polarity Select"]
            #[inline(always)]
            pub const fn topola(&self) -> super::vals::Topola {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Topola::from_bits(val as u8)
            }
            #[doc = "AGTOAn Pin Polarity Select"]
            #[inline(always)]
            pub fn set_topola(&mut self, val: super::vals::Topola) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "AGT Compare Match B Register Enable"]
            #[inline(always)]
            pub const fn tcmeb(&self) -> super::vals::Tcmeb {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tcmeb::from_bits(val as u8)
            }
            #[doc = "AGT Compare Match B Register Enable"]
            #[inline(always)]
            pub fn set_tcmeb(&mut self, val: super::vals::Tcmeb) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "AGTOBn Pin Output Enable"]
            #[inline(always)]
            pub const fn toeb(&self) -> super::vals::Toeb {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Toeb::from_bits(val as u8)
            }
            #[doc = "AGTOBn Pin Output Enable"]
            #[inline(always)]
            pub fn set_toeb(&mut self, val: super::vals::Toeb) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "AGTOBn Pin Polarity Select"]
            #[inline(always)]
            pub const fn topolb(&self) -> super::vals::Topolb {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Topolb::from_bits(val as u8)
            }
            #[doc = "AGTOBn Pin Polarity Select"]
            #[inline(always)]
            pub fn set_topolb(&mut self, val: super::vals::Topolb) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Agtcmsr {
            #[inline(always)]
            fn default() -> Agtcmsr {
                Agtcmsr(0)
            }
        }
        impl core::fmt::Debug for Agtcmsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcmsr")
                    .field("tcmea", &self.tcmea())
                    .field("toea", &self.toea())
                    .field("topola", &self.topola())
                    .field("tcmeb", &self.tcmeb())
                    .field("toeb", &self.toeb())
                    .field("topolb", &self.topolb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcmsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Agtcmsr {{ tcmea: {:?}, toea: {:?}, topola: {:?}, tcmeb: {:?}, toeb: {:?}, topolb: {:?} }}" , self . tcmea () , self . toea () , self . topola () , self . tcmeb () , self . toeb () , self . topolb ())
            }
        }
        #[doc = "AGT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcr(pub u8);
        impl Agtcr {
            #[doc = "AGT Count Start"]
            #[inline(always)]
            pub const fn tstart(&self) -> super::vals::Tstart {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tstart::from_bits(val as u8)
            }
            #[doc = "AGT Count Start"]
            #[inline(always)]
            pub fn set_tstart(&mut self, val: super::vals::Tstart) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AGT Count Status Flag"]
            #[inline(always)]
            pub const fn tcstf(&self) -> super::vals::Tcstf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tcstf::from_bits(val as u8)
            }
            #[doc = "AGT Count Status Flag"]
            #[inline(always)]
            pub fn set_tcstf(&mut self, val: super::vals::Tcstf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AGT Count Forced Stop"]
            #[inline(always)]
            pub const fn tstop(&self) -> super::vals::Tstop {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tstop::from_bits(val as u8)
            }
            #[doc = "AGT Count Forced Stop"]
            #[inline(always)]
            pub fn set_tstop(&mut self, val: super::vals::Tstop) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Active Edge Judgment Flag"]
            #[inline(always)]
            pub const fn tedgf(&self) -> super::vals::Tedgf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tedgf::from_bits(val as u8)
            }
            #[doc = "Active Edge Judgment Flag"]
            #[inline(always)]
            pub fn set_tedgf(&mut self, val: super::vals::Tedgf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn tundf(&self) -> super::vals::Tundf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tundf::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_tundf(&mut self, val: super::vals::Tundf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Compare Match A Flag"]
            #[inline(always)]
            pub const fn tcmaf(&self) -> super::vals::Tcmaf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tcmaf::from_bits(val as u8)
            }
            #[doc = "Compare Match A Flag"]
            #[inline(always)]
            pub fn set_tcmaf(&mut self, val: super::vals::Tcmaf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Compare Match B Flag"]
            #[inline(always)]
            pub const fn tcmbf(&self) -> super::vals::Tcmbf {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tcmbf::from_bits(val as u8)
            }
            #[doc = "Compare Match B Flag"]
            #[inline(always)]
            pub fn set_tcmbf(&mut self, val: super::vals::Tcmbf) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtcr {
            #[inline(always)]
            fn default() -> Agtcr {
                Agtcr(0)
            }
        }
        impl core::fmt::Debug for Agtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcr")
                    .field("tstart", &self.tstart())
                    .field("tcstf", &self.tcstf())
                    .field("tstop", &self.tstop())
                    .field("tedgf", &self.tedgf())
                    .field("tundf", &self.tundf())
                    .field("tcmaf", &self.tcmaf())
                    .field("tcmbf", &self.tcmbf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Agtcr {{ tstart: {:?}, tcstf: {:?}, tstop: {:?}, tedgf: {:?}, tundf: {:?}, tcmaf: {:?}, tcmbf: {:?} }}" , self . tstart () , self . tcstf () , self . tstop () , self . tedgf () , self . tundf () , self . tcmaf () , self . tcmbf ())
            }
        }
        #[doc = "AGT I/O Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtioc(pub u8);
        impl Agtioc {
            #[doc = "I/O Polarity Switch"]
            #[inline(always)]
            pub const fn tedgsel(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "I/O Polarity Switch"]
            #[inline(always)]
            pub fn set_tedgsel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "AGTOn pin Output Enable"]
            #[inline(always)]
            pub const fn toe(&self) -> super::vals::Toe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Toe::from_bits(val as u8)
            }
            #[doc = "AGTOn pin Output Enable"]
            #[inline(always)]
            pub fn set_toe(&mut self, val: super::vals::Toe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Input Filter"]
            #[inline(always)]
            pub const fn tipf(&self) -> super::vals::Tipf {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Tipf::from_bits(val as u8)
            }
            #[doc = "Input Filter"]
            #[inline(always)]
            pub fn set_tipf(&mut self, val: super::vals::Tipf) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "Count Control"]
            #[inline(always)]
            pub const fn tiogt(&self) -> super::vals::Tiogt {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tiogt::from_bits(val as u8)
            }
            #[doc = "Count Control"]
            #[inline(always)]
            pub fn set_tiogt(&mut self, val: super::vals::Tiogt) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Agtioc {
            #[inline(always)]
            fn default() -> Agtioc {
                Agtioc(0)
            }
        }
        impl core::fmt::Debug for Agtioc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtioc")
                    .field("tedgsel", &self.tedgsel())
                    .field("toe", &self.toe())
                    .field("tipf", &self.tipf())
                    .field("tiogt", &self.tiogt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtioc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtioc {{ tedgsel: {=bool:?}, toe: {:?}, tipf: {:?}, tiogt: {:?} }}",
                    self.tedgsel(),
                    self.toe(),
                    self.tipf(),
                    self.tiogt()
                )
            }
        }
        #[doc = "AGT Pin Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtiosel(pub u8);
        impl Agtiosel {
            #[doc = "AGTIOn Pin Input Enable"]
            #[inline(always)]
            pub const fn ties(&self) -> super::vals::Ties {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ties::from_bits(val as u8)
            }
            #[doc = "AGTIOn Pin Input Enable"]
            #[inline(always)]
            pub fn set_ties(&mut self, val: super::vals::Ties) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Agtiosel {
            #[inline(always)]
            fn default() -> Agtiosel {
                Agtiosel(0)
            }
        }
        impl core::fmt::Debug for Agtiosel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtiosel")
                    .field("ties", &self.ties())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtiosel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Agtiosel {{ ties: {:?} }}", self.ties())
            }
        }
        #[doc = "AGT Event Pin Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtisr(pub u8);
        impl Agtisr {
            #[doc = "AGTEEn Polarity Selection"]
            #[inline(always)]
            pub const fn eeps(&self) -> super::vals::Eeps {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Eeps::from_bits(val as u8)
            }
            #[doc = "AGTEEn Polarity Selection"]
            #[inline(always)]
            pub fn set_eeps(&mut self, val: super::vals::Eeps) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Agtisr {
            #[inline(always)]
            fn default() -> Agtisr {
                Agtisr(0)
            }
        }
        impl core::fmt::Debug for Agtisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtisr")
                    .field("eeps", &self.eeps())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Agtisr {{ eeps: {:?} }}", self.eeps())
            }
        }
        #[doc = "AGT Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtmr1(pub u8);
        impl Agtmr1 {
            #[doc = "Operating Mode"]
            #[inline(always)]
            pub const fn tmod(&self) -> super::vals::Tmod {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Tmod::from_bits(val as u8)
            }
            #[doc = "Operating Mode"]
            #[inline(always)]
            pub fn set_tmod(&mut self, val: super::vals::Tmod) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Edge Polarity"]
            #[inline(always)]
            pub const fn tedgpl(&self) -> super::vals::Tedgpl {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tedgpl::from_bits(val as u8)
            }
            #[doc = "Edge Polarity"]
            #[inline(always)]
            pub fn set_tedgpl(&mut self, val: super::vals::Tedgpl) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Count Source"]
            #[inline(always)]
            pub const fn tck(&self) -> super::vals::Tck {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Tck::from_bits(val as u8)
            }
            #[doc = "Count Source"]
            #[inline(always)]
            pub fn set_tck(&mut self, val: super::vals::Tck) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Agtmr1 {
            #[inline(always)]
            fn default() -> Agtmr1 {
                Agtmr1(0)
            }
        }
        impl core::fmt::Debug for Agtmr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtmr1")
                    .field("tmod", &self.tmod())
                    .field("tedgpl", &self.tedgpl())
                    .field("tck", &self.tck())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtmr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtmr1 {{ tmod: {:?}, tedgpl: {:?}, tck: {:?} }}",
                    self.tmod(),
                    self.tedgpl(),
                    self.tck()
                )
            }
        }
        #[doc = "AGT Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtmr2(pub u8);
        impl Agtmr2 {
            #[doc = "AGTLCLK or AGTSCLK Count Source Clock Frequency Division Ratio"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Cks {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Cks::from_bits(val as u8)
            }
            #[doc = "AGTLCLK or AGTSCLK Count Source Clock Frequency Division Ratio"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Cks) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Low Power Mode"]
            #[inline(always)]
            pub const fn lpm(&self) -> super::vals::Lpm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lpm::from_bits(val as u8)
            }
            #[doc = "Low Power Mode"]
            #[inline(always)]
            pub fn set_lpm(&mut self, val: super::vals::Lpm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtmr2 {
            #[inline(always)]
            fn default() -> Agtmr2 {
                Agtmr2(0)
            }
        }
        impl core::fmt::Debug for Agtmr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtmr2")
                    .field("cks", &self.cks())
                    .field("lpm", &self.lpm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtmr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtmr2 {{ cks: {:?}, lpm: {:?} }}",
                    self.cks(),
                    self.lpm()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cks {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cks {
            #[inline(always)]
            fn from(val: u8) -> Cks {
                Cks::from_bits(val)
            }
        }
        impl From<Cks> for u8 {
            #[inline(always)]
            fn from(val: Cks) -> u8 {
                Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eeps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eeps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eeps {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eeps {
            #[inline(always)]
            fn from(val: u8) -> Eeps {
                Eeps::from_bits(val)
            }
        }
        impl From<Eeps> for u8 {
            #[inline(always)]
            fn from(val: Eeps) -> u8 {
                Eeps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lpm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpm {
            #[inline(always)]
            fn from(val: u8) -> Lpm {
                Lpm::from_bits(val)
            }
        }
        impl From<Lpm> for u8 {
            #[inline(always)]
            fn from(val: Lpm) -> u8 {
                Lpm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tck {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tck {
            #[inline(always)]
            fn from(val: u8) -> Tck {
                Tck::from_bits(val)
            }
        }
        impl From<Tck> for u8 {
            #[inline(always)]
            fn from(val: Tck) -> u8 {
                Tck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmaf {
            #[inline(always)]
            fn from(val: u8) -> Tcmaf {
                Tcmaf::from_bits(val)
            }
        }
        impl From<Tcmaf> for u8 {
            #[inline(always)]
            fn from(val: Tcmaf) -> u8 {
                Tcmaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmbf {
            #[inline(always)]
            fn from(val: u8) -> Tcmbf {
                Tcmbf::from_bits(val)
            }
        }
        impl From<Tcmbf> for u8 {
            #[inline(always)]
            fn from(val: Tcmbf) -> u8 {
                Tcmbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmea {
            #[inline(always)]
            fn from(val: u8) -> Tcmea {
                Tcmea::from_bits(val)
            }
        }
        impl From<Tcmea> for u8 {
            #[inline(always)]
            fn from(val: Tcmea) -> u8 {
                Tcmea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmeb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmeb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmeb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmeb {
            #[inline(always)]
            fn from(val: u8) -> Tcmeb {
                Tcmeb::from_bits(val)
            }
        }
        impl From<Tcmeb> for u8 {
            #[inline(always)]
            fn from(val: Tcmeb) -> u8 {
                Tcmeb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcstf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcstf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcstf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcstf {
            #[inline(always)]
            fn from(val: u8) -> Tcstf {
                Tcstf::from_bits(val)
            }
        }
        impl From<Tcstf> for u8 {
            #[inline(always)]
            fn from(val: Tcstf) -> u8 {
                Tcstf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tedgf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tedgf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tedgf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tedgf {
            #[inline(always)]
            fn from(val: u8) -> Tedgf {
                Tedgf::from_bits(val)
            }
        }
        impl From<Tedgf> for u8 {
            #[inline(always)]
            fn from(val: Tedgf) -> u8 {
                Tedgf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tedgpl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tedgpl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tedgpl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tedgpl {
            #[inline(always)]
            fn from(val: u8) -> Tedgpl {
                Tedgpl::from_bits(val)
            }
        }
        impl From<Tedgpl> for u8 {
            #[inline(always)]
            fn from(val: Tedgpl) -> u8 {
                Tedgpl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ties {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ties {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ties {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ties {
            #[inline(always)]
            fn from(val: u8) -> Ties {
                Ties::from_bits(val)
            }
        }
        impl From<Ties> for u8 {
            #[inline(always)]
            fn from(val: Ties) -> u8 {
                Ties::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tiogt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tiogt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tiogt {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tiogt {
            #[inline(always)]
            fn from(val: u8) -> Tiogt {
                Tiogt::from_bits(val)
            }
        }
        impl From<Tiogt> for u8 {
            #[inline(always)]
            fn from(val: Tiogt) -> u8 {
                Tiogt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tipf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tipf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tipf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tipf {
            #[inline(always)]
            fn from(val: u8) -> Tipf {
                Tipf::from_bits(val)
            }
        }
        impl From<Tipf> for u8 {
            #[inline(always)]
            fn from(val: Tipf) -> u8 {
                Tipf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmod {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmod {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmod {
            #[inline(always)]
            fn from(val: u8) -> Tmod {
                Tmod::from_bits(val)
            }
        }
        impl From<Tmod> for u8 {
            #[inline(always)]
            fn from(val: Tmod) -> u8 {
                Tmod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toe {
            #[inline(always)]
            fn from(val: u8) -> Toe {
                Toe::from_bits(val)
            }
        }
        impl From<Toe> for u8 {
            #[inline(always)]
            fn from(val: Toe) -> u8 {
                Toe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toea {
            #[inline(always)]
            fn from(val: u8) -> Toea {
                Toea::from_bits(val)
            }
        }
        impl From<Toea> for u8 {
            #[inline(always)]
            fn from(val: Toea) -> u8 {
                Toea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toeb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toeb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toeb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toeb {
            #[inline(always)]
            fn from(val: u8) -> Toeb {
                Toeb::from_bits(val)
            }
        }
        impl From<Toeb> for u8 {
            #[inline(always)]
            fn from(val: Toeb) -> u8 {
                Toeb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Topola {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Topola {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Topola {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Topola {
            #[inline(always)]
            fn from(val: u8) -> Topola {
                Topola::from_bits(val)
            }
        }
        impl From<Topola> for u8 {
            #[inline(always)]
            fn from(val: Topola) -> u8 {
                Topola::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Topolb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Topolb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Topolb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Topolb {
            #[inline(always)]
            fn from(val: u8) -> Topolb {
                Topolb::from_bits(val)
            }
        }
        impl From<Topolb> for u8 {
            #[inline(always)]
            fn from(val: Topolb) -> u8 {
                Topolb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstart {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstart {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstart {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstart {
            #[inline(always)]
            fn from(val: u8) -> Tstart {
                Tstart::from_bits(val)
            }
        }
        impl From<Tstart> for u8 {
            #[inline(always)]
            fn from(val: Tstart) -> u8 {
                Tstart::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstop {
            #[inline(always)]
            fn from(val: u8) -> Tstop {
                Tstop::from_bits(val)
            }
        }
        impl From<Tstop> for u8 {
            #[inline(always)]
            fn from(val: Tstop) -> u8 {
                Tstop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tundf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tundf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tundf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tundf {
            #[inline(always)]
            fn from(val: u8) -> Tundf {
                Tundf::from_bits(val)
            }
        }
        impl From<Tundf> for u8 {
            #[inline(always)]
            fn from(val: Tundf) -> u8 {
                Tundf::to_bits(val)
            }
        }
    }
}
pub mod agtw0 {
    #[doc = "Low Power Asynchronous General Purpose Timer 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Agtw0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Agtw0 {}
    unsafe impl Sync for Agtw0 {}
    impl Agtw0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "AGT Counter Register"]
        #[inline(always)]
        pub const fn agt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "AGT Compare Match A Register"]
        #[inline(always)]
        pub const fn agtcma(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "AGT Compare Match B Register"]
        #[inline(always)]
        pub const fn agtcmb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "AGT Control Register"]
        #[inline(always)]
        pub const fn agtcr(self) -> crate::common::Reg<regs::Agtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "AGT Mode Register 1"]
        #[inline(always)]
        pub const fn agtmr1(self) -> crate::common::Reg<regs::Agtmr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "AGT Mode Register 2"]
        #[inline(always)]
        pub const fn agtmr2(self) -> crate::common::Reg<regs::Agtmr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "AGT Pin Select Register"]
        #[inline(always)]
        pub const fn agtiosel(self) -> crate::common::Reg<regs::Agtiosel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
        #[doc = "AGT I/O Control Register"]
        #[inline(always)]
        pub const fn agtioc(self) -> crate::common::Reg<regs::Agtioc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "AGT Event Pin Select Register"]
        #[inline(always)]
        pub const fn agtisr(self) -> crate::common::Reg<regs::Agtisr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
        #[doc = "AGT Compare Match Function Select Register"]
        #[inline(always)]
        pub const fn agtcmsr(self) -> crate::common::Reg<regs::Agtcmsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "AGT Compare Match Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcmsr(pub u8);
        impl Agtcmsr {
            #[doc = "AGT Compare Match A Register Enable"]
            #[inline(always)]
            pub const fn tcmea(&self) -> super::vals::Tcmea {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tcmea::from_bits(val as u8)
            }
            #[doc = "AGT Compare Match A Register Enable"]
            #[inline(always)]
            pub fn set_tcmea(&mut self, val: super::vals::Tcmea) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AGTWOAn Pin Output Enable"]
            #[inline(always)]
            pub const fn toea(&self) -> super::vals::Toea {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Toea::from_bits(val as u8)
            }
            #[doc = "AGTWOAn Pin Output Enable"]
            #[inline(always)]
            pub fn set_toea(&mut self, val: super::vals::Toea) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AGTWOAn Pin Polarity Select"]
            #[inline(always)]
            pub const fn topola(&self) -> super::vals::Topola {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Topola::from_bits(val as u8)
            }
            #[doc = "AGTWOAn Pin Polarity Select"]
            #[inline(always)]
            pub fn set_topola(&mut self, val: super::vals::Topola) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "AGT Compare Match B Register Enable"]
            #[inline(always)]
            pub const fn tcmeb(&self) -> super::vals::Tcmeb {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tcmeb::from_bits(val as u8)
            }
            #[doc = "AGT Compare Match B Register Enable"]
            #[inline(always)]
            pub fn set_tcmeb(&mut self, val: super::vals::Tcmeb) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "AGTWOBn Pin Output Enable"]
            #[inline(always)]
            pub const fn toeb(&self) -> super::vals::Toeb {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Toeb::from_bits(val as u8)
            }
            #[doc = "AGTWOBn Pin Output Enable"]
            #[inline(always)]
            pub fn set_toeb(&mut self, val: super::vals::Toeb) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "AGTWOBn Pin Polarity Select"]
            #[inline(always)]
            pub const fn topolb(&self) -> super::vals::Topolb {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Topolb::from_bits(val as u8)
            }
            #[doc = "AGTWOBn Pin Polarity Select"]
            #[inline(always)]
            pub fn set_topolb(&mut self, val: super::vals::Topolb) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Agtcmsr {
            #[inline(always)]
            fn default() -> Agtcmsr {
                Agtcmsr(0)
            }
        }
        impl core::fmt::Debug for Agtcmsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcmsr")
                    .field("tcmea", &self.tcmea())
                    .field("toea", &self.toea())
                    .field("topola", &self.topola())
                    .field("tcmeb", &self.tcmeb())
                    .field("toeb", &self.toeb())
                    .field("topolb", &self.topolb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcmsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Agtcmsr {{ tcmea: {:?}, toea: {:?}, topola: {:?}, tcmeb: {:?}, toeb: {:?}, topolb: {:?} }}" , self . tcmea () , self . toea () , self . topola () , self . tcmeb () , self . toeb () , self . topolb ())
            }
        }
        #[doc = "AGT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcr(pub u8);
        impl Agtcr {
            #[doc = "AGT Count Start"]
            #[inline(always)]
            pub const fn tstart(&self) -> super::vals::Tstart {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tstart::from_bits(val as u8)
            }
            #[doc = "AGT Count Start"]
            #[inline(always)]
            pub fn set_tstart(&mut self, val: super::vals::Tstart) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AGT Count Status Flag"]
            #[inline(always)]
            pub const fn tcstf(&self) -> super::vals::Tcstf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tcstf::from_bits(val as u8)
            }
            #[doc = "AGT Count Status Flag"]
            #[inline(always)]
            pub fn set_tcstf(&mut self, val: super::vals::Tcstf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AGT Count Forced Stop"]
            #[inline(always)]
            pub const fn tstop(&self) -> super::vals::Tstop {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tstop::from_bits(val as u8)
            }
            #[doc = "AGT Count Forced Stop"]
            #[inline(always)]
            pub fn set_tstop(&mut self, val: super::vals::Tstop) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Active Edge Judgment Flag"]
            #[inline(always)]
            pub const fn tedgf(&self) -> super::vals::Tedgf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tedgf::from_bits(val as u8)
            }
            #[doc = "Active Edge Judgment Flag"]
            #[inline(always)]
            pub fn set_tedgf(&mut self, val: super::vals::Tedgf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn tundf(&self) -> super::vals::Tundf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tundf::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_tundf(&mut self, val: super::vals::Tundf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Compare Match A Flag"]
            #[inline(always)]
            pub const fn tcmaf(&self) -> super::vals::Tcmaf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tcmaf::from_bits(val as u8)
            }
            #[doc = "Compare Match A Flag"]
            #[inline(always)]
            pub fn set_tcmaf(&mut self, val: super::vals::Tcmaf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Compare Match B Flag"]
            #[inline(always)]
            pub const fn tcmbf(&self) -> super::vals::Tcmbf {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tcmbf::from_bits(val as u8)
            }
            #[doc = "Compare Match B Flag"]
            #[inline(always)]
            pub fn set_tcmbf(&mut self, val: super::vals::Tcmbf) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtcr {
            #[inline(always)]
            fn default() -> Agtcr {
                Agtcr(0)
            }
        }
        impl core::fmt::Debug for Agtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcr")
                    .field("tstart", &self.tstart())
                    .field("tcstf", &self.tcstf())
                    .field("tstop", &self.tstop())
                    .field("tedgf", &self.tedgf())
                    .field("tundf", &self.tundf())
                    .field("tcmaf", &self.tcmaf())
                    .field("tcmbf", &self.tcmbf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Agtcr {{ tstart: {:?}, tcstf: {:?}, tstop: {:?}, tedgf: {:?}, tundf: {:?}, tcmaf: {:?}, tcmbf: {:?} }}" , self . tstart () , self . tcstf () , self . tstop () , self . tedgf () , self . tundf () , self . tcmaf () , self . tcmbf ())
            }
        }
        #[doc = "AGT I/O Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtioc(pub u8);
        impl Agtioc {
            #[doc = "I/O Polarity Switch"]
            #[inline(always)]
            pub const fn tedgsel(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "I/O Polarity Switch"]
            #[inline(always)]
            pub fn set_tedgsel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "AGTWOn pin Output Enable"]
            #[inline(always)]
            pub const fn toe(&self) -> super::vals::Toe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Toe::from_bits(val as u8)
            }
            #[doc = "AGTWOn pin Output Enable"]
            #[inline(always)]
            pub fn set_toe(&mut self, val: super::vals::Toe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Input Filter"]
            #[inline(always)]
            pub const fn tipf(&self) -> super::vals::Tipf {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Tipf::from_bits(val as u8)
            }
            #[doc = "Input Filter"]
            #[inline(always)]
            pub fn set_tipf(&mut self, val: super::vals::Tipf) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "Count Control"]
            #[inline(always)]
            pub const fn tiogt(&self) -> super::vals::Tiogt {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tiogt::from_bits(val as u8)
            }
            #[doc = "Count Control"]
            #[inline(always)]
            pub fn set_tiogt(&mut self, val: super::vals::Tiogt) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Agtioc {
            #[inline(always)]
            fn default() -> Agtioc {
                Agtioc(0)
            }
        }
        impl core::fmt::Debug for Agtioc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtioc")
                    .field("tedgsel", &self.tedgsel())
                    .field("toe", &self.toe())
                    .field("tipf", &self.tipf())
                    .field("tiogt", &self.tiogt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtioc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtioc {{ tedgsel: {=bool:?}, toe: {:?}, tipf: {:?}, tiogt: {:?} }}",
                    self.tedgsel(),
                    self.toe(),
                    self.tipf(),
                    self.tiogt()
                )
            }
        }
        #[doc = "AGT Pin Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtiosel(pub u8);
        impl Agtiosel {
            #[doc = "AGTWIOn Pin Input Enable"]
            #[inline(always)]
            pub const fn ties(&self) -> super::vals::Ties {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ties::from_bits(val as u8)
            }
            #[doc = "AGTWIOn Pin Input Enable"]
            #[inline(always)]
            pub fn set_ties(&mut self, val: super::vals::Ties) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Agtiosel {
            #[inline(always)]
            fn default() -> Agtiosel {
                Agtiosel(0)
            }
        }
        impl core::fmt::Debug for Agtiosel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtiosel")
                    .field("ties", &self.ties())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtiosel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Agtiosel {{ ties: {:?} }}", self.ties())
            }
        }
        #[doc = "AGT Event Pin Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtisr(pub u8);
        impl Agtisr {
            #[doc = "AGTWEEn Polarity Selection"]
            #[inline(always)]
            pub const fn eeps(&self) -> super::vals::Eeps {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Eeps::from_bits(val as u8)
            }
            #[doc = "AGTWEEn Polarity Selection"]
            #[inline(always)]
            pub fn set_eeps(&mut self, val: super::vals::Eeps) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Agtisr {
            #[inline(always)]
            fn default() -> Agtisr {
                Agtisr(0)
            }
        }
        impl core::fmt::Debug for Agtisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtisr")
                    .field("eeps", &self.eeps())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Agtisr {{ eeps: {:?} }}", self.eeps())
            }
        }
        #[doc = "AGT Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtmr1(pub u8);
        impl Agtmr1 {
            #[doc = "Operating Mode"]
            #[inline(always)]
            pub const fn tmod(&self) -> super::vals::Tmod {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Tmod::from_bits(val as u8)
            }
            #[doc = "Operating Mode"]
            #[inline(always)]
            pub fn set_tmod(&mut self, val: super::vals::Tmod) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Edge Polarity"]
            #[inline(always)]
            pub const fn tedgpl(&self) -> super::vals::Tedgpl {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tedgpl::from_bits(val as u8)
            }
            #[doc = "Edge Polarity"]
            #[inline(always)]
            pub fn set_tedgpl(&mut self, val: super::vals::Tedgpl) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Count Source"]
            #[inline(always)]
            pub const fn tck(&self) -> super::vals::Tck {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Tck::from_bits(val as u8)
            }
            #[doc = "Count Source"]
            #[inline(always)]
            pub fn set_tck(&mut self, val: super::vals::Tck) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Agtmr1 {
            #[inline(always)]
            fn default() -> Agtmr1 {
                Agtmr1(0)
            }
        }
        impl core::fmt::Debug for Agtmr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtmr1")
                    .field("tmod", &self.tmod())
                    .field("tedgpl", &self.tedgpl())
                    .field("tck", &self.tck())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtmr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtmr1 {{ tmod: {:?}, tedgpl: {:?}, tck: {:?} }}",
                    self.tmod(),
                    self.tedgpl(),
                    self.tck()
                )
            }
        }
        #[doc = "AGT Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtmr2(pub u8);
        impl Agtmr2 {
            #[doc = "AGTLCLK or AGTSCLK Count Source Clock Frequency Division Ratio"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Cks {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Cks::from_bits(val as u8)
            }
            #[doc = "AGTLCLK or AGTSCLK Count Source Clock Frequency Division Ratio"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Cks) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Low Power Mode"]
            #[inline(always)]
            pub const fn lpm(&self) -> super::vals::Lpm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lpm::from_bits(val as u8)
            }
            #[doc = "Low Power Mode"]
            #[inline(always)]
            pub fn set_lpm(&mut self, val: super::vals::Lpm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtmr2 {
            #[inline(always)]
            fn default() -> Agtmr2 {
                Agtmr2(0)
            }
        }
        impl core::fmt::Debug for Agtmr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtmr2")
                    .field("cks", &self.cks())
                    .field("lpm", &self.lpm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtmr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtmr2 {{ cks: {:?}, lpm: {:?} }}",
                    self.cks(),
                    self.lpm()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cks {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cks {
            #[inline(always)]
            fn from(val: u8) -> Cks {
                Cks::from_bits(val)
            }
        }
        impl From<Cks> for u8 {
            #[inline(always)]
            fn from(val: Cks) -> u8 {
                Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eeps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eeps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eeps {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eeps {
            #[inline(always)]
            fn from(val: u8) -> Eeps {
                Eeps::from_bits(val)
            }
        }
        impl From<Eeps> for u8 {
            #[inline(always)]
            fn from(val: Eeps) -> u8 {
                Eeps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lpm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpm {
            #[inline(always)]
            fn from(val: u8) -> Lpm {
                Lpm::from_bits(val)
            }
        }
        impl From<Lpm> for u8 {
            #[inline(always)]
            fn from(val: Lpm) -> u8 {
                Lpm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tck {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tck {
            #[inline(always)]
            fn from(val: u8) -> Tck {
                Tck::from_bits(val)
            }
        }
        impl From<Tck> for u8 {
            #[inline(always)]
            fn from(val: Tck) -> u8 {
                Tck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmaf {
            #[inline(always)]
            fn from(val: u8) -> Tcmaf {
                Tcmaf::from_bits(val)
            }
        }
        impl From<Tcmaf> for u8 {
            #[inline(always)]
            fn from(val: Tcmaf) -> u8 {
                Tcmaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmbf {
            #[inline(always)]
            fn from(val: u8) -> Tcmbf {
                Tcmbf::from_bits(val)
            }
        }
        impl From<Tcmbf> for u8 {
            #[inline(always)]
            fn from(val: Tcmbf) -> u8 {
                Tcmbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmea {
            #[inline(always)]
            fn from(val: u8) -> Tcmea {
                Tcmea::from_bits(val)
            }
        }
        impl From<Tcmea> for u8 {
            #[inline(always)]
            fn from(val: Tcmea) -> u8 {
                Tcmea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmeb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmeb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmeb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmeb {
            #[inline(always)]
            fn from(val: u8) -> Tcmeb {
                Tcmeb::from_bits(val)
            }
        }
        impl From<Tcmeb> for u8 {
            #[inline(always)]
            fn from(val: Tcmeb) -> u8 {
                Tcmeb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcstf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcstf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcstf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcstf {
            #[inline(always)]
            fn from(val: u8) -> Tcstf {
                Tcstf::from_bits(val)
            }
        }
        impl From<Tcstf> for u8 {
            #[inline(always)]
            fn from(val: Tcstf) -> u8 {
                Tcstf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tedgf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tedgf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tedgf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tedgf {
            #[inline(always)]
            fn from(val: u8) -> Tedgf {
                Tedgf::from_bits(val)
            }
        }
        impl From<Tedgf> for u8 {
            #[inline(always)]
            fn from(val: Tedgf) -> u8 {
                Tedgf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tedgpl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tedgpl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tedgpl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tedgpl {
            #[inline(always)]
            fn from(val: u8) -> Tedgpl {
                Tedgpl::from_bits(val)
            }
        }
        impl From<Tedgpl> for u8 {
            #[inline(always)]
            fn from(val: Tedgpl) -> u8 {
                Tedgpl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ties {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ties {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ties {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ties {
            #[inline(always)]
            fn from(val: u8) -> Ties {
                Ties::from_bits(val)
            }
        }
        impl From<Ties> for u8 {
            #[inline(always)]
            fn from(val: Ties) -> u8 {
                Ties::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tiogt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tiogt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tiogt {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tiogt {
            #[inline(always)]
            fn from(val: u8) -> Tiogt {
                Tiogt::from_bits(val)
            }
        }
        impl From<Tiogt> for u8 {
            #[inline(always)]
            fn from(val: Tiogt) -> u8 {
                Tiogt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tipf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tipf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tipf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tipf {
            #[inline(always)]
            fn from(val: u8) -> Tipf {
                Tipf::from_bits(val)
            }
        }
        impl From<Tipf> for u8 {
            #[inline(always)]
            fn from(val: Tipf) -> u8 {
                Tipf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmod {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmod {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmod {
            #[inline(always)]
            fn from(val: u8) -> Tmod {
                Tmod::from_bits(val)
            }
        }
        impl From<Tmod> for u8 {
            #[inline(always)]
            fn from(val: Tmod) -> u8 {
                Tmod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toe {
            #[inline(always)]
            fn from(val: u8) -> Toe {
                Toe::from_bits(val)
            }
        }
        impl From<Toe> for u8 {
            #[inline(always)]
            fn from(val: Toe) -> u8 {
                Toe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toea {
            #[inline(always)]
            fn from(val: u8) -> Toea {
                Toea::from_bits(val)
            }
        }
        impl From<Toea> for u8 {
            #[inline(always)]
            fn from(val: Toea) -> u8 {
                Toea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toeb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toeb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toeb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toeb {
            #[inline(always)]
            fn from(val: u8) -> Toeb {
                Toeb::from_bits(val)
            }
        }
        impl From<Toeb> for u8 {
            #[inline(always)]
            fn from(val: Toeb) -> u8 {
                Toeb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Topola {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Topola {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Topola {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Topola {
            #[inline(always)]
            fn from(val: u8) -> Topola {
                Topola::from_bits(val)
            }
        }
        impl From<Topola> for u8 {
            #[inline(always)]
            fn from(val: Topola) -> u8 {
                Topola::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Topolb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Topolb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Topolb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Topolb {
            #[inline(always)]
            fn from(val: u8) -> Topolb {
                Topolb::from_bits(val)
            }
        }
        impl From<Topolb> for u8 {
            #[inline(always)]
            fn from(val: Topolb) -> u8 {
                Topolb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstart {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstart {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstart {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstart {
            #[inline(always)]
            fn from(val: u8) -> Tstart {
                Tstart::from_bits(val)
            }
        }
        impl From<Tstart> for u8 {
            #[inline(always)]
            fn from(val: Tstart) -> u8 {
                Tstart::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstop {
            #[inline(always)]
            fn from(val: u8) -> Tstop {
                Tstop::from_bits(val)
            }
        }
        impl From<Tstop> for u8 {
            #[inline(always)]
            fn from(val: Tstop) -> u8 {
                Tstop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tundf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tundf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tundf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tundf {
            #[inline(always)]
            fn from(val: u8) -> Tundf {
                Tundf::from_bits(val)
            }
        }
        impl From<Tundf> for u8 {
            #[inline(always)]
            fn from(val: Tundf) -> u8 {
                Tundf::to_bits(val)
            }
        }
    }
}
pub mod bus {
    #[doc = "BUS Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bus {
        ptr: *mut u8,
    }
    unsafe impl Send for Bus {}
    unsafe impl Sync for Bus {}
    impl Bus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Master Bus Control Register SYS"]
        #[inline(always)]
        pub const fn busmcntsys(self) -> crate::common::Reg<regs::Busmcntsys, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1008usize) as _) }
        }
        #[doc = "Master Bus Control Register DMA"]
        #[inline(always)]
        pub const fn busmcntdma(self) -> crate::common::Reg<regs::Busmcntdma, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x100cusize) as _) }
        }
        #[doc = "Bus Error Address Register 3"]
        #[inline(always)]
        pub const fn bus3erradd(self) -> crate::common::Reg<regs::Bus3erradd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1820usize) as _) }
        }
        #[doc = "BUS Error Status Register 3"]
        #[inline(always)]
        pub const fn bus3errstat(self) -> crate::common::Reg<regs::Bus3errstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1824usize) as _) }
        }
        #[doc = "Bus Error Address Register 4"]
        #[inline(always)]
        pub const fn bus4erradd(self) -> crate::common::Reg<regs::Bus4erradd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1830usize) as _) }
        }
        #[doc = "BUS Error Status Register 4"]
        #[inline(always)]
        pub const fn bus4errstat(self) -> crate::common::Reg<regs::Bus4errstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1834usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bus Error Address Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus3erradd(pub u32);
        impl Bus3erradd {
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub const fn berad(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub fn set_berad(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bus3erradd {
            #[inline(always)]
            fn default() -> Bus3erradd {
                Bus3erradd(0)
            }
        }
        impl core::fmt::Debug for Bus3erradd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus3erradd")
                    .field("berad", &self.berad())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus3erradd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bus3erradd {{ berad: {=u32:?} }}", self.berad())
            }
        }
        #[doc = "BUS Error Status Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus3errstat(pub u8);
        impl Bus3errstat {
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub const fn accstat(&self) -> super::vals::Bus3errstatAccstat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bus3errstatAccstat::from_bits(val as u8)
            }
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub fn set_accstat(&mut self, val: super::vals::Bus3errstatAccstat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub const fn errstat(&self) -> super::vals::Bus3errstatErrstat {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bus3errstatErrstat::from_bits(val as u8)
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub fn set_errstat(&mut self, val: super::vals::Bus3errstatErrstat) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Bus3errstat {
            #[inline(always)]
            fn default() -> Bus3errstat {
                Bus3errstat(0)
            }
        }
        impl core::fmt::Debug for Bus3errstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus3errstat")
                    .field("accstat", &self.accstat())
                    .field("errstat", &self.errstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus3errstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bus3errstat {{ accstat: {:?}, errstat: {:?} }}",
                    self.accstat(),
                    self.errstat()
                )
            }
        }
        #[doc = "Bus Error Address Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus4erradd(pub u32);
        impl Bus4erradd {
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub const fn berad(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub fn set_berad(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bus4erradd {
            #[inline(always)]
            fn default() -> Bus4erradd {
                Bus4erradd(0)
            }
        }
        impl core::fmt::Debug for Bus4erradd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus4erradd")
                    .field("berad", &self.berad())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus4erradd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bus4erradd {{ berad: {=u32:?} }}", self.berad())
            }
        }
        #[doc = "BUS Error Status Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus4errstat(pub u8);
        impl Bus4errstat {
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub const fn accstat(&self) -> super::vals::Bus4errstatAccstat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bus4errstatAccstat::from_bits(val as u8)
            }
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub fn set_accstat(&mut self, val: super::vals::Bus4errstatAccstat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub const fn errstat(&self) -> super::vals::Bus4errstatErrstat {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bus4errstatErrstat::from_bits(val as u8)
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub fn set_errstat(&mut self, val: super::vals::Bus4errstatErrstat) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Bus4errstat {
            #[inline(always)]
            fn default() -> Bus4errstat {
                Bus4errstat(0)
            }
        }
        impl core::fmt::Debug for Bus4errstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus4errstat")
                    .field("accstat", &self.accstat())
                    .field("errstat", &self.errstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus4errstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bus4errstat {{ accstat: {:?}, errstat: {:?} }}",
                    self.accstat(),
                    self.errstat()
                )
            }
        }
        #[doc = "Master Bus Control Register DMA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busmcntdma(pub u16);
        impl Busmcntdma {
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub const fn ieres(&self) -> super::vals::BusmcntdmaIeres {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::BusmcntdmaIeres::from_bits(val as u8)
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub fn set_ieres(&mut self, val: super::vals::BusmcntdmaIeres) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Busmcntdma {
            #[inline(always)]
            fn default() -> Busmcntdma {
                Busmcntdma(0)
            }
        }
        impl core::fmt::Debug for Busmcntdma {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busmcntdma")
                    .field("ieres", &self.ieres())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busmcntdma {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Busmcntdma {{ ieres: {:?} }}", self.ieres())
            }
        }
        #[doc = "Master Bus Control Register SYS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busmcntsys(pub u16);
        impl Busmcntsys {
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub const fn ieres(&self) -> super::vals::BusmcntsysIeres {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::BusmcntsysIeres::from_bits(val as u8)
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub fn set_ieres(&mut self, val: super::vals::BusmcntsysIeres) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Busmcntsys {
            #[inline(always)]
            fn default() -> Busmcntsys {
                Busmcntsys(0)
            }
        }
        impl core::fmt::Debug for Busmcntsys {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busmcntsys")
                    .field("ieres", &self.ieres())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busmcntsys {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Busmcntsys {{ ieres: {:?} }}", self.ieres())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus3errstatAccstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus3errstatAccstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus3errstatAccstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus3errstatAccstat {
            #[inline(always)]
            fn from(val: u8) -> Bus3errstatAccstat {
                Bus3errstatAccstat::from_bits(val)
            }
        }
        impl From<Bus3errstatAccstat> for u8 {
            #[inline(always)]
            fn from(val: Bus3errstatAccstat) -> u8 {
                Bus3errstatAccstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus3errstatErrstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus3errstatErrstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus3errstatErrstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus3errstatErrstat {
            #[inline(always)]
            fn from(val: u8) -> Bus3errstatErrstat {
                Bus3errstatErrstat::from_bits(val)
            }
        }
        impl From<Bus3errstatErrstat> for u8 {
            #[inline(always)]
            fn from(val: Bus3errstatErrstat) -> u8 {
                Bus3errstatErrstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus4errstatAccstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus4errstatAccstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus4errstatAccstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus4errstatAccstat {
            #[inline(always)]
            fn from(val: u8) -> Bus4errstatAccstat {
                Bus4errstatAccstat::from_bits(val)
            }
        }
        impl From<Bus4errstatAccstat> for u8 {
            #[inline(always)]
            fn from(val: Bus4errstatAccstat) -> u8 {
                Bus4errstatAccstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus4errstatErrstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus4errstatErrstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus4errstatErrstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus4errstatErrstat {
            #[inline(always)]
            fn from(val: u8) -> Bus4errstatErrstat {
                Bus4errstatErrstat::from_bits(val)
            }
        }
        impl From<Bus4errstatErrstat> for u8 {
            #[inline(always)]
            fn from(val: Bus4errstatErrstat) -> u8 {
                Bus4errstatErrstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusmcntdmaIeres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl BusmcntdmaIeres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusmcntdmaIeres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusmcntdmaIeres {
            #[inline(always)]
            fn from(val: u8) -> BusmcntdmaIeres {
                BusmcntdmaIeres::from_bits(val)
            }
        }
        impl From<BusmcntdmaIeres> for u8 {
            #[inline(always)]
            fn from(val: BusmcntdmaIeres) -> u8 {
                BusmcntdmaIeres::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusmcntsysIeres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl BusmcntsysIeres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusmcntsysIeres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusmcntsysIeres {
            #[inline(always)]
            fn from(val: u8) -> BusmcntsysIeres {
                BusmcntsysIeres::from_bits(val)
            }
        }
        impl From<BusmcntsysIeres> for u8 {
            #[inline(always)]
            fn from(val: BusmcntsysIeres) -> u8 {
                BusmcntsysIeres::to_bits(val)
            }
        }
    }
}
pub mod cac {
    #[doc = "Clock Frequency Accuracy Measurement Circuit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cac {
        ptr: *mut u8,
    }
    unsafe impl Send for Cac {}
    unsafe impl Sync for Cac {}
    impl Cac {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CAC Control Register 0"]
        #[inline(always)]
        pub const fn cacr0(self) -> crate::common::Reg<regs::Cacr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CAC Control Register 1"]
        #[inline(always)]
        pub const fn cacr1(self) -> crate::common::Reg<regs::Cacr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "CAC Control Register 2"]
        #[inline(always)]
        pub const fn cacr2(self) -> crate::common::Reg<regs::Cacr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "CAC Interrupt Control Register"]
        #[inline(always)]
        pub const fn caicr(self) -> crate::common::Reg<regs::Caicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "CAC Status Register"]
        #[inline(always)]
        pub const fn castr(self) -> crate::common::Reg<regs::Castr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CAC Upper,Limit Value Setting Register"]
        #[inline(always)]
        pub const fn caulvr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "CAC Lower,Limit Value Setting Register"]
        #[inline(always)]
        pub const fn callvr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CAC Counter Buffer Register"]
        #[inline(always)]
        pub const fn cacntbr(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CAC Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacr0(pub u8);
        impl Cacr0 {
            #[doc = "Clock Frequency Measurement Enable"]
            #[inline(always)]
            pub const fn cfme(&self) -> super::vals::Cfme {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cfme::from_bits(val as u8)
            }
            #[doc = "Clock Frequency Measurement Enable"]
            #[inline(always)]
            pub fn set_cfme(&mut self, val: super::vals::Cfme) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Cacr0 {
            #[inline(always)]
            fn default() -> Cacr0 {
                Cacr0(0)
            }
        }
        impl core::fmt::Debug for Cacr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacr0").field("cfme", &self.cfme()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cacr0 {{ cfme: {:?} }}", self.cfme())
            }
        }
        #[doc = "CAC Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacr1(pub u8);
        impl Cacr1 {
            #[doc = "CACREF Pin Input Enable"]
            #[inline(always)]
            pub const fn cacrefe(&self) -> super::vals::Cacrefe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cacrefe::from_bits(val as u8)
            }
            #[doc = "CACREF Pin Input Enable"]
            #[inline(always)]
            pub fn set_cacrefe(&mut self, val: super::vals::Cacrefe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement Target Clock Select"]
            #[inline(always)]
            pub const fn fmcs(&self) -> super::vals::Fmcs {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Fmcs::from_bits(val as u8)
            }
            #[doc = "Measurement Target Clock Select"]
            #[inline(always)]
            pub fn set_fmcs(&mut self, val: super::vals::Fmcs) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u8) & 0x07) << 1usize);
            }
            #[doc = "Timer Count Clock Source Select"]
            #[inline(always)]
            pub const fn tcss(&self) -> super::vals::Tcss {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Tcss::from_bits(val as u8)
            }
            #[doc = "Timer Count Clock Source Select"]
            #[inline(always)]
            pub fn set_tcss(&mut self, val: super::vals::Tcss) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "Valid Edge Select"]
            #[inline(always)]
            pub const fn edges(&self) -> super::vals::Edges {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Edges::from_bits(val as u8)
            }
            #[doc = "Valid Edge Select"]
            #[inline(always)]
            pub fn set_edges(&mut self, val: super::vals::Edges) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Cacr1 {
            #[inline(always)]
            fn default() -> Cacr1 {
                Cacr1(0)
            }
        }
        impl core::fmt::Debug for Cacr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacr1")
                    .field("cacrefe", &self.cacrefe())
                    .field("fmcs", &self.fmcs())
                    .field("tcss", &self.tcss())
                    .field("edges", &self.edges())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cacr1 {{ cacrefe: {:?}, fmcs: {:?}, tcss: {:?}, edges: {:?} }}",
                    self.cacrefe(),
                    self.fmcs(),
                    self.tcss(),
                    self.edges()
                )
            }
        }
        #[doc = "CAC Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacr2(pub u8);
        impl Cacr2 {
            #[doc = "Reference Signal Select"]
            #[inline(always)]
            pub const fn rps(&self) -> super::vals::Rps {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rps::from_bits(val as u8)
            }
            #[doc = "Reference Signal Select"]
            #[inline(always)]
            pub fn set_rps(&mut self, val: super::vals::Rps) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement Reference Clock Select"]
            #[inline(always)]
            pub const fn rscs(&self) -> super::vals::Rscs {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Rscs::from_bits(val as u8)
            }
            #[doc = "Measurement Reference Clock Select"]
            #[inline(always)]
            pub fn set_rscs(&mut self, val: super::vals::Rscs) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u8) & 0x07) << 1usize);
            }
            #[doc = "Measurement Reference Clock Frequency Division Ratio Select"]
            #[inline(always)]
            pub const fn rcds(&self) -> super::vals::Rcds {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Rcds::from_bits(val as u8)
            }
            #[doc = "Measurement Reference Clock Frequency Division Ratio Select"]
            #[inline(always)]
            pub fn set_rcds(&mut self, val: super::vals::Rcds) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "Digital Filter Select"]
            #[inline(always)]
            pub const fn dfs(&self) -> super::vals::Dfs {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Dfs::from_bits(val as u8)
            }
            #[doc = "Digital Filter Select"]
            #[inline(always)]
            pub fn set_dfs(&mut self, val: super::vals::Dfs) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Cacr2 {
            #[inline(always)]
            fn default() -> Cacr2 {
                Cacr2(0)
            }
        }
        impl core::fmt::Debug for Cacr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacr2")
                    .field("rps", &self.rps())
                    .field("rscs", &self.rscs())
                    .field("rcds", &self.rcds())
                    .field("dfs", &self.dfs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cacr2 {{ rps: {:?}, rscs: {:?}, rcds: {:?}, dfs: {:?} }}",
                    self.rps(),
                    self.rscs(),
                    self.rcds(),
                    self.dfs()
                )
            }
        }
        #[doc = "CAC Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Caicr(pub u8);
        impl Caicr {
            #[doc = "Frequency Error Interrupt Request Enable"]
            #[inline(always)]
            pub const fn ferrie(&self) -> super::vals::Ferrie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ferrie::from_bits(val as u8)
            }
            #[doc = "Frequency Error Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_ferrie(&mut self, val: super::vals::Ferrie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement End Interrupt Request Enable"]
            #[inline(always)]
            pub const fn mendie(&self) -> super::vals::Mendie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mendie::from_bits(val as u8)
            }
            #[doc = "Measurement End Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_mendie(&mut self, val: super::vals::Mendie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Overflow Interrupt Request Enable"]
            #[inline(always)]
            pub const fn ovfie(&self) -> super::vals::Ovfie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ovfie::from_bits(val as u8)
            }
            #[doc = "Overflow Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_ovfie(&mut self, val: super::vals::Ovfie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "FERRF Clear"]
            #[inline(always)]
            pub const fn ferrfcl(&self) -> super::vals::Ferrfcl {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ferrfcl::from_bits(val as u8)
            }
            #[doc = "FERRF Clear"]
            #[inline(always)]
            pub fn set_ferrfcl(&mut self, val: super::vals::Ferrfcl) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "MENDF Clear"]
            #[inline(always)]
            pub const fn mendfcl(&self) -> super::vals::Mendfcl {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Mendfcl::from_bits(val as u8)
            }
            #[doc = "MENDF Clear"]
            #[inline(always)]
            pub fn set_mendfcl(&mut self, val: super::vals::Mendfcl) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "OVFF Clear"]
            #[inline(always)]
            pub const fn ovffcl(&self) -> super::vals::Ovffcl {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ovffcl::from_bits(val as u8)
            }
            #[doc = "OVFF Clear"]
            #[inline(always)]
            pub fn set_ovffcl(&mut self, val: super::vals::Ovffcl) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Caicr {
            #[inline(always)]
            fn default() -> Caicr {
                Caicr(0)
            }
        }
        impl core::fmt::Debug for Caicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Caicr")
                    .field("ferrie", &self.ferrie())
                    .field("mendie", &self.mendie())
                    .field("ovfie", &self.ovfie())
                    .field("ferrfcl", &self.ferrfcl())
                    .field("mendfcl", &self.mendfcl())
                    .field("ovffcl", &self.ovffcl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Caicr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Caicr {{ ferrie: {:?}, mendie: {:?}, ovfie: {:?}, ferrfcl: {:?}, mendfcl: {:?}, ovffcl: {:?} }}" , self . ferrie () , self . mendie () , self . ovfie () , self . ferrfcl () , self . mendfcl () , self . ovffcl ())
            }
        }
        #[doc = "CAC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Castr(pub u8);
        impl Castr {
            #[doc = "Frequency Error Flag"]
            #[inline(always)]
            pub const fn ferrf(&self) -> super::vals::Ferrf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ferrf::from_bits(val as u8)
            }
            #[doc = "Frequency Error Flag"]
            #[inline(always)]
            pub fn set_ferrf(&mut self, val: super::vals::Ferrf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement End Flag"]
            #[inline(always)]
            pub const fn mendf(&self) -> super::vals::Mendf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mendf::from_bits(val as u8)
            }
            #[doc = "Measurement End Flag"]
            #[inline(always)]
            pub fn set_mendf(&mut self, val: super::vals::Mendf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub const fn ovff(&self) -> super::vals::Ovff {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ovff::from_bits(val as u8)
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub fn set_ovff(&mut self, val: super::vals::Ovff) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Castr {
            #[inline(always)]
            fn default() -> Castr {
                Castr(0)
            }
        }
        impl core::fmt::Debug for Castr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Castr")
                    .field("ferrf", &self.ferrf())
                    .field("mendf", &self.mendf())
                    .field("ovff", &self.ovff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Castr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Castr {{ ferrf: {:?}, mendf: {:?}, ovff: {:?} }}",
                    self.ferrf(),
                    self.mendf(),
                    self.ovff()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cacrefe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cacrefe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cacrefe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cacrefe {
            #[inline(always)]
            fn from(val: u8) -> Cacrefe {
                Cacrefe::from_bits(val)
            }
        }
        impl From<Cacrefe> for u8 {
            #[inline(always)]
            fn from(val: Cacrefe) -> u8 {
                Cacrefe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cfme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cfme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cfme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cfme {
            #[inline(always)]
            fn from(val: u8) -> Cfme {
                Cfme::from_bits(val)
            }
        }
        impl From<Cfme> for u8 {
            #[inline(always)]
            fn from(val: Cfme) -> u8 {
                Cfme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Dfs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfs {
            #[inline(always)]
            fn from(val: u8) -> Dfs {
                Dfs::from_bits(val)
            }
        }
        impl From<Dfs> for u8 {
            #[inline(always)]
            fn from(val: Dfs) -> u8 {
                Dfs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edges {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Edges {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edges {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edges {
            #[inline(always)]
            fn from(val: u8) -> Edges {
                Edges::from_bits(val)
            }
        }
        impl From<Edges> for u8 {
            #[inline(always)]
            fn from(val: Edges) -> u8 {
                Edges::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ferrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ferrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ferrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ferrf {
            #[inline(always)]
            fn from(val: u8) -> Ferrf {
                Ferrf::from_bits(val)
            }
        }
        impl From<Ferrf> for u8 {
            #[inline(always)]
            fn from(val: Ferrf) -> u8 {
                Ferrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ferrfcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ferrfcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ferrfcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ferrfcl {
            #[inline(always)]
            fn from(val: u8) -> Ferrfcl {
                Ferrfcl::from_bits(val)
            }
        }
        impl From<Ferrfcl> for u8 {
            #[inline(always)]
            fn from(val: Ferrfcl) -> u8 {
                Ferrfcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ferrie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ferrie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ferrie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ferrie {
            #[inline(always)]
            fn from(val: u8) -> Ferrie {
                Ferrie::from_bits(val)
            }
        }
        impl From<Ferrie> for u8 {
            #[inline(always)]
            fn from(val: Ferrie) -> u8 {
                Ferrie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fmcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fmcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fmcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fmcs {
            #[inline(always)]
            fn from(val: u8) -> Fmcs {
                Fmcs::from_bits(val)
            }
        }
        impl From<Fmcs> for u8 {
            #[inline(always)]
            fn from(val: Fmcs) -> u8 {
                Fmcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mendf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mendf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mendf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mendf {
            #[inline(always)]
            fn from(val: u8) -> Mendf {
                Mendf::from_bits(val)
            }
        }
        impl From<Mendf> for u8 {
            #[inline(always)]
            fn from(val: Mendf) -> u8 {
                Mendf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mendfcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mendfcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mendfcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mendfcl {
            #[inline(always)]
            fn from(val: u8) -> Mendfcl {
                Mendfcl::from_bits(val)
            }
        }
        impl From<Mendfcl> for u8 {
            #[inline(always)]
            fn from(val: Mendfcl) -> u8 {
                Mendfcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mendie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mendie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mendie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mendie {
            #[inline(always)]
            fn from(val: u8) -> Mendie {
                Mendie::from_bits(val)
            }
        }
        impl From<Mendie> for u8 {
            #[inline(always)]
            fn from(val: Mendie) -> u8 {
                Mendie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovff {
            #[inline(always)]
            fn from(val: u8) -> Ovff {
                Ovff::from_bits(val)
            }
        }
        impl From<Ovff> for u8 {
            #[inline(always)]
            fn from(val: Ovff) -> u8 {
                Ovff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovffcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovffcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovffcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovffcl {
            #[inline(always)]
            fn from(val: u8) -> Ovffcl {
                Ovffcl::from_bits(val)
            }
        }
        impl From<Ovffcl> for u8 {
            #[inline(always)]
            fn from(val: Ovffcl) -> u8 {
                Ovffcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovfie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovfie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovfie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovfie {
            #[inline(always)]
            fn from(val: u8) -> Ovfie {
                Ovfie::from_bits(val)
            }
        }
        impl From<Ovfie> for u8 {
            #[inline(always)]
            fn from(val: Ovfie) -> u8 {
                Ovfie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcds {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rcds {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcds {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcds {
            #[inline(always)]
            fn from(val: u8) -> Rcds {
                Rcds::from_bits(val)
            }
        }
        impl From<Rcds> for u8 {
            #[inline(always)]
            fn from(val: Rcds) -> u8 {
                Rcds::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rps {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rps {
            #[inline(always)]
            fn from(val: u8) -> Rps {
                Rps::from_bits(val)
            }
        }
        impl From<Rps> for u8 {
            #[inline(always)]
            fn from(val: Rps) -> u8 {
                Rps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rscs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rscs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rscs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rscs {
            #[inline(always)]
            fn from(val: u8) -> Rscs {
                Rscs::from_bits(val)
            }
        }
        impl From<Rscs> for u8 {
            #[inline(always)]
            fn from(val: Rscs) -> u8 {
                Rscs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tcss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcss {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcss {
            #[inline(always)]
            fn from(val: u8) -> Tcss {
                Tcss::from_bits(val)
            }
        }
        impl From<Tcss> for u8 {
            #[inline(always)]
            fn from(val: Tcss) -> u8 {
                Tcss::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = Default::default();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = self.read();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
}
pub mod crc {
    #[doc = "Cyclic Redundancy Check Calculator"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Crc {
        ptr: *mut u8,
    }
    unsafe impl Send for Crc {}
    unsafe impl Sync for Crc {}
    impl Crc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CRC Control Register 0"]
        #[inline(always)]
        pub const fn crccr0(self) -> crate::common::Reg<regs::Crccr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CRC Control Register 1"]
        #[inline(always)]
        pub const fn crccr1(self) -> crate::common::Reg<regs::Crccr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "CRC Data Input Register"]
        #[inline(always)]
        pub const fn crcdir(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CRC Data Input Register"]
        #[inline(always)]
        pub const fn crcdir_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CRC Data Output Register"]
        #[inline(always)]
        pub const fn crcdor(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CRC Data Output Register"]
        #[inline(always)]
        pub const fn crcdor_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CRC Data Output Register"]
        #[inline(always)]
        pub const fn crcdor_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Snoop Address Register"]
        #[inline(always)]
        pub const fn crcsar(self) -> crate::common::Reg<regs::Crcsar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CRC Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccr0(pub u8);
        impl Crccr0 {
            #[doc = "CRC Generating Polynomial Switching"]
            #[inline(always)]
            pub const fn gps(&self) -> super::vals::Gps {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Gps::from_bits(val as u8)
            }
            #[doc = "CRC Generating Polynomial Switching"]
            #[inline(always)]
            pub fn set_gps(&mut self, val: super::vals::Gps) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "CRC Calculation Switching"]
            #[inline(always)]
            pub const fn lms(&self) -> super::vals::Lms {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lms::from_bits(val as u8)
            }
            #[doc = "CRC Calculation Switching"]
            #[inline(always)]
            pub fn set_lms(&mut self, val: super::vals::Lms) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "CRCDOR/CRCDOR_HA/CRCDOR_BY Register Clear"]
            #[inline(always)]
            pub const fn dorclr(&self) -> super::vals::Dorclr {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dorclr::from_bits(val as u8)
            }
            #[doc = "CRCDOR/CRCDOR_HA/CRCDOR_BY Register Clear"]
            #[inline(always)]
            pub fn set_dorclr(&mut self, val: super::vals::Dorclr) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Crccr0 {
            #[inline(always)]
            fn default() -> Crccr0 {
                Crccr0(0)
            }
        }
        impl core::fmt::Debug for Crccr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccr0")
                    .field("gps", &self.gps())
                    .field("lms", &self.lms())
                    .field("dorclr", &self.dorclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crccr0 {{ gps: {:?}, lms: {:?}, dorclr: {:?} }}",
                    self.gps(),
                    self.lms(),
                    self.dorclr()
                )
            }
        }
        #[doc = "CRC Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccr1(pub u8);
        impl Crccr1 {
            #[doc = "Snoop,On,Write/Read Switch"]
            #[inline(always)]
            pub const fn crcswr(&self) -> super::vals::Crcswr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Crcswr::from_bits(val as u8)
            }
            #[doc = "Snoop,On,Write/Read Switch"]
            #[inline(always)]
            pub fn set_crcswr(&mut self, val: super::vals::Crcswr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Snoop Enable"]
            #[inline(always)]
            pub const fn crcsen(&self) -> super::vals::Crcsen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Crcsen::from_bits(val as u8)
            }
            #[doc = "Snoop Enable"]
            #[inline(always)]
            pub fn set_crcsen(&mut self, val: super::vals::Crcsen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Crccr1 {
            #[inline(always)]
            fn default() -> Crccr1 {
                Crccr1(0)
            }
        }
        impl core::fmt::Debug for Crccr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccr1")
                    .field("crcswr", &self.crcswr())
                    .field("crcsen", &self.crcsen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crccr1 {{ crcswr: {:?}, crcsen: {:?} }}",
                    self.crcswr(),
                    self.crcsen()
                )
            }
        }
        #[doc = "Snoop Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcsar(pub u16);
        impl Crcsar {
            #[doc = "Register Snoop Address"]
            #[inline(always)]
            pub const fn crcsa(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Register Snoop Address"]
            #[inline(always)]
            pub fn set_crcsa(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u16) & 0x3fff) << 0usize);
            }
        }
        impl Default for Crcsar {
            #[inline(always)]
            fn default() -> Crcsar {
                Crcsar(0)
            }
        }
        impl core::fmt::Debug for Crcsar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcsar")
                    .field("crcsa", &self.crcsa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcsar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcsar {{ crcsa: {=u16:?} }}", self.crcsa())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcsen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Crcsen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcsen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcsen {
            #[inline(always)]
            fn from(val: u8) -> Crcsen {
                Crcsen::from_bits(val)
            }
        }
        impl From<Crcsen> for u8 {
            #[inline(always)]
            fn from(val: Crcsen) -> u8 {
                Crcsen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcswr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Crcswr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcswr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcswr {
            #[inline(always)]
            fn from(val: u8) -> Crcswr {
                Crcswr::from_bits(val)
            }
        }
        impl From<Crcswr> for u8 {
            #[inline(always)]
            fn from(val: Crcswr) -> u8 {
                Crcswr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dorclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dorclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dorclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dorclr {
            #[inline(always)]
            fn from(val: u8) -> Dorclr {
                Dorclr::from_bits(val)
            }
        }
        impl From<Dorclr> for u8 {
            #[inline(always)]
            fn from(val: Dorclr) -> u8 {
                Dorclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gps {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gps {
            #[inline(always)]
            fn from(val: u8) -> Gps {
                Gps::from_bits(val)
            }
        }
        impl From<Gps> for u8 {
            #[inline(always)]
            fn from(val: Gps) -> u8 {
                Gps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lms {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lms {
            #[inline(always)]
            fn from(val: u8) -> Lms {
                Lms::from_bits(val)
            }
        }
        impl From<Lms> for u8 {
            #[inline(always)]
            fn from(val: Lms) -> u8 {
                Lms::to_bits(val)
            }
        }
    }
}
pub mod dbg {
    #[doc = "Debug Function"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dbg {
        ptr: *mut u8,
    }
    unsafe impl Send for Dbg {}
    unsafe impl Sync for Dbg {}
    impl Dbg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Debug Status Register"]
        #[inline(always)]
        pub const fn dbgstr(self) -> crate::common::Reg<regs::Dbgstr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug Stop Control Register"]
        #[inline(always)]
        pub const fn dbgstopcr(self) -> crate::common::Reg<regs::Dbgstopcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug Stop Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgstopcr(pub u32);
        impl Dbgstopcr {
            #[doc = "Mask bit for IWDT reset/interrupt in the OCD run mode"]
            #[inline(always)]
            pub const fn dbgstop_iwdt(&self) -> super::vals::DbgstopIwdt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DbgstopIwdt::from_bits(val as u8)
            }
            #[doc = "Mask bit for IWDT reset/interrupt in the OCD run mode"]
            #[inline(always)]
            pub fn set_dbgstop_iwdt(&mut self, val: super::vals::DbgstopIwdt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Mask bit for WDT reset/interrupt in the OCD run mode"]
            #[inline(always)]
            pub const fn dbgstop_wdt(&self) -> super::vals::DbgstopWdt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::DbgstopWdt::from_bits(val as u8)
            }
            #[doc = "Mask bit for WDT reset/interrupt in the OCD run mode"]
            #[inline(always)]
            pub fn set_dbgstop_wdt(&mut self, val: super::vals::DbgstopWdt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Mask bit for LVD0 reset"]
            #[inline(always)]
            pub const fn dbgstop_lvd0(&self) -> super::vals::DbgstopLvd0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::DbgstopLvd0::from_bits(val as u8)
            }
            #[doc = "Mask bit for LVD0 reset"]
            #[inline(always)]
            pub fn set_dbgstop_lvd0(&mut self, val: super::vals::DbgstopLvd0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Mask bit for LVD1 reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_lvd1(&self) -> super::vals::DbgstopLvd1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::DbgstopLvd1::from_bits(val as u8)
            }
            #[doc = "Mask bit for LVD1 reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_lvd1(&mut self, val: super::vals::DbgstopLvd1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Mask bit for LVD2 reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_lvd2(&self) -> super::vals::DbgstopLvd2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::DbgstopLvd2::from_bits(val as u8)
            }
            #[doc = "Mask bit for LVD2 reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_lvd2(&mut self, val: super::vals::DbgstopLvd2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Mask bit for SRAM parity error reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_rper(&self) -> super::vals::DbgstopRper {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::DbgstopRper::from_bits(val as u8)
            }
            #[doc = "Mask bit for SRAM parity error reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_rper(&mut self, val: super::vals::DbgstopRper) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Mask bit for SRAM ECC error reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_reccr(&self) -> super::vals::DbgstopReccr {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::DbgstopReccr::from_bits(val as u8)
            }
            #[doc = "Mask bit for SRAM ECC error reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_reccr(&mut self, val: super::vals::DbgstopReccr) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Dbgstopcr {
            #[inline(always)]
            fn default() -> Dbgstopcr {
                Dbgstopcr(0)
            }
        }
        impl core::fmt::Debug for Dbgstopcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgstopcr")
                    .field("dbgstop_iwdt", &self.dbgstop_iwdt())
                    .field("dbgstop_wdt", &self.dbgstop_wdt())
                    .field("dbgstop_lvd0", &self.dbgstop_lvd0())
                    .field("dbgstop_lvd1", &self.dbgstop_lvd1())
                    .field("dbgstop_lvd2", &self.dbgstop_lvd2())
                    .field("dbgstop_rper", &self.dbgstop_rper())
                    .field("dbgstop_reccr", &self.dbgstop_reccr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgstopcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dbgstopcr {{ dbgstop_iwdt: {:?}, dbgstop_wdt: {:?}, dbgstop_lvd0: {:?}, dbgstop_lvd1: {:?}, dbgstop_lvd2: {:?}, dbgstop_rper: {:?}, dbgstop_reccr: {:?} }}" , self . dbgstop_iwdt () , self . dbgstop_wdt () , self . dbgstop_lvd0 () , self . dbgstop_lvd1 () , self . dbgstop_lvd2 () , self . dbgstop_rper () , self . dbgstop_reccr ())
            }
        }
        #[doc = "Debug Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgstr(pub u32);
        impl Dbgstr {
            #[doc = "Debug power,up request"]
            #[inline(always)]
            pub const fn cdbgpwrupreq(&self) -> super::vals::Cdbgpwrupreq {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Cdbgpwrupreq::from_bits(val as u8)
            }
            #[doc = "Debug power,up request"]
            #[inline(always)]
            pub fn set_cdbgpwrupreq(&mut self, val: super::vals::Cdbgpwrupreq) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Debug power,up acknowledge"]
            #[inline(always)]
            pub const fn cdbgpwrupack(&self) -> super::vals::Cdbgpwrupack {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Cdbgpwrupack::from_bits(val as u8)
            }
            #[doc = "Debug power,up acknowledge"]
            #[inline(always)]
            pub fn set_cdbgpwrupack(&mut self, val: super::vals::Cdbgpwrupack) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Dbgstr {
            #[inline(always)]
            fn default() -> Dbgstr {
                Dbgstr(0)
            }
        }
        impl core::fmt::Debug for Dbgstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgstr")
                    .field("cdbgpwrupreq", &self.cdbgpwrupreq())
                    .field("cdbgpwrupack", &self.cdbgpwrupack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgstr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dbgstr {{ cdbgpwrupreq: {:?}, cdbgpwrupack: {:?} }}",
                    self.cdbgpwrupreq(),
                    self.cdbgpwrupack()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdbgpwrupack {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdbgpwrupack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdbgpwrupack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdbgpwrupack {
            #[inline(always)]
            fn from(val: u8) -> Cdbgpwrupack {
                Cdbgpwrupack::from_bits(val)
            }
        }
        impl From<Cdbgpwrupack> for u8 {
            #[inline(always)]
            fn from(val: Cdbgpwrupack) -> u8 {
                Cdbgpwrupack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdbgpwrupreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdbgpwrupreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdbgpwrupreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdbgpwrupreq {
            #[inline(always)]
            fn from(val: u8) -> Cdbgpwrupreq {
                Cdbgpwrupreq::from_bits(val)
            }
        }
        impl From<Cdbgpwrupreq> for u8 {
            #[inline(always)]
            fn from(val: Cdbgpwrupreq) -> u8 {
                Cdbgpwrupreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopIwdt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopIwdt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopIwdt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopIwdt {
            #[inline(always)]
            fn from(val: u8) -> DbgstopIwdt {
                DbgstopIwdt::from_bits(val)
            }
        }
        impl From<DbgstopIwdt> for u8 {
            #[inline(always)]
            fn from(val: DbgstopIwdt) -> u8 {
                DbgstopIwdt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopLvd0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopLvd0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopLvd0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopLvd0 {
            #[inline(always)]
            fn from(val: u8) -> DbgstopLvd0 {
                DbgstopLvd0::from_bits(val)
            }
        }
        impl From<DbgstopLvd0> for u8 {
            #[inline(always)]
            fn from(val: DbgstopLvd0) -> u8 {
                DbgstopLvd0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopLvd1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopLvd1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopLvd1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopLvd1 {
            #[inline(always)]
            fn from(val: u8) -> DbgstopLvd1 {
                DbgstopLvd1::from_bits(val)
            }
        }
        impl From<DbgstopLvd1> for u8 {
            #[inline(always)]
            fn from(val: DbgstopLvd1) -> u8 {
                DbgstopLvd1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopLvd2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopLvd2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopLvd2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopLvd2 {
            #[inline(always)]
            fn from(val: u8) -> DbgstopLvd2 {
                DbgstopLvd2::from_bits(val)
            }
        }
        impl From<DbgstopLvd2> for u8 {
            #[inline(always)]
            fn from(val: DbgstopLvd2) -> u8 {
                DbgstopLvd2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopReccr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopReccr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopReccr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopReccr {
            #[inline(always)]
            fn from(val: u8) -> DbgstopReccr {
                DbgstopReccr::from_bits(val)
            }
        }
        impl From<DbgstopReccr> for u8 {
            #[inline(always)]
            fn from(val: DbgstopReccr) -> u8 {
                DbgstopReccr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopRper {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopRper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopRper {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopRper {
            #[inline(always)]
            fn from(val: u8) -> DbgstopRper {
                DbgstopRper::from_bits(val)
            }
        }
        impl From<DbgstopRper> for u8 {
            #[inline(always)]
            fn from(val: DbgstopRper) -> u8 {
                DbgstopRper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopWdt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopWdt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopWdt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopWdt {
            #[inline(always)]
            fn from(val: u8) -> DbgstopWdt {
                DbgstopWdt::from_bits(val)
            }
        }
        impl From<DbgstopWdt> for u8 {
            #[inline(always)]
            fn from(val: DbgstopWdt) -> u8 {
                DbgstopWdt::to_bits(val)
            }
        }
    }
}
pub mod doc {
    #[doc = "Data Operation Circuit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Doc {
        ptr: *mut u8,
    }
    unsafe impl Send for Doc {}
    unsafe impl Sync for Doc {}
    impl Doc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "DOC Control Register"]
        #[inline(always)]
        pub const fn docr(self) -> crate::common::Reg<regs::Docr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "DOC Data Input Register"]
        #[inline(always)]
        pub const fn dodir(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "DOC Data Setting Register"]
        #[inline(always)]
        pub const fn dodsr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "DOC Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Docr(pub u8);
        impl Docr {
            #[doc = "Operating Mode Select"]
            #[inline(always)]
            pub const fn oms(&self) -> super::vals::Oms {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Oms::from_bits(val as u8)
            }
            #[doc = "Operating Mode Select"]
            #[inline(always)]
            pub fn set_oms(&mut self, val: super::vals::Oms) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Detection Condition Select"]
            #[inline(always)]
            pub const fn dcsel(&self) -> super::vals::Dcsel {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dcsel::from_bits(val as u8)
            }
            #[doc = "Detection Condition Select"]
            #[inline(always)]
            pub fn set_dcsel(&mut self, val: super::vals::Dcsel) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "DOC Flag"]
            #[inline(always)]
            pub const fn dopcf(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "DOC Flag"]
            #[inline(always)]
            pub fn set_dopcf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "DOPCF Clear"]
            #[inline(always)]
            pub const fn dopcfcl(&self) -> super::vals::Dopcfcl {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Dopcfcl::from_bits(val as u8)
            }
            #[doc = "DOPCF Clear"]
            #[inline(always)]
            pub fn set_dopcfcl(&mut self, val: super::vals::Dopcfcl) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Docr {
            #[inline(always)]
            fn default() -> Docr {
                Docr(0)
            }
        }
        impl core::fmt::Debug for Docr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Docr")
                    .field("oms", &self.oms())
                    .field("dcsel", &self.dcsel())
                    .field("dopcf", &self.dopcf())
                    .field("dopcfcl", &self.dopcfcl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Docr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Docr {{ oms: {:?}, dcsel: {:?}, dopcf: {=bool:?}, dopcfcl: {:?} }}",
                    self.oms(),
                    self.dcsel(),
                    self.dopcf(),
                    self.dopcfcl()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcsel {
            #[inline(always)]
            fn from(val: u8) -> Dcsel {
                Dcsel::from_bits(val)
            }
        }
        impl From<Dcsel> for u8 {
            #[inline(always)]
            fn from(val: Dcsel) -> u8 {
                Dcsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dopcfcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dopcfcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dopcfcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dopcfcl {
            #[inline(always)]
            fn from(val: u8) -> Dopcfcl {
                Dopcfcl::from_bits(val)
            }
        }
        impl From<Dopcfcl> for u8 {
            #[inline(always)]
            fn from(val: Dopcfcl) -> u8 {
                Dopcfcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oms {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oms {
            #[inline(always)]
            fn from(val: u8) -> Oms {
                Oms::from_bits(val)
            }
        }
        impl From<Oms> for u8 {
            #[inline(always)]
            fn from(val: Oms) -> u8 {
                Oms::to_bits(val)
            }
        }
    }
}
pub mod dtc {
    #[doc = "Data Transfer Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Dtc {}
    unsafe impl Sync for Dtc {}
    impl Dtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "DTC Control Register"]
        #[inline(always)]
        pub const fn dtccr(self) -> crate::common::Reg<regs::Dtccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "DTC Vector Base Register"]
        #[inline(always)]
        pub const fn dtcvbr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "DTC Module Start Register"]
        #[inline(always)]
        pub const fn dtcst(self) -> crate::common::Reg<regs::Dtcst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DTC Status Register"]
        #[inline(always)]
        pub const fn dtcsts(self) -> crate::common::Reg<regs::Dtcsts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "DTC Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtccr(pub u8);
        impl Dtccr {
            #[doc = "DTC Transfer Information Read Skip Enable"]
            #[inline(always)]
            pub const fn rrs(&self) -> super::vals::Rrs {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rrs::from_bits(val as u8)
            }
            #[doc = "DTC Transfer Information Read Skip Enable"]
            #[inline(always)]
            pub fn set_rrs(&mut self, val: super::vals::Rrs) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Dtccr {
            #[inline(always)]
            fn default() -> Dtccr {
                Dtccr(0)
            }
        }
        impl core::fmt::Debug for Dtccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtccr").field("rrs", &self.rrs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dtccr {{ rrs: {:?} }}", self.rrs())
            }
        }
        #[doc = "DTC Module Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcst(pub u8);
        impl Dtcst {
            #[doc = "DTC Module Start"]
            #[inline(always)]
            pub const fn dtcst(&self) -> super::vals::Dtcst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dtcst::from_bits(val as u8)
            }
            #[doc = "DTC Module Start"]
            #[inline(always)]
            pub fn set_dtcst(&mut self, val: super::vals::Dtcst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Dtcst {
            #[inline(always)]
            fn default() -> Dtcst {
                Dtcst(0)
            }
        }
        impl core::fmt::Debug for Dtcst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcst")
                    .field("dtcst", &self.dtcst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dtcst {{ dtcst: {:?} }}", self.dtcst())
            }
        }
        #[doc = "DTC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcsts(pub u16);
        impl Dtcsts {
            #[doc = "DTC,Activating Vector Number Monitoring"]
            #[inline(always)]
            pub const fn vecn(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DTC,Activating Vector Number Monitoring"]
            #[inline(always)]
            pub fn set_vecn(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "DTC Active Flag"]
            #[inline(always)]
            pub const fn act(&self) -> super::vals::Act {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Act::from_bits(val as u8)
            }
            #[doc = "DTC Active Flag"]
            #[inline(always)]
            pub fn set_act(&mut self, val: super::vals::Act) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Dtcsts {
            #[inline(always)]
            fn default() -> Dtcsts {
                Dtcsts(0)
            }
        }
        impl core::fmt::Debug for Dtcsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcsts")
                    .field("vecn", &self.vecn())
                    .field("act", &self.act())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtcsts {{ vecn: {=u8:?}, act: {:?} }}",
                    self.vecn(),
                    self.act()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Act {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Act {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Act {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Act {
            #[inline(always)]
            fn from(val: u8) -> Act {
                Act::from_bits(val)
            }
        }
        impl From<Act> for u8 {
            #[inline(always)]
            fn from(val: Act) -> u8 {
                Act::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtcst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtcst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtcst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtcst {
            #[inline(always)]
            fn from(val: u8) -> Dtcst {
                Dtcst::from_bits(val)
            }
        }
        impl From<Dtcst> for u8 {
            #[inline(always)]
            fn from(val: Dtcst) -> u8 {
                Dtcst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rrs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rrs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rrs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rrs {
            #[inline(always)]
            fn from(val: u8) -> Rrs {
                Rrs::from_bits(val)
            }
        }
        impl From<Rrs> for u8 {
            #[inline(always)]
            fn from(val: Rrs) -> u8 {
                Rrs::to_bits(val)
            }
        }
    }
}
pub mod elc {
    #[doc = "Event Link Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Elc {
        ptr: *mut u8,
    }
    unsafe impl Send for Elc {}
    unsafe impl Sync for Elc {}
    impl Elc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Event Link Controller Register"]
        #[inline(always)]
        pub const fn elcr(self) -> crate::common::Reg<regs::Elcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Event Link Software Event Generation Register %s"]
        #[inline(always)]
        pub const fn elsegr(self, n: usize) -> crate::common::Reg<regs::Elsegr, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize + n * 2usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr(self, n: usize) -> crate::common::Reg<regs::Elsr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr_1(self, n: usize) -> crate::common::Reg<regs::Elsr1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize + n * 4usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr_2(self, n: usize) -> crate::common::Reg<regs::Elsr2, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Event Link Controller Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elcr(pub u8);
        impl Elcr {
            #[doc = "All Event Link Enable"]
            #[inline(always)]
            pub const fn elcon(&self) -> super::vals::Elcon {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Elcon::from_bits(val as u8)
            }
            #[doc = "All Event Link Enable"]
            #[inline(always)]
            pub fn set_elcon(&mut self, val: super::vals::Elcon) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Elcr {
            #[inline(always)]
            fn default() -> Elcr {
                Elcr(0)
            }
        }
        impl core::fmt::Debug for Elcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elcr")
                    .field("elcon", &self.elcon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elcr {{ elcon: {:?} }}", self.elcon())
            }
        }
        #[doc = "Event Link Software Event Generation Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsegr(pub u8);
        impl Elsegr {
            #[doc = "Software Event Generation"]
            #[inline(always)]
            pub const fn seg(&self) -> super::vals::Seg {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Seg::from_bits(val as u8)
            }
            #[doc = "Software Event Generation"]
            #[inline(always)]
            pub fn set_seg(&mut self, val: super::vals::Seg) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SEG Bit Write Enable"]
            #[inline(always)]
            pub const fn we(&self) -> super::vals::We {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::We::from_bits(val as u8)
            }
            #[doc = "SEG Bit Write Enable"]
            #[inline(always)]
            pub fn set_we(&mut self, val: super::vals::We) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "ELSEGR Register Write Disable"]
            #[inline(always)]
            pub const fn wi(&self) -> super::vals::Wi {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wi::from_bits(val as u8)
            }
            #[doc = "ELSEGR Register Write Disable"]
            #[inline(always)]
            pub fn set_wi(&mut self, val: super::vals::Wi) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Elsegr {
            #[inline(always)]
            fn default() -> Elsegr {
                Elsegr(0)
            }
        }
        impl core::fmt::Debug for Elsegr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsegr")
                    .field("seg", &self.seg())
                    .field("we", &self.we())
                    .field("wi", &self.wi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsegr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsegr {{ seg: {:?}, we: {:?}, wi: {:?} }}",
                    self.seg(),
                    self.we(),
                    self.wi()
                )
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr(pub u16);
        impl Elsr {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
        }
        impl Default for Elsr {
            #[inline(always)]
            fn default() -> Elsr {
                Elsr(0)
            }
        }
        impl core::fmt::Debug for Elsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr").field("els", &self.els()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elsr {{ els: {=u8:?} }}", self.els())
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr1(pub u16);
        impl Elsr1 {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
        }
        impl Default for Elsr1 {
            #[inline(always)]
            fn default() -> Elsr1 {
                Elsr1(0)
            }
        }
        impl core::fmt::Debug for Elsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr1").field("els", &self.els()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elsr1 {{ els: {=u8:?} }}", self.els())
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr2(pub u16);
        impl Elsr2 {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
        }
        impl Default for Elsr2 {
            #[inline(always)]
            fn default() -> Elsr2 {
                Elsr2(0)
            }
        }
        impl core::fmt::Debug for Elsr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr2").field("els", &self.els()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elsr2 {{ els: {=u8:?} }}", self.els())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Elcon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Elcon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Elcon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Elcon {
            #[inline(always)]
            fn from(val: u8) -> Elcon {
                Elcon::from_bits(val)
            }
        }
        impl From<Elcon> for u8 {
            #[inline(always)]
            fn from(val: Elcon) -> u8 {
                Elcon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Seg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Seg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Seg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Seg {
            #[inline(always)]
            fn from(val: u8) -> Seg {
                Seg::from_bits(val)
            }
        }
        impl From<Seg> for u8 {
            #[inline(always)]
            fn from(val: Seg) -> u8 {
                Seg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum We {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl We {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> We {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for We {
            #[inline(always)]
            fn from(val: u8) -> We {
                We::from_bits(val)
            }
        }
        impl From<We> for u8 {
            #[inline(always)]
            fn from(val: We) -> u8 {
                We::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wi {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wi {
            #[inline(always)]
            fn from(val: u8) -> Wi {
                Wi::from_bits(val)
            }
        }
        impl From<Wi> for u8 {
            #[inline(always)]
            fn from(val: Wi) -> u8 {
                Wi::to_bits(val)
            }
        }
    }
}
pub mod flcn {
    #[doc = "Flash I/O Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Flcn {
        ptr: *mut u8,
    }
    unsafe impl Send for Flcn {}
    unsafe impl Sync for Flcn {}
    impl Flcn {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data Flash Control Register"]
        #[inline(always)]
        pub const fn dflctl(self) -> crate::common::Reg<regs::Dflctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Flash P/E Mode Control Register"]
        #[inline(always)]
        pub const fn fpmcr(self) -> crate::common::Reg<regs::Fpmcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Flash Area Select Register"]
        #[inline(always)]
        pub const fn fasr(self) -> crate::common::Reg<regs::Fasr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Flash Processing Start Address Register L"]
        #[inline(always)]
        pub const fn fsarl(self) -> crate::common::Reg<regs::Fsarl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Flash Processing Start Address Register H"]
        #[inline(always)]
        pub const fn fsarh(self) -> crate::common::Reg<regs::Fsarh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Flash Control Register"]
        #[inline(always)]
        pub const fn fcr(self) -> crate::common::Reg<regs::Fcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Flash Processing End Address Register L"]
        #[inline(always)]
        pub const fn fearl(self) -> crate::common::Reg<regs::Fearl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Flash Processing End Address Register H"]
        #[inline(always)]
        pub const fn fearh(self) -> crate::common::Reg<regs::Fearh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Flash Reset Register"]
        #[inline(always)]
        pub const fn fresetr(self) -> crate::common::Reg<regs::Fresetr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Flash Status Register 1"]
        #[inline(always)]
        pub const fn fstatr1(self) -> crate::common::Reg<regs::Fstatr1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "Flash Write Buffer Register L0"]
        #[inline(always)]
        pub const fn fwbl0(self) -> crate::common::Reg<regs::Fwbl0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Flash Write Buffer Register H0"]
        #[inline(always)]
        pub const fn fwbh0(self) -> crate::common::Reg<regs::Fwbh0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Protection Unlock Register"]
        #[inline(always)]
        pub const fn fpr(self) -> crate::common::Reg<regs::Fpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Protection Unlock Status Register"]
        #[inline(always)]
        pub const fn fpsr(self) -> crate::common::Reg<regs::Fpsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Flash Read Buffer Register L0"]
        #[inline(always)]
        pub const fn frbl0(self) -> crate::common::Reg<regs::Frbl0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Flash Read Buffer Register H0"]
        #[inline(always)]
        pub const fn frbh0(self) -> crate::common::Reg<regs::Frbh0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Flash Startup Setting Monitor Register"]
        #[inline(always)]
        pub const fn fscmr(self) -> crate::common::Reg<regs::Fscmr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[doc = "Flash Access Window Start Address Monitor Register"]
        #[inline(always)]
        pub const fn fawsmr(self) -> crate::common::Reg<regs::Fawsmr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c8usize) as _) }
        }
        #[doc = "Flash Access Window End Address Monitor Register"]
        #[inline(always)]
        pub const fn fawemr(self) -> crate::common::Reg<regs::Fawemr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d0usize) as _) }
        }
        #[doc = "Flash Initial Setting Register"]
        #[inline(always)]
        pub const fn fisr(self) -> crate::common::Reg<regs::Fisr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d8usize) as _) }
        }
        #[doc = "Flash Extra Area Control Register"]
        #[inline(always)]
        pub const fn fexcr(self) -> crate::common::Reg<regs::Fexcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01dcusize) as _) }
        }
        #[doc = "Flash Error Address Monitor Register L"]
        #[inline(always)]
        pub const fn feaml(self) -> crate::common::Reg<regs::Feaml, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01e0usize) as _) }
        }
        #[doc = "Flash Error Address Monitor Register H"]
        #[inline(always)]
        pub const fn feamh(self) -> crate::common::Reg<regs::Feamh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01e8usize) as _) }
        }
        #[doc = "Flash Status Register 2"]
        #[inline(always)]
        pub const fn fstatr2(self) -> crate::common::Reg<regs::Fstatr2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01f0usize) as _) }
        }
        #[doc = "Temperature Sensor Calibration Data Register"]
        #[inline(always)]
        pub const fn tscdr(self) -> crate::common::Reg<regs::Tscdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0228usize) as _) }
        }
        #[doc = "Flash Control Flag Register"]
        #[inline(always)]
        pub const fn fctlfr(self) -> crate::common::Reg<regs::Fctlfr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0370usize) as _) }
        }
        #[doc = "Flash P/E Mode Entry Register"]
        #[inline(always)]
        pub const fn fentryr(self) -> crate::common::Reg<regs::Fentryr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3fb0usize) as _) }
        }
        #[doc = "Memory Wait Cycle Control Register for Data Flash"]
        #[inline(always)]
        pub const fn fldwaitr(self) -> crate::common::Reg<regs::Fldwaitr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3fc4usize) as _) }
        }
        #[doc = "Prefetch Buffer Enable Register"]
        #[inline(always)]
        pub const fn pfber(self) -> crate::common::Reg<regs::Pfber, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3fc8usize) as _) }
        }
        #[doc = "Flash Bank Program Control Register"]
        #[inline(always)]
        pub const fn fbkpgcr(self) -> crate::common::Reg<regs::Fbkpgcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3fd0usize) as _) }
        }
        #[doc = "Flash Bank Swap Control Register"]
        #[inline(always)]
        pub const fn fbkswcr(self) -> crate::common::Reg<regs::Fbkswcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3fd4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Data Flash Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dflctl(pub u8);
        impl Dflctl {
            #[doc = "Data Flash Access Enable"]
            #[inline(always)]
            pub const fn dflen(&self) -> super::vals::Dflen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dflen::from_bits(val as u8)
            }
            #[doc = "Data Flash Access Enable"]
            #[inline(always)]
            pub fn set_dflen(&mut self, val: super::vals::Dflen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Dflctl {
            #[inline(always)]
            fn default() -> Dflctl {
                Dflctl(0)
            }
        }
        impl core::fmt::Debug for Dflctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dflctl")
                    .field("dflen", &self.dflen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dflctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dflctl {{ dflen: {:?} }}", self.dflen())
            }
        }
        #[doc = "Flash Area Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fasr(pub u8);
        impl Fasr {
            #[doc = "Extra Area Select"]
            #[inline(always)]
            pub const fn exs(&self) -> super::vals::Exs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Exs::from_bits(val as u8)
            }
            #[doc = "Extra Area Select"]
            #[inline(always)]
            pub fn set_exs(&mut self, val: super::vals::Exs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fasr {
            #[inline(always)]
            fn default() -> Fasr {
                Fasr(0)
            }
        }
        impl core::fmt::Debug for Fasr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fasr").field("exs", &self.exs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fasr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fasr {{ exs: {:?} }}", self.exs())
            }
        }
        #[doc = "Flash Access Window End Address Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fawemr(pub u16);
        impl Fawemr {
            #[doc = "Access Window End Address"]
            #[inline(always)]
            pub const fn fawe(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Access Window End Address"]
            #[inline(always)]
            pub fn set_fawe(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u16) & 0x07ff) << 0usize);
            }
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub const fn sasmf(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub fn set_sasmf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Fawemr {
            #[inline(always)]
            fn default() -> Fawemr {
                Fawemr(0)
            }
        }
        impl core::fmt::Debug for Fawemr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fawemr")
                    .field("fawe", &self.fawe())
                    .field("sasmf", &self.sasmf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fawemr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fawemr {{ fawe: {=u16:?}, sasmf: {=bool:?} }}",
                    self.fawe(),
                    self.sasmf()
                )
            }
        }
        #[doc = "Flash Access Window Start Address Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fawsmr(pub u16);
        impl Fawsmr {
            #[doc = "Access Window Start Address"]
            #[inline(always)]
            pub const fn faws(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Access Window Start Address"]
            #[inline(always)]
            pub fn set_faws(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u16) & 0x07ff) << 0usize);
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub const fn fspr(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub fn set_fspr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Fawsmr {
            #[inline(always)]
            fn default() -> Fawsmr {
                Fawsmr(0)
            }
        }
        impl core::fmt::Debug for Fawsmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fawsmr")
                    .field("faws", &self.faws())
                    .field("fspr", &self.fspr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fawsmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fawsmr {{ faws: {=u16:?}, fspr: {=bool:?} }}",
                    self.faws(),
                    self.fspr()
                )
            }
        }
        #[doc = "Flash Bank Program Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fbkpgcr(pub u16);
        impl Fbkpgcr {
            #[doc = "Bank Programming Setting Enable"]
            #[inline(always)]
            pub const fn bkpgen(&self) -> super::vals::Bkpgen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bkpgen::from_bits(val as u8)
            }
            #[doc = "Bank Programming Setting Enable"]
            #[inline(always)]
            pub fn set_bkpgen(&mut self, val: super::vals::Bkpgen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn fekey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_fekey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Fbkpgcr {
            #[inline(always)]
            fn default() -> Fbkpgcr {
                Fbkpgcr(0)
            }
        }
        impl core::fmt::Debug for Fbkpgcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fbkpgcr")
                    .field("bkpgen", &self.bkpgen())
                    .field("fekey", &self.fekey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fbkpgcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fbkpgcr {{ bkpgen: {:?}, fekey: {=u8:?} }}",
                    self.bkpgen(),
                    self.fekey()
                )
            }
        }
        #[doc = "Flash Bank Swap Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fbkswcr(pub u16);
        impl Fbkswcr {
            #[doc = "Bank Swap Update Enable"]
            #[inline(always)]
            pub const fn bkswupen(&self) -> super::vals::Bkswupen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bkswupen::from_bits(val as u8)
            }
            #[doc = "Bank Swap Update Enable"]
            #[inline(always)]
            pub fn set_bkswupen(&mut self, val: super::vals::Bkswupen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn fekey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_fekey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Fbkswcr {
            #[inline(always)]
            fn default() -> Fbkswcr {
                Fbkswcr(0)
            }
        }
        impl core::fmt::Debug for Fbkswcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fbkswcr")
                    .field("bkswupen", &self.bkswupen())
                    .field("fekey", &self.fekey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fbkswcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fbkswcr {{ bkswupen: {:?}, fekey: {=u8:?} }}",
                    self.bkswupen(),
                    self.fekey()
                )
            }
        }
        #[doc = "Flash Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fcr(pub u8);
        impl Fcr {
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub const fn cmd(&self) -> super::vals::FcrCmd {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::FcrCmd::from_bits(val as u8)
            }
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub fn set_cmd(&mut self, val: super::vals::FcrCmd) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u8) & 0x0f) << 0usize);
            }
            #[doc = "Data Read Completion"]
            #[inline(always)]
            pub const fn drc(&self) -> super::vals::Drc {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Drc::from_bits(val as u8)
            }
            #[doc = "Data Read Completion"]
            #[inline(always)]
            pub fn set_drc(&mut self, val: super::vals::Drc) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Forced Processing Stop"]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Forced Processing Stop"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub const fn opst(&self) -> super::vals::FcrOpst {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::FcrOpst::from_bits(val as u8)
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub fn set_opst(&mut self, val: super::vals::FcrOpst) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Fcr {
            #[inline(always)]
            fn default() -> Fcr {
                Fcr(0)
            }
        }
        impl core::fmt::Debug for Fcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fcr")
                    .field("cmd", &self.cmd())
                    .field("drc", &self.drc())
                    .field("stop", &self.stop())
                    .field("opst", &self.opst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fcr {{ cmd: {:?}, drc: {:?}, stop: {=bool:?}, opst: {:?} }}",
                    self.cmd(),
                    self.drc(),
                    self.stop(),
                    self.opst()
                )
            }
        }
        #[doc = "Flash Control Flag Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fctlfr(pub u32);
        impl Fctlfr {
            #[doc = "Bank Swap Setting"]
            #[inline(always)]
            pub const fn bankswp(&self) -> super::vals::Bankswp {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Bankswp::from_bits(val as u8)
            }
            #[doc = "Bank Swap Setting"]
            #[inline(always)]
            pub fn set_bankswp(&mut self, val: super::vals::Bankswp) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Fctlfr {
            #[inline(always)]
            fn default() -> Fctlfr {
                Fctlfr(0)
            }
        }
        impl core::fmt::Debug for Fctlfr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fctlfr")
                    .field("bankswp", &self.bankswp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fctlfr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fctlfr {{ bankswp: {:?} }}", self.bankswp())
            }
        }
        #[doc = "Flash Error Address Monitor Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Feamh(pub u16);
        impl Feamh {
            #[doc = "Flash Error Address Monitor Register H"]
            #[inline(always)]
            pub const fn feamh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Error Address Monitor Register H"]
            #[inline(always)]
            pub fn set_feamh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Feamh {
            #[inline(always)]
            fn default() -> Feamh {
                Feamh(0)
            }
        }
        impl core::fmt::Debug for Feamh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Feamh")
                    .field("feamh", &self.feamh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Feamh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Feamh {{ feamh: {=u16:?} }}", self.feamh())
            }
        }
        #[doc = "Flash Error Address Monitor Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Feaml(pub u16);
        impl Feaml {
            #[doc = "Flash Error Address Monitor Register L"]
            #[inline(always)]
            pub const fn feaml(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Error Address Monitor Register L"]
            #[inline(always)]
            pub fn set_feaml(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Feaml {
            #[inline(always)]
            fn default() -> Feaml {
                Feaml(0)
            }
        }
        impl core::fmt::Debug for Feaml {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Feaml")
                    .field("feaml", &self.feaml())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Feaml {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Feaml {{ feaml: {=u16:?} }}", self.feaml())
            }
        }
        #[doc = "Flash Processing End Address Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fearh(pub u16);
        impl Fearh {
            #[doc = "Flash Processing End Address H"]
            #[inline(always)]
            pub const fn fearh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing End Address H"]
            #[inline(always)]
            pub fn set_fearh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fearh {
            #[inline(always)]
            fn default() -> Fearh {
                Fearh(0)
            }
        }
        impl core::fmt::Debug for Fearh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fearh")
                    .field("fearh", &self.fearh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fearh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fearh {{ fearh: {=u16:?} }}", self.fearh())
            }
        }
        #[doc = "Flash Processing End Address Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fearl(pub u16);
        impl Fearl {
            #[doc = "Flash Processing End Address L"]
            #[inline(always)]
            pub const fn fearl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing End Address L"]
            #[inline(always)]
            pub fn set_fearl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fearl {
            #[inline(always)]
            fn default() -> Fearl {
                Fearl(0)
            }
        }
        impl core::fmt::Debug for Fearl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fearl")
                    .field("fearl", &self.fearl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fearl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fearl {{ fearl: {=u16:?} }}", self.fearl())
            }
        }
        #[doc = "Flash P/E Mode Entry Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fentryr(pub u16);
        impl Fentryr {
            #[doc = "Code Flash P/E Mode Entry 0"]
            #[inline(always)]
            pub const fn fentry0(&self) -> super::vals::Fentry0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fentry0::from_bits(val as u8)
            }
            #[doc = "Code Flash P/E Mode Entry 0"]
            #[inline(always)]
            pub fn set_fentry0(&mut self, val: super::vals::Fentry0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Data Flash P/E Mode Entry"]
            #[inline(always)]
            pub const fn fentryd(&self) -> super::vals::Fentryd {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Fentryd::from_bits(val as u8)
            }
            #[doc = "Data Flash P/E Mode Entry"]
            #[inline(always)]
            pub fn set_fentryd(&mut self, val: super::vals::Fentryd) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn fekey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_fekey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Fentryr {
            #[inline(always)]
            fn default() -> Fentryr {
                Fentryr(0)
            }
        }
        impl core::fmt::Debug for Fentryr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fentryr")
                    .field("fentry0", &self.fentry0())
                    .field("fentryd", &self.fentryd())
                    .field("fekey", &self.fekey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fentryr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fentryr {{ fentry0: {:?}, fentryd: {:?}, fekey: {=u8:?} }}",
                    self.fentry0(),
                    self.fentryd(),
                    self.fekey()
                )
            }
        }
        #[doc = "Flash Extra Area Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fexcr(pub u8);
        impl Fexcr {
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub const fn cmd(&self) -> super::vals::FexcrCmd {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::FexcrCmd::from_bits(val as u8)
            }
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub fn set_cmd(&mut self, val: super::vals::FexcrCmd) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub const fn opst(&self) -> super::vals::FexcrOpst {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::FexcrOpst::from_bits(val as u8)
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub fn set_opst(&mut self, val: super::vals::FexcrOpst) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Fexcr {
            #[inline(always)]
            fn default() -> Fexcr {
                Fexcr(0)
            }
        }
        impl core::fmt::Debug for Fexcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fexcr")
                    .field("cmd", &self.cmd())
                    .field("opst", &self.opst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fexcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fexcr {{ cmd: {:?}, opst: {:?} }}",
                    self.cmd(),
                    self.opst()
                )
            }
        }
        #[doc = "Flash Initial Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fisr(pub u8);
        impl Fisr {
            #[doc = "Flash,IF Clock Notification"]
            #[inline(always)]
            pub const fn pcka(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Flash,IF Clock Notification"]
            #[inline(always)]
            pub fn set_pcka(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "Startup Area Select"]
            #[inline(always)]
            pub const fn sas(&self) -> super::vals::Sas {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Sas::from_bits(val as u8)
            }
            #[doc = "Startup Area Select"]
            #[inline(always)]
            pub fn set_sas(&mut self, val: super::vals::Sas) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Fisr {
            #[inline(always)]
            fn default() -> Fisr {
                Fisr(0)
            }
        }
        impl core::fmt::Debug for Fisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fisr")
                    .field("pcka", &self.pcka())
                    .field("sas", &self.sas())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fisr {{ pcka: {=u8:?}, sas: {:?} }}",
                    self.pcka(),
                    self.sas()
                )
            }
        }
        #[doc = "Memory Wait Cycle Control Register for Data Flash"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fldwaitr(pub u8);
        impl Fldwaitr {
            #[doc = "Memory Wait Cycle Select for Data Flash"]
            #[inline(always)]
            pub const fn fldwait1(&self) -> super::vals::Fldwait1 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fldwait1::from_bits(val as u8)
            }
            #[doc = "Memory Wait Cycle Select for Data Flash"]
            #[inline(always)]
            pub fn set_fldwait1(&mut self, val: super::vals::Fldwait1) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fldwaitr {
            #[inline(always)]
            fn default() -> Fldwaitr {
                Fldwaitr(0)
            }
        }
        impl core::fmt::Debug for Fldwaitr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fldwaitr")
                    .field("fldwait1", &self.fldwait1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fldwaitr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fldwaitr {{ fldwait1: {:?} }}", self.fldwait1())
            }
        }
        #[doc = "Flash P/E Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpmcr(pub u8);
        impl Fpmcr {
            #[doc = "Flash Operating Mode Select 0"]
            #[inline(always)]
            pub const fn fms0(&self) -> super::vals::Fms0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Fms0::from_bits(val as u8)
            }
            #[doc = "Flash Operating Mode Select 0"]
            #[inline(always)]
            pub fn set_fms0(&mut self, val: super::vals::Fms0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Code Flash P/E Disable"]
            #[inline(always)]
            pub const fn rpdis(&self) -> super::vals::Rpdis {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rpdis::from_bits(val as u8)
            }
            #[doc = "Code Flash P/E Disable"]
            #[inline(always)]
            pub fn set_rpdis(&mut self, val: super::vals::Rpdis) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Flash Operating Mode Select 1"]
            #[inline(always)]
            pub const fn fms1(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Operating Mode Select 1"]
            #[inline(always)]
            pub fn set_fms1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Fpmcr {
            #[inline(always)]
            fn default() -> Fpmcr {
                Fpmcr(0)
            }
        }
        impl core::fmt::Debug for Fpmcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpmcr")
                    .field("fms0", &self.fms0())
                    .field("rpdis", &self.rpdis())
                    .field("fms1", &self.fms1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpmcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fpmcr {{ fms0: {:?}, rpdis: {:?}, fms1: {=bool:?} }}",
                    self.fms0(),
                    self.rpdis(),
                    self.fms1()
                )
            }
        }
        #[doc = "Protection Unlock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpr(pub u8);
        impl Fpr {
            #[doc = "Protection Unlock"]
            #[inline(always)]
            pub const fn fpr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Protection Unlock"]
            #[inline(always)]
            pub fn set_fpr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Fpr {
            #[inline(always)]
            fn default() -> Fpr {
                Fpr(0)
            }
        }
        impl core::fmt::Debug for Fpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpr").field("fpr", &self.fpr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fpr {{ fpr: {=u8:?} }}", self.fpr())
            }
        }
        #[doc = "Protection Unlock Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpsr(pub u8);
        impl Fpsr {
            #[doc = "Protect Error Flag"]
            #[inline(always)]
            pub const fn perr(&self) -> super::vals::Perr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Perr::from_bits(val as u8)
            }
            #[doc = "Protect Error Flag"]
            #[inline(always)]
            pub fn set_perr(&mut self, val: super::vals::Perr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fpsr {
            #[inline(always)]
            fn default() -> Fpsr {
                Fpsr(0)
            }
        }
        impl core::fmt::Debug for Fpsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpsr").field("perr", &self.perr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fpsr {{ perr: {:?} }}", self.perr())
            }
        }
        #[doc = "Flash Read Buffer Register H0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frbh0(pub u16);
        impl Frbh0 {
            #[doc = "Flash Read Buffer H0"]
            #[inline(always)]
            pub const fn rdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Read Buffer H0"]
            #[inline(always)]
            pub fn set_rdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Frbh0 {
            #[inline(always)]
            fn default() -> Frbh0 {
                Frbh0(0)
            }
        }
        impl core::fmt::Debug for Frbh0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frbh0")
                    .field("rdata", &self.rdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frbh0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frbh0 {{ rdata: {=u16:?} }}", self.rdata())
            }
        }
        #[doc = "Flash Read Buffer Register L0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frbl0(pub u16);
        impl Frbl0 {
            #[doc = "Flash Read Buffer L0"]
            #[inline(always)]
            pub const fn rdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Read Buffer L0"]
            #[inline(always)]
            pub fn set_rdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Frbl0 {
            #[inline(always)]
            fn default() -> Frbl0 {
                Frbl0(0)
            }
        }
        impl core::fmt::Debug for Frbl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frbl0")
                    .field("rdata", &self.rdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frbl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frbl0 {{ rdata: {=u16:?} }}", self.rdata())
            }
        }
        #[doc = "Flash Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fresetr(pub u8);
        impl Fresetr {
            #[doc = "Software reset of the registers"]
            #[inline(always)]
            pub const fn freset(&self) -> super::vals::Freset {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Freset::from_bits(val as u8)
            }
            #[doc = "Software reset of the registers"]
            #[inline(always)]
            pub fn set_freset(&mut self, val: super::vals::Freset) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fresetr {
            #[inline(always)]
            fn default() -> Fresetr {
                Fresetr(0)
            }
        }
        impl core::fmt::Debug for Fresetr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fresetr")
                    .field("freset", &self.freset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fresetr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fresetr {{ freset: {:?} }}", self.freset())
            }
        }
        #[doc = "Flash Processing Start Address Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fsarh(pub u16);
        impl Fsarh {
            #[doc = "Flash Processing Start Address H"]
            #[inline(always)]
            pub const fn fsarh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing Start Address H"]
            #[inline(always)]
            pub fn set_fsarh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fsarh {
            #[inline(always)]
            fn default() -> Fsarh {
                Fsarh(0)
            }
        }
        impl core::fmt::Debug for Fsarh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fsarh")
                    .field("fsarh", &self.fsarh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fsarh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fsarh {{ fsarh: {=u16:?} }}", self.fsarh())
            }
        }
        #[doc = "Flash Processing Start Address Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fsarl(pub u16);
        impl Fsarl {
            #[doc = "Flash Processing Start Address L"]
            #[inline(always)]
            pub const fn fsarl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing Start Address L"]
            #[inline(always)]
            pub fn set_fsarl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fsarl {
            #[inline(always)]
            fn default() -> Fsarl {
                Fsarl(0)
            }
        }
        impl core::fmt::Debug for Fsarl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fsarl")
                    .field("fsarl", &self.fsarl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fsarl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fsarl {{ fsarl: {=u16:?} }}", self.fsarl())
            }
        }
        #[doc = "Flash Startup Setting Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fscmr(pub u16);
        impl Fscmr {
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub const fn sasmf(&self) -> super::vals::Sasmf {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Sasmf::from_bits(val as u8)
            }
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub fn set_sasmf(&mut self, val: super::vals::Sasmf) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub const fn fspr(&self) -> super::vals::Fspr {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Fspr::from_bits(val as u8)
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub fn set_fspr(&mut self, val: super::vals::Fspr) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
        }
        impl Default for Fscmr {
            #[inline(always)]
            fn default() -> Fscmr {
                Fscmr(0)
            }
        }
        impl core::fmt::Debug for Fscmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fscmr")
                    .field("sasmf", &self.sasmf())
                    .field("fspr", &self.fspr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fscmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fscmr {{ sasmf: {:?}, fspr: {:?} }}",
                    self.sasmf(),
                    self.fspr()
                )
            }
        }
        #[doc = "Flash Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fstatr1(pub u8);
        impl Fstatr1 {
            #[doc = "Data Read Ready Flag"]
            #[inline(always)]
            pub const fn drrdy(&self) -> super::vals::Drrdy {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Drrdy::from_bits(val as u8)
            }
            #[doc = "Data Read Ready Flag"]
            #[inline(always)]
            pub fn set_drrdy(&mut self, val: super::vals::Drrdy) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Flash Ready Flag"]
            #[inline(always)]
            pub const fn frdy(&self) -> super::vals::Frdy {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Frdy::from_bits(val as u8)
            }
            #[doc = "Flash Ready Flag"]
            #[inline(always)]
            pub fn set_frdy(&mut self, val: super::vals::Frdy) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Extra Area Ready Flag"]
            #[inline(always)]
            pub const fn exrdy(&self) -> super::vals::Exrdy {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Exrdy::from_bits(val as u8)
            }
            #[doc = "Extra Area Ready Flag"]
            #[inline(always)]
            pub fn set_exrdy(&mut self, val: super::vals::Exrdy) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Fstatr1 {
            #[inline(always)]
            fn default() -> Fstatr1 {
                Fstatr1(0)
            }
        }
        impl core::fmt::Debug for Fstatr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fstatr1")
                    .field("drrdy", &self.drrdy())
                    .field("frdy", &self.frdy())
                    .field("exrdy", &self.exrdy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fstatr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fstatr1 {{ drrdy: {:?}, frdy: {:?}, exrdy: {:?} }}",
                    self.drrdy(),
                    self.frdy(),
                    self.exrdy()
                )
            }
        }
        #[doc = "Flash Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fstatr2(pub u16);
        impl Fstatr2 {
            #[doc = "Erase Error Flag"]
            #[inline(always)]
            pub const fn ererr(&self) -> super::vals::Ererr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ererr::from_bits(val as u8)
            }
            #[doc = "Erase Error Flag"]
            #[inline(always)]
            pub fn set_ererr(&mut self, val: super::vals::Ererr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Program Error Flag"]
            #[inline(always)]
            pub const fn prgerr(&self) -> super::vals::Prgerr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Prgerr::from_bits(val as u8)
            }
            #[doc = "Program Error Flag"]
            #[inline(always)]
            pub fn set_prgerr(&mut self, val: super::vals::Prgerr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Program Error Flag 01"]
            #[inline(always)]
            pub const fn prgerr01(&self) -> super::vals::Prgerr01 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Prgerr01::from_bits(val as u8)
            }
            #[doc = "Program Error Flag 01"]
            #[inline(always)]
            pub fn set_prgerr01(&mut self, val: super::vals::Prgerr01) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Blank Check Error Flag"]
            #[inline(always)]
            pub const fn bcerr(&self) -> super::vals::Bcerr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bcerr::from_bits(val as u8)
            }
            #[doc = "Blank Check Error Flag"]
            #[inline(always)]
            pub fn set_bcerr(&mut self, val: super::vals::Bcerr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Illegal Command Error Flag"]
            #[inline(always)]
            pub const fn ilglerr(&self) -> super::vals::Ilglerr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ilglerr::from_bits(val as u8)
            }
            #[doc = "Illegal Command Error Flag"]
            #[inline(always)]
            pub fn set_ilglerr(&mut self, val: super::vals::Ilglerr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Extra Area Illegal Command Error Flag"]
            #[inline(always)]
            pub const fn eilglerr(&self) -> super::vals::Eilglerr {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Eilglerr::from_bits(val as u8)
            }
            #[doc = "Extra Area Illegal Command Error Flag"]
            #[inline(always)]
            pub fn set_eilglerr(&mut self, val: super::vals::Eilglerr) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
        }
        impl Default for Fstatr2 {
            #[inline(always)]
            fn default() -> Fstatr2 {
                Fstatr2(0)
            }
        }
        impl core::fmt::Debug for Fstatr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fstatr2")
                    .field("ererr", &self.ererr())
                    .field("prgerr", &self.prgerr())
                    .field("prgerr01", &self.prgerr01())
                    .field("bcerr", &self.bcerr())
                    .field("ilglerr", &self.ilglerr())
                    .field("eilglerr", &self.eilglerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fstatr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fstatr2 {{ ererr: {:?}, prgerr: {:?}, prgerr01: {:?}, bcerr: {:?}, ilglerr: {:?}, eilglerr: {:?} }}" , self . ererr () , self . prgerr () , self . prgerr01 () , self . bcerr () , self . ilglerr () , self . eilglerr ())
            }
        }
        #[doc = "Flash Write Buffer Register H0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fwbh0(pub u16);
        impl Fwbh0 {
            #[doc = "Flash Write Buffer H0"]
            #[inline(always)]
            pub const fn wdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Write Buffer H0"]
            #[inline(always)]
            pub fn set_wdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fwbh0 {
            #[inline(always)]
            fn default() -> Fwbh0 {
                Fwbh0(0)
            }
        }
        impl core::fmt::Debug for Fwbh0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fwbh0")
                    .field("wdata", &self.wdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fwbh0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fwbh0 {{ wdata: {=u16:?} }}", self.wdata())
            }
        }
        #[doc = "Flash Write Buffer Register L0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fwbl0(pub u16);
        impl Fwbl0 {
            #[doc = "Flash Write Buffer L0"]
            #[inline(always)]
            pub const fn wdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Write Buffer L0"]
            #[inline(always)]
            pub fn set_wdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fwbl0 {
            #[inline(always)]
            fn default() -> Fwbl0 {
                Fwbl0(0)
            }
        }
        impl core::fmt::Debug for Fwbl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fwbl0")
                    .field("wdata", &self.wdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fwbl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fwbl0 {{ wdata: {=u16:?} }}", self.wdata())
            }
        }
        #[doc = "Prefetch Buffer Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pfber(pub u8);
        impl Pfber {
            #[doc = "Prefetch Buffer Enable bit"]
            #[inline(always)]
            pub const fn pfbe(&self) -> super::vals::Pfbe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pfbe::from_bits(val as u8)
            }
            #[doc = "Prefetch Buffer Enable bit"]
            #[inline(always)]
            pub fn set_pfbe(&mut self, val: super::vals::Pfbe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Pfber {
            #[inline(always)]
            fn default() -> Pfber {
                Pfber(0)
            }
        }
        impl core::fmt::Debug for Pfber {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pfber").field("pfbe", &self.pfbe()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pfber {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pfber {{ pfbe: {:?} }}", self.pfbe())
            }
        }
        #[doc = "Temperature Sensor Calibration Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tscdr(pub u32);
        impl Tscdr {
            #[doc = "Temperature Sensor Calibration Data"]
            #[inline(always)]
            pub const fn tscdr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Temperature Sensor Calibration Data"]
            #[inline(always)]
            pub fn set_tscdr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Tscdr {
            #[inline(always)]
            fn default() -> Tscdr {
                Tscdr(0)
            }
        }
        impl core::fmt::Debug for Tscdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tscdr")
                    .field("tscdr", &self.tscdr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tscdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tscdr {{ tscdr: {=u16:?} }}", self.tscdr())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bankswp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Bankswp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bankswp {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bankswp {
            #[inline(always)]
            fn from(val: u8) -> Bankswp {
                Bankswp::from_bits(val)
            }
        }
        impl From<Bankswp> for u8 {
            #[inline(always)]
            fn from(val: Bankswp) -> u8 {
                Bankswp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bcerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcerr {
            #[inline(always)]
            fn from(val: u8) -> Bcerr {
                Bcerr::from_bits(val)
            }
        }
        impl From<Bcerr> for u8 {
            #[inline(always)]
            fn from(val: Bcerr) -> u8 {
                Bcerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bkpgen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bkpgen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bkpgen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bkpgen {
            #[inline(always)]
            fn from(val: u8) -> Bkpgen {
                Bkpgen::from_bits(val)
            }
        }
        impl From<Bkpgen> for u8 {
            #[inline(always)]
            fn from(val: Bkpgen) -> u8 {
                Bkpgen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bkswupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bkswupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bkswupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bkswupen {
            #[inline(always)]
            fn from(val: u8) -> Bkswupen {
                Bkswupen::from_bits(val)
            }
        }
        impl From<Bkswupen> for u8 {
            #[inline(always)]
            fn from(val: Bkswupen) -> u8 {
                Bkswupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dflen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dflen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dflen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dflen {
            #[inline(always)]
            fn from(val: u8) -> Dflen {
                Dflen::from_bits(val)
            }
        }
        impl From<Dflen> for u8 {
            #[inline(always)]
            fn from(val: Dflen) -> u8 {
                Dflen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Drc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Drc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Drc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Drc {
            #[inline(always)]
            fn from(val: u8) -> Drc {
                Drc::from_bits(val)
            }
        }
        impl From<Drc> for u8 {
            #[inline(always)]
            fn from(val: Drc) -> u8 {
                Drc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Drrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Drrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Drrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Drrdy {
            #[inline(always)]
            fn from(val: u8) -> Drrdy {
                Drrdy::from_bits(val)
            }
        }
        impl From<Drrdy> for u8 {
            #[inline(always)]
            fn from(val: Drrdy) -> u8 {
                Drrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eilglerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eilglerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eilglerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eilglerr {
            #[inline(always)]
            fn from(val: u8) -> Eilglerr {
                Eilglerr::from_bits(val)
            }
        }
        impl From<Eilglerr> for u8 {
            #[inline(always)]
            fn from(val: Eilglerr) -> u8 {
                Eilglerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ererr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ererr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ererr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ererr {
            #[inline(always)]
            fn from(val: u8) -> Ererr {
                Ererr::from_bits(val)
            }
        }
        impl From<Ererr> for u8 {
            #[inline(always)]
            fn from(val: Ererr) -> u8 {
                Ererr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Exrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exrdy {
            #[inline(always)]
            fn from(val: u8) -> Exrdy {
                Exrdy::from_bits(val)
            }
        }
        impl From<Exrdy> for u8 {
            #[inline(always)]
            fn from(val: Exrdy) -> u8 {
                Exrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Exs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exs {
            #[inline(always)]
            fn from(val: u8) -> Exs {
                Exs::from_bits(val)
            }
        }
        impl From<Exs> for u8 {
            #[inline(always)]
            fn from(val: Exs) -> u8 {
                Exs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FcrCmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl FcrCmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FcrCmd {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FcrCmd {
            #[inline(always)]
            fn from(val: u8) -> FcrCmd {
                FcrCmd::from_bits(val)
            }
        }
        impl From<FcrCmd> for u8 {
            #[inline(always)]
            fn from(val: FcrCmd) -> u8 {
                FcrCmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FcrOpst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FcrOpst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FcrOpst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FcrOpst {
            #[inline(always)]
            fn from(val: u8) -> FcrOpst {
                FcrOpst::from_bits(val)
            }
        }
        impl From<FcrOpst> for u8 {
            #[inline(always)]
            fn from(val: FcrOpst) -> u8 {
                FcrOpst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fentry0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fentry0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fentry0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fentry0 {
            #[inline(always)]
            fn from(val: u8) -> Fentry0 {
                Fentry0::from_bits(val)
            }
        }
        impl From<Fentry0> for u8 {
            #[inline(always)]
            fn from(val: Fentry0) -> u8 {
                Fentry0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fentryd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fentryd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fentryd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fentryd {
            #[inline(always)]
            fn from(val: u8) -> Fentryd {
                Fentryd::from_bits(val)
            }
        }
        impl From<Fentryd> for u8 {
            #[inline(always)]
            fn from(val: Fentryd) -> u8 {
                Fentryd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FexcrCmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl FexcrCmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FexcrCmd {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FexcrCmd {
            #[inline(always)]
            fn from(val: u8) -> FexcrCmd {
                FexcrCmd::from_bits(val)
            }
        }
        impl From<FexcrCmd> for u8 {
            #[inline(always)]
            fn from(val: FexcrCmd) -> u8 {
                FexcrCmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FexcrOpst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FexcrOpst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FexcrOpst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FexcrOpst {
            #[inline(always)]
            fn from(val: u8) -> FexcrOpst {
                FexcrOpst::from_bits(val)
            }
        }
        impl From<FexcrOpst> for u8 {
            #[inline(always)]
            fn from(val: FexcrOpst) -> u8 {
                FexcrOpst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fldwait1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fldwait1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fldwait1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fldwait1 {
            #[inline(always)]
            fn from(val: u8) -> Fldwait1 {
                Fldwait1::from_bits(val)
            }
        }
        impl From<Fldwait1> for u8 {
            #[inline(always)]
            fn from(val: Fldwait1) -> u8 {
                Fldwait1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fms0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fms0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fms0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fms0 {
            #[inline(always)]
            fn from(val: u8) -> Fms0 {
                Fms0::from_bits(val)
            }
        }
        impl From<Fms0> for u8 {
            #[inline(always)]
            fn from(val: Fms0) -> u8 {
                Fms0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Frdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Frdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Frdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Frdy {
            #[inline(always)]
            fn from(val: u8) -> Frdy {
                Frdy::from_bits(val)
            }
        }
        impl From<Frdy> for u8 {
            #[inline(always)]
            fn from(val: Frdy) -> u8 {
                Frdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Freset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Freset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Freset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Freset {
            #[inline(always)]
            fn from(val: u8) -> Freset {
                Freset::from_bits(val)
            }
        }
        impl From<Freset> for u8 {
            #[inline(always)]
            fn from(val: Freset) -> u8 {
                Freset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fspr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fspr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fspr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fspr {
            #[inline(always)]
            fn from(val: u8) -> Fspr {
                Fspr::from_bits(val)
            }
        }
        impl From<Fspr> for u8 {
            #[inline(always)]
            fn from(val: Fspr) -> u8 {
                Fspr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ilglerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ilglerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ilglerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ilglerr {
            #[inline(always)]
            fn from(val: u8) -> Ilglerr {
                Ilglerr::from_bits(val)
            }
        }
        impl From<Ilglerr> for u8 {
            #[inline(always)]
            fn from(val: Ilglerr) -> u8 {
                Ilglerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Perr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Perr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Perr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Perr {
            #[inline(always)]
            fn from(val: u8) -> Perr {
                Perr::from_bits(val)
            }
        }
        impl From<Perr> for u8 {
            #[inline(always)]
            fn from(val: Perr) -> u8 {
                Perr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pfbe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pfbe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pfbe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pfbe {
            #[inline(always)]
            fn from(val: u8) -> Pfbe {
                Pfbe::from_bits(val)
            }
        }
        impl From<Pfbe> for u8 {
            #[inline(always)]
            fn from(val: Pfbe) -> u8 {
                Pfbe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prgerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prgerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prgerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prgerr {
            #[inline(always)]
            fn from(val: u8) -> Prgerr {
                Prgerr::from_bits(val)
            }
        }
        impl From<Prgerr> for u8 {
            #[inline(always)]
            fn from(val: Prgerr) -> u8 {
                Prgerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prgerr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prgerr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prgerr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prgerr01 {
            #[inline(always)]
            fn from(val: u8) -> Prgerr01 {
                Prgerr01::from_bits(val)
            }
        }
        impl From<Prgerr01> for u8 {
            #[inline(always)]
            fn from(val: Prgerr01) -> u8 {
                Prgerr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpdis {
            #[inline(always)]
            fn from(val: u8) -> Rpdis {
                Rpdis::from_bits(val)
            }
        }
        impl From<Rpdis> for u8 {
            #[inline(always)]
            fn from(val: Rpdis) -> u8 {
                Rpdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sas {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sas {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sas {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sas {
            #[inline(always)]
            fn from(val: u8) -> Sas {
                Sas::from_bits(val)
            }
        }
        impl From<Sas> for u8 {
            #[inline(always)]
            fn from(val: Sas) -> u8 {
                Sas::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sasmf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sasmf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sasmf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sasmf {
            #[inline(always)]
            fn from(val: u8) -> Sasmf {
                Sasmf::from_bits(val)
            }
        }
        impl From<Sasmf> for u8 {
            #[inline(always)]
            fn from(val: Sasmf) -> u8 {
                Sasmf::to_bits(val)
            }
        }
    }
}
pub mod gpt164 {
    #[doc = "General PWM 16-bit Timer 4"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpt164 {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpt164 {}
    unsafe impl Sync for Gpt164 {}
    impl Gpt164 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "General PWM Timer Write,Protection Register"]
        #[inline(always)]
        pub const fn gtwp(self) -> crate::common::Reg<regs::Gtwp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "General PWM Timer Software Start Register"]
        #[inline(always)]
        pub const fn gtstr(self) -> crate::common::Reg<regs::Gtstr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "General PWM Timer Software Stop Register"]
        #[inline(always)]
        pub const fn gtstp(self) -> crate::common::Reg<regs::Gtstp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "General PWM Timer Software Clear Register"]
        #[inline(always)]
        pub const fn gtclr(self) -> crate::common::Reg<regs::Gtclr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "General PWM Timer Start Source Select Register"]
        #[inline(always)]
        pub const fn gtssr(self) -> crate::common::Reg<regs::Gtssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "General PWM Timer Stop Source Select Register"]
        #[inline(always)]
        pub const fn gtpsr(self) -> crate::common::Reg<regs::Gtpsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "General PWM Timer Clear Source Select Register"]
        #[inline(always)]
        pub const fn gtcsr(self) -> crate::common::Reg<regs::Gtcsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "General PWM Timer Up Count Source Select Register"]
        #[inline(always)]
        pub const fn gtupsr(self) -> crate::common::Reg<regs::Gtupsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "General PWM Timer Down Count Source Select Register"]
        #[inline(always)]
        pub const fn gtdnsr(self) -> crate::common::Reg<regs::Gtdnsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register A"]
        #[inline(always)]
        pub const fn gticasr(self) -> crate::common::Reg<regs::Gticasr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register B"]
        #[inline(always)]
        pub const fn gticbsr(self) -> crate::common::Reg<regs::Gticbsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "General PWM Timer Control Register"]
        #[inline(always)]
        pub const fn gtcr(self) -> crate::common::Reg<regs::Gtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "General PWM Timer Count Direction and Duty Setting Register"]
        #[inline(always)]
        pub const fn gtuddtyc(self) -> crate::common::Reg<regs::Gtuddtyc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "General PWM Timer I/O Control Register"]
        #[inline(always)]
        pub const fn gtior(self) -> crate::common::Reg<regs::Gtior, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "General PWM Timer Interrupt Output Setting Register"]
        #[inline(always)]
        pub const fn gtintad(self) -> crate::common::Reg<regs::Gtintad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "General PWM Timer Status Register"]
        #[inline(always)]
        pub const fn gtst(self) -> crate::common::Reg<regs::Gtst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "General PWM Timer Buffer Enable Register"]
        #[inline(always)]
        pub const fn gtber(self) -> crate::common::Reg<regs::Gtber, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "General PWM Timer Counter"]
        #[inline(always)]
        pub const fn gtcnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register A"]
        #[inline(always)]
        pub const fn gtccra(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register B"]
        #[inline(always)]
        pub const fn gtccrb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register C"]
        #[inline(always)]
        pub const fn gtccrc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register E"]
        #[inline(always)]
        pub const fn gtccre(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register D"]
        #[inline(always)]
        pub const fn gtccrd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register F"]
        #[inline(always)]
        pub const fn gtccrf(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "General PWM Timer Cycle Setting Register"]
        #[inline(always)]
        pub const fn gtpr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "General PWM Timer Cycle Setting Buffer Register"]
        #[inline(always)]
        pub const fn gtpbr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "General PWM Timer Dead Time Control Register"]
        #[inline(always)]
        pub const fn gtdtcr(self) -> crate::common::Reg<regs::Gtdtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "General PWM Timer Dead Time Value Register U"]
        #[inline(always)]
        pub const fn gtdvu(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "General PWM Timer Buffer Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtber(pub u32);
        impl Gtber {
            #[doc = "GTCCR Buffer Operation Disable"]
            #[inline(always)]
            pub const fn bd0(&self) -> super::vals::Bd0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bd0::from_bits(val as u8)
            }
            #[doc = "GTCCR Buffer Operation Disable"]
            #[inline(always)]
            pub fn set_bd0(&mut self, val: super::vals::Bd0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTPR Buffer Operation Disable"]
            #[inline(always)]
            pub const fn bd1(&self) -> super::vals::Bd1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Bd1::from_bits(val as u8)
            }
            #[doc = "GTPR Buffer Operation Disable"]
            #[inline(always)]
            pub fn set_bd1(&mut self, val: super::vals::Bd1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTCCRA Buffer Operation"]
            #[inline(always)]
            pub const fn ccra(&self) -> super::vals::Ccra {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Ccra::from_bits(val as u8)
            }
            #[doc = "GTCCRA Buffer Operation"]
            #[inline(always)]
            pub fn set_ccra(&mut self, val: super::vals::Ccra) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "GTCCRB Buffer Operation"]
            #[inline(always)]
            pub const fn ccrb(&self) -> super::vals::Ccrb {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Ccrb::from_bits(val as u8)
            }
            #[doc = "GTCCRB Buffer Operation"]
            #[inline(always)]
            pub fn set_ccrb(&mut self, val: super::vals::Ccrb) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "GTPR Buffer Operation"]
            #[inline(always)]
            pub const fn pr(&self) -> super::vals::Pr {
                let val = (self.0 >> 20usize) & 0x03;
                super::vals::Pr::from_bits(val as u8)
            }
            #[doc = "GTPR Buffer Operation"]
            #[inline(always)]
            pub fn set_pr(&mut self, val: super::vals::Pr) {
                self.0 =
                    (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
            }
            #[doc = "GTCCRA and GTCCRB Forcible Buffer Operation"]
            #[inline(always)]
            pub const fn ccrswt(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GTCCRA and GTCCRB Forcible Buffer Operation"]
            #[inline(always)]
            pub fn set_ccrswt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Gtber {
            #[inline(always)]
            fn default() -> Gtber {
                Gtber(0)
            }
        }
        impl core::fmt::Debug for Gtber {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtber")
                    .field("bd0", &self.bd0())
                    .field("bd1", &self.bd1())
                    .field("ccra", &self.ccra())
                    .field("ccrb", &self.ccrb())
                    .field("pr", &self.pr())
                    .field("ccrswt", &self.ccrswt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtber {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtber {{ bd0: {:?}, bd1: {:?}, ccra: {:?}, ccrb: {:?}, pr: {:?}, ccrswt: {=bool:?} }}" , self . bd0 () , self . bd1 () , self . ccra () , self . ccrb () , self . pr () , self . ccrswt ())
            }
        }
        #[doc = "General PWM Timer Software Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtclr(pub u32);
        impl Gtclr {
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr0(&self) -> super::vals::Cclr0 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cclr0::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr0(&mut self, val: super::vals::Cclr0) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr1(&self) -> super::vals::Cclr1 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cclr1::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr1(&mut self, val: super::vals::Cclr1) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr2(&self) -> super::vals::Cclr2 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cclr2::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr2(&mut self, val: super::vals::Cclr2) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr3(&self) -> super::vals::Cclr3 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cclr3::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr3(&mut self, val: super::vals::Cclr3) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr4(&self) -> super::vals::Cclr4 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cclr4::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr4(&mut self, val: super::vals::Cclr4) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr5(&self) -> super::vals::Cclr5 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cclr5::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr5(&mut self, val: super::vals::Cclr5) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr6(&self) -> super::vals::Cclr6 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cclr6::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr6(&mut self, val: super::vals::Cclr6) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr7(&self) -> super::vals::Cclr7 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cclr7::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr7(&mut self, val: super::vals::Cclr7) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr8(&self) -> super::vals::Cclr8 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cclr8::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr8(&mut self, val: super::vals::Cclr8) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr9(&self) -> super::vals::Cclr9 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cclr9::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr9(&mut self, val: super::vals::Cclr9) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Gtclr {
            #[inline(always)]
            fn default() -> Gtclr {
                Gtclr(0)
            }
        }
        impl core::fmt::Debug for Gtclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtclr")
                    .field("cclr0", &self.cclr0())
                    .field("cclr1", &self.cclr1())
                    .field("cclr2", &self.cclr2())
                    .field("cclr3", &self.cclr3())
                    .field("cclr4", &self.cclr4())
                    .field("cclr5", &self.cclr5())
                    .field("cclr6", &self.cclr6())
                    .field("cclr7", &self.cclr7())
                    .field("cclr8", &self.cclr8())
                    .field("cclr9", &self.cclr9())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtclr {{ cclr0: {:?}, cclr1: {:?}, cclr2: {:?}, cclr3: {:?}, cclr4: {:?}, cclr5: {:?}, cclr6: {:?}, cclr7: {:?}, cclr8: {:?}, cclr9: {:?} }}" , self . cclr0 () , self . cclr1 () , self . cclr2 () , self . cclr3 () , self . cclr4 () , self . cclr5 () , self . cclr6 () , self . cclr7 () , self . cclr8 () , self . cclr9 ())
            }
        }
        #[doc = "General PWM Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcr(pub u32);
        impl Gtcr {
            #[doc = "Count Start"]
            #[inline(always)]
            pub const fn cst(&self) -> super::vals::Cst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cst::from_bits(val as u8)
            }
            #[doc = "Count Start"]
            #[inline(always)]
            pub fn set_cst(&mut self, val: super::vals::Cst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Mode Select"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Md {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Md::from_bits(val as u8)
            }
            #[doc = "Mode Select"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Md) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "Timer Prescaler Select"]
            #[inline(always)]
            pub const fn tpcs(&self) -> super::vals::Tpcs {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Tpcs::from_bits(val as u8)
            }
            #[doc = "Timer Prescaler Select"]
            #[inline(always)]
            pub fn set_tpcs(&mut self, val: super::vals::Tpcs) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Gtcr {
            #[inline(always)]
            fn default() -> Gtcr {
                Gtcr(0)
            }
        }
        impl core::fmt::Debug for Gtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcr")
                    .field("cst", &self.cst())
                    .field("md", &self.md())
                    .field("tpcs", &self.tpcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtcr {{ cst: {:?}, md: {:?}, tpcs: {:?} }}",
                    self.cst(),
                    self.md(),
                    self.tpcs()
                )
            }
        }
        #[doc = "General PWM Timer Clear Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcsr(pub u32);
        impl Gtcsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgar(&self) -> super::vals::Csgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Csgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgar(&mut self, val: super::vals::Csgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgaf(&self) -> super::vals::Csgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Csgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgaf(&mut self, val: super::vals::Csgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgbr(&self) -> super::vals::Csgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Csgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgbr(&mut self, val: super::vals::Csgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgbf(&self) -> super::vals::Csgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Csgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgbf(&mut self, val: super::vals::Csgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscarbl(&self) -> super::vals::Cscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscarbl(&mut self, val: super::vals::Cscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscarbh(&self) -> super::vals::Cscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscarbh(&mut self, val: super::vals::Cscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscafbl(&self) -> super::vals::Cscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscafbl(&mut self, val: super::vals::Cscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscafbh(&self) -> super::vals::Cscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscafbh(&mut self, val: super::vals::Cscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbral(&self) -> super::vals::Cscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbral(&mut self, val: super::vals::Cscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbrah(&self) -> super::vals::Cscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbrah(&mut self, val: super::vals::Cscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbfal(&self) -> super::vals::Cscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbfal(&mut self, val: super::vals::Cscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbfah(&self) -> super::vals::Cscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbfah(&mut self, val: super::vals::Cscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselca(&self) -> super::vals::Cselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Cselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselca(&mut self, val: super::vals::Cselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcb(&self) -> super::vals::Cselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Cselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcb(&mut self, val: super::vals::Cselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcc(&self) -> super::vals::Cselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Cselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcc(&mut self, val: super::vals::Cselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcd(&self) -> super::vals::Cselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Cselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcd(&mut self, val: super::vals::Cselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Software Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cclr(&self) -> super::vals::Cclr {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cclr::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cclr(&mut self, val: super::vals::Cclr) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtcsr {
            #[inline(always)]
            fn default() -> Gtcsr {
                Gtcsr(0)
            }
        }
        impl core::fmt::Debug for Gtcsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcsr")
                    .field("csgtrgar", &self.csgtrgar())
                    .field("csgtrgaf", &self.csgtrgaf())
                    .field("csgtrgbr", &self.csgtrgbr())
                    .field("csgtrgbf", &self.csgtrgbf())
                    .field("cscarbl", &self.cscarbl())
                    .field("cscarbh", &self.cscarbh())
                    .field("cscafbl", &self.cscafbl())
                    .field("cscafbh", &self.cscafbh())
                    .field("cscbral", &self.cscbral())
                    .field("cscbrah", &self.cscbrah())
                    .field("cscbfal", &self.cscbfal())
                    .field("cscbfah", &self.cscbfah())
                    .field("cselca", &self.cselca())
                    .field("cselcb", &self.cselcb())
                    .field("cselcc", &self.cselcc())
                    .field("cselcd", &self.cselcd())
                    .field("cclr", &self.cclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtcsr {{ csgtrgar: {:?}, csgtrgaf: {:?}, csgtrgbr: {:?}, csgtrgbf: {:?}, cscarbl: {:?}, cscarbh: {:?}, cscafbl: {:?}, cscafbh: {:?}, cscbral: {:?}, cscbrah: {:?}, cscbfal: {:?}, cscbfah: {:?}, cselca: {:?}, cselcb: {:?}, cselcc: {:?}, cselcd: {:?}, cclr: {:?} }}" , self . csgtrgar () , self . csgtrgaf () , self . csgtrgbr () , self . csgtrgbf () , self . cscarbl () , self . cscarbh () , self . cscafbl () , self . cscafbh () , self . cscbral () , self . cscbrah () , self . cscbfal () , self . cscbfah () , self . cselca () , self . cselcb () , self . cselcc () , self . cselcd () , self . cclr ())
            }
        }
        #[doc = "General PWM Timer Down Count Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdnsr(pub u32);
        impl Gtdnsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgar(&self) -> super::vals::Dsgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dsgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgar(&mut self, val: super::vals::Dsgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgaf(&self) -> super::vals::Dsgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Dsgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgaf(&mut self, val: super::vals::Dsgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgbr(&self) -> super::vals::Dsgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dsgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgbr(&mut self, val: super::vals::Dsgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgbf(&self) -> super::vals::Dsgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dsgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgbf(&mut self, val: super::vals::Dsgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscarbl(&self) -> super::vals::Dscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Dscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscarbl(&mut self, val: super::vals::Dscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscarbh(&self) -> super::vals::Dscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Dscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscarbh(&mut self, val: super::vals::Dscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscafbl(&self) -> super::vals::Dscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Dscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscafbl(&mut self, val: super::vals::Dscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscafbh(&self) -> super::vals::Dscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Dscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscafbh(&mut self, val: super::vals::Dscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbral(&self) -> super::vals::Dscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Dscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbral(&mut self, val: super::vals::Dscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbrah(&self) -> super::vals::Dscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Dscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbrah(&mut self, val: super::vals::Dscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbfal(&self) -> super::vals::Dscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Dscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbfal(&mut self, val: super::vals::Dscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbfah(&self) -> super::vals::Dscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Dscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbfah(&mut self, val: super::vals::Dscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselca(&self) -> super::vals::Dselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Dselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselca(&mut self, val: super::vals::Dselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcb(&self) -> super::vals::Dselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Dselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcb(&mut self, val: super::vals::Dselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcc(&self) -> super::vals::Dselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Dselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcc(&mut self, val: super::vals::Dselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcd(&self) -> super::vals::Dselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Dselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcd(&mut self, val: super::vals::Dselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gtdnsr {
            #[inline(always)]
            fn default() -> Gtdnsr {
                Gtdnsr(0)
            }
        }
        impl core::fmt::Debug for Gtdnsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdnsr")
                    .field("dsgtrgar", &self.dsgtrgar())
                    .field("dsgtrgaf", &self.dsgtrgaf())
                    .field("dsgtrgbr", &self.dsgtrgbr())
                    .field("dsgtrgbf", &self.dsgtrgbf())
                    .field("dscarbl", &self.dscarbl())
                    .field("dscarbh", &self.dscarbh())
                    .field("dscafbl", &self.dscafbl())
                    .field("dscafbh", &self.dscafbh())
                    .field("dscbral", &self.dscbral())
                    .field("dscbrah", &self.dscbrah())
                    .field("dscbfal", &self.dscbfal())
                    .field("dscbfah", &self.dscbfah())
                    .field("dselca", &self.dselca())
                    .field("dselcb", &self.dselcb())
                    .field("dselcc", &self.dselcc())
                    .field("dselcd", &self.dselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdnsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtdnsr {{ dsgtrgar: {:?}, dsgtrgaf: {:?}, dsgtrgbr: {:?}, dsgtrgbf: {:?}, dscarbl: {:?}, dscarbh: {:?}, dscafbl: {:?}, dscafbh: {:?}, dscbral: {:?}, dscbrah: {:?}, dscbfal: {:?}, dscbfah: {:?}, dselca: {:?}, dselcb: {:?}, dselcc: {:?}, dselcd: {:?} }}" , self . dsgtrgar () , self . dsgtrgaf () , self . dsgtrgbr () , self . dsgtrgbf () , self . dscarbl () , self . dscarbh () , self . dscafbl () , self . dscafbh () , self . dscbral () , self . dscbrah () , self . dscbfal () , self . dscbfah () , self . dselca () , self . dselcb () , self . dselcc () , self . dselcd ())
            }
        }
        #[doc = "General PWM Timer Dead Time Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdtcr(pub u32);
        impl Gtdtcr {
            #[doc = "Negative,Phase Waveform Setting"]
            #[inline(always)]
            pub const fn tde(&self) -> super::vals::Tde {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tde::from_bits(val as u8)
            }
            #[doc = "Negative,Phase Waveform Setting"]
            #[inline(always)]
            pub fn set_tde(&mut self, val: super::vals::Tde) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Gtdtcr {
            #[inline(always)]
            fn default() -> Gtdtcr {
                Gtdtcr(0)
            }
        }
        impl core::fmt::Debug for Gtdtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdtcr").field("tde", &self.tde()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtdtcr {{ tde: {:?} }}", self.tde())
            }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gticasr(pub u32);
        impl Gticasr {
            #[doc = "GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgar(&self) -> super::vals::Asgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Asgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgar(&mut self, val: super::vals::Asgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgaf(&self) -> super::vals::Asgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Asgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgaf(&mut self, val: super::vals::Asgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgbr(&self) -> super::vals::Asgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Asgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgbr(&mut self, val: super::vals::Asgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgbf(&self) -> super::vals::Asgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Asgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgbf(&mut self, val: super::vals::Asgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascarbl(&self) -> super::vals::Ascarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ascarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascarbl(&mut self, val: super::vals::Ascarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascarbh(&self) -> super::vals::Ascarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ascarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascarbh(&mut self, val: super::vals::Ascarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascafbl(&self) -> super::vals::Ascafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ascafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascafbl(&mut self, val: super::vals::Ascafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascafbh(&self) -> super::vals::Ascafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ascafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascafbh(&mut self, val: super::vals::Ascafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbral(&self) -> super::vals::Ascbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ascbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbral(&mut self, val: super::vals::Ascbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbrah(&self) -> super::vals::Ascbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ascbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbrah(&mut self, val: super::vals::Ascbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbfal(&self) -> super::vals::Ascbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ascbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbfal(&mut self, val: super::vals::Ascbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbfah(&self) -> super::vals::Ascbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ascbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbfah(&mut self, val: super::vals::Ascbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselca(&self) -> super::vals::Aselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Aselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselca(&mut self, val: super::vals::Aselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcb(&self) -> super::vals::Aselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Aselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcb(&mut self, val: super::vals::Aselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcc(&self) -> super::vals::Aselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Aselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcc(&mut self, val: super::vals::Aselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcd(&self) -> super::vals::Aselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Aselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcd(&mut self, val: super::vals::Aselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gticasr {
            #[inline(always)]
            fn default() -> Gticasr {
                Gticasr(0)
            }
        }
        impl core::fmt::Debug for Gticasr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gticasr")
                    .field("asgtrgar", &self.asgtrgar())
                    .field("asgtrgaf", &self.asgtrgaf())
                    .field("asgtrgbr", &self.asgtrgbr())
                    .field("asgtrgbf", &self.asgtrgbf())
                    .field("ascarbl", &self.ascarbl())
                    .field("ascarbh", &self.ascarbh())
                    .field("ascafbl", &self.ascafbl())
                    .field("ascafbh", &self.ascafbh())
                    .field("ascbral", &self.ascbral())
                    .field("ascbrah", &self.ascbrah())
                    .field("ascbfal", &self.ascbfal())
                    .field("ascbfah", &self.ascbfah())
                    .field("aselca", &self.aselca())
                    .field("aselcb", &self.aselcb())
                    .field("aselcc", &self.aselcc())
                    .field("aselcd", &self.aselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gticasr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gticasr {{ asgtrgar: {:?}, asgtrgaf: {:?}, asgtrgbr: {:?}, asgtrgbf: {:?}, ascarbl: {:?}, ascarbh: {:?}, ascafbl: {:?}, ascafbh: {:?}, ascbral: {:?}, ascbrah: {:?}, ascbfal: {:?}, ascbfah: {:?}, aselca: {:?}, aselcb: {:?}, aselcc: {:?}, aselcd: {:?} }}" , self . asgtrgar () , self . asgtrgaf () , self . asgtrgbr () , self . asgtrgbf () , self . ascarbl () , self . ascarbh () , self . ascafbl () , self . ascafbh () , self . ascbral () , self . ascbrah () , self . ascbfal () , self . ascbfah () , self . aselca () , self . aselcb () , self . aselcc () , self . aselcd ())
            }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gticbsr(pub u32);
        impl Gticbsr {
            #[doc = "GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgar(&self) -> super::vals::Bsgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bsgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgar(&mut self, val: super::vals::Bsgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgaf(&self) -> super::vals::Bsgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Bsgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgaf(&mut self, val: super::vals::Bsgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgbr(&self) -> super::vals::Bsgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Bsgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgbr(&mut self, val: super::vals::Bsgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgbf(&self) -> super::vals::Bsgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bsgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgbf(&mut self, val: super::vals::Bsgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscarbl(&self) -> super::vals::Bscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Bscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscarbl(&mut self, val: super::vals::Bscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscarbh(&self) -> super::vals::Bscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Bscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscarbh(&mut self, val: super::vals::Bscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscafbl(&self) -> super::vals::Bscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscafbl(&mut self, val: super::vals::Bscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscafbh(&self) -> super::vals::Bscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Bscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscafbh(&mut self, val: super::vals::Bscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbral(&self) -> super::vals::Bscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Bscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbral(&mut self, val: super::vals::Bscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbrah(&self) -> super::vals::Bscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Bscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbrah(&mut self, val: super::vals::Bscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbfal(&self) -> super::vals::Bscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Bscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbfal(&mut self, val: super::vals::Bscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbfah(&self) -> super::vals::Bscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Bscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbfah(&mut self, val: super::vals::Bscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselca(&self) -> super::vals::Bselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Bselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselca(&mut self, val: super::vals::Bselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcb(&self) -> super::vals::Bselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Bselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcb(&mut self, val: super::vals::Bselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcc(&self) -> super::vals::Bselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Bselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcc(&mut self, val: super::vals::Bselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcd(&self) -> super::vals::Bselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Bselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcd(&mut self, val: super::vals::Bselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gticbsr {
            #[inline(always)]
            fn default() -> Gticbsr {
                Gticbsr(0)
            }
        }
        impl core::fmt::Debug for Gticbsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gticbsr")
                    .field("bsgtrgar", &self.bsgtrgar())
                    .field("bsgtrgaf", &self.bsgtrgaf())
                    .field("bsgtrgbr", &self.bsgtrgbr())
                    .field("bsgtrgbf", &self.bsgtrgbf())
                    .field("bscarbl", &self.bscarbl())
                    .field("bscarbh", &self.bscarbh())
                    .field("bscafbl", &self.bscafbl())
                    .field("bscafbh", &self.bscafbh())
                    .field("bscbral", &self.bscbral())
                    .field("bscbrah", &self.bscbrah())
                    .field("bscbfal", &self.bscbfal())
                    .field("bscbfah", &self.bscbfah())
                    .field("bselca", &self.bselca())
                    .field("bselcb", &self.bselcb())
                    .field("bselcc", &self.bselcc())
                    .field("bselcd", &self.bselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gticbsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gticbsr {{ bsgtrgar: {:?}, bsgtrgaf: {:?}, bsgtrgbr: {:?}, bsgtrgbf: {:?}, bscarbl: {:?}, bscarbh: {:?}, bscafbl: {:?}, bscafbh: {:?}, bscbral: {:?}, bscbrah: {:?}, bscbfal: {:?}, bscbfah: {:?}, bselca: {:?}, bselcb: {:?}, bselcc: {:?}, bselcd: {:?} }}" , self . bsgtrgar () , self . bsgtrgaf () , self . bsgtrgbr () , self . bsgtrgbf () , self . bscarbl () , self . bscarbh () , self . bscafbl () , self . bscafbh () , self . bscbral () , self . bscbrah () , self . bscbfal () , self . bscbfah () , self . bselca () , self . bselcb () , self . bselcc () , self . bselcd ())
            }
        }
        #[doc = "General PWM Timer Interrupt Output Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtintad(pub u32);
        impl Gtintad {
            #[doc = "Output Disable Source Select"]
            #[inline(always)]
            pub const fn grp(&self) -> super::vals::Grp {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Grp::from_bits(val as u8)
            }
            #[doc = "Output Disable Source Select"]
            #[inline(always)]
            pub fn set_grp(&mut self, val: super::vals::Grp) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub const fn grpabh(&self) -> super::vals::Grpabh {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Grpabh::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub fn set_grpabh(&mut self, val: super::vals::Grpabh) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub const fn grpabl(&self) -> super::vals::Grpabl {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Grpabl::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub fn set_grpabl(&mut self, val: super::vals::Grpabl) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Gtintad {
            #[inline(always)]
            fn default() -> Gtintad {
                Gtintad(0)
            }
        }
        impl core::fmt::Debug for Gtintad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtintad")
                    .field("grp", &self.grp())
                    .field("grpabh", &self.grpabh())
                    .field("grpabl", &self.grpabl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtintad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtintad {{ grp: {:?}, grpabh: {:?}, grpabl: {:?} }}",
                    self.grp(),
                    self.grpabh(),
                    self.grpabl()
                )
            }
        }
        #[doc = "General PWM Timer I/O Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtior(pub u32);
        impl Gtior {
            #[doc = "GTIOCnA Pin Function Select"]
            #[inline(always)]
            pub const fn gtioa(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "GTIOCnA Pin Function Select"]
            #[inline(always)]
            pub fn set_gtioa(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GTIOCnA Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub const fn oadflt(&self) -> super::vals::Oadflt {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Oadflt::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub fn set_oadflt(&mut self, val: super::vals::Oadflt) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "GTIOCnA Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub const fn oahld(&self) -> super::vals::Oahld {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Oahld::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub fn set_oahld(&mut self, val: super::vals::Oahld) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "GTIOCnA Pin Output Enable"]
            #[inline(always)]
            pub const fn oae(&self) -> super::vals::Oae {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Oae::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Output Enable"]
            #[inline(always)]
            pub fn set_oae(&mut self, val: super::vals::Oae) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Disable Value Setting"]
            #[inline(always)]
            pub const fn oadf(&self) -> super::vals::Oadf {
                let val = (self.0 >> 9usize) & 0x03;
                super::vals::Oadf::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Disable Value Setting"]
            #[inline(always)]
            pub fn set_oadf(&mut self, val: super::vals::Oadf) {
                self.0 = (self.0 & !(0x03 << 9usize)) | (((val.to_bits() as u32) & 0x03) << 9usize);
            }
            #[doc = "Noise Filter A Enable"]
            #[inline(always)]
            pub const fn nfaen(&self) -> super::vals::Nfaen {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Nfaen::from_bits(val as u8)
            }
            #[doc = "Noise Filter A Enable"]
            #[inline(always)]
            pub fn set_nfaen(&mut self, val: super::vals::Nfaen) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Noise Filter A Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfcsa(&self) -> super::vals::Nfcsa {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Nfcsa::from_bits(val as u8)
            }
            #[doc = "Noise Filter A Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfcsa(&mut self, val: super::vals::Nfcsa) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u32) & 0x03) << 14usize);
            }
            #[doc = "GTIOCnB Pin Function Select"]
            #[inline(always)]
            pub const fn gtiob(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "GTIOCnB Pin Function Select"]
            #[inline(always)]
            pub fn set_gtiob(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
            #[doc = "GTIOCnB Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub const fn obdflt(&self) -> super::vals::Obdflt {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Obdflt::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub fn set_obdflt(&mut self, val: super::vals::Obdflt) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "GTIOCnB Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub const fn obhld(&self) -> super::vals::Obhld {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Obhld::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub fn set_obhld(&mut self, val: super::vals::Obhld) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "GTIOCnB Pin Output Enable"]
            #[inline(always)]
            pub const fn obe(&self) -> super::vals::Obe {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Obe::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Output Enable"]
            #[inline(always)]
            pub fn set_obe(&mut self, val: super::vals::Obe) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "GTIOCnB Pin Disable Value Setting"]
            #[inline(always)]
            pub const fn obdf(&self) -> super::vals::Obdf {
                let val = (self.0 >> 25usize) & 0x03;
                super::vals::Obdf::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Disable Value Setting"]
            #[inline(always)]
            pub fn set_obdf(&mut self, val: super::vals::Obdf) {
                self.0 =
                    (self.0 & !(0x03 << 25usize)) | (((val.to_bits() as u32) & 0x03) << 25usize);
            }
            #[doc = "Noise Filter B Enable"]
            #[inline(always)]
            pub const fn nfben(&self) -> super::vals::Nfben {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Nfben::from_bits(val as u8)
            }
            #[doc = "Noise Filter B Enable"]
            #[inline(always)]
            pub fn set_nfben(&mut self, val: super::vals::Nfben) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Noise Filter B Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfcsb(&self) -> super::vals::Nfcsb {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::Nfcsb::from_bits(val as u8)
            }
            #[doc = "Noise Filter B Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfcsb(&mut self, val: super::vals::Nfcsb) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Gtior {
            #[inline(always)]
            fn default() -> Gtior {
                Gtior(0)
            }
        }
        impl core::fmt::Debug for Gtior {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtior")
                    .field("gtioa", &self.gtioa())
                    .field("oadflt", &self.oadflt())
                    .field("oahld", &self.oahld())
                    .field("oae", &self.oae())
                    .field("oadf", &self.oadf())
                    .field("nfaen", &self.nfaen())
                    .field("nfcsa", &self.nfcsa())
                    .field("gtiob", &self.gtiob())
                    .field("obdflt", &self.obdflt())
                    .field("obhld", &self.obhld())
                    .field("obe", &self.obe())
                    .field("obdf", &self.obdf())
                    .field("nfben", &self.nfben())
                    .field("nfcsb", &self.nfcsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtior {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtior {{ gtioa: {=u8:?}, oadflt: {:?}, oahld: {:?}, oae: {:?}, oadf: {:?}, nfaen: {:?}, nfcsa: {:?}, gtiob: {=u8:?}, obdflt: {:?}, obhld: {:?}, obe: {:?}, obdf: {:?}, nfben: {:?}, nfcsb: {:?} }}" , self . gtioa () , self . oadflt () , self . oahld () , self . oae () , self . oadf () , self . nfaen () , self . nfcsa () , self . gtiob () , self . obdflt () , self . obhld () , self . obe () , self . obdf () , self . nfben () , self . nfcsb ())
            }
        }
        #[doc = "General PWM Timer Stop Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtpsr(pub u32);
        impl Gtpsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgar(&self) -> super::vals::Psgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Psgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgar(&mut self, val: super::vals::Psgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgaf(&self) -> super::vals::Psgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Psgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgaf(&mut self, val: super::vals::Psgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgbr(&self) -> super::vals::Psgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Psgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgbr(&mut self, val: super::vals::Psgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgbf(&self) -> super::vals::Psgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Psgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgbf(&mut self, val: super::vals::Psgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscarbl(&self) -> super::vals::Pscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscarbl(&mut self, val: super::vals::Pscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscarbh(&self) -> super::vals::Pscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscarbh(&mut self, val: super::vals::Pscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscafbl(&self) -> super::vals::Pscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscafbl(&mut self, val: super::vals::Pscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscafbh(&self) -> super::vals::Pscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscafbh(&mut self, val: super::vals::Pscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbral(&self) -> super::vals::Pscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbral(&mut self, val: super::vals::Pscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbrah(&self) -> super::vals::Pscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbrah(&mut self, val: super::vals::Pscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbfal(&self) -> super::vals::Pscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbfal(&mut self, val: super::vals::Pscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbfah(&self) -> super::vals::Pscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbfah(&mut self, val: super::vals::Pscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselca(&self) -> super::vals::Pselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselca(&mut self, val: super::vals::Pselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcb(&self) -> super::vals::Pselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcb(&mut self, val: super::vals::Pselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcc(&self) -> super::vals::Pselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcc(&mut self, val: super::vals::Pselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcd(&self) -> super::vals::Pselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcd(&mut self, val: super::vals::Pselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Software Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn cstop(&self) -> super::vals::Cstop {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cstop::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_cstop(&mut self, val: super::vals::Cstop) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtpsr {
            #[inline(always)]
            fn default() -> Gtpsr {
                Gtpsr(0)
            }
        }
        impl core::fmt::Debug for Gtpsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtpsr")
                    .field("psgtrgar", &self.psgtrgar())
                    .field("psgtrgaf", &self.psgtrgaf())
                    .field("psgtrgbr", &self.psgtrgbr())
                    .field("psgtrgbf", &self.psgtrgbf())
                    .field("pscarbl", &self.pscarbl())
                    .field("pscarbh", &self.pscarbh())
                    .field("pscafbl", &self.pscafbl())
                    .field("pscafbh", &self.pscafbh())
                    .field("pscbral", &self.pscbral())
                    .field("pscbrah", &self.pscbrah())
                    .field("pscbfal", &self.pscbfal())
                    .field("pscbfah", &self.pscbfah())
                    .field("pselca", &self.pselca())
                    .field("pselcb", &self.pselcb())
                    .field("pselcc", &self.pselcc())
                    .field("pselcd", &self.pselcd())
                    .field("cstop", &self.cstop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtpsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtpsr {{ psgtrgar: {:?}, psgtrgaf: {:?}, psgtrgbr: {:?}, psgtrgbf: {:?}, pscarbl: {:?}, pscarbh: {:?}, pscafbl: {:?}, pscafbh: {:?}, pscbral: {:?}, pscbrah: {:?}, pscbfal: {:?}, pscbfah: {:?}, pselca: {:?}, pselcb: {:?}, pselcc: {:?}, pselcd: {:?}, cstop: {:?} }}" , self . psgtrgar () , self . psgtrgaf () , self . psgtrgbr () , self . psgtrgbf () , self . pscarbl () , self . pscarbh () , self . pscafbl () , self . pscafbh () , self . pscbral () , self . pscbrah () , self . pscbfal () , self . pscbfah () , self . pselca () , self . pselcb () , self . pselcc () , self . pselcd () , self . cstop ())
            }
        }
        #[doc = "General PWM Timer Start Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtssr(pub u32);
        impl Gtssr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgar(&self) -> super::vals::Ssgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgar(&mut self, val: super::vals::Ssgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgaf(&self) -> super::vals::Ssgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgaf(&mut self, val: super::vals::Ssgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgbr(&self) -> super::vals::Ssgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ssgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgbr(&mut self, val: super::vals::Ssgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgbf(&self) -> super::vals::Ssgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ssgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgbf(&mut self, val: super::vals::Ssgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscarbl(&self) -> super::vals::Sscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Sscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscarbl(&mut self, val: super::vals::Sscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscarbh(&self) -> super::vals::Sscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Sscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscarbh(&mut self, val: super::vals::Sscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscafbl(&self) -> super::vals::Sscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Sscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscafbl(&mut self, val: super::vals::Sscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscafbh(&self) -> super::vals::Sscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Sscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscafbh(&mut self, val: super::vals::Sscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbral(&self) -> super::vals::Sscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Sscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbral(&mut self, val: super::vals::Sscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbrah(&self) -> super::vals::Sscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Sscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbrah(&mut self, val: super::vals::Sscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbfal(&self) -> super::vals::Sscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Sscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbfal(&mut self, val: super::vals::Sscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbfah(&self) -> super::vals::Sscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbfah(&mut self, val: super::vals::Sscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselca(&self) -> super::vals::Sselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Sselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselca(&mut self, val: super::vals::Sselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcb(&self) -> super::vals::Sselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Sselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcb(&mut self, val: super::vals::Sselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcc(&self) -> super::vals::Sselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Sselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcc(&mut self, val: super::vals::Sselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcd(&self) -> super::vals::Sselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Sselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcd(&mut self, val: super::vals::Sselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Software Source Counter Start Enable"]
            #[inline(always)]
            pub const fn cstrt(&self) -> super::vals::Cstrt {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cstrt::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_cstrt(&mut self, val: super::vals::Cstrt) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtssr {
            #[inline(always)]
            fn default() -> Gtssr {
                Gtssr(0)
            }
        }
        impl core::fmt::Debug for Gtssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtssr")
                    .field("ssgtrgar", &self.ssgtrgar())
                    .field("ssgtrgaf", &self.ssgtrgaf())
                    .field("ssgtrgbr", &self.ssgtrgbr())
                    .field("ssgtrgbf", &self.ssgtrgbf())
                    .field("sscarbl", &self.sscarbl())
                    .field("sscarbh", &self.sscarbh())
                    .field("sscafbl", &self.sscafbl())
                    .field("sscafbh", &self.sscafbh())
                    .field("sscbral", &self.sscbral())
                    .field("sscbrah", &self.sscbrah())
                    .field("sscbfal", &self.sscbfal())
                    .field("sscbfah", &self.sscbfah())
                    .field("sselca", &self.sselca())
                    .field("sselcb", &self.sselcb())
                    .field("sselcc", &self.sselcc())
                    .field("sselcd", &self.sselcd())
                    .field("cstrt", &self.cstrt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtssr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtssr {{ ssgtrgar: {:?}, ssgtrgaf: {:?}, ssgtrgbr: {:?}, ssgtrgbf: {:?}, sscarbl: {:?}, sscarbh: {:?}, sscafbl: {:?}, sscafbh: {:?}, sscbral: {:?}, sscbrah: {:?}, sscbfal: {:?}, sscbfah: {:?}, sselca: {:?}, sselcb: {:?}, sselcc: {:?}, sselcd: {:?}, cstrt: {:?} }}" , self . ssgtrgar () , self . ssgtrgaf () , self . ssgtrgbr () , self . ssgtrgbf () , self . sscarbl () , self . sscarbh () , self . sscafbl () , self . sscafbh () , self . sscbral () , self . sscbrah () , self . sscbfal () , self . sscbfah () , self . sselca () , self . sselcb () , self . sselcc () , self . sselcd () , self . cstrt ())
            }
        }
        #[doc = "General PWM Timer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtst(pub u32);
        impl Gtst {
            #[doc = "Input Capture/Compare Match Flag A"]
            #[inline(always)]
            pub const fn tcfa(&self) -> super::vals::Tcfa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tcfa::from_bits(val as u8)
            }
            #[doc = "Input Capture/Compare Match Flag A"]
            #[inline(always)]
            pub fn set_tcfa(&mut self, val: super::vals::Tcfa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Input Capture/Compare Match Flag B"]
            #[inline(always)]
            pub const fn tcfb(&self) -> super::vals::Tcfb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tcfb::from_bits(val as u8)
            }
            #[doc = "Input Capture/Compare Match Flag B"]
            #[inline(always)]
            pub fn set_tcfb(&mut self, val: super::vals::Tcfb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Input Compare Match Flag C"]
            #[inline(always)]
            pub const fn tcfc(&self) -> super::vals::Tcfc {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tcfc::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag C"]
            #[inline(always)]
            pub fn set_tcfc(&mut self, val: super::vals::Tcfc) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Input Compare Match Flag D"]
            #[inline(always)]
            pub const fn tcfd(&self) -> super::vals::Tcfd {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tcfd::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag D"]
            #[inline(always)]
            pub fn set_tcfd(&mut self, val: super::vals::Tcfd) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Input Compare Match Flag E"]
            #[inline(always)]
            pub const fn tcfe(&self) -> super::vals::Tcfe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tcfe::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag E"]
            #[inline(always)]
            pub fn set_tcfe(&mut self, val: super::vals::Tcfe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Input Compare Match Flag F"]
            #[inline(always)]
            pub const fn tcff(&self) -> super::vals::Tcff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tcff::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag F"]
            #[inline(always)]
            pub fn set_tcff(&mut self, val: super::vals::Tcff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub const fn tcfpo(&self) -> super::vals::Tcfpo {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tcfpo::from_bits(val as u8)
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub fn set_tcfpo(&mut self, val: super::vals::Tcfpo) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn tcfpu(&self) -> super::vals::Tcfpu {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tcfpu::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_tcfpu(&mut self, val: super::vals::Tcfpu) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Count Direction Flag"]
            #[inline(always)]
            pub const fn tucf(&self) -> super::vals::Tucf {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Tucf::from_bits(val as u8)
            }
            #[doc = "Count Direction Flag"]
            #[inline(always)]
            pub fn set_tucf(&mut self, val: super::vals::Tucf) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Output Disable Flag"]
            #[inline(always)]
            pub const fn odf(&self) -> super::vals::Odf {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Odf::from_bits(val as u8)
            }
            #[doc = "Output Disable Flag"]
            #[inline(always)]
            pub fn set_odf(&mut self, val: super::vals::Odf) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Same Time Output Level High Flag"]
            #[inline(always)]
            pub const fn oabhf(&self) -> super::vals::Oabhf {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Oabhf::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level High Flag"]
            #[inline(always)]
            pub fn set_oabhf(&mut self, val: super::vals::Oabhf) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Same Time Output Level Low Flag"]
            #[inline(always)]
            pub const fn oablf(&self) -> super::vals::Oablf {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Oablf::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level Low Flag"]
            #[inline(always)]
            pub fn set_oablf(&mut self, val: super::vals::Oablf) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Gtst {
            #[inline(always)]
            fn default() -> Gtst {
                Gtst(0)
            }
        }
        impl core::fmt::Debug for Gtst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtst")
                    .field("tcfa", &self.tcfa())
                    .field("tcfb", &self.tcfb())
                    .field("tcfc", &self.tcfc())
                    .field("tcfd", &self.tcfd())
                    .field("tcfe", &self.tcfe())
                    .field("tcff", &self.tcff())
                    .field("tcfpo", &self.tcfpo())
                    .field("tcfpu", &self.tcfpu())
                    .field("tucf", &self.tucf())
                    .field("odf", &self.odf())
                    .field("oabhf", &self.oabhf())
                    .field("oablf", &self.oablf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtst {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtst {{ tcfa: {:?}, tcfb: {:?}, tcfc: {:?}, tcfd: {:?}, tcfe: {:?}, tcff: {:?}, tcfpo: {:?}, tcfpu: {:?}, tucf: {:?}, odf: {:?}, oabhf: {:?}, oablf: {:?} }}" , self . tcfa () , self . tcfb () , self . tcfc () , self . tcfd () , self . tcfe () , self . tcff () , self . tcfpo () , self . tcfpu () , self . tucf () , self . odf () , self . oabhf () , self . oablf ())
            }
        }
        #[doc = "General PWM Timer Software Stop Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtstp(pub u32);
        impl Gtstp {
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub const fn cstop4(&self) -> super::vals::Cstop4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cstop4::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub fn set_cstop4(&mut self, val: super::vals::Cstop4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub const fn cstop5(&self) -> super::vals::Cstop5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cstop5::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub fn set_cstop5(&mut self, val: super::vals::Cstop5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub const fn cstop6(&self) -> super::vals::Cstop6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cstop6::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub fn set_cstop6(&mut self, val: super::vals::Cstop6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub const fn cstop7(&self) -> super::vals::Cstop7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cstop7::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub fn set_cstop7(&mut self, val: super::vals::Cstop7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub const fn cstop8(&self) -> super::vals::Cstop8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cstop8::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub fn set_cstop8(&mut self, val: super::vals::Cstop8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub const fn cstop9(&self) -> super::vals::Cstop9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cstop9::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n is the same as the bit position value)"]
            #[inline(always)]
            pub fn set_cstop9(&mut self, val: super::vals::Cstop9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Gtstp {
            #[inline(always)]
            fn default() -> Gtstp {
                Gtstp(0)
            }
        }
        impl core::fmt::Debug for Gtstp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtstp")
                    .field("cstop4", &self.cstop4())
                    .field("cstop5", &self.cstop5())
                    .field("cstop6", &self.cstop6())
                    .field("cstop7", &self.cstop7())
                    .field("cstop8", &self.cstop8())
                    .field("cstop9", &self.cstop9())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtstp {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtstp {{ cstop4: {:?}, cstop5: {:?}, cstop6: {:?}, cstop7: {:?}, cstop8: {:?}, cstop9: {:?} }}" , self . cstop4 () , self . cstop5 () , self . cstop6 () , self . cstop7 () , self . cstop8 () , self . cstop9 ())
            }
        }
        #[doc = "General PWM Timer Software Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtstr(pub u32);
        impl Gtstr {
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt4(&self) -> super::vals::Cstrt4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cstrt4::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt4(&mut self, val: super::vals::Cstrt4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt5(&self) -> super::vals::Cstrt5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cstrt5::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt5(&mut self, val: super::vals::Cstrt5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt6(&self) -> super::vals::Cstrt6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cstrt6::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt6(&mut self, val: super::vals::Cstrt6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt7(&self) -> super::vals::Cstrt7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cstrt7::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt7(&mut self, val: super::vals::Cstrt7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt8(&self) -> super::vals::Cstrt8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cstrt8::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt8(&mut self, val: super::vals::Cstrt8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt9(&self) -> super::vals::Cstrt9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cstrt9::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt9(&mut self, val: super::vals::Cstrt9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Gtstr {
            #[inline(always)]
            fn default() -> Gtstr {
                Gtstr(0)
            }
        }
        impl core::fmt::Debug for Gtstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtstr")
                    .field("cstrt4", &self.cstrt4())
                    .field("cstrt5", &self.cstrt5())
                    .field("cstrt6", &self.cstrt6())
                    .field("cstrt7", &self.cstrt7())
                    .field("cstrt8", &self.cstrt8())
                    .field("cstrt9", &self.cstrt9())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtstr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtstr {{ cstrt4: {:?}, cstrt5: {:?}, cstrt6: {:?}, cstrt7: {:?}, cstrt8: {:?}, cstrt9: {:?} }}" , self . cstrt4 () , self . cstrt5 () , self . cstrt6 () , self . cstrt7 () , self . cstrt8 () , self . cstrt9 ())
            }
        }
        #[doc = "General PWM Timer Count Direction and Duty Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtuddtyc(pub u32);
        impl Gtuddtyc {
            #[doc = "Count Direction Setting"]
            #[inline(always)]
            pub const fn ud(&self) -> super::vals::Ud {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ud::from_bits(val as u8)
            }
            #[doc = "Count Direction Setting"]
            #[inline(always)]
            pub fn set_ud(&mut self, val: super::vals::Ud) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Forcible Count Direction Setting"]
            #[inline(always)]
            pub const fn udf(&self) -> super::vals::Udf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Udf::from_bits(val as u8)
            }
            #[doc = "Forcible Count Direction Setting"]
            #[inline(always)]
            pub fn set_udf(&mut self, val: super::vals::Udf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTIOCnA Output Duty Setting"]
            #[inline(always)]
            pub const fn oadty(&self) -> super::vals::Oadty {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Oadty::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Output Duty Setting"]
            #[inline(always)]
            pub fn set_oadty(&mut self, val: super::vals::Oadty) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "Forcible GTIOCnA Output Duty Setting"]
            #[inline(always)]
            pub const fn oadtyf(&self) -> super::vals::Oadtyf {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oadtyf::from_bits(val as u8)
            }
            #[doc = "Forcible GTIOCnA Output Duty Setting"]
            #[inline(always)]
            pub fn set_oadtyf(&mut self, val: super::vals::Oadtyf) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "GTIOCnA Output Value Selecting after Releasing 0%/100% Duty Setting"]
            #[inline(always)]
            pub const fn oadtyr(&self) -> super::vals::Oadtyr {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oadtyr::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Output Value Selecting after Releasing 0%/100% Duty Setting"]
            #[inline(always)]
            pub fn set_oadtyr(&mut self, val: super::vals::Oadtyr) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "GTIOCnB Output Duty Setting"]
            #[inline(always)]
            pub const fn obdty(&self) -> super::vals::Obdty {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Obdty::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Output Duty Setting"]
            #[inline(always)]
            pub fn set_obdty(&mut self, val: super::vals::Obdty) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Forcible GTIOCnB Output Duty Setting"]
            #[inline(always)]
            pub const fn obdtyf(&self) -> super::vals::Obdtyf {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Obdtyf::from_bits(val as u8)
            }
            #[doc = "Forcible GTIOCnB Output Duty Setting"]
            #[inline(always)]
            pub fn set_obdtyf(&mut self, val: super::vals::Obdtyf) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "GTIOCnB Output Value Selecting after Releasing 0%/100% Duty Setting"]
            #[inline(always)]
            pub const fn obdtyr(&self) -> super::vals::Obdtyr {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Obdtyr::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Output Value Selecting after Releasing 0%/100% Duty Setting"]
            #[inline(always)]
            pub fn set_obdtyr(&mut self, val: super::vals::Obdtyr) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Gtuddtyc {
            #[inline(always)]
            fn default() -> Gtuddtyc {
                Gtuddtyc(0)
            }
        }
        impl core::fmt::Debug for Gtuddtyc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtuddtyc")
                    .field("ud", &self.ud())
                    .field("udf", &self.udf())
                    .field("oadty", &self.oadty())
                    .field("oadtyf", &self.oadtyf())
                    .field("oadtyr", &self.oadtyr())
                    .field("obdty", &self.obdty())
                    .field("obdtyf", &self.obdtyf())
                    .field("obdtyr", &self.obdtyr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtuddtyc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtuddtyc {{ ud: {:?}, udf: {:?}, oadty: {:?}, oadtyf: {:?}, oadtyr: {:?}, obdty: {:?}, obdtyf: {:?}, obdtyr: {:?} }}" , self . ud () , self . udf () , self . oadty () , self . oadtyf () , self . oadtyr () , self . obdty () , self . obdtyf () , self . obdtyr ())
            }
        }
        #[doc = "General PWM Timer Up Count Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtupsr(pub u32);
        impl Gtupsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgar(&self) -> super::vals::Usgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Usgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgar(&mut self, val: super::vals::Usgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgaf(&self) -> super::vals::Usgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Usgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgaf(&mut self, val: super::vals::Usgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgbr(&self) -> super::vals::Usgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Usgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgbr(&mut self, val: super::vals::Usgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgbf(&self) -> super::vals::Usgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Usgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgbf(&mut self, val: super::vals::Usgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscarbl(&self) -> super::vals::Uscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Uscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscarbl(&mut self, val: super::vals::Uscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscarbh(&self) -> super::vals::Uscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Uscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscarbh(&mut self, val: super::vals::Uscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscafbl(&self) -> super::vals::Uscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Uscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscafbl(&mut self, val: super::vals::Uscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscafbh(&self) -> super::vals::Uscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Uscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscafbh(&mut self, val: super::vals::Uscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbral(&self) -> super::vals::Uscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Uscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbral(&mut self, val: super::vals::Uscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbrah(&self) -> super::vals::Uscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Uscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbrah(&mut self, val: super::vals::Uscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbfal(&self) -> super::vals::Uscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Uscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbfal(&mut self, val: super::vals::Uscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbfah(&self) -> super::vals::Uscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Uscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbfah(&mut self, val: super::vals::Uscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselca(&self) -> super::vals::Uselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Uselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselca(&mut self, val: super::vals::Uselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcb(&self) -> super::vals::Uselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Uselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcb(&mut self, val: super::vals::Uselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcc(&self) -> super::vals::Uselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Uselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcc(&mut self, val: super::vals::Uselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcd(&self) -> super::vals::Uselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Uselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcd(&mut self, val: super::vals::Uselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gtupsr {
            #[inline(always)]
            fn default() -> Gtupsr {
                Gtupsr(0)
            }
        }
        impl core::fmt::Debug for Gtupsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtupsr")
                    .field("usgtrgar", &self.usgtrgar())
                    .field("usgtrgaf", &self.usgtrgaf())
                    .field("usgtrgbr", &self.usgtrgbr())
                    .field("usgtrgbf", &self.usgtrgbf())
                    .field("uscarbl", &self.uscarbl())
                    .field("uscarbh", &self.uscarbh())
                    .field("uscafbl", &self.uscafbl())
                    .field("uscafbh", &self.uscafbh())
                    .field("uscbral", &self.uscbral())
                    .field("uscbrah", &self.uscbrah())
                    .field("uscbfal", &self.uscbfal())
                    .field("uscbfah", &self.uscbfah())
                    .field("uselca", &self.uselca())
                    .field("uselcb", &self.uselcb())
                    .field("uselcc", &self.uselcc())
                    .field("uselcd", &self.uselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtupsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtupsr {{ usgtrgar: {:?}, usgtrgaf: {:?}, usgtrgbr: {:?}, usgtrgbf: {:?}, uscarbl: {:?}, uscarbh: {:?}, uscafbl: {:?}, uscafbh: {:?}, uscbral: {:?}, uscbrah: {:?}, uscbfal: {:?}, uscbfah: {:?}, uselca: {:?}, uselcb: {:?}, uselcc: {:?}, uselcd: {:?} }}" , self . usgtrgar () , self . usgtrgaf () , self . usgtrgbr () , self . usgtrgbf () , self . uscarbl () , self . uscarbh () , self . uscafbl () , self . uscafbh () , self . uscbral () , self . uscbrah () , self . uscbfal () , self . uscbfah () , self . uselca () , self . uselcb () , self . uselcc () , self . uselcd ())
            }
        }
        #[doc = "General PWM Timer Write,Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtwp(pub u32);
        impl Gtwp {
            #[doc = "Register Write Disable"]
            #[inline(always)]
            pub const fn wp(&self) -> super::vals::Wp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Wp::from_bits(val as u8)
            }
            #[doc = "Register Write Disable"]
            #[inline(always)]
            pub fn set_wp(&mut self, val: super::vals::Wp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTWP Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "GTWP Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Gtwp {
            #[inline(always)]
            fn default() -> Gtwp {
                Gtwp(0)
            }
        }
        impl core::fmt::Debug for Gtwp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtwp")
                    .field("wp", &self.wp())
                    .field("prkey", &self.prkey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtwp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtwp {{ wp: {:?}, prkey: {=u8:?} }}",
                    self.wp(),
                    self.prkey()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascafbh {
            #[inline(always)]
            fn from(val: u8) -> Ascafbh {
                Ascafbh::from_bits(val)
            }
        }
        impl From<Ascafbh> for u8 {
            #[inline(always)]
            fn from(val: Ascafbh) -> u8 {
                Ascafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascafbl {
            #[inline(always)]
            fn from(val: u8) -> Ascafbl {
                Ascafbl::from_bits(val)
            }
        }
        impl From<Ascafbl> for u8 {
            #[inline(always)]
            fn from(val: Ascafbl) -> u8 {
                Ascafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascarbh {
            #[inline(always)]
            fn from(val: u8) -> Ascarbh {
                Ascarbh::from_bits(val)
            }
        }
        impl From<Ascarbh> for u8 {
            #[inline(always)]
            fn from(val: Ascarbh) -> u8 {
                Ascarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascarbl {
            #[inline(always)]
            fn from(val: u8) -> Ascarbl {
                Ascarbl::from_bits(val)
            }
        }
        impl From<Ascarbl> for u8 {
            #[inline(always)]
            fn from(val: Ascarbl) -> u8 {
                Ascarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbfah {
            #[inline(always)]
            fn from(val: u8) -> Ascbfah {
                Ascbfah::from_bits(val)
            }
        }
        impl From<Ascbfah> for u8 {
            #[inline(always)]
            fn from(val: Ascbfah) -> u8 {
                Ascbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbfal {
            #[inline(always)]
            fn from(val: u8) -> Ascbfal {
                Ascbfal::from_bits(val)
            }
        }
        impl From<Ascbfal> for u8 {
            #[inline(always)]
            fn from(val: Ascbfal) -> u8 {
                Ascbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbrah {
            #[inline(always)]
            fn from(val: u8) -> Ascbrah {
                Ascbrah::from_bits(val)
            }
        }
        impl From<Ascbrah> for u8 {
            #[inline(always)]
            fn from(val: Ascbrah) -> u8 {
                Ascbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbral {
            #[inline(always)]
            fn from(val: u8) -> Ascbral {
                Ascbral::from_bits(val)
            }
        }
        impl From<Ascbral> for u8 {
            #[inline(always)]
            fn from(val: Ascbral) -> u8 {
                Ascbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselca {
            #[inline(always)]
            fn from(val: u8) -> Aselca {
                Aselca::from_bits(val)
            }
        }
        impl From<Aselca> for u8 {
            #[inline(always)]
            fn from(val: Aselca) -> u8 {
                Aselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcb {
            #[inline(always)]
            fn from(val: u8) -> Aselcb {
                Aselcb::from_bits(val)
            }
        }
        impl From<Aselcb> for u8 {
            #[inline(always)]
            fn from(val: Aselcb) -> u8 {
                Aselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcc {
            #[inline(always)]
            fn from(val: u8) -> Aselcc {
                Aselcc::from_bits(val)
            }
        }
        impl From<Aselcc> for u8 {
            #[inline(always)]
            fn from(val: Aselcc) -> u8 {
                Aselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcd {
            #[inline(always)]
            fn from(val: u8) -> Aselcd {
                Aselcd::from_bits(val)
            }
        }
        impl From<Aselcd> for u8 {
            #[inline(always)]
            fn from(val: Aselcd) -> u8 {
                Aselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgaf {
                Asgtrgaf::from_bits(val)
            }
        }
        impl From<Asgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgaf) -> u8 {
                Asgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgar {
                Asgtrgar::from_bits(val)
            }
        }
        impl From<Asgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgar) -> u8 {
                Asgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgbf {
                Asgtrgbf::from_bits(val)
            }
        }
        impl From<Asgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgbf) -> u8 {
                Asgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgbr {
                Asgtrgbr::from_bits(val)
            }
        }
        impl From<Asgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgbr) -> u8 {
                Asgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bd0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bd0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bd0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bd0 {
            #[inline(always)]
            fn from(val: u8) -> Bd0 {
                Bd0::from_bits(val)
            }
        }
        impl From<Bd0> for u8 {
            #[inline(always)]
            fn from(val: Bd0) -> u8 {
                Bd0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bd1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bd1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bd1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bd1 {
            #[inline(always)]
            fn from(val: u8) -> Bd1 {
                Bd1::from_bits(val)
            }
        }
        impl From<Bd1> for u8 {
            #[inline(always)]
            fn from(val: Bd1) -> u8 {
                Bd1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscafbh {
            #[inline(always)]
            fn from(val: u8) -> Bscafbh {
                Bscafbh::from_bits(val)
            }
        }
        impl From<Bscafbh> for u8 {
            #[inline(always)]
            fn from(val: Bscafbh) -> u8 {
                Bscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscafbl {
            #[inline(always)]
            fn from(val: u8) -> Bscafbl {
                Bscafbl::from_bits(val)
            }
        }
        impl From<Bscafbl> for u8 {
            #[inline(always)]
            fn from(val: Bscafbl) -> u8 {
                Bscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscarbh {
            #[inline(always)]
            fn from(val: u8) -> Bscarbh {
                Bscarbh::from_bits(val)
            }
        }
        impl From<Bscarbh> for u8 {
            #[inline(always)]
            fn from(val: Bscarbh) -> u8 {
                Bscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscarbl {
            #[inline(always)]
            fn from(val: u8) -> Bscarbl {
                Bscarbl::from_bits(val)
            }
        }
        impl From<Bscarbl> for u8 {
            #[inline(always)]
            fn from(val: Bscarbl) -> u8 {
                Bscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbfah {
            #[inline(always)]
            fn from(val: u8) -> Bscbfah {
                Bscbfah::from_bits(val)
            }
        }
        impl From<Bscbfah> for u8 {
            #[inline(always)]
            fn from(val: Bscbfah) -> u8 {
                Bscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbfal {
            #[inline(always)]
            fn from(val: u8) -> Bscbfal {
                Bscbfal::from_bits(val)
            }
        }
        impl From<Bscbfal> for u8 {
            #[inline(always)]
            fn from(val: Bscbfal) -> u8 {
                Bscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbrah {
            #[inline(always)]
            fn from(val: u8) -> Bscbrah {
                Bscbrah::from_bits(val)
            }
        }
        impl From<Bscbrah> for u8 {
            #[inline(always)]
            fn from(val: Bscbrah) -> u8 {
                Bscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbral {
            #[inline(always)]
            fn from(val: u8) -> Bscbral {
                Bscbral::from_bits(val)
            }
        }
        impl From<Bscbral> for u8 {
            #[inline(always)]
            fn from(val: Bscbral) -> u8 {
                Bscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselca {
            #[inline(always)]
            fn from(val: u8) -> Bselca {
                Bselca::from_bits(val)
            }
        }
        impl From<Bselca> for u8 {
            #[inline(always)]
            fn from(val: Bselca) -> u8 {
                Bselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcb {
            #[inline(always)]
            fn from(val: u8) -> Bselcb {
                Bselcb::from_bits(val)
            }
        }
        impl From<Bselcb> for u8 {
            #[inline(always)]
            fn from(val: Bselcb) -> u8 {
                Bselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcc {
            #[inline(always)]
            fn from(val: u8) -> Bselcc {
                Bselcc::from_bits(val)
            }
        }
        impl From<Bselcc> for u8 {
            #[inline(always)]
            fn from(val: Bselcc) -> u8 {
                Bselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcd {
            #[inline(always)]
            fn from(val: u8) -> Bselcd {
                Bselcd::from_bits(val)
            }
        }
        impl From<Bselcd> for u8 {
            #[inline(always)]
            fn from(val: Bselcd) -> u8 {
                Bselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgaf {
                Bsgtrgaf::from_bits(val)
            }
        }
        impl From<Bsgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgaf) -> u8 {
                Bsgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgar {
                Bsgtrgar::from_bits(val)
            }
        }
        impl From<Bsgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgar) -> u8 {
                Bsgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgbf {
                Bsgtrgbf::from_bits(val)
            }
        }
        impl From<Bsgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgbf) -> u8 {
                Bsgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgbr {
                Bsgtrgbr::from_bits(val)
            }
        }
        impl From<Bsgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgbr) -> u8 {
                Bsgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr {
            #[inline(always)]
            fn from(val: u8) -> Cclr {
                Cclr::from_bits(val)
            }
        }
        impl From<Cclr> for u8 {
            #[inline(always)]
            fn from(val: Cclr) -> u8 {
                Cclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr0 {
            #[inline(always)]
            fn from(val: u8) -> Cclr0 {
                Cclr0::from_bits(val)
            }
        }
        impl From<Cclr0> for u8 {
            #[inline(always)]
            fn from(val: Cclr0) -> u8 {
                Cclr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr1 {
            #[inline(always)]
            fn from(val: u8) -> Cclr1 {
                Cclr1::from_bits(val)
            }
        }
        impl From<Cclr1> for u8 {
            #[inline(always)]
            fn from(val: Cclr1) -> u8 {
                Cclr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr2 {
            #[inline(always)]
            fn from(val: u8) -> Cclr2 {
                Cclr2::from_bits(val)
            }
        }
        impl From<Cclr2> for u8 {
            #[inline(always)]
            fn from(val: Cclr2) -> u8 {
                Cclr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr3 {
            #[inline(always)]
            fn from(val: u8) -> Cclr3 {
                Cclr3::from_bits(val)
            }
        }
        impl From<Cclr3> for u8 {
            #[inline(always)]
            fn from(val: Cclr3) -> u8 {
                Cclr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr4 {
            #[inline(always)]
            fn from(val: u8) -> Cclr4 {
                Cclr4::from_bits(val)
            }
        }
        impl From<Cclr4> for u8 {
            #[inline(always)]
            fn from(val: Cclr4) -> u8 {
                Cclr4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr5 {
            #[inline(always)]
            fn from(val: u8) -> Cclr5 {
                Cclr5::from_bits(val)
            }
        }
        impl From<Cclr5> for u8 {
            #[inline(always)]
            fn from(val: Cclr5) -> u8 {
                Cclr5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr6 {
            #[inline(always)]
            fn from(val: u8) -> Cclr6 {
                Cclr6::from_bits(val)
            }
        }
        impl From<Cclr6> for u8 {
            #[inline(always)]
            fn from(val: Cclr6) -> u8 {
                Cclr6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr7 {
            #[inline(always)]
            fn from(val: u8) -> Cclr7 {
                Cclr7::from_bits(val)
            }
        }
        impl From<Cclr7> for u8 {
            #[inline(always)]
            fn from(val: Cclr7) -> u8 {
                Cclr7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr8 {
            #[inline(always)]
            fn from(val: u8) -> Cclr8 {
                Cclr8::from_bits(val)
            }
        }
        impl From<Cclr8> for u8 {
            #[inline(always)]
            fn from(val: Cclr8) -> u8 {
                Cclr8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr9 {
            #[inline(always)]
            fn from(val: u8) -> Cclr9 {
                Cclr9::from_bits(val)
            }
        }
        impl From<Cclr9> for u8 {
            #[inline(always)]
            fn from(val: Cclr9) -> u8 {
                Cclr9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccra {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ccra {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccra {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccra {
            #[inline(always)]
            fn from(val: u8) -> Ccra {
                Ccra::from_bits(val)
            }
        }
        impl From<Ccra> for u8 {
            #[inline(always)]
            fn from(val: Ccra) -> u8 {
                Ccra::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccrb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ccrb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccrb {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccrb {
            #[inline(always)]
            fn from(val: u8) -> Ccrb {
                Ccrb::from_bits(val)
            }
        }
        impl From<Ccrb> for u8 {
            #[inline(always)]
            fn from(val: Ccrb) -> u8 {
                Ccrb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscafbh {
            #[inline(always)]
            fn from(val: u8) -> Cscafbh {
                Cscafbh::from_bits(val)
            }
        }
        impl From<Cscafbh> for u8 {
            #[inline(always)]
            fn from(val: Cscafbh) -> u8 {
                Cscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscafbl {
            #[inline(always)]
            fn from(val: u8) -> Cscafbl {
                Cscafbl::from_bits(val)
            }
        }
        impl From<Cscafbl> for u8 {
            #[inline(always)]
            fn from(val: Cscafbl) -> u8 {
                Cscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscarbh {
            #[inline(always)]
            fn from(val: u8) -> Cscarbh {
                Cscarbh::from_bits(val)
            }
        }
        impl From<Cscarbh> for u8 {
            #[inline(always)]
            fn from(val: Cscarbh) -> u8 {
                Cscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscarbl {
            #[inline(always)]
            fn from(val: u8) -> Cscarbl {
                Cscarbl::from_bits(val)
            }
        }
        impl From<Cscarbl> for u8 {
            #[inline(always)]
            fn from(val: Cscarbl) -> u8 {
                Cscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbfah {
            #[inline(always)]
            fn from(val: u8) -> Cscbfah {
                Cscbfah::from_bits(val)
            }
        }
        impl From<Cscbfah> for u8 {
            #[inline(always)]
            fn from(val: Cscbfah) -> u8 {
                Cscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbfal {
            #[inline(always)]
            fn from(val: u8) -> Cscbfal {
                Cscbfal::from_bits(val)
            }
        }
        impl From<Cscbfal> for u8 {
            #[inline(always)]
            fn from(val: Cscbfal) -> u8 {
                Cscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbrah {
            #[inline(always)]
            fn from(val: u8) -> Cscbrah {
                Cscbrah::from_bits(val)
            }
        }
        impl From<Cscbrah> for u8 {
            #[inline(always)]
            fn from(val: Cscbrah) -> u8 {
                Cscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbral {
            #[inline(always)]
            fn from(val: u8) -> Cscbral {
                Cscbral::from_bits(val)
            }
        }
        impl From<Cscbral> for u8 {
            #[inline(always)]
            fn from(val: Cscbral) -> u8 {
                Cscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselca {
            #[inline(always)]
            fn from(val: u8) -> Cselca {
                Cselca::from_bits(val)
            }
        }
        impl From<Cselca> for u8 {
            #[inline(always)]
            fn from(val: Cselca) -> u8 {
                Cselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcb {
            #[inline(always)]
            fn from(val: u8) -> Cselcb {
                Cselcb::from_bits(val)
            }
        }
        impl From<Cselcb> for u8 {
            #[inline(always)]
            fn from(val: Cselcb) -> u8 {
                Cselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcc {
            #[inline(always)]
            fn from(val: u8) -> Cselcc {
                Cselcc::from_bits(val)
            }
        }
        impl From<Cselcc> for u8 {
            #[inline(always)]
            fn from(val: Cselcc) -> u8 {
                Cselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcd {
            #[inline(always)]
            fn from(val: u8) -> Cselcd {
                Cselcd::from_bits(val)
            }
        }
        impl From<Cselcd> for u8 {
            #[inline(always)]
            fn from(val: Cselcd) -> u8 {
                Cselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgaf {
                Csgtrgaf::from_bits(val)
            }
        }
        impl From<Csgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgaf) -> u8 {
                Csgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgar {
                Csgtrgar::from_bits(val)
            }
        }
        impl From<Csgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgar) -> u8 {
                Csgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgbf {
                Csgtrgbf::from_bits(val)
            }
        }
        impl From<Csgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgbf) -> u8 {
                Csgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgbr {
                Csgtrgbr::from_bits(val)
            }
        }
        impl From<Csgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgbr) -> u8 {
                Csgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cst {
            #[inline(always)]
            fn from(val: u8) -> Cst {
                Cst::from_bits(val)
            }
        }
        impl From<Cst> for u8 {
            #[inline(always)]
            fn from(val: Cst) -> u8 {
                Cst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop {
            #[inline(always)]
            fn from(val: u8) -> Cstop {
                Cstop::from_bits(val)
            }
        }
        impl From<Cstop> for u8 {
            #[inline(always)]
            fn from(val: Cstop) -> u8 {
                Cstop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop4 {
            #[inline(always)]
            fn from(val: u8) -> Cstop4 {
                Cstop4::from_bits(val)
            }
        }
        impl From<Cstop4> for u8 {
            #[inline(always)]
            fn from(val: Cstop4) -> u8 {
                Cstop4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop5 {
            #[inline(always)]
            fn from(val: u8) -> Cstop5 {
                Cstop5::from_bits(val)
            }
        }
        impl From<Cstop5> for u8 {
            #[inline(always)]
            fn from(val: Cstop5) -> u8 {
                Cstop5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop6 {
            #[inline(always)]
            fn from(val: u8) -> Cstop6 {
                Cstop6::from_bits(val)
            }
        }
        impl From<Cstop6> for u8 {
            #[inline(always)]
            fn from(val: Cstop6) -> u8 {
                Cstop6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop7 {
            #[inline(always)]
            fn from(val: u8) -> Cstop7 {
                Cstop7::from_bits(val)
            }
        }
        impl From<Cstop7> for u8 {
            #[inline(always)]
            fn from(val: Cstop7) -> u8 {
                Cstop7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop8 {
            #[inline(always)]
            fn from(val: u8) -> Cstop8 {
                Cstop8::from_bits(val)
            }
        }
        impl From<Cstop8> for u8 {
            #[inline(always)]
            fn from(val: Cstop8) -> u8 {
                Cstop8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop9 {
            #[inline(always)]
            fn from(val: u8) -> Cstop9 {
                Cstop9::from_bits(val)
            }
        }
        impl From<Cstop9> for u8 {
            #[inline(always)]
            fn from(val: Cstop9) -> u8 {
                Cstop9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt {
            #[inline(always)]
            fn from(val: u8) -> Cstrt {
                Cstrt::from_bits(val)
            }
        }
        impl From<Cstrt> for u8 {
            #[inline(always)]
            fn from(val: Cstrt) -> u8 {
                Cstrt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt4 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt4 {
                Cstrt4::from_bits(val)
            }
        }
        impl From<Cstrt4> for u8 {
            #[inline(always)]
            fn from(val: Cstrt4) -> u8 {
                Cstrt4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt5 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt5 {
                Cstrt5::from_bits(val)
            }
        }
        impl From<Cstrt5> for u8 {
            #[inline(always)]
            fn from(val: Cstrt5) -> u8 {
                Cstrt5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt6 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt6 {
                Cstrt6::from_bits(val)
            }
        }
        impl From<Cstrt6> for u8 {
            #[inline(always)]
            fn from(val: Cstrt6) -> u8 {
                Cstrt6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt7 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt7 {
                Cstrt7::from_bits(val)
            }
        }
        impl From<Cstrt7> for u8 {
            #[inline(always)]
            fn from(val: Cstrt7) -> u8 {
                Cstrt7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt8 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt8 {
                Cstrt8::from_bits(val)
            }
        }
        impl From<Cstrt8> for u8 {
            #[inline(always)]
            fn from(val: Cstrt8) -> u8 {
                Cstrt8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt9 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt9 {
                Cstrt9::from_bits(val)
            }
        }
        impl From<Cstrt9> for u8 {
            #[inline(always)]
            fn from(val: Cstrt9) -> u8 {
                Cstrt9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscafbh {
            #[inline(always)]
            fn from(val: u8) -> Dscafbh {
                Dscafbh::from_bits(val)
            }
        }
        impl From<Dscafbh> for u8 {
            #[inline(always)]
            fn from(val: Dscafbh) -> u8 {
                Dscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscafbl {
            #[inline(always)]
            fn from(val: u8) -> Dscafbl {
                Dscafbl::from_bits(val)
            }
        }
        impl From<Dscafbl> for u8 {
            #[inline(always)]
            fn from(val: Dscafbl) -> u8 {
                Dscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscarbh {
            #[inline(always)]
            fn from(val: u8) -> Dscarbh {
                Dscarbh::from_bits(val)
            }
        }
        impl From<Dscarbh> for u8 {
            #[inline(always)]
            fn from(val: Dscarbh) -> u8 {
                Dscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscarbl {
            #[inline(always)]
            fn from(val: u8) -> Dscarbl {
                Dscarbl::from_bits(val)
            }
        }
        impl From<Dscarbl> for u8 {
            #[inline(always)]
            fn from(val: Dscarbl) -> u8 {
                Dscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbfah {
            #[inline(always)]
            fn from(val: u8) -> Dscbfah {
                Dscbfah::from_bits(val)
            }
        }
        impl From<Dscbfah> for u8 {
            #[inline(always)]
            fn from(val: Dscbfah) -> u8 {
                Dscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbfal {
            #[inline(always)]
            fn from(val: u8) -> Dscbfal {
                Dscbfal::from_bits(val)
            }
        }
        impl From<Dscbfal> for u8 {
            #[inline(always)]
            fn from(val: Dscbfal) -> u8 {
                Dscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbrah {
            #[inline(always)]
            fn from(val: u8) -> Dscbrah {
                Dscbrah::from_bits(val)
            }
        }
        impl From<Dscbrah> for u8 {
            #[inline(always)]
            fn from(val: Dscbrah) -> u8 {
                Dscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbral {
            #[inline(always)]
            fn from(val: u8) -> Dscbral {
                Dscbral::from_bits(val)
            }
        }
        impl From<Dscbral> for u8 {
            #[inline(always)]
            fn from(val: Dscbral) -> u8 {
                Dscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselca {
            #[inline(always)]
            fn from(val: u8) -> Dselca {
                Dselca::from_bits(val)
            }
        }
        impl From<Dselca> for u8 {
            #[inline(always)]
            fn from(val: Dselca) -> u8 {
                Dselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcb {
            #[inline(always)]
            fn from(val: u8) -> Dselcb {
                Dselcb::from_bits(val)
            }
        }
        impl From<Dselcb> for u8 {
            #[inline(always)]
            fn from(val: Dselcb) -> u8 {
                Dselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcc {
            #[inline(always)]
            fn from(val: u8) -> Dselcc {
                Dselcc::from_bits(val)
            }
        }
        impl From<Dselcc> for u8 {
            #[inline(always)]
            fn from(val: Dselcc) -> u8 {
                Dselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcd {
            #[inline(always)]
            fn from(val: u8) -> Dselcd {
                Dselcd::from_bits(val)
            }
        }
        impl From<Dselcd> for u8 {
            #[inline(always)]
            fn from(val: Dselcd) -> u8 {
                Dselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgaf {
                Dsgtrgaf::from_bits(val)
            }
        }
        impl From<Dsgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgaf) -> u8 {
                Dsgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgar {
                Dsgtrgar::from_bits(val)
            }
        }
        impl From<Dsgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgar) -> u8 {
                Dsgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgbf {
                Dsgtrgbf::from_bits(val)
            }
        }
        impl From<Dsgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgbf) -> u8 {
                Dsgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgbr {
                Dsgtrgbr::from_bits(val)
            }
        }
        impl From<Dsgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgbr) -> u8 {
                Dsgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Grp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grp {
            #[inline(always)]
            fn from(val: u8) -> Grp {
                Grp::from_bits(val)
            }
        }
        impl From<Grp> for u8 {
            #[inline(always)]
            fn from(val: Grp) -> u8 {
                Grp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grpabh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Grpabh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grpabh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grpabh {
            #[inline(always)]
            fn from(val: u8) -> Grpabh {
                Grpabh::from_bits(val)
            }
        }
        impl From<Grpabh> for u8 {
            #[inline(always)]
            fn from(val: Grpabh) -> u8 {
                Grpabh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grpabl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Grpabl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grpabl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grpabl {
            #[inline(always)]
            fn from(val: u8) -> Grpabl {
                Grpabl::from_bits(val)
            }
        }
        impl From<Grpabl> for u8 {
            #[inline(always)]
            fn from(val: Grpabl) -> u8 {
                Grpabl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Md {
            #[inline(always)]
            fn from(val: u8) -> Md {
                Md::from_bits(val)
            }
        }
        impl From<Md> for u8 {
            #[inline(always)]
            fn from(val: Md) -> u8 {
                Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfaen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfaen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfaen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfaen {
            #[inline(always)]
            fn from(val: u8) -> Nfaen {
                Nfaen::from_bits(val)
            }
        }
        impl From<Nfaen> for u8 {
            #[inline(always)]
            fn from(val: Nfaen) -> u8 {
                Nfaen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfben {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfben {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfben {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfben {
            #[inline(always)]
            fn from(val: u8) -> Nfben {
                Nfben::from_bits(val)
            }
        }
        impl From<Nfben> for u8 {
            #[inline(always)]
            fn from(val: Nfben) -> u8 {
                Nfben::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcsa {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcsa {
            #[inline(always)]
            fn from(val: u8) -> Nfcsa {
                Nfcsa::from_bits(val)
            }
        }
        impl From<Nfcsa> for u8 {
            #[inline(always)]
            fn from(val: Nfcsa) -> u8 {
                Nfcsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcsb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcsb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcsb {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcsb {
            #[inline(always)]
            fn from(val: u8) -> Nfcsb {
                Nfcsb::from_bits(val)
            }
        }
        impl From<Nfcsb> for u8 {
            #[inline(always)]
            fn from(val: Nfcsb) -> u8 {
                Nfcsb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oabhf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oabhf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oabhf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oabhf {
            #[inline(always)]
            fn from(val: u8) -> Oabhf {
                Oabhf::from_bits(val)
            }
        }
        impl From<Oabhf> for u8 {
            #[inline(always)]
            fn from(val: Oabhf) -> u8 {
                Oabhf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oablf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oablf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oablf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oablf {
            #[inline(always)]
            fn from(val: u8) -> Oablf {
                Oablf::from_bits(val)
            }
        }
        impl From<Oablf> for u8 {
            #[inline(always)]
            fn from(val: Oablf) -> u8 {
                Oablf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oadf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadf {
            #[inline(always)]
            fn from(val: u8) -> Oadf {
                Oadf::from_bits(val)
            }
        }
        impl From<Oadf> for u8 {
            #[inline(always)]
            fn from(val: Oadf) -> u8 {
                Oadf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadflt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadflt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadflt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadflt {
            #[inline(always)]
            fn from(val: u8) -> Oadflt {
                Oadflt::from_bits(val)
            }
        }
        impl From<Oadflt> for u8 {
            #[inline(always)]
            fn from(val: Oadflt) -> u8 {
                Oadflt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadty {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oadty {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadty {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadty {
            #[inline(always)]
            fn from(val: u8) -> Oadty {
                Oadty::from_bits(val)
            }
        }
        impl From<Oadty> for u8 {
            #[inline(always)]
            fn from(val: Oadty) -> u8 {
                Oadty::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadtyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadtyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadtyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadtyf {
            #[inline(always)]
            fn from(val: u8) -> Oadtyf {
                Oadtyf::from_bits(val)
            }
        }
        impl From<Oadtyf> for u8 {
            #[inline(always)]
            fn from(val: Oadtyf) -> u8 {
                Oadtyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadtyr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadtyr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadtyr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadtyr {
            #[inline(always)]
            fn from(val: u8) -> Oadtyr {
                Oadtyr::from_bits(val)
            }
        }
        impl From<Oadtyr> for u8 {
            #[inline(always)]
            fn from(val: Oadtyr) -> u8 {
                Oadtyr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oae {
            #[inline(always)]
            fn from(val: u8) -> Oae {
                Oae::from_bits(val)
            }
        }
        impl From<Oae> for u8 {
            #[inline(always)]
            fn from(val: Oae) -> u8 {
                Oae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oahld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oahld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oahld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oahld {
            #[inline(always)]
            fn from(val: u8) -> Oahld {
                Oahld::from_bits(val)
            }
        }
        impl From<Oahld> for u8 {
            #[inline(always)]
            fn from(val: Oahld) -> u8 {
                Oahld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Obdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdf {
            #[inline(always)]
            fn from(val: u8) -> Obdf {
                Obdf::from_bits(val)
            }
        }
        impl From<Obdf> for u8 {
            #[inline(always)]
            fn from(val: Obdf) -> u8 {
                Obdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdflt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdflt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdflt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdflt {
            #[inline(always)]
            fn from(val: u8) -> Obdflt {
                Obdflt::from_bits(val)
            }
        }
        impl From<Obdflt> for u8 {
            #[inline(always)]
            fn from(val: Obdflt) -> u8 {
                Obdflt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdty {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Obdty {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdty {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdty {
            #[inline(always)]
            fn from(val: u8) -> Obdty {
                Obdty::from_bits(val)
            }
        }
        impl From<Obdty> for u8 {
            #[inline(always)]
            fn from(val: Obdty) -> u8 {
                Obdty::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdtyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdtyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdtyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdtyf {
            #[inline(always)]
            fn from(val: u8) -> Obdtyf {
                Obdtyf::from_bits(val)
            }
        }
        impl From<Obdtyf> for u8 {
            #[inline(always)]
            fn from(val: Obdtyf) -> u8 {
                Obdtyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdtyr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdtyr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdtyr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdtyr {
            #[inline(always)]
            fn from(val: u8) -> Obdtyr {
                Obdtyr::from_bits(val)
            }
        }
        impl From<Obdtyr> for u8 {
            #[inline(always)]
            fn from(val: Obdtyr) -> u8 {
                Obdtyr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obe {
            #[inline(always)]
            fn from(val: u8) -> Obe {
                Obe::from_bits(val)
            }
        }
        impl From<Obe> for u8 {
            #[inline(always)]
            fn from(val: Obe) -> u8 {
                Obe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obhld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obhld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obhld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obhld {
            #[inline(always)]
            fn from(val: u8) -> Obhld {
                Obhld::from_bits(val)
            }
        }
        impl From<Obhld> for u8 {
            #[inline(always)]
            fn from(val: Obhld) -> u8 {
                Obhld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Odf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Odf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Odf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Odf {
            #[inline(always)]
            fn from(val: u8) -> Odf {
                Odf::from_bits(val)
            }
        }
        impl From<Odf> for u8 {
            #[inline(always)]
            fn from(val: Odf) -> u8 {
                Odf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Pr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pr {
            #[inline(always)]
            fn from(val: u8) -> Pr {
                Pr::from_bits(val)
            }
        }
        impl From<Pr> for u8 {
            #[inline(always)]
            fn from(val: Pr) -> u8 {
                Pr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscafbh {
            #[inline(always)]
            fn from(val: u8) -> Pscafbh {
                Pscafbh::from_bits(val)
            }
        }
        impl From<Pscafbh> for u8 {
            #[inline(always)]
            fn from(val: Pscafbh) -> u8 {
                Pscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscafbl {
            #[inline(always)]
            fn from(val: u8) -> Pscafbl {
                Pscafbl::from_bits(val)
            }
        }
        impl From<Pscafbl> for u8 {
            #[inline(always)]
            fn from(val: Pscafbl) -> u8 {
                Pscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscarbh {
            #[inline(always)]
            fn from(val: u8) -> Pscarbh {
                Pscarbh::from_bits(val)
            }
        }
        impl From<Pscarbh> for u8 {
            #[inline(always)]
            fn from(val: Pscarbh) -> u8 {
                Pscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscarbl {
            #[inline(always)]
            fn from(val: u8) -> Pscarbl {
                Pscarbl::from_bits(val)
            }
        }
        impl From<Pscarbl> for u8 {
            #[inline(always)]
            fn from(val: Pscarbl) -> u8 {
                Pscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbfah {
            #[inline(always)]
            fn from(val: u8) -> Pscbfah {
                Pscbfah::from_bits(val)
            }
        }
        impl From<Pscbfah> for u8 {
            #[inline(always)]
            fn from(val: Pscbfah) -> u8 {
                Pscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbfal {
            #[inline(always)]
            fn from(val: u8) -> Pscbfal {
                Pscbfal::from_bits(val)
            }
        }
        impl From<Pscbfal> for u8 {
            #[inline(always)]
            fn from(val: Pscbfal) -> u8 {
                Pscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbrah {
            #[inline(always)]
            fn from(val: u8) -> Pscbrah {
                Pscbrah::from_bits(val)
            }
        }
        impl From<Pscbrah> for u8 {
            #[inline(always)]
            fn from(val: Pscbrah) -> u8 {
                Pscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbral {
            #[inline(always)]
            fn from(val: u8) -> Pscbral {
                Pscbral::from_bits(val)
            }
        }
        impl From<Pscbral> for u8 {
            #[inline(always)]
            fn from(val: Pscbral) -> u8 {
                Pscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselca {
            #[inline(always)]
            fn from(val: u8) -> Pselca {
                Pselca::from_bits(val)
            }
        }
        impl From<Pselca> for u8 {
            #[inline(always)]
            fn from(val: Pselca) -> u8 {
                Pselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcb {
            #[inline(always)]
            fn from(val: u8) -> Pselcb {
                Pselcb::from_bits(val)
            }
        }
        impl From<Pselcb> for u8 {
            #[inline(always)]
            fn from(val: Pselcb) -> u8 {
                Pselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcc {
            #[inline(always)]
            fn from(val: u8) -> Pselcc {
                Pselcc::from_bits(val)
            }
        }
        impl From<Pselcc> for u8 {
            #[inline(always)]
            fn from(val: Pselcc) -> u8 {
                Pselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcd {
            #[inline(always)]
            fn from(val: u8) -> Pselcd {
                Pselcd::from_bits(val)
            }
        }
        impl From<Pselcd> for u8 {
            #[inline(always)]
            fn from(val: Pselcd) -> u8 {
                Pselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgaf {
                Psgtrgaf::from_bits(val)
            }
        }
        impl From<Psgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgaf) -> u8 {
                Psgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgar {
                Psgtrgar::from_bits(val)
            }
        }
        impl From<Psgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgar) -> u8 {
                Psgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgbf {
                Psgtrgbf::from_bits(val)
            }
        }
        impl From<Psgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgbf) -> u8 {
                Psgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgbr {
                Psgtrgbr::from_bits(val)
            }
        }
        impl From<Psgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgbr) -> u8 {
                Psgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscafbh {
            #[inline(always)]
            fn from(val: u8) -> Sscafbh {
                Sscafbh::from_bits(val)
            }
        }
        impl From<Sscafbh> for u8 {
            #[inline(always)]
            fn from(val: Sscafbh) -> u8 {
                Sscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscafbl {
            #[inline(always)]
            fn from(val: u8) -> Sscafbl {
                Sscafbl::from_bits(val)
            }
        }
        impl From<Sscafbl> for u8 {
            #[inline(always)]
            fn from(val: Sscafbl) -> u8 {
                Sscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscarbh {
            #[inline(always)]
            fn from(val: u8) -> Sscarbh {
                Sscarbh::from_bits(val)
            }
        }
        impl From<Sscarbh> for u8 {
            #[inline(always)]
            fn from(val: Sscarbh) -> u8 {
                Sscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscarbl {
            #[inline(always)]
            fn from(val: u8) -> Sscarbl {
                Sscarbl::from_bits(val)
            }
        }
        impl From<Sscarbl> for u8 {
            #[inline(always)]
            fn from(val: Sscarbl) -> u8 {
                Sscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbfah {
            #[inline(always)]
            fn from(val: u8) -> Sscbfah {
                Sscbfah::from_bits(val)
            }
        }
        impl From<Sscbfah> for u8 {
            #[inline(always)]
            fn from(val: Sscbfah) -> u8 {
                Sscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbfal {
            #[inline(always)]
            fn from(val: u8) -> Sscbfal {
                Sscbfal::from_bits(val)
            }
        }
        impl From<Sscbfal> for u8 {
            #[inline(always)]
            fn from(val: Sscbfal) -> u8 {
                Sscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbrah {
            #[inline(always)]
            fn from(val: u8) -> Sscbrah {
                Sscbrah::from_bits(val)
            }
        }
        impl From<Sscbrah> for u8 {
            #[inline(always)]
            fn from(val: Sscbrah) -> u8 {
                Sscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbral {
            #[inline(always)]
            fn from(val: u8) -> Sscbral {
                Sscbral::from_bits(val)
            }
        }
        impl From<Sscbral> for u8 {
            #[inline(always)]
            fn from(val: Sscbral) -> u8 {
                Sscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselca {
            #[inline(always)]
            fn from(val: u8) -> Sselca {
                Sselca::from_bits(val)
            }
        }
        impl From<Sselca> for u8 {
            #[inline(always)]
            fn from(val: Sselca) -> u8 {
                Sselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcb {
            #[inline(always)]
            fn from(val: u8) -> Sselcb {
                Sselcb::from_bits(val)
            }
        }
        impl From<Sselcb> for u8 {
            #[inline(always)]
            fn from(val: Sselcb) -> u8 {
                Sselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcc {
            #[inline(always)]
            fn from(val: u8) -> Sselcc {
                Sselcc::from_bits(val)
            }
        }
        impl From<Sselcc> for u8 {
            #[inline(always)]
            fn from(val: Sselcc) -> u8 {
                Sselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcd {
            #[inline(always)]
            fn from(val: u8) -> Sselcd {
                Sselcd::from_bits(val)
            }
        }
        impl From<Sselcd> for u8 {
            #[inline(always)]
            fn from(val: Sselcd) -> u8 {
                Sselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgaf {
                Ssgtrgaf::from_bits(val)
            }
        }
        impl From<Ssgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgaf) -> u8 {
                Ssgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgar {
                Ssgtrgar::from_bits(val)
            }
        }
        impl From<Ssgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgar) -> u8 {
                Ssgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgbf {
                Ssgtrgbf::from_bits(val)
            }
        }
        impl From<Ssgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgbf) -> u8 {
                Ssgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgbr {
                Ssgtrgbr::from_bits(val)
            }
        }
        impl From<Ssgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgbr) -> u8 {
                Ssgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfa {
            #[inline(always)]
            fn from(val: u8) -> Tcfa {
                Tcfa::from_bits(val)
            }
        }
        impl From<Tcfa> for u8 {
            #[inline(always)]
            fn from(val: Tcfa) -> u8 {
                Tcfa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfb {
            #[inline(always)]
            fn from(val: u8) -> Tcfb {
                Tcfb::from_bits(val)
            }
        }
        impl From<Tcfb> for u8 {
            #[inline(always)]
            fn from(val: Tcfb) -> u8 {
                Tcfb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfc {
            #[inline(always)]
            fn from(val: u8) -> Tcfc {
                Tcfc::from_bits(val)
            }
        }
        impl From<Tcfc> for u8 {
            #[inline(always)]
            fn from(val: Tcfc) -> u8 {
                Tcfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfd {
            #[inline(always)]
            fn from(val: u8) -> Tcfd {
                Tcfd::from_bits(val)
            }
        }
        impl From<Tcfd> for u8 {
            #[inline(always)]
            fn from(val: Tcfd) -> u8 {
                Tcfd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfe {
            #[inline(always)]
            fn from(val: u8) -> Tcfe {
                Tcfe::from_bits(val)
            }
        }
        impl From<Tcfe> for u8 {
            #[inline(always)]
            fn from(val: Tcfe) -> u8 {
                Tcfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcff {
            #[inline(always)]
            fn from(val: u8) -> Tcff {
                Tcff::from_bits(val)
            }
        }
        impl From<Tcff> for u8 {
            #[inline(always)]
            fn from(val: Tcff) -> u8 {
                Tcff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfpo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfpo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfpo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfpo {
            #[inline(always)]
            fn from(val: u8) -> Tcfpo {
                Tcfpo::from_bits(val)
            }
        }
        impl From<Tcfpo> for u8 {
            #[inline(always)]
            fn from(val: Tcfpo) -> u8 {
                Tcfpo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfpu {
            #[inline(always)]
            fn from(val: u8) -> Tcfpu {
                Tcfpu::from_bits(val)
            }
        }
        impl From<Tcfpu> for u8 {
            #[inline(always)]
            fn from(val: Tcfpu) -> u8 {
                Tcfpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tde {
            #[inline(always)]
            fn from(val: u8) -> Tde {
                Tde::from_bits(val)
            }
        }
        impl From<Tde> for u8 {
            #[inline(always)]
            fn from(val: Tde) -> u8 {
                Tde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tpcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tpcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tpcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tpcs {
            #[inline(always)]
            fn from(val: u8) -> Tpcs {
                Tpcs::from_bits(val)
            }
        }
        impl From<Tpcs> for u8 {
            #[inline(always)]
            fn from(val: Tpcs) -> u8 {
                Tpcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tucf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tucf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tucf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tucf {
            #[inline(always)]
            fn from(val: u8) -> Tucf {
                Tucf::from_bits(val)
            }
        }
        impl From<Tucf> for u8 {
            #[inline(always)]
            fn from(val: Tucf) -> u8 {
                Tucf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ud {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ud {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ud {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ud {
            #[inline(always)]
            fn from(val: u8) -> Ud {
                Ud::from_bits(val)
            }
        }
        impl From<Ud> for u8 {
            #[inline(always)]
            fn from(val: Ud) -> u8 {
                Ud::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Udf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Udf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Udf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Udf {
            #[inline(always)]
            fn from(val: u8) -> Udf {
                Udf::from_bits(val)
            }
        }
        impl From<Udf> for u8 {
            #[inline(always)]
            fn from(val: Udf) -> u8 {
                Udf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscafbh {
            #[inline(always)]
            fn from(val: u8) -> Uscafbh {
                Uscafbh::from_bits(val)
            }
        }
        impl From<Uscafbh> for u8 {
            #[inline(always)]
            fn from(val: Uscafbh) -> u8 {
                Uscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscafbl {
            #[inline(always)]
            fn from(val: u8) -> Uscafbl {
                Uscafbl::from_bits(val)
            }
        }
        impl From<Uscafbl> for u8 {
            #[inline(always)]
            fn from(val: Uscafbl) -> u8 {
                Uscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscarbh {
            #[inline(always)]
            fn from(val: u8) -> Uscarbh {
                Uscarbh::from_bits(val)
            }
        }
        impl From<Uscarbh> for u8 {
            #[inline(always)]
            fn from(val: Uscarbh) -> u8 {
                Uscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscarbl {
            #[inline(always)]
            fn from(val: u8) -> Uscarbl {
                Uscarbl::from_bits(val)
            }
        }
        impl From<Uscarbl> for u8 {
            #[inline(always)]
            fn from(val: Uscarbl) -> u8 {
                Uscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbfah {
            #[inline(always)]
            fn from(val: u8) -> Uscbfah {
                Uscbfah::from_bits(val)
            }
        }
        impl From<Uscbfah> for u8 {
            #[inline(always)]
            fn from(val: Uscbfah) -> u8 {
                Uscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbfal {
            #[inline(always)]
            fn from(val: u8) -> Uscbfal {
                Uscbfal::from_bits(val)
            }
        }
        impl From<Uscbfal> for u8 {
            #[inline(always)]
            fn from(val: Uscbfal) -> u8 {
                Uscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbrah {
            #[inline(always)]
            fn from(val: u8) -> Uscbrah {
                Uscbrah::from_bits(val)
            }
        }
        impl From<Uscbrah> for u8 {
            #[inline(always)]
            fn from(val: Uscbrah) -> u8 {
                Uscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbral {
            #[inline(always)]
            fn from(val: u8) -> Uscbral {
                Uscbral::from_bits(val)
            }
        }
        impl From<Uscbral> for u8 {
            #[inline(always)]
            fn from(val: Uscbral) -> u8 {
                Uscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselca {
            #[inline(always)]
            fn from(val: u8) -> Uselca {
                Uselca::from_bits(val)
            }
        }
        impl From<Uselca> for u8 {
            #[inline(always)]
            fn from(val: Uselca) -> u8 {
                Uselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcb {
            #[inline(always)]
            fn from(val: u8) -> Uselcb {
                Uselcb::from_bits(val)
            }
        }
        impl From<Uselcb> for u8 {
            #[inline(always)]
            fn from(val: Uselcb) -> u8 {
                Uselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcc {
            #[inline(always)]
            fn from(val: u8) -> Uselcc {
                Uselcc::from_bits(val)
            }
        }
        impl From<Uselcc> for u8 {
            #[inline(always)]
            fn from(val: Uselcc) -> u8 {
                Uselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcd {
            #[inline(always)]
            fn from(val: u8) -> Uselcd {
                Uselcd::from_bits(val)
            }
        }
        impl From<Uselcd> for u8 {
            #[inline(always)]
            fn from(val: Uselcd) -> u8 {
                Uselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgaf {
                Usgtrgaf::from_bits(val)
            }
        }
        impl From<Usgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgaf) -> u8 {
                Usgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgar {
                Usgtrgar::from_bits(val)
            }
        }
        impl From<Usgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgar) -> u8 {
                Usgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgbf {
                Usgtrgbf::from_bits(val)
            }
        }
        impl From<Usgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgbf) -> u8 {
                Usgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgbr {
                Usgtrgbr::from_bits(val)
            }
        }
        impl From<Usgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgbr) -> u8 {
                Usgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wp {
            #[inline(always)]
            fn from(val: u8) -> Wp {
                Wp::from_bits(val)
            }
        }
        impl From<Wp> for u8 {
            #[inline(always)]
            fn from(val: Wp) -> u8 {
                Wp::to_bits(val)
            }
        }
    }
}
pub mod gpt_ops {
    #[doc = "Output Phase Switching Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GptOps {
        ptr: *mut u8,
    }
    unsafe impl Send for GptOps {}
    unsafe impl Sync for GptOps {}
    impl GptOps {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output Phase Switching Control Register"]
        #[inline(always)]
        pub const fn opscr(self) -> crate::common::Reg<regs::Opscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Output Phase Switching Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opscr(pub u32);
        impl Opscr {
            #[inline(always)]
            pub const fn uf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_uf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[inline(always)]
            pub const fn vf(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_vf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn wf(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_wf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Output Phase Enable"]
            #[inline(always)]
            pub const fn en(&self) -> super::vals::En {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::En::from_bits(val as u8)
            }
            #[doc = "Output Phase Enable"]
            #[inline(always)]
            pub fn set_en(&mut self, val: super::vals::En) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "External Feedback Signal Enable"]
            #[inline(always)]
            pub const fn fb(&self) -> super::vals::Fb {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Fb::from_bits(val as u8)
            }
            #[doc = "External Feedback Signal Enable"]
            #[inline(always)]
            pub fn set_fb(&mut self, val: super::vals::Fb) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Positive,Phase Output (P) Control"]
            #[inline(always)]
            pub const fn p(&self) -> super::vals::P {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::P::from_bits(val as u8)
            }
            #[doc = "Positive,Phase Output (P) Control"]
            #[inline(always)]
            pub fn set_p(&mut self, val: super::vals::P) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Negative,Phase Output (N) Control"]
            #[inline(always)]
            pub const fn n(&self) -> super::vals::N {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::N::from_bits(val as u8)
            }
            #[doc = "Negative,Phase Output (N) Control"]
            #[inline(always)]
            pub fn set_n(&mut self, val: super::vals::N) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Output Phase Invert Control"]
            #[inline(always)]
            pub const fn inv(&self) -> super::vals::Inv {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Inv::from_bits(val as u8)
            }
            #[doc = "Output Phase Invert Control"]
            #[inline(always)]
            pub fn set_inv(&mut self, val: super::vals::Inv) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Output Phase Rotation Direction Reversal Control"]
            #[inline(always)]
            pub const fn rv(&self) -> super::vals::Rv {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Rv::from_bits(val as u8)
            }
            #[doc = "Output Phase Rotation Direction Reversal Control"]
            #[inline(always)]
            pub fn set_rv(&mut self, val: super::vals::Rv) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Input Phase Alignment"]
            #[inline(always)]
            pub const fn align(&self) -> super::vals::Align {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Align::from_bits(val as u8)
            }
            #[doc = "Input Phase Alignment"]
            #[inline(always)]
            pub fn set_align(&mut self, val: super::vals::Align) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Output Disabled Source Selection"]
            #[inline(always)]
            pub const fn grp(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "Output Disabled Source Selection"]
            #[inline(always)]
            pub fn set_grp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
            #[doc = "Group Output Disable Function"]
            #[inline(always)]
            pub const fn godf(&self) -> super::vals::Godf {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Godf::from_bits(val as u8)
            }
            #[doc = "Group Output Disable Function"]
            #[inline(always)]
            pub fn set_godf(&mut self, val: super::vals::Godf) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "External Input Noise Filter Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::Nfen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Nfen::from_bits(val as u8)
            }
            #[doc = "External Input Noise Filter Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::Nfen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "External Input Noise Filter Clock Selection"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::Nfcs {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::Nfcs::from_bits(val as u8)
            }
            #[doc = "External Input Noise Filter Clock Selection"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::Nfcs) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Opscr {
            #[inline(always)]
            fn default() -> Opscr {
                Opscr(0)
            }
        }
        impl core::fmt::Debug for Opscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opscr")
                    .field("uf", &self.uf())
                    .field("vf", &self.vf())
                    .field("wf", &self.wf())
                    .field("en", &self.en())
                    .field("fb", &self.fb())
                    .field("p", &self.p())
                    .field("n", &self.n())
                    .field("inv", &self.inv())
                    .field("rv", &self.rv())
                    .field("align", &self.align())
                    .field("grp", &self.grp())
                    .field("godf", &self.godf())
                    .field("nfen", &self.nfen())
                    .field("nfcs", &self.nfcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opscr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Opscr {{ uf: {=bool:?}, vf: {=bool:?}, wf: {=bool:?}, en: {:?}, fb: {:?}, p: {:?}, n: {:?}, inv: {:?}, rv: {:?}, align: {:?}, grp: {=u8:?}, godf: {:?}, nfen: {:?}, nfcs: {:?} }}" , self . uf () , self . vf () , self . wf () , self . en () , self . fb () , self . p () , self . n () , self . inv () , self . rv () , self . align () , self . grp () , self . godf () , self . nfen () , self . nfcs ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Align {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Align {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Align {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Align {
            #[inline(always)]
            fn from(val: u8) -> Align {
                Align::from_bits(val)
            }
        }
        impl From<Align> for u8 {
            #[inline(always)]
            fn from(val: Align) -> u8 {
                Align::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En {
            #[inline(always)]
            fn from(val: u8) -> En {
                En::from_bits(val)
            }
        }
        impl From<En> for u8 {
            #[inline(always)]
            fn from(val: En) -> u8 {
                En::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fb {
            #[inline(always)]
            fn from(val: u8) -> Fb {
                Fb::from_bits(val)
            }
        }
        impl From<Fb> for u8 {
            #[inline(always)]
            fn from(val: Fb) -> u8 {
                Fb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Godf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Godf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Godf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Godf {
            #[inline(always)]
            fn from(val: u8) -> Godf {
                Godf::from_bits(val)
            }
        }
        impl From<Godf> for u8 {
            #[inline(always)]
            fn from(val: Godf) -> u8 {
                Godf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Inv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inv {
            #[inline(always)]
            fn from(val: u8) -> Inv {
                Inv::from_bits(val)
            }
        }
        impl From<Inv> for u8 {
            #[inline(always)]
            fn from(val: Inv) -> u8 {
                Inv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum N {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl N {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> N {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for N {
            #[inline(always)]
            fn from(val: u8) -> N {
                N::from_bits(val)
            }
        }
        impl From<N> for u8 {
            #[inline(always)]
            fn from(val: N) -> u8 {
                N::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcs {
            #[inline(always)]
            fn from(val: u8) -> Nfcs {
                Nfcs::from_bits(val)
            }
        }
        impl From<Nfcs> for u8 {
            #[inline(always)]
            fn from(val: Nfcs) -> u8 {
                Nfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfen {
            #[inline(always)]
            fn from(val: u8) -> Nfen {
                Nfen::from_bits(val)
            }
        }
        impl From<Nfen> for u8 {
            #[inline(always)]
            fn from(val: Nfen) -> u8 {
                Nfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P {
            #[inline(always)]
            fn from(val: u8) -> P {
                P::from_bits(val)
            }
        }
        impl From<P> for u8 {
            #[inline(always)]
            fn from(val: P) -> u8 {
                P::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rv {
            #[inline(always)]
            fn from(val: u8) -> Rv {
                Rv::from_bits(val)
            }
        }
        impl From<Rv> for u8 {
            #[inline(always)]
            fn from(val: Rv) -> u8 {
                Rv::to_bits(val)
            }
        }
    }
}
pub mod icu {
    #[doc = "ICU for CPU"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Icu {
        ptr: *mut u8,
    }
    unsafe impl Send for Icu {}
    unsafe impl Sync for Icu {}
    impl Icu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IRQ Control Register %s"]
        #[inline(always)]
        pub const fn irqcr(self, n: usize) -> crate::common::Reg<regs::Irqcr, crate::common::RW> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 1usize) as _) }
        }
        #[doc = "NMI Pin Interrupt Control Register"]
        #[inline(always)]
        pub const fn nmicr(self) -> crate::common::Reg<regs::Nmicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Non,Maskable Interrupt Enable Register"]
        #[inline(always)]
        pub const fn nmier(self) -> crate::common::Reg<regs::Nmier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Non,Maskable Interrupt Status Clear Register"]
        #[inline(always)]
        pub const fn nmiclr(self) -> crate::common::Reg<regs::Nmiclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Non,Maskable Interrupt Status Register"]
        #[inline(always)]
        pub const fn nmisr(self) -> crate::common::Reg<regs::Nmisr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "Wake Up Interrupt Enable Register 0"]
        #[inline(always)]
        pub const fn wupen0(self) -> crate::common::Reg<regs::Wupen0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a0usize) as _) }
        }
        #[doc = "Wake Up Interrupt Enable Register 1"]
        #[inline(always)]
        pub const fn wupen1(self) -> crate::common::Reg<regs::Wupen1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a4usize) as _) }
        }
        #[doc = "ICU Event Enable Register"]
        #[inline(always)]
        pub const fn ielen(self) -> crate::common::Reg<regs::Ielen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[doc = "SYS Event Link Setting Register"]
        #[inline(always)]
        pub const fn selsr0(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "ICU Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn ielsr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize + n * 4usize) as _) }
        }
        #[doc = "ICU Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn ielsr_1(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 36usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0380usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "ICU Event Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ielen(pub u8);
        impl Ielen {
            #[doc = "RTCALM0, RTCALM1, and RTCPRD Interrupts Enable (when LPOPTEN bit = 1)"]
            #[inline(always)]
            pub const fn rtcinten(&self) -> super::vals::Rtcinten {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rtcinten::from_bits(val as u8)
            }
            #[doc = "RTCALM0, RTCALM1, and RTCPRD Interrupts Enable (when LPOPTEN bit = 1)"]
            #[inline(always)]
            pub fn set_rtcinten(&mut self, val: super::vals::Rtcinten) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Parts Asynchronous Interrupts Enable except RTC (when LPOPTEN bit = 1)"]
            #[inline(always)]
            pub const fn ielen(&self) -> super::vals::Ielen {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ielen::from_bits(val as u8)
            }
            #[doc = "Parts Asynchronous Interrupts Enable except RTC (when LPOPTEN bit = 1)"]
            #[inline(always)]
            pub fn set_ielen(&mut self, val: super::vals::Ielen) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Ielen {
            #[inline(always)]
            fn default() -> Ielen {
                Ielen(0)
            }
        }
        impl core::fmt::Debug for Ielen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ielen")
                    .field("rtcinten", &self.rtcinten())
                    .field("ielen", &self.ielen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ielen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ielen {{ rtcinten: {:?}, ielen: {:?} }}",
                    self.rtcinten(),
                    self.ielen()
                )
            }
        }
        #[doc = "IRQ Control Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Irqcr(pub u8);
        impl Irqcr {
            #[doc = "IRQi Detection Sense Select"]
            #[inline(always)]
            pub const fn irqmd(&self) -> super::vals::Irqmd {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Irqmd::from_bits(val as u8)
            }
            #[doc = "IRQi Detection Sense Select"]
            #[inline(always)]
            pub fn set_irqmd(&mut self, val: super::vals::Irqmd) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "IRQi Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub const fn fclksel(&self) -> super::vals::Fclksel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Fclksel::from_bits(val as u8)
            }
            #[doc = "IRQi Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub fn set_fclksel(&mut self, val: super::vals::Fclksel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "IRQi Digital Filter Enable"]
            #[inline(always)]
            pub const fn flten(&self) -> super::vals::Flten {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Flten::from_bits(val as u8)
            }
            #[doc = "IRQi Digital Filter Enable"]
            #[inline(always)]
            pub fn set_flten(&mut self, val: super::vals::Flten) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Irqcr {
            #[inline(always)]
            fn default() -> Irqcr {
                Irqcr(0)
            }
        }
        impl core::fmt::Debug for Irqcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Irqcr")
                    .field("irqmd", &self.irqmd())
                    .field("fclksel", &self.fclksel())
                    .field("flten", &self.flten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Irqcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Irqcr {{ irqmd: {:?}, fclksel: {:?}, flten: {:?} }}",
                    self.irqmd(),
                    self.fclksel(),
                    self.flten()
                )
            }
        }
        #[doc = "Non,Maskable Interrupt Status Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmiclr(pub u16);
        impl Nmiclr {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn iwdtclr(&self) -> super::vals::Iwdtclr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtclr::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_iwdtclr(&mut self, val: super::vals::Iwdtclr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn wdtclr(&self) -> super::vals::Wdtclr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtclr::from_bits(val as u8)
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_wdtclr(&mut self, val: super::vals::Wdtclr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn lvd1clr(&self) -> super::vals::Lvd1clr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1clr::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_lvd1clr(&mut self, val: super::vals::Lvd1clr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 2 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn lvd2clr(&self) -> super::vals::Lvd2clr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2clr::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_lvd2clr(&mut self, val: super::vals::Lvd2clr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Oscillation Stop Detection Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn ostclr(&self) -> super::vals::Ostclr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ostclr::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_ostclr(&mut self, val: super::vals::Ostclr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "NMI Pin Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn nmiclr(&self) -> super::vals::Nmiclr {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmiclr::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_nmiclr(&mut self, val: super::vals::Nmiclr) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn rpeclr(&self) -> super::vals::Rpeclr {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpeclr::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_rpeclr(&mut self, val: super::vals::Rpeclr) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "SRAM ECC Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn reccclr(&self) -> super::vals::Reccclr {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Reccclr::from_bits(val as u8)
            }
            #[doc = "SRAM ECC Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_reccclr(&mut self, val: super::vals::Reccclr) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Bus Slave MPU Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn bussclr(&self) -> super::vals::Bussclr {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussclr::from_bits(val as u8)
            }
            #[doc = "Bus Slave MPU Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_bussclr(&mut self, val: super::vals::Bussclr) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus Master MPU Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn busmclr(&self) -> super::vals::Busmclr {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmclr::from_bits(val as u8)
            }
            #[doc = "Bus Master MPU Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_busmclr(&mut self, val: super::vals::Busmclr) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn speclr(&self) -> super::vals::Speclr {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Speclr::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_speclr(&mut self, val: super::vals::Speclr) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Nmiclr {
            #[inline(always)]
            fn default() -> Nmiclr {
                Nmiclr(0)
            }
        }
        impl core::fmt::Debug for Nmiclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmiclr")
                    .field("iwdtclr", &self.iwdtclr())
                    .field("wdtclr", &self.wdtclr())
                    .field("lvd1clr", &self.lvd1clr())
                    .field("lvd2clr", &self.lvd2clr())
                    .field("ostclr", &self.ostclr())
                    .field("nmiclr", &self.nmiclr())
                    .field("rpeclr", &self.rpeclr())
                    .field("reccclr", &self.reccclr())
                    .field("bussclr", &self.bussclr())
                    .field("busmclr", &self.busmclr())
                    .field("speclr", &self.speclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmiclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmiclr {{ iwdtclr: {:?}, wdtclr: {:?}, lvd1clr: {:?}, lvd2clr: {:?}, ostclr: {:?}, nmiclr: {:?}, rpeclr: {:?}, reccclr: {:?}, bussclr: {:?}, busmclr: {:?}, speclr: {:?} }}" , self . iwdtclr () , self . wdtclr () , self . lvd1clr () , self . lvd2clr () , self . ostclr () , self . nmiclr () , self . rpeclr () , self . reccclr () , self . bussclr () , self . busmclr () , self . speclr ())
            }
        }
        #[doc = "NMI Pin Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmicr(pub u8);
        impl Nmicr {
            #[doc = "NMI Detection Set"]
            #[inline(always)]
            pub const fn nmimd(&self) -> super::vals::Nmimd {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Nmimd::from_bits(val as u8)
            }
            #[doc = "NMI Detection Set"]
            #[inline(always)]
            pub fn set_nmimd(&mut self, val: super::vals::Nmimd) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "NMI Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfclksel(&self) -> super::vals::Nfclksel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Nfclksel::from_bits(val as u8)
            }
            #[doc = "NMI Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfclksel(&mut self, val: super::vals::Nfclksel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "NMI Digital Filter Enable"]
            #[inline(always)]
            pub const fn nflten(&self) -> super::vals::Nflten {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nflten::from_bits(val as u8)
            }
            #[doc = "NMI Digital Filter Enable"]
            #[inline(always)]
            pub fn set_nflten(&mut self, val: super::vals::Nflten) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Nmicr {
            #[inline(always)]
            fn default() -> Nmicr {
                Nmicr(0)
            }
        }
        impl core::fmt::Debug for Nmicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmicr")
                    .field("nmimd", &self.nmimd())
                    .field("nfclksel", &self.nfclksel())
                    .field("nflten", &self.nflten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmicr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nmicr {{ nmimd: {:?}, nfclksel: {:?}, nflten: {:?} }}",
                    self.nmimd(),
                    self.nfclksel(),
                    self.nflten()
                )
            }
        }
        #[doc = "Non,Maskable Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmier(pub u16);
        impl Nmier {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub const fn iwdten(&self) -> super::vals::Iwdten {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdten::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_iwdten(&mut self, val: super::vals::Iwdten) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub const fn wdten(&self) -> super::vals::Wdten {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdten::from_bits(val as u8)
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_wdten(&mut self, val: super::vals::Wdten) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Voltage monitor 1 Interrupt Enable"]
            #[inline(always)]
            pub const fn lvd1en(&self) -> super::vals::Lvd1en {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1en::from_bits(val as u8)
            }
            #[doc = "Voltage monitor 1 Interrupt Enable"]
            #[inline(always)]
            pub fn set_lvd1en(&mut self, val: super::vals::Lvd1en) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Voltage monitor 2 Interrupt Enable"]
            #[inline(always)]
            pub const fn lvd2en(&self) -> super::vals::Lvd2en {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2en::from_bits(val as u8)
            }
            #[doc = "Voltage monitor 2 Interrupt Enable"]
            #[inline(always)]
            pub fn set_lvd2en(&mut self, val: super::vals::Lvd2en) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Main Clock Oscillation Stop Detection Interrupt Enable"]
            #[inline(always)]
            pub const fn osten(&self) -> super::vals::Osten {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Osten::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillation Stop Detection Interrupt Enable"]
            #[inline(always)]
            pub fn set_osten(&mut self, val: super::vals::Osten) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "NMI Pin Interrupt Enable"]
            #[inline(always)]
            pub const fn nmien(&self) -> super::vals::Nmien {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmien::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Enable"]
            #[inline(always)]
            pub fn set_nmien(&mut self, val: super::vals::Nmien) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Interrupt Enable"]
            #[inline(always)]
            pub const fn rpeen(&self) -> super::vals::Rpeen {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpeen::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_rpeen(&mut self, val: super::vals::Rpeen) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "SRAM ECC Error Interrupt Enable"]
            #[inline(always)]
            pub const fn reccen(&self) -> super::vals::Reccen {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Reccen::from_bits(val as u8)
            }
            #[doc = "SRAM ECC Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_reccen(&mut self, val: super::vals::Reccen) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Bus Slave MPU Error Interrupt Enable"]
            #[inline(always)]
            pub const fn bussen(&self) -> super::vals::Bussen {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussen::from_bits(val as u8)
            }
            #[doc = "Bus Slave MPU Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_bussen(&mut self, val: super::vals::Bussen) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus Master MPU Error Interrupt Enable"]
            #[inline(always)]
            pub const fn busmen(&self) -> super::vals::Busmen {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmen::from_bits(val as u8)
            }
            #[doc = "Bus Master MPU Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_busmen(&mut self, val: super::vals::Busmen) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Enable"]
            #[inline(always)]
            pub const fn speen(&self) -> super::vals::Speen {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Speen::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Enable"]
            #[inline(always)]
            pub fn set_speen(&mut self, val: super::vals::Speen) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Nmier {
            #[inline(always)]
            fn default() -> Nmier {
                Nmier(0)
            }
        }
        impl core::fmt::Debug for Nmier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmier")
                    .field("iwdten", &self.iwdten())
                    .field("wdten", &self.wdten())
                    .field("lvd1en", &self.lvd1en())
                    .field("lvd2en", &self.lvd2en())
                    .field("osten", &self.osten())
                    .field("nmien", &self.nmien())
                    .field("rpeen", &self.rpeen())
                    .field("reccen", &self.reccen())
                    .field("bussen", &self.bussen())
                    .field("busmen", &self.busmen())
                    .field("speen", &self.speen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmier {{ iwdten: {:?}, wdten: {:?}, lvd1en: {:?}, lvd2en: {:?}, osten: {:?}, nmien: {:?}, rpeen: {:?}, reccen: {:?}, bussen: {:?}, busmen: {:?}, speen: {:?} }}" , self . iwdten () , self . wdten () , self . lvd1en () , self . lvd2en () , self . osten () , self . nmien () , self . rpeen () , self . reccen () , self . bussen () , self . busmen () , self . speen ())
            }
        }
        #[doc = "Non,Maskable Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmisr(pub u16);
        impl Nmisr {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn iwdtst(&self) -> super::vals::Iwdtst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtst::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_iwdtst(&mut self, val: super::vals::Iwdtst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn wdtst(&self) -> super::vals::Wdtst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtst::from_bits(val as u8)
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_wdtst(&mut self, val: super::vals::Wdtst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag"]
            #[inline(always)]
            pub const fn lvd1st(&self) -> super::vals::Lvd1st {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1st::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_lvd1st(&mut self, val: super::vals::Lvd1st) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 2 Interrupt Status Flag"]
            #[inline(always)]
            pub const fn lvd2st(&self) -> super::vals::Lvd2st {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2st::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_lvd2st(&mut self, val: super::vals::Lvd2st) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Main Clock Oscillation Stop Detection Interrupt Status Flag"]
            #[inline(always)]
            pub const fn ostst(&self) -> super::vals::Ostst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ostst::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillation Stop Detection Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_ostst(&mut self, val: super::vals::Ostst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "NMI Pin Interrupt Status Flag"]
            #[inline(always)]
            pub const fn nmist(&self) -> super::vals::Nmist {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmist::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_nmist(&mut self, val: super::vals::Nmist) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn rpest(&self) -> super::vals::Rpest {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpest::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_rpest(&mut self, val: super::vals::Rpest) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "SRAM ECC Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn reccst(&self) -> super::vals::Reccst {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Reccst::from_bits(val as u8)
            }
            #[doc = "SRAM ECC Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_reccst(&mut self, val: super::vals::Reccst) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Bus Slave MPU Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn bussst(&self) -> super::vals::Bussst {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussst::from_bits(val as u8)
            }
            #[doc = "Bus Slave MPU Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_bussst(&mut self, val: super::vals::Bussst) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus Master MPU Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn busmst(&self) -> super::vals::Busmst {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmst::from_bits(val as u8)
            }
            #[doc = "Bus Master MPU Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_busmst(&mut self, val: super::vals::Busmst) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag"]
            #[inline(always)]
            pub const fn spest(&self) -> super::vals::Spest {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Spest::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_spest(&mut self, val: super::vals::Spest) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Nmisr {
            #[inline(always)]
            fn default() -> Nmisr {
                Nmisr(0)
            }
        }
        impl core::fmt::Debug for Nmisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmisr")
                    .field("iwdtst", &self.iwdtst())
                    .field("wdtst", &self.wdtst())
                    .field("lvd1st", &self.lvd1st())
                    .field("lvd2st", &self.lvd2st())
                    .field("ostst", &self.ostst())
                    .field("nmist", &self.nmist())
                    .field("rpest", &self.rpest())
                    .field("reccst", &self.reccst())
                    .field("bussst", &self.bussst())
                    .field("busmst", &self.busmst())
                    .field("spest", &self.spest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmisr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmisr {{ iwdtst: {:?}, wdtst: {:?}, lvd1st: {:?}, lvd2st: {:?}, ostst: {:?}, nmist: {:?}, rpest: {:?}, reccst: {:?}, bussst: {:?}, busmst: {:?}, spest: {:?} }}" , self . iwdtst () , self . wdtst () , self . lvd1st () , self . lvd2st () , self . ostst () , self . nmist () , self . rpest () , self . reccst () , self . bussst () , self . busmst () , self . spest ())
            }
        }
        #[doc = "Wake Up Interrupt Enable Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wupen0(pub u32);
        impl Wupen0 {
            #[doc = "IRQ Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn irqwupen(&self) -> super::vals::Irqwupen {
                let val = (self.0 >> 0usize) & 0x0fff;
                super::vals::Irqwupen::from_bits(val as u16)
            }
            #[doc = "IRQ Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_irqwupen(&mut self, val: super::vals::Irqwupen) {
                self.0 =
                    (self.0 & !(0x0fff << 0usize)) | (((val.to_bits() as u32) & 0x0fff) << 0usize);
            }
            #[doc = "IWDT Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn iwdtwupen(&self) -> super::vals::Iwdtwupen {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Iwdtwupen::from_bits(val as u8)
            }
            #[doc = "IWDT Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_iwdtwupen(&mut self, val: super::vals::Iwdtwupen) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "LVD1 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn lvd1wupen(&self) -> super::vals::Lvd1wupen {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Lvd1wupen::from_bits(val as u8)
            }
            #[doc = "LVD1 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_lvd1wupen(&mut self, val: super::vals::Lvd1wupen) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "LVD2 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn lvd2wupen(&self) -> super::vals::Lvd2wupen {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Lvd2wupen::from_bits(val as u8)
            }
            #[doc = "LVD2 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_lvd2wupen(&mut self, val: super::vals::Lvd2wupen) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "LVDVBAT Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn lvdvbatwupen(&self) -> super::vals::Lvdvbatwupen {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Lvdvbatwupen::from_bits(val as u8)
            }
            #[doc = "LVDVBAT Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_lvdvbatwupen(&mut self, val: super::vals::Lvdvbatwupen) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "LVDVRTC Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn lvdvrtcwupen(&self) -> super::vals::Lvdvrtcwupen {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Lvdvrtcwupen::from_bits(val as u8)
            }
            #[doc = "LVDVRTC Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_lvdvrtcwupen(&mut self, val: super::vals::Lvdvrtcwupen) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "LVDEXLVD Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn lvdexlvdwupen(&self) -> super::vals::Lvdexlvdwupen {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Lvdexlvdwupen::from_bits(val as u8)
            }
            #[doc = "LVDEXLVD Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_lvdexlvdwupen(&mut self, val: super::vals::Lvdexlvdwupen) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "RTC Alarm Interrupt 1 Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn rtcalm1wupen(&self) -> super::vals::Rtcalm1wupen {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Rtcalm1wupen::from_bits(val as u8)
            }
            #[doc = "RTC Alarm Interrupt 1 Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_rtcalm1wupen(&mut self, val: super::vals::Rtcalm1wupen) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "RTC Alarm Interrupt 0 Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn rtcalm0wupen(&self) -> super::vals::Rtcalm0wupen {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Rtcalm0wupen::from_bits(val as u8)
            }
            #[doc = "RTC Alarm Interrupt 0 Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_rtcalm0wupen(&mut self, val: super::vals::Rtcalm0wupen) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "RTC Period Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn rtcprdwupen(&self) -> super::vals::Rtcprdwupen {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Rtcprdwupen::from_bits(val as u8)
            }
            #[doc = "RTC Period Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_rtcprdwupen(&mut self, val: super::vals::Rtcprdwupen) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "AGTW0 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agtw0udwupen(&self) -> super::vals::Agtw0udwupen {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Agtw0udwupen::from_bits(val as u8)
            }
            #[doc = "AGTW0 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agtw0udwupen(&mut self, val: super::vals::Agtw0udwupen) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "AGTW1 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agtw1udwupen(&self) -> super::vals::Agtw1udwupen {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Agtw1udwupen::from_bits(val as u8)
            }
            #[doc = "AGTW1 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agtw1udwupen(&mut self, val: super::vals::Agtw1udwupen) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "AGTW1 Compare Match A Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agtw1cawupen(&self) -> super::vals::Agtw1cawupen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Agtw1cawupen::from_bits(val as u8)
            }
            #[doc = "AGTW1 Compare Match A Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agtw1cawupen(&mut self, val: super::vals::Agtw1cawupen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "AGTW1 Compare Match B Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agtw1cbwupen(&self) -> super::vals::Agtw1cbwupen {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Agtw1cbwupen::from_bits(val as u8)
            }
            #[doc = "AGTW1 Compare Match B Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agtw1cbwupen(&mut self, val: super::vals::Agtw1cbwupen) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "IIC0 Address Match Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn iic0wupen(&self) -> super::vals::Iic0wupen {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Iic0wupen::from_bits(val as u8)
            }
            #[doc = "IIC0 Address Match Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_iic0wupen(&mut self, val: super::vals::Iic0wupen) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Wupen0 {
            #[inline(always)]
            fn default() -> Wupen0 {
                Wupen0(0)
            }
        }
        impl core::fmt::Debug for Wupen0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wupen0")
                    .field("irqwupen", &self.irqwupen())
                    .field("iwdtwupen", &self.iwdtwupen())
                    .field("lvd1wupen", &self.lvd1wupen())
                    .field("lvd2wupen", &self.lvd2wupen())
                    .field("lvdvbatwupen", &self.lvdvbatwupen())
                    .field("lvdvrtcwupen", &self.lvdvrtcwupen())
                    .field("lvdexlvdwupen", &self.lvdexlvdwupen())
                    .field("rtcalm1wupen", &self.rtcalm1wupen())
                    .field("rtcalm0wupen", &self.rtcalm0wupen())
                    .field("rtcprdwupen", &self.rtcprdwupen())
                    .field("agtw0udwupen", &self.agtw0udwupen())
                    .field("agtw1udwupen", &self.agtw1udwupen())
                    .field("agtw1cawupen", &self.agtw1cawupen())
                    .field("agtw1cbwupen", &self.agtw1cbwupen())
                    .field("iic0wupen", &self.iic0wupen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wupen0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Wupen0 {{ irqwupen: {:?}, iwdtwupen: {:?}, lvd1wupen: {:?}, lvd2wupen: {:?}, lvdvbatwupen: {:?}, lvdvrtcwupen: {:?}, lvdexlvdwupen: {:?}, rtcalm1wupen: {:?}, rtcalm0wupen: {:?}, rtcprdwupen: {:?}, agtw0udwupen: {:?}, agtw1udwupen: {:?}, agtw1cawupen: {:?}, agtw1cbwupen: {:?}, iic0wupen: {:?} }}" , self . irqwupen () , self . iwdtwupen () , self . lvd1wupen () , self . lvd2wupen () , self . lvdvbatwupen () , self . lvdvrtcwupen () , self . lvdexlvdwupen () , self . rtcalm1wupen () , self . rtcalm0wupen () , self . rtcprdwupen () , self . agtw0udwupen () , self . agtw1udwupen () , self . agtw1cawupen () , self . agtw1cbwupen () , self . iic0wupen ())
            }
        }
        #[doc = "Wake Up Interrupt Enable Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wupen1(pub u32);
        impl Wupen1 {
            #[doc = "AGT0 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt0udwupen(&self) -> super::vals::Agt0udwupen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Agt0udwupen::from_bits(val as u8)
            }
            #[doc = "AGT0 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt0udwupen(&mut self, val: super::vals::Agt0udwupen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "AGT1 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt1udwupen(&self) -> super::vals::Agt1udwupen {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Agt1udwupen::from_bits(val as u8)
            }
            #[doc = "AGT1 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt1udwupen(&mut self, val: super::vals::Agt1udwupen) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "AGT2 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt2udwupen(&self) -> super::vals::Agt2udwupen {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Agt2udwupen::from_bits(val as u8)
            }
            #[doc = "AGT2 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt2udwupen(&mut self, val: super::vals::Agt2udwupen) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "AGT3 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt3udwupen(&self) -> super::vals::Agt3udwupen {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Agt3udwupen::from_bits(val as u8)
            }
            #[doc = "AGT3 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt3udwupen(&mut self, val: super::vals::Agt3udwupen) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "AGT4 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt4udwupen(&self) -> super::vals::Agt4udwupen {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Agt4udwupen::from_bits(val as u8)
            }
            #[doc = "AGT4 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt4udwupen(&mut self, val: super::vals::Agt4udwupen) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "AGT5 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt5udwupen(&self) -> super::vals::Agt5udwupen {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Agt5udwupen::from_bits(val as u8)
            }
            #[doc = "AGT5 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt5udwupen(&mut self, val: super::vals::Agt5udwupen) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "AGT6 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt6udwupen(&self) -> super::vals::Agt6udwupen {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Agt6udwupen::from_bits(val as u8)
            }
            #[doc = "AGT6 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt6udwupen(&mut self, val: super::vals::Agt6udwupen) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "AGT7 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt7udwupen(&self) -> super::vals::Agt7udwupen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Agt7udwupen::from_bits(val as u8)
            }
            #[doc = "AGT7 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt7udwupen(&mut self, val: super::vals::Agt7udwupen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "SOSTD Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn sostdwupen(&self) -> super::vals::Sostdwupen {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Sostdwupen::from_bits(val as u8)
            }
            #[doc = "SOSTD Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_sostdwupen(&mut self, val: super::vals::Sostdwupen) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Wupen1 {
            #[inline(always)]
            fn default() -> Wupen1 {
                Wupen1(0)
            }
        }
        impl core::fmt::Debug for Wupen1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wupen1")
                    .field("agt0udwupen", &self.agt0udwupen())
                    .field("agt1udwupen", &self.agt1udwupen())
                    .field("agt2udwupen", &self.agt2udwupen())
                    .field("agt3udwupen", &self.agt3udwupen())
                    .field("agt4udwupen", &self.agt4udwupen())
                    .field("agt5udwupen", &self.agt5udwupen())
                    .field("agt6udwupen", &self.agt6udwupen())
                    .field("agt7udwupen", &self.agt7udwupen())
                    .field("sostdwupen", &self.sostdwupen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wupen1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Wupen1 {{ agt0udwupen: {:?}, agt1udwupen: {:?}, agt2udwupen: {:?}, agt3udwupen: {:?}, agt4udwupen: {:?}, agt5udwupen: {:?}, agt6udwupen: {:?}, agt7udwupen: {:?}, sostdwupen: {:?} }}" , self . agt0udwupen () , self . agt1udwupen () , self . agt2udwupen () , self . agt3udwupen () , self . agt4udwupen () , self . agt5udwupen () , self . agt6udwupen () , self . agt7udwupen () , self . sostdwupen ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt0udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt0udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt0udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt0udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt0udwupen {
                Agt0udwupen::from_bits(val)
            }
        }
        impl From<Agt0udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt0udwupen) -> u8 {
                Agt0udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt1udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt1udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt1udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt1udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt1udwupen {
                Agt1udwupen::from_bits(val)
            }
        }
        impl From<Agt1udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt1udwupen) -> u8 {
                Agt1udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt2udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt2udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt2udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt2udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt2udwupen {
                Agt2udwupen::from_bits(val)
            }
        }
        impl From<Agt2udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt2udwupen) -> u8 {
                Agt2udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt3udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt3udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt3udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt3udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt3udwupen {
                Agt3udwupen::from_bits(val)
            }
        }
        impl From<Agt3udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt3udwupen) -> u8 {
                Agt3udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt4udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt4udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt4udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt4udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt4udwupen {
                Agt4udwupen::from_bits(val)
            }
        }
        impl From<Agt4udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt4udwupen) -> u8 {
                Agt4udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt5udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt5udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt5udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt5udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt5udwupen {
                Agt5udwupen::from_bits(val)
            }
        }
        impl From<Agt5udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt5udwupen) -> u8 {
                Agt5udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt6udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt6udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt6udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt6udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt6udwupen {
                Agt6udwupen::from_bits(val)
            }
        }
        impl From<Agt6udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt6udwupen) -> u8 {
                Agt6udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt7udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt7udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt7udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt7udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt7udwupen {
                Agt7udwupen::from_bits(val)
            }
        }
        impl From<Agt7udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt7udwupen) -> u8 {
                Agt7udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agtw0udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agtw0udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agtw0udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agtw0udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agtw0udwupen {
                Agtw0udwupen::from_bits(val)
            }
        }
        impl From<Agtw0udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agtw0udwupen) -> u8 {
                Agtw0udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agtw1cawupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agtw1cawupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agtw1cawupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agtw1cawupen {
            #[inline(always)]
            fn from(val: u8) -> Agtw1cawupen {
                Agtw1cawupen::from_bits(val)
            }
        }
        impl From<Agtw1cawupen> for u8 {
            #[inline(always)]
            fn from(val: Agtw1cawupen) -> u8 {
                Agtw1cawupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agtw1cbwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agtw1cbwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agtw1cbwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agtw1cbwupen {
            #[inline(always)]
            fn from(val: u8) -> Agtw1cbwupen {
                Agtw1cbwupen::from_bits(val)
            }
        }
        impl From<Agtw1cbwupen> for u8 {
            #[inline(always)]
            fn from(val: Agtw1cbwupen) -> u8 {
                Agtw1cbwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agtw1udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agtw1udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agtw1udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agtw1udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agtw1udwupen {
                Agtw1udwupen::from_bits(val)
            }
        }
        impl From<Agtw1udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agtw1udwupen) -> u8 {
                Agtw1udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmclr {
            #[inline(always)]
            fn from(val: u8) -> Busmclr {
                Busmclr::from_bits(val)
            }
        }
        impl From<Busmclr> for u8 {
            #[inline(always)]
            fn from(val: Busmclr) -> u8 {
                Busmclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmen {
            #[inline(always)]
            fn from(val: u8) -> Busmen {
                Busmen::from_bits(val)
            }
        }
        impl From<Busmen> for u8 {
            #[inline(always)]
            fn from(val: Busmen) -> u8 {
                Busmen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmst {
            #[inline(always)]
            fn from(val: u8) -> Busmst {
                Busmst::from_bits(val)
            }
        }
        impl From<Busmst> for u8 {
            #[inline(always)]
            fn from(val: Busmst) -> u8 {
                Busmst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussclr {
            #[inline(always)]
            fn from(val: u8) -> Bussclr {
                Bussclr::from_bits(val)
            }
        }
        impl From<Bussclr> for u8 {
            #[inline(always)]
            fn from(val: Bussclr) -> u8 {
                Bussclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussen {
            #[inline(always)]
            fn from(val: u8) -> Bussen {
                Bussen::from_bits(val)
            }
        }
        impl From<Bussen> for u8 {
            #[inline(always)]
            fn from(val: Bussen) -> u8 {
                Bussen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussst {
            #[inline(always)]
            fn from(val: u8) -> Bussst {
                Bussst::from_bits(val)
            }
        }
        impl From<Bussst> for u8 {
            #[inline(always)]
            fn from(val: Bussst) -> u8 {
                Bussst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fclksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Fclksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fclksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fclksel {
            #[inline(always)]
            fn from(val: u8) -> Fclksel {
                Fclksel::from_bits(val)
            }
        }
        impl From<Fclksel> for u8 {
            #[inline(always)]
            fn from(val: Fclksel) -> u8 {
                Fclksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Flten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flten {
            #[inline(always)]
            fn from(val: u8) -> Flten {
                Flten::from_bits(val)
            }
        }
        impl From<Flten> for u8 {
            #[inline(always)]
            fn from(val: Flten) -> u8 {
                Flten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ielen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ielen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ielen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ielen {
            #[inline(always)]
            fn from(val: u8) -> Ielen {
                Ielen::from_bits(val)
            }
        }
        impl From<Ielen> for u8 {
            #[inline(always)]
            fn from(val: Ielen) -> u8 {
                Ielen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iic0wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iic0wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iic0wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iic0wupen {
            #[inline(always)]
            fn from(val: u8) -> Iic0wupen {
                Iic0wupen::from_bits(val)
            }
        }
        impl From<Iic0wupen> for u8 {
            #[inline(always)]
            fn from(val: Iic0wupen) -> u8 {
                Iic0wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Irqmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqmd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqmd {
            #[inline(always)]
            fn from(val: u8) -> Irqmd {
                Irqmd::from_bits(val)
            }
        }
        impl From<Irqmd> for u8 {
            #[inline(always)]
            fn from(val: Irqmd) -> u8 {
                Irqmd::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Irqwupen(u16);
        impl Irqwupen {}
        impl Irqwupen {
            pub const fn from_bits(val: u16) -> Irqwupen {
                Self(val & 0x0fff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Irqwupen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Irqwupen {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Irqwupen {
            #[inline(always)]
            fn from(val: u16) -> Irqwupen {
                Irqwupen::from_bits(val)
            }
        }
        impl From<Irqwupen> for u16 {
            #[inline(always)]
            fn from(val: Irqwupen) -> u16 {
                Irqwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtclr {
            #[inline(always)]
            fn from(val: u8) -> Iwdtclr {
                Iwdtclr::from_bits(val)
            }
        }
        impl From<Iwdtclr> for u8 {
            #[inline(always)]
            fn from(val: Iwdtclr) -> u8 {
                Iwdtclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdten {
            #[inline(always)]
            fn from(val: u8) -> Iwdten {
                Iwdten::from_bits(val)
            }
        }
        impl From<Iwdten> for u8 {
            #[inline(always)]
            fn from(val: Iwdten) -> u8 {
                Iwdten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtst {
            #[inline(always)]
            fn from(val: u8) -> Iwdtst {
                Iwdtst::from_bits(val)
            }
        }
        impl From<Iwdtst> for u8 {
            #[inline(always)]
            fn from(val: Iwdtst) -> u8 {
                Iwdtst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtwupen {
            #[inline(always)]
            fn from(val: u8) -> Iwdtwupen {
                Iwdtwupen::from_bits(val)
            }
        }
        impl From<Iwdtwupen> for u8 {
            #[inline(always)]
            fn from(val: Iwdtwupen) -> u8 {
                Iwdtwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1clr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1clr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1clr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1clr {
            #[inline(always)]
            fn from(val: u8) -> Lvd1clr {
                Lvd1clr::from_bits(val)
            }
        }
        impl From<Lvd1clr> for u8 {
            #[inline(always)]
            fn from(val: Lvd1clr) -> u8 {
                Lvd1clr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1en {
            #[inline(always)]
            fn from(val: u8) -> Lvd1en {
                Lvd1en::from_bits(val)
            }
        }
        impl From<Lvd1en> for u8 {
            #[inline(always)]
            fn from(val: Lvd1en) -> u8 {
                Lvd1en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1st {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1st {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1st {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1st {
            #[inline(always)]
            fn from(val: u8) -> Lvd1st {
                Lvd1st::from_bits(val)
            }
        }
        impl From<Lvd1st> for u8 {
            #[inline(always)]
            fn from(val: Lvd1st) -> u8 {
                Lvd1st::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1wupen {
            #[inline(always)]
            fn from(val: u8) -> Lvd1wupen {
                Lvd1wupen::from_bits(val)
            }
        }
        impl From<Lvd1wupen> for u8 {
            #[inline(always)]
            fn from(val: Lvd1wupen) -> u8 {
                Lvd1wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2clr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2clr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2clr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2clr {
            #[inline(always)]
            fn from(val: u8) -> Lvd2clr {
                Lvd2clr::from_bits(val)
            }
        }
        impl From<Lvd2clr> for u8 {
            #[inline(always)]
            fn from(val: Lvd2clr) -> u8 {
                Lvd2clr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2en {
            #[inline(always)]
            fn from(val: u8) -> Lvd2en {
                Lvd2en::from_bits(val)
            }
        }
        impl From<Lvd2en> for u8 {
            #[inline(always)]
            fn from(val: Lvd2en) -> u8 {
                Lvd2en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2st {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2st {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2st {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2st {
            #[inline(always)]
            fn from(val: u8) -> Lvd2st {
                Lvd2st::from_bits(val)
            }
        }
        impl From<Lvd2st> for u8 {
            #[inline(always)]
            fn from(val: Lvd2st) -> u8 {
                Lvd2st::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2wupen {
            #[inline(always)]
            fn from(val: u8) -> Lvd2wupen {
                Lvd2wupen::from_bits(val)
            }
        }
        impl From<Lvd2wupen> for u8 {
            #[inline(always)]
            fn from(val: Lvd2wupen) -> u8 {
                Lvd2wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvdexlvdwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvdexlvdwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvdexlvdwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvdexlvdwupen {
            #[inline(always)]
            fn from(val: u8) -> Lvdexlvdwupen {
                Lvdexlvdwupen::from_bits(val)
            }
        }
        impl From<Lvdexlvdwupen> for u8 {
            #[inline(always)]
            fn from(val: Lvdexlvdwupen) -> u8 {
                Lvdexlvdwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvdvbatwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvdvbatwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvdvbatwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvdvbatwupen {
            #[inline(always)]
            fn from(val: u8) -> Lvdvbatwupen {
                Lvdvbatwupen::from_bits(val)
            }
        }
        impl From<Lvdvbatwupen> for u8 {
            #[inline(always)]
            fn from(val: Lvdvbatwupen) -> u8 {
                Lvdvbatwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvdvrtcwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvdvrtcwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvdvrtcwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvdvrtcwupen {
            #[inline(always)]
            fn from(val: u8) -> Lvdvrtcwupen {
                Lvdvrtcwupen::from_bits(val)
            }
        }
        impl From<Lvdvrtcwupen> for u8 {
            #[inline(always)]
            fn from(val: Lvdvrtcwupen) -> u8 {
                Lvdvrtcwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfclksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfclksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfclksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfclksel {
            #[inline(always)]
            fn from(val: u8) -> Nfclksel {
                Nfclksel::from_bits(val)
            }
        }
        impl From<Nfclksel> for u8 {
            #[inline(always)]
            fn from(val: Nfclksel) -> u8 {
                Nfclksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nflten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nflten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nflten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nflten {
            #[inline(always)]
            fn from(val: u8) -> Nflten {
                Nflten::from_bits(val)
            }
        }
        impl From<Nflten> for u8 {
            #[inline(always)]
            fn from(val: Nflten) -> u8 {
                Nflten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmiclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmiclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmiclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmiclr {
            #[inline(always)]
            fn from(val: u8) -> Nmiclr {
                Nmiclr::from_bits(val)
            }
        }
        impl From<Nmiclr> for u8 {
            #[inline(always)]
            fn from(val: Nmiclr) -> u8 {
                Nmiclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmien {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmien {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmien {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmien {
            #[inline(always)]
            fn from(val: u8) -> Nmien {
                Nmien::from_bits(val)
            }
        }
        impl From<Nmien> for u8 {
            #[inline(always)]
            fn from(val: Nmien) -> u8 {
                Nmien::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmimd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmimd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmimd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmimd {
            #[inline(always)]
            fn from(val: u8) -> Nmimd {
                Nmimd::from_bits(val)
            }
        }
        impl From<Nmimd> for u8 {
            #[inline(always)]
            fn from(val: Nmimd) -> u8 {
                Nmimd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmist {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmist {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmist {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmist {
            #[inline(always)]
            fn from(val: u8) -> Nmist {
                Nmist::from_bits(val)
            }
        }
        impl From<Nmist> for u8 {
            #[inline(always)]
            fn from(val: Nmist) -> u8 {
                Nmist::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostclr {
            #[inline(always)]
            fn from(val: u8) -> Ostclr {
                Ostclr::from_bits(val)
            }
        }
        impl From<Ostclr> for u8 {
            #[inline(always)]
            fn from(val: Ostclr) -> u8 {
                Ostclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Osten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Osten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Osten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Osten {
            #[inline(always)]
            fn from(val: u8) -> Osten {
                Osten::from_bits(val)
            }
        }
        impl From<Osten> for u8 {
            #[inline(always)]
            fn from(val: Osten) -> u8 {
                Osten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostst {
            #[inline(always)]
            fn from(val: u8) -> Ostst {
                Ostst::from_bits(val)
            }
        }
        impl From<Ostst> for u8 {
            #[inline(always)]
            fn from(val: Ostst) -> u8 {
                Ostst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reccclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Reccclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reccclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reccclr {
            #[inline(always)]
            fn from(val: u8) -> Reccclr {
                Reccclr::from_bits(val)
            }
        }
        impl From<Reccclr> for u8 {
            #[inline(always)]
            fn from(val: Reccclr) -> u8 {
                Reccclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reccen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Reccen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reccen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reccen {
            #[inline(always)]
            fn from(val: u8) -> Reccen {
                Reccen::from_bits(val)
            }
        }
        impl From<Reccen> for u8 {
            #[inline(always)]
            fn from(val: Reccen) -> u8 {
                Reccen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reccst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Reccst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reccst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reccst {
            #[inline(always)]
            fn from(val: u8) -> Reccst {
                Reccst::from_bits(val)
            }
        }
        impl From<Reccst> for u8 {
            #[inline(always)]
            fn from(val: Reccst) -> u8 {
                Reccst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpeclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpeclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpeclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpeclr {
            #[inline(always)]
            fn from(val: u8) -> Rpeclr {
                Rpeclr::from_bits(val)
            }
        }
        impl From<Rpeclr> for u8 {
            #[inline(always)]
            fn from(val: Rpeclr) -> u8 {
                Rpeclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpeen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpeen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpeen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpeen {
            #[inline(always)]
            fn from(val: u8) -> Rpeen {
                Rpeen::from_bits(val)
            }
        }
        impl From<Rpeen> for u8 {
            #[inline(always)]
            fn from(val: Rpeen) -> u8 {
                Rpeen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpest {
            #[inline(always)]
            fn from(val: u8) -> Rpest {
                Rpest::from_bits(val)
            }
        }
        impl From<Rpest> for u8 {
            #[inline(always)]
            fn from(val: Rpest) -> u8 {
                Rpest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcalm0wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcalm0wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcalm0wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcalm0wupen {
            #[inline(always)]
            fn from(val: u8) -> Rtcalm0wupen {
                Rtcalm0wupen::from_bits(val)
            }
        }
        impl From<Rtcalm0wupen> for u8 {
            #[inline(always)]
            fn from(val: Rtcalm0wupen) -> u8 {
                Rtcalm0wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcalm1wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcalm1wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcalm1wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcalm1wupen {
            #[inline(always)]
            fn from(val: u8) -> Rtcalm1wupen {
                Rtcalm1wupen::from_bits(val)
            }
        }
        impl From<Rtcalm1wupen> for u8 {
            #[inline(always)]
            fn from(val: Rtcalm1wupen) -> u8 {
                Rtcalm1wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcinten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcinten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcinten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcinten {
            #[inline(always)]
            fn from(val: u8) -> Rtcinten {
                Rtcinten::from_bits(val)
            }
        }
        impl From<Rtcinten> for u8 {
            #[inline(always)]
            fn from(val: Rtcinten) -> u8 {
                Rtcinten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcprdwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcprdwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcprdwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcprdwupen {
            #[inline(always)]
            fn from(val: u8) -> Rtcprdwupen {
                Rtcprdwupen::from_bits(val)
            }
        }
        impl From<Rtcprdwupen> for u8 {
            #[inline(always)]
            fn from(val: Rtcprdwupen) -> u8 {
                Rtcprdwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sostdwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sostdwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sostdwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sostdwupen {
            #[inline(always)]
            fn from(val: u8) -> Sostdwupen {
                Sostdwupen::from_bits(val)
            }
        }
        impl From<Sostdwupen> for u8 {
            #[inline(always)]
            fn from(val: Sostdwupen) -> u8 {
                Sostdwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Speclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Speclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Speclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Speclr {
            #[inline(always)]
            fn from(val: u8) -> Speclr {
                Speclr::from_bits(val)
            }
        }
        impl From<Speclr> for u8 {
            #[inline(always)]
            fn from(val: Speclr) -> u8 {
                Speclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Speen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Speen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Speen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Speen {
            #[inline(always)]
            fn from(val: u8) -> Speen {
                Speen::from_bits(val)
            }
        }
        impl From<Speen> for u8 {
            #[inline(always)]
            fn from(val: Speen) -> u8 {
                Speen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spest {
            #[inline(always)]
            fn from(val: u8) -> Spest {
                Spest::from_bits(val)
            }
        }
        impl From<Spest> for u8 {
            #[inline(always)]
            fn from(val: Spest) -> u8 {
                Spest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtclr {
            #[inline(always)]
            fn from(val: u8) -> Wdtclr {
                Wdtclr::from_bits(val)
            }
        }
        impl From<Wdtclr> for u8 {
            #[inline(always)]
            fn from(val: Wdtclr) -> u8 {
                Wdtclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdten {
            #[inline(always)]
            fn from(val: u8) -> Wdten {
                Wdten::from_bits(val)
            }
        }
        impl From<Wdten> for u8 {
            #[inline(always)]
            fn from(val: Wdten) -> u8 {
                Wdten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtst {
            #[inline(always)]
            fn from(val: u8) -> Wdtst {
                Wdtst::from_bits(val)
            }
        }
        impl From<Wdtst> for u8 {
            #[inline(always)]
            fn from(val: Wdtst) -> u8 {
                Wdtst::to_bits(val)
            }
        }
    }
}
pub mod iic0 {
    #[doc = "Inter,Integrated Circuit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iic0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Iic0 {}
    unsafe impl Sync for Iic0 {}
    impl Iic0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "I2C Bus Control Register 1"]
        #[inline(always)]
        pub const fn iccr1(self) -> crate::common::Reg<regs::Iccr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "I2C Bus Control Register 2"]
        #[inline(always)]
        pub const fn iccr2(self) -> crate::common::Reg<regs::Iccr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "I2C Bus Mode Register 1"]
        #[inline(always)]
        pub const fn icmr1(self) -> crate::common::Reg<regs::Icmr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "I2C Bus Mode Register 2"]
        #[inline(always)]
        pub const fn icmr2(self) -> crate::common::Reg<regs::Icmr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "I2C Bus Mode Register 3"]
        #[inline(always)]
        pub const fn icmr3(self) -> crate::common::Reg<regs::Icmr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "I2C Bus Function Enable Register"]
        #[inline(always)]
        pub const fn icfer(self) -> crate::common::Reg<regs::Icfer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "I2C Bus Status Enable Register"]
        #[inline(always)]
        pub const fn icser(self) -> crate::common::Reg<regs::Icser, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "I2C Bus Interrupt Enable Register"]
        #[inline(always)]
        pub const fn icier(self) -> crate::common::Reg<regs::Icier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "I2C Bus Status Register 1"]
        #[inline(always)]
        pub const fn icsr1(self) -> crate::common::Reg<regs::Icsr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "I2C Bus Status Register 2"]
        #[inline(always)]
        pub const fn icsr2(self) -> crate::common::Reg<regs::Icsr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "Slave Address Register Ly"]
        #[inline(always)]
        pub const fn sarl(self, n: usize) -> crate::common::Reg<regs::Sarl, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize + n * 2usize) as _) }
        }
        #[doc = "Slave Address Register Uy"]
        #[inline(always)]
        pub const fn saru(self, n: usize) -> crate::common::Reg<regs::Saru, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize + n * 2usize) as _) }
        }
        #[doc = "I2C Bus Bit Rate Low,Level Register"]
        #[inline(always)]
        pub const fn icbrl(self) -> crate::common::Reg<regs::Icbrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "I2C Bus Bit Rate High,Level Register"]
        #[inline(always)]
        pub const fn icbrh(self) -> crate::common::Reg<regs::Icbrh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
        #[doc = "I2C Bus Transmit Data Register"]
        #[inline(always)]
        pub const fn icdrt(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "I2C Bus Receive Data Register"]
        #[inline(always)]
        pub const fn icdrr(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "I2C Bus Bit Rate High,Level Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icbrh(pub u8);
        impl Icbrh {
            #[doc = "Bit Rate High,Level Period"]
            #[inline(always)]
            pub const fn brh(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Bit Rate High,Level Period"]
            #[inline(always)]
            pub fn set_brh(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
        }
        impl Default for Icbrh {
            #[inline(always)]
            fn default() -> Icbrh {
                Icbrh(0)
            }
        }
        impl core::fmt::Debug for Icbrh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icbrh").field("brh", &self.brh()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icbrh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Icbrh {{ brh: {=u8:?} }}", self.brh())
            }
        }
        #[doc = "I2C Bus Bit Rate Low,Level Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icbrl(pub u8);
        impl Icbrl {
            #[doc = "Bit Rate Low,Level Period"]
            #[inline(always)]
            pub const fn brl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Bit Rate Low,Level Period"]
            #[inline(always)]
            pub fn set_brl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u8) & 0x1f) << 0usize);
            }
        }
        impl Default for Icbrl {
            #[inline(always)]
            fn default() -> Icbrl {
                Icbrl(0)
            }
        }
        impl core::fmt::Debug for Icbrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icbrl").field("brl", &self.brl()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icbrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Icbrl {{ brl: {=u8:?} }}", self.brl())
            }
        }
        #[doc = "I2C Bus Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iccr1(pub u8);
        impl Iccr1 {
            #[doc = "SDA Line Monitor"]
            #[inline(always)]
            pub const fn sdai(&self) -> super::vals::Sdai {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sdai::from_bits(val as u8)
            }
            #[doc = "SDA Line Monitor"]
            #[inline(always)]
            pub fn set_sdai(&mut self, val: super::vals::Sdai) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SCL Line Monitor"]
            #[inline(always)]
            pub const fn scli(&self) -> super::vals::Scli {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Scli::from_bits(val as u8)
            }
            #[doc = "SCL Line Monitor"]
            #[inline(always)]
            pub fn set_scli(&mut self, val: super::vals::Scli) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "SDA Output Control/Monitor"]
            #[inline(always)]
            pub const fn sdao(&self) -> super::vals::Sdao {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sdao::from_bits(val as u8)
            }
            #[doc = "SDA Output Control/Monitor"]
            #[inline(always)]
            pub fn set_sdao(&mut self, val: super::vals::Sdao) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "SCL Output Control/Monitor"]
            #[inline(always)]
            pub const fn sclo(&self) -> super::vals::Sclo {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sclo::from_bits(val as u8)
            }
            #[doc = "SCL Output Control/Monitor"]
            #[inline(always)]
            pub fn set_sclo(&mut self, val: super::vals::Sclo) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SCLO/SDAO Write Protect"]
            #[inline(always)]
            pub const fn sowp(&self) -> super::vals::Sowp {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sowp::from_bits(val as u8)
            }
            #[doc = "SCLO/SDAO Write Protect"]
            #[inline(always)]
            pub fn set_sowp(&mut self, val: super::vals::Sowp) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Extra SCL Clock Cycle Output"]
            #[inline(always)]
            pub const fn clo(&self) -> super::vals::Clo {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Clo::from_bits(val as u8)
            }
            #[doc = "Extra SCL Clock Cycle Output"]
            #[inline(always)]
            pub fn set_clo(&mut self, val: super::vals::Clo) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "I2C Bus Interface Internal Reset"]
            #[inline(always)]
            pub const fn iicrst(&self) -> super::vals::Iicrst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Iicrst::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface Internal Reset"]
            #[inline(always)]
            pub fn set_iicrst(&mut self, val: super::vals::Iicrst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "I2C Bus Interface Enable"]
            #[inline(always)]
            pub const fn ice(&self) -> super::vals::Ice {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ice::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface Enable"]
            #[inline(always)]
            pub fn set_ice(&mut self, val: super::vals::Ice) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iccr1 {
            #[inline(always)]
            fn default() -> Iccr1 {
                Iccr1(0)
            }
        }
        impl core::fmt::Debug for Iccr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iccr1")
                    .field("sdai", &self.sdai())
                    .field("scli", &self.scli())
                    .field("sdao", &self.sdao())
                    .field("sclo", &self.sclo())
                    .field("sowp", &self.sowp())
                    .field("clo", &self.clo())
                    .field("iicrst", &self.iicrst())
                    .field("ice", &self.ice())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iccr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Iccr1 {{ sdai: {:?}, scli: {:?}, sdao: {:?}, sclo: {:?}, sowp: {:?}, clo: {:?}, iicrst: {:?}, ice: {:?} }}" , self . sdai () , self . scli () , self . sdao () , self . sclo () , self . sowp () , self . clo () , self . iicrst () , self . ice ())
            }
        }
        #[doc = "I2C Bus Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iccr2(pub u8);
        impl Iccr2 {
            #[doc = "Start Condition Issuance Request"]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::St {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::St::from_bits(val as u8)
            }
            #[doc = "Start Condition Issuance Request"]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::St) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Restart Condition Issuance Request"]
            #[inline(always)]
            pub const fn rs(&self) -> super::vals::Rs {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Rs::from_bits(val as u8)
            }
            #[doc = "Restart Condition Issuance Request"]
            #[inline(always)]
            pub fn set_rs(&mut self, val: super::vals::Rs) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Condition Issuance Request"]
            #[inline(always)]
            pub const fn sp(&self) -> super::vals::Sp {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sp::from_bits(val as u8)
            }
            #[doc = "Stop Condition Issuance Request"]
            #[inline(always)]
            pub fn set_sp(&mut self, val: super::vals::Sp) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Transmit/Receive Mode"]
            #[inline(always)]
            pub const fn trs(&self) -> super::vals::Trs {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Trs::from_bits(val as u8)
            }
            #[doc = "Transmit/Receive Mode"]
            #[inline(always)]
            pub fn set_trs(&mut self, val: super::vals::Trs) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Master/Slave Mode"]
            #[inline(always)]
            pub const fn mst(&self) -> super::vals::Mst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mst::from_bits(val as u8)
            }
            #[doc = "Master/Slave Mode"]
            #[inline(always)]
            pub fn set_mst(&mut self, val: super::vals::Mst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Bus Busy Detection Flag"]
            #[inline(always)]
            pub const fn bbsy(&self) -> super::vals::Bbsy {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bbsy::from_bits(val as u8)
            }
            #[doc = "Bus Busy Detection Flag"]
            #[inline(always)]
            pub fn set_bbsy(&mut self, val: super::vals::Bbsy) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Iccr2 {
            #[inline(always)]
            fn default() -> Iccr2 {
                Iccr2(0)
            }
        }
        impl core::fmt::Debug for Iccr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iccr2")
                    .field("st", &self.st())
                    .field("rs", &self.rs())
                    .field("sp", &self.sp())
                    .field("trs", &self.trs())
                    .field("mst", &self.mst())
                    .field("bbsy", &self.bbsy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iccr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Iccr2 {{ st: {:?}, rs: {:?}, sp: {:?}, trs: {:?}, mst: {:?}, bbsy: {:?} }}",
                    self.st(),
                    self.rs(),
                    self.sp(),
                    self.trs(),
                    self.mst(),
                    self.bbsy()
                )
            }
        }
        #[doc = "I2C Bus Function Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icfer(pub u8);
        impl Icfer {
            #[doc = "Timeout Function Enable"]
            #[inline(always)]
            pub const fn tmoe(&self) -> super::vals::Tmoe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmoe::from_bits(val as u8)
            }
            #[doc = "Timeout Function Enable"]
            #[inline(always)]
            pub fn set_tmoe(&mut self, val: super::vals::Tmoe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Master Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn male(&self) -> super::vals::Male {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Male::from_bits(val as u8)
            }
            #[doc = "Master Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_male(&mut self, val: super::vals::Male) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "NACK Transmission Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn nale(&self) -> super::vals::Nale {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Nale::from_bits(val as u8)
            }
            #[doc = "NACK Transmission Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_nale(&mut self, val: super::vals::Nale) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Slave Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn sale(&self) -> super::vals::Sale {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sale::from_bits(val as u8)
            }
            #[doc = "Slave Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_sale(&mut self, val: super::vals::Sale) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "NACK Reception Transfer Suspension Enable"]
            #[inline(always)]
            pub const fn nacke(&self) -> super::vals::Nacke {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nacke::from_bits(val as u8)
            }
            #[doc = "NACK Reception Transfer Suspension Enable"]
            #[inline(always)]
            pub fn set_nacke(&mut self, val: super::vals::Nacke) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Digital Noise Filter Circuit Enable"]
            #[inline(always)]
            pub const fn nfe(&self) -> super::vals::Nfe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Nfe::from_bits(val as u8)
            }
            #[doc = "Digital Noise Filter Circuit Enable"]
            #[inline(always)]
            pub fn set_nfe(&mut self, val: super::vals::Nfe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SCL Synchronous Circuit Enable"]
            #[inline(always)]
            pub const fn scle(&self) -> super::vals::Scle {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Scle::from_bits(val as u8)
            }
            #[doc = "SCL Synchronous Circuit Enable"]
            #[inline(always)]
            pub fn set_scle(&mut self, val: super::vals::Scle) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Icfer {
            #[inline(always)]
            fn default() -> Icfer {
                Icfer(0)
            }
        }
        impl core::fmt::Debug for Icfer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icfer")
                    .field("tmoe", &self.tmoe())
                    .field("male", &self.male())
                    .field("nale", &self.nale())
                    .field("sale", &self.sale())
                    .field("nacke", &self.nacke())
                    .field("nfe", &self.nfe())
                    .field("scle", &self.scle())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icfer {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icfer {{ tmoe: {:?}, male: {:?}, nale: {:?}, sale: {:?}, nacke: {:?}, nfe: {:?}, scle: {:?} }}" , self . tmoe () , self . male () , self . nale () , self . sale () , self . nacke () , self . nfe () , self . scle ())
            }
        }
        #[doc = "I2C Bus Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icier(pub u8);
        impl Icier {
            #[doc = "Timeout Interrupt Request Enable"]
            #[inline(always)]
            pub const fn tmoie(&self) -> super::vals::Tmoie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmoie::from_bits(val as u8)
            }
            #[doc = "Timeout Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_tmoie(&mut self, val: super::vals::Tmoie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Arbitration,Lost Interrupt Request Enable"]
            #[inline(always)]
            pub const fn alie(&self) -> super::vals::Alie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Alie::from_bits(val as u8)
            }
            #[doc = "Arbitration,Lost Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_alie(&mut self, val: super::vals::Alie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Start Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub const fn stie(&self) -> super::vals::Stie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Stie::from_bits(val as u8)
            }
            #[doc = "Start Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_stie(&mut self, val: super::vals::Stie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub const fn spie(&self) -> super::vals::Spie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Spie::from_bits(val as u8)
            }
            #[doc = "Stop Condition Detection Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_spie(&mut self, val: super::vals::Spie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "NACK Reception Interrupt Request Enable"]
            #[inline(always)]
            pub const fn nakie(&self) -> super::vals::Nakie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nakie::from_bits(val as u8)
            }
            #[doc = "NACK Reception Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_nakie(&mut self, val: super::vals::Nakie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Receive Data Full Interrupt Request Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::Rie {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rie::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::Rie) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmit End Interrupt Request Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> super::vals::Teie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Teie::from_bits(val as u8)
            }
            #[doc = "Transmit End Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: super::vals::Teie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Interrupt Request Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::Tie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tie::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::Tie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icier {
            #[inline(always)]
            fn default() -> Icier {
                Icier(0)
            }
        }
        impl core::fmt::Debug for Icier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icier")
                    .field("tmoie", &self.tmoie())
                    .field("alie", &self.alie())
                    .field("stie", &self.stie())
                    .field("spie", &self.spie())
                    .field("nakie", &self.nakie())
                    .field("rie", &self.rie())
                    .field("teie", &self.teie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icier {{ tmoie: {:?}, alie: {:?}, stie: {:?}, spie: {:?}, nakie: {:?}, rie: {:?}, teie: {:?}, tie: {:?} }}" , self . tmoie () , self . alie () , self . stie () , self . spie () , self . nakie () , self . rie () , self . teie () , self . tie ())
            }
        }
        #[doc = "I2C Bus Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icmr1(pub u8);
        impl Icmr1 {
            #[doc = "Bit Counter"]
            #[inline(always)]
            pub const fn bc(&self) -> super::vals::Bc {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Bc::from_bits(val as u8)
            }
            #[doc = "Bit Counter"]
            #[inline(always)]
            pub fn set_bc(&mut self, val: super::vals::Bc) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "BC Write Protect"]
            #[inline(always)]
            pub const fn bcwp(&self) -> super::vals::Bcwp {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bcwp::from_bits(val as u8)
            }
            #[doc = "BC Write Protect"]
            #[inline(always)]
            pub fn set_bcwp(&mut self, val: super::vals::Bcwp) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Internal Reference Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "Internal Reference Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
            #[doc = "MST/TRS Write Protect"]
            #[inline(always)]
            pub const fn mtwp(&self) -> super::vals::Mtwp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Mtwp::from_bits(val as u8)
            }
            #[doc = "MST/TRS Write Protect"]
            #[inline(always)]
            pub fn set_mtwp(&mut self, val: super::vals::Mtwp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icmr1 {
            #[inline(always)]
            fn default() -> Icmr1 {
                Icmr1(0)
            }
        }
        impl core::fmt::Debug for Icmr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icmr1")
                    .field("bc", &self.bc())
                    .field("bcwp", &self.bcwp())
                    .field("cks", &self.cks())
                    .field("mtwp", &self.mtwp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icmr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icmr1 {{ bc: {:?}, bcwp: {:?}, cks: {=u8:?}, mtwp: {:?} }}",
                    self.bc(),
                    self.bcwp(),
                    self.cks(),
                    self.mtwp()
                )
            }
        }
        #[doc = "I2C Bus Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icmr2(pub u8);
        impl Icmr2 {
            #[doc = "Timeout Detection Time Select"]
            #[inline(always)]
            pub const fn tmos(&self) -> super::vals::Tmos {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmos::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Time Select"]
            #[inline(always)]
            pub fn set_tmos(&mut self, val: super::vals::Tmos) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Timeout L Count Control"]
            #[inline(always)]
            pub const fn tmol(&self) -> super::vals::Tmol {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tmol::from_bits(val as u8)
            }
            #[doc = "Timeout L Count Control"]
            #[inline(always)]
            pub fn set_tmol(&mut self, val: super::vals::Tmol) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Timeout H Count Control"]
            #[inline(always)]
            pub const fn tmoh(&self) -> super::vals::Tmoh {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tmoh::from_bits(val as u8)
            }
            #[doc = "Timeout H Count Control"]
            #[inline(always)]
            pub fn set_tmoh(&mut self, val: super::vals::Tmoh) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "SDA Output Delay Counter"]
            #[inline(always)]
            pub const fn sddl(&self) -> super::vals::Sddl {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Sddl::from_bits(val as u8)
            }
            #[doc = "SDA Output Delay Counter"]
            #[inline(always)]
            pub fn set_sddl(&mut self, val: super::vals::Sddl) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "SDA Output Delay Clock Source Select"]
            #[inline(always)]
            pub const fn dlcs(&self) -> super::vals::Dlcs {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dlcs::from_bits(val as u8)
            }
            #[doc = "SDA Output Delay Clock Source Select"]
            #[inline(always)]
            pub fn set_dlcs(&mut self, val: super::vals::Dlcs) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icmr2 {
            #[inline(always)]
            fn default() -> Icmr2 {
                Icmr2(0)
            }
        }
        impl core::fmt::Debug for Icmr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icmr2")
                    .field("tmos", &self.tmos())
                    .field("tmol", &self.tmol())
                    .field("tmoh", &self.tmoh())
                    .field("sddl", &self.sddl())
                    .field("dlcs", &self.dlcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icmr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icmr2 {{ tmos: {:?}, tmol: {:?}, tmoh: {:?}, sddl: {:?}, dlcs: {:?} }}",
                    self.tmos(),
                    self.tmol(),
                    self.tmoh(),
                    self.sddl(),
                    self.dlcs()
                )
            }
        }
        #[doc = "I2C Bus Mode Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icmr3(pub u8);
        impl Icmr3 {
            #[doc = "Noise Filter Stage Select"]
            #[inline(always)]
            pub const fn nf(&self) -> super::vals::Nf {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nf::from_bits(val as u8)
            }
            #[doc = "Noise Filter Stage Select"]
            #[inline(always)]
            pub fn set_nf(&mut self, val: super::vals::Nf) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Receive Acknowledge"]
            #[inline(always)]
            pub const fn ackbr(&self) -> super::vals::Ackbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ackbr::from_bits(val as u8)
            }
            #[doc = "Receive Acknowledge"]
            #[inline(always)]
            pub fn set_ackbr(&mut self, val: super::vals::Ackbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmit Acknowledge"]
            #[inline(always)]
            pub const fn ackbt(&self) -> super::vals::Ackbt {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ackbt::from_bits(val as u8)
            }
            #[doc = "Transmit Acknowledge"]
            #[inline(always)]
            pub fn set_ackbt(&mut self, val: super::vals::Ackbt) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "ACKBT Write Protect"]
            #[inline(always)]
            pub const fn ackwp(&self) -> super::vals::Ackwp {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ackwp::from_bits(val as u8)
            }
            #[doc = "ACKBT Write Protect"]
            #[inline(always)]
            pub fn set_ackwp(&mut self, val: super::vals::Ackwp) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "RDRF Flag Set Timing Select"]
            #[inline(always)]
            pub const fn rdrfs(&self) -> super::vals::Rdrfs {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rdrfs::from_bits(val as u8)
            }
            #[doc = "RDRF Flag Set Timing Select"]
            #[inline(always)]
            pub fn set_rdrfs(&mut self, val: super::vals::Rdrfs) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Low,hold is released by reading ICDRR."]
            #[inline(always)]
            pub const fn wait(&self) -> super::vals::Wait {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Wait::from_bits(val as u8)
            }
            #[doc = "Low,hold is released by reading ICDRR."]
            #[inline(always)]
            pub fn set_wait(&mut self, val: super::vals::Wait) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "SMBus/I2C Bus Select"]
            #[inline(always)]
            pub const fn smbs(&self) -> super::vals::Smbs {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Smbs::from_bits(val as u8)
            }
            #[doc = "SMBus/I2C Bus Select"]
            #[inline(always)]
            pub fn set_smbs(&mut self, val: super::vals::Smbs) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icmr3 {
            #[inline(always)]
            fn default() -> Icmr3 {
                Icmr3(0)
            }
        }
        impl core::fmt::Debug for Icmr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icmr3")
                    .field("nf", &self.nf())
                    .field("ackbr", &self.ackbr())
                    .field("ackbt", &self.ackbt())
                    .field("ackwp", &self.ackwp())
                    .field("rdrfs", &self.rdrfs())
                    .field("wait", &self.wait())
                    .field("smbs", &self.smbs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icmr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icmr3 {{ nf: {:?}, ackbr: {:?}, ackbt: {:?}, ackwp: {:?}, rdrfs: {:?}, wait: {:?}, smbs: {:?} }}" , self . nf () , self . ackbr () , self . ackbt () , self . ackwp () , self . rdrfs () , self . wait () , self . smbs ())
            }
        }
        #[doc = "I2C Bus Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icser(pub u8);
        impl Icser {
            #[doc = "Slave Address Register 0 Enable"]
            #[inline(always)]
            pub const fn sar0e(&self) -> super::vals::Sar0e {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sar0e::from_bits(val as u8)
            }
            #[doc = "Slave Address Register 0 Enable"]
            #[inline(always)]
            pub fn set_sar0e(&mut self, val: super::vals::Sar0e) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Slave Address Register 1 Enable"]
            #[inline(always)]
            pub const fn sar1e(&self) -> super::vals::Sar1e {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Sar1e::from_bits(val as u8)
            }
            #[doc = "Slave Address Register 1 Enable"]
            #[inline(always)]
            pub fn set_sar1e(&mut self, val: super::vals::Sar1e) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Slave Address Register 2 Enable"]
            #[inline(always)]
            pub const fn sar2e(&self) -> super::vals::Sar2e {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sar2e::from_bits(val as u8)
            }
            #[doc = "Slave Address Register 2 Enable"]
            #[inline(always)]
            pub fn set_sar2e(&mut self, val: super::vals::Sar2e) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "General Call Address Enable"]
            #[inline(always)]
            pub const fn gcae(&self) -> super::vals::Gcae {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Gcae::from_bits(val as u8)
            }
            #[doc = "General Call Address Enable"]
            #[inline(always)]
            pub fn set_gcae(&mut self, val: super::vals::Gcae) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Device,ID Address Detection Enable"]
            #[inline(always)]
            pub const fn dide(&self) -> super::vals::Dide {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Dide::from_bits(val as u8)
            }
            #[doc = "Device,ID Address Detection Enable"]
            #[inline(always)]
            pub fn set_dide(&mut self, val: super::vals::Dide) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Host Address Enable"]
            #[inline(always)]
            pub const fn hoae(&self) -> super::vals::Hoae {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Hoae::from_bits(val as u8)
            }
            #[doc = "Host Address Enable"]
            #[inline(always)]
            pub fn set_hoae(&mut self, val: super::vals::Hoae) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icser {
            #[inline(always)]
            fn default() -> Icser {
                Icser(0)
            }
        }
        impl core::fmt::Debug for Icser {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icser")
                    .field("sar0e", &self.sar0e())
                    .field("sar1e", &self.sar1e())
                    .field("sar2e", &self.sar2e())
                    .field("gcae", &self.gcae())
                    .field("dide", &self.dide())
                    .field("hoae", &self.hoae())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icser {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icser {{ sar0e: {:?}, sar1e: {:?}, sar2e: {:?}, gcae: {:?}, dide: {:?}, hoae: {:?} }}" , self . sar0e () , self . sar1e () , self . sar2e () , self . gcae () , self . dide () , self . hoae ())
            }
        }
        #[doc = "I2C Bus Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icsr1(pub u8);
        impl Icsr1 {
            #[doc = "Slave Address 0 Detection Flag"]
            #[inline(always)]
            pub const fn aas0(&self) -> super::vals::Aas0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Aas0::from_bits(val as u8)
            }
            #[doc = "Slave Address 0 Detection Flag"]
            #[inline(always)]
            pub fn set_aas0(&mut self, val: super::vals::Aas0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Slave Address 1 Detection Flag"]
            #[inline(always)]
            pub const fn aas1(&self) -> super::vals::Aas1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Aas1::from_bits(val as u8)
            }
            #[doc = "Slave Address 1 Detection Flag"]
            #[inline(always)]
            pub fn set_aas1(&mut self, val: super::vals::Aas1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Slave Address 2 Detection Flag"]
            #[inline(always)]
            pub const fn aas2(&self) -> super::vals::Aas2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Aas2::from_bits(val as u8)
            }
            #[doc = "Slave Address 2 Detection Flag"]
            #[inline(always)]
            pub fn set_aas2(&mut self, val: super::vals::Aas2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "General Call Address Detection Flag"]
            #[inline(always)]
            pub const fn gca(&self) -> super::vals::Gca {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Gca::from_bits(val as u8)
            }
            #[doc = "General Call Address Detection Flag"]
            #[inline(always)]
            pub fn set_gca(&mut self, val: super::vals::Gca) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Device,ID Address Detection Flag"]
            #[inline(always)]
            pub const fn did(&self) -> super::vals::Did {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Did::from_bits(val as u8)
            }
            #[doc = "Device,ID Address Detection Flag"]
            #[inline(always)]
            pub fn set_did(&mut self, val: super::vals::Did) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Host Address Detection Flag"]
            #[inline(always)]
            pub const fn hoa(&self) -> super::vals::Hoa {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Hoa::from_bits(val as u8)
            }
            #[doc = "Host Address Detection Flag"]
            #[inline(always)]
            pub fn set_hoa(&mut self, val: super::vals::Hoa) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icsr1 {
            #[inline(always)]
            fn default() -> Icsr1 {
                Icsr1(0)
            }
        }
        impl core::fmt::Debug for Icsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icsr1")
                    .field("aas0", &self.aas0())
                    .field("aas1", &self.aas1())
                    .field("aas2", &self.aas2())
                    .field("gca", &self.gca())
                    .field("did", &self.did())
                    .field("hoa", &self.hoa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icsr1 {{ aas0: {:?}, aas1: {:?}, aas2: {:?}, gca: {:?}, did: {:?}, hoa: {:?} }}" , self . aas0 () , self . aas1 () , self . aas2 () , self . gca () , self . did () , self . hoa ())
            }
        }
        #[doc = "I2C Bus Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icsr2(pub u8);
        impl Icsr2 {
            #[doc = "Timeout Detection Flag"]
            #[inline(always)]
            pub const fn tmof(&self) -> super::vals::Tmof {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tmof::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Flag"]
            #[inline(always)]
            pub fn set_tmof(&mut self, val: super::vals::Tmof) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Arbitration,Lost Flag"]
            #[inline(always)]
            pub const fn al(&self) -> super::vals::Al {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Al::from_bits(val as u8)
            }
            #[doc = "Arbitration,Lost Flag"]
            #[inline(always)]
            pub fn set_al(&mut self, val: super::vals::Al) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Start Condition Detection Flag"]
            #[inline(always)]
            pub const fn start(&self) -> super::vals::Start {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Start::from_bits(val as u8)
            }
            #[doc = "Start Condition Detection Flag"]
            #[inline(always)]
            pub fn set_start(&mut self, val: super::vals::Start) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Condition Detection Flag"]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::Stop {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Stop::from_bits(val as u8)
            }
            #[doc = "Stop Condition Detection Flag"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: super::vals::Stop) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "NACK Detection Flag"]
            #[inline(always)]
            pub const fn nackf(&self) -> super::vals::Nackf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nackf::from_bits(val as u8)
            }
            #[doc = "NACK Detection Flag"]
            #[inline(always)]
            pub fn set_nackf(&mut self, val: super::vals::Nackf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::Rdrf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::Rdrf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::Tend {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::Tend) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::Tdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::Tdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icsr2 {
            #[inline(always)]
            fn default() -> Icsr2 {
                Icsr2(0)
            }
        }
        impl core::fmt::Debug for Icsr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icsr2")
                    .field("tmof", &self.tmof())
                    .field("al", &self.al())
                    .field("start", &self.start())
                    .field("stop", &self.stop())
                    .field("nackf", &self.nackf())
                    .field("rdrf", &self.rdrf())
                    .field("tend", &self.tend())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icsr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icsr2 {{ tmof: {:?}, al: {:?}, start: {:?}, stop: {:?}, nackf: {:?}, rdrf: {:?}, tend: {:?}, tdre: {:?} }}" , self . tmof () , self . al () , self . start () , self . stop () , self . nackf () , self . rdrf () , self . tend () , self . tdre ())
            }
        }
        #[doc = "Slave Address Register Ly"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sarl(pub u8);
        impl Sarl {
            #[doc = "10-bit Address LSB"]
            #[inline(always)]
            pub const fn sva0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "10-bit Address LSB"]
            #[inline(always)]
            pub fn set_sva0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "7-bit Address/10-bit Address Lower Bits"]
            #[inline(always)]
            pub const fn sva(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "7-bit Address/10-bit Address Lower Bits"]
            #[inline(always)]
            pub fn set_sva(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Sarl {
            #[inline(always)]
            fn default() -> Sarl {
                Sarl(0)
            }
        }
        impl core::fmt::Debug for Sarl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sarl")
                    .field("sva0", &self.sva0())
                    .field("sva", &self.sva())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sarl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sarl {{ sva0: {=bool:?}, sva: {=u8:?} }}",
                    self.sva0(),
                    self.sva()
                )
            }
        }
        #[doc = "Slave Address Register Uy"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Saru(pub u8);
        impl Saru {
            #[doc = "7-bit/10-bit Address Format Select"]
            #[inline(always)]
            pub const fn fs(&self) -> super::vals::Fs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fs::from_bits(val as u8)
            }
            #[doc = "7-bit/10-bit Address Format Select"]
            #[inline(always)]
            pub fn set_fs(&mut self, val: super::vals::Fs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "10-bit Address Upper Bits"]
            #[inline(always)]
            pub const fn sva(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "10-bit Address Upper Bits"]
            #[inline(always)]
            pub fn set_sva(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u8) & 0x03) << 1usize);
            }
        }
        impl Default for Saru {
            #[inline(always)]
            fn default() -> Saru {
                Saru(0)
            }
        }
        impl core::fmt::Debug for Saru {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Saru")
                    .field("fs", &self.fs())
                    .field("sva", &self.sva())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Saru {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Saru {{ fs: {:?}, sva: {=u8:?} }}",
                    self.fs(),
                    self.sva()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aas0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aas0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aas0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aas0 {
            #[inline(always)]
            fn from(val: u8) -> Aas0 {
                Aas0::from_bits(val)
            }
        }
        impl From<Aas0> for u8 {
            #[inline(always)]
            fn from(val: Aas0) -> u8 {
                Aas0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aas1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aas1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aas1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aas1 {
            #[inline(always)]
            fn from(val: u8) -> Aas1 {
                Aas1::from_bits(val)
            }
        }
        impl From<Aas1> for u8 {
            #[inline(always)]
            fn from(val: Aas1) -> u8 {
                Aas1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aas2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aas2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aas2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aas2 {
            #[inline(always)]
            fn from(val: u8) -> Aas2 {
                Aas2::from_bits(val)
            }
        }
        impl From<Aas2> for u8 {
            #[inline(always)]
            fn from(val: Aas2) -> u8 {
                Aas2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackbr {
            #[inline(always)]
            fn from(val: u8) -> Ackbr {
                Ackbr::from_bits(val)
            }
        }
        impl From<Ackbr> for u8 {
            #[inline(always)]
            fn from(val: Ackbr) -> u8 {
                Ackbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackbt {
            #[inline(always)]
            fn from(val: u8) -> Ackbt {
                Ackbt::from_bits(val)
            }
        }
        impl From<Ackbt> for u8 {
            #[inline(always)]
            fn from(val: Ackbt) -> u8 {
                Ackbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackwp {
            #[inline(always)]
            fn from(val: u8) -> Ackwp {
                Ackwp::from_bits(val)
            }
        }
        impl From<Ackwp> for u8 {
            #[inline(always)]
            fn from(val: Ackwp) -> u8 {
                Ackwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Al {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Al {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Al {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Al {
            #[inline(always)]
            fn from(val: u8) -> Al {
                Al::from_bits(val)
            }
        }
        impl From<Al> for u8 {
            #[inline(always)]
            fn from(val: Al) -> u8 {
                Al::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Alie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Alie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Alie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Alie {
            #[inline(always)]
            fn from(val: u8) -> Alie {
                Alie::from_bits(val)
            }
        }
        impl From<Alie> for u8 {
            #[inline(always)]
            fn from(val: Alie) -> u8 {
                Alie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bbsy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bbsy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bbsy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bbsy {
            #[inline(always)]
            fn from(val: u8) -> Bbsy {
                Bbsy::from_bits(val)
            }
        }
        impl From<Bbsy> for u8 {
            #[inline(always)]
            fn from(val: Bbsy) -> u8 {
                Bbsy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Bc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bc {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bc {
            #[inline(always)]
            fn from(val: u8) -> Bc {
                Bc::from_bits(val)
            }
        }
        impl From<Bc> for u8 {
            #[inline(always)]
            fn from(val: Bc) -> u8 {
                Bc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bcwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcwp {
            #[inline(always)]
            fn from(val: u8) -> Bcwp {
                Bcwp::from_bits(val)
            }
        }
        impl From<Bcwp> for u8 {
            #[inline(always)]
            fn from(val: Bcwp) -> u8 {
                Bcwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Clo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clo {
            #[inline(always)]
            fn from(val: u8) -> Clo {
                Clo::from_bits(val)
            }
        }
        impl From<Clo> for u8 {
            #[inline(always)]
            fn from(val: Clo) -> u8 {
                Clo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Did {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Did {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Did {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Did {
            #[inline(always)]
            fn from(val: u8) -> Did {
                Did::from_bits(val)
            }
        }
        impl From<Did> for u8 {
            #[inline(always)]
            fn from(val: Did) -> u8 {
                Did::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dide {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dide {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dide {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dide {
            #[inline(always)]
            fn from(val: u8) -> Dide {
                Dide::from_bits(val)
            }
        }
        impl From<Dide> for u8 {
            #[inline(always)]
            fn from(val: Dide) -> u8 {
                Dide::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dlcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dlcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dlcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dlcs {
            #[inline(always)]
            fn from(val: u8) -> Dlcs {
                Dlcs::from_bits(val)
            }
        }
        impl From<Dlcs> for u8 {
            #[inline(always)]
            fn from(val: Dlcs) -> u8 {
                Dlcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fs {
            #[inline(always)]
            fn from(val: u8) -> Fs {
                Fs::from_bits(val)
            }
        }
        impl From<Fs> for u8 {
            #[inline(always)]
            fn from(val: Fs) -> u8 {
                Fs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gca {
            #[inline(always)]
            fn from(val: u8) -> Gca {
                Gca::from_bits(val)
            }
        }
        impl From<Gca> for u8 {
            #[inline(always)]
            fn from(val: Gca) -> u8 {
                Gca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gcae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gcae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gcae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gcae {
            #[inline(always)]
            fn from(val: u8) -> Gcae {
                Gcae::from_bits(val)
            }
        }
        impl From<Gcae> for u8 {
            #[inline(always)]
            fn from(val: Gcae) -> u8 {
                Gcae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hoa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hoa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hoa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hoa {
            #[inline(always)]
            fn from(val: u8) -> Hoa {
                Hoa::from_bits(val)
            }
        }
        impl From<Hoa> for u8 {
            #[inline(always)]
            fn from(val: Hoa) -> u8 {
                Hoa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hoae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hoae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hoae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hoae {
            #[inline(always)]
            fn from(val: u8) -> Hoae {
                Hoae::from_bits(val)
            }
        }
        impl From<Hoae> for u8 {
            #[inline(always)]
            fn from(val: Hoae) -> u8 {
                Hoae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ice {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ice {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ice {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ice {
            #[inline(always)]
            fn from(val: u8) -> Ice {
                Ice::from_bits(val)
            }
        }
        impl From<Ice> for u8 {
            #[inline(always)]
            fn from(val: Ice) -> u8 {
                Ice::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicrst {
            #[inline(always)]
            fn from(val: u8) -> Iicrst {
                Iicrst::from_bits(val)
            }
        }
        impl From<Iicrst> for u8 {
            #[inline(always)]
            fn from(val: Iicrst) -> u8 {
                Iicrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Male {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Male {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Male {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Male {
            #[inline(always)]
            fn from(val: u8) -> Male {
                Male::from_bits(val)
            }
        }
        impl From<Male> for u8 {
            #[inline(always)]
            fn from(val: Male) -> u8 {
                Male::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mst {
            #[inline(always)]
            fn from(val: u8) -> Mst {
                Mst::from_bits(val)
            }
        }
        impl From<Mst> for u8 {
            #[inline(always)]
            fn from(val: Mst) -> u8 {
                Mst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mtwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mtwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mtwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mtwp {
            #[inline(always)]
            fn from(val: u8) -> Mtwp {
                Mtwp::from_bits(val)
            }
        }
        impl From<Mtwp> for u8 {
            #[inline(always)]
            fn from(val: Mtwp) -> u8 {
                Mtwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nacke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nacke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nacke {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nacke {
            #[inline(always)]
            fn from(val: u8) -> Nacke {
                Nacke::from_bits(val)
            }
        }
        impl From<Nacke> for u8 {
            #[inline(always)]
            fn from(val: Nacke) -> u8 {
                Nacke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nackf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nackf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nackf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nackf {
            #[inline(always)]
            fn from(val: u8) -> Nackf {
                Nackf::from_bits(val)
            }
        }
        impl From<Nackf> for u8 {
            #[inline(always)]
            fn from(val: Nackf) -> u8 {
                Nackf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nakie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nakie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nakie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nakie {
            #[inline(always)]
            fn from(val: u8) -> Nakie {
                Nakie::from_bits(val)
            }
        }
        impl From<Nakie> for u8 {
            #[inline(always)]
            fn from(val: Nakie) -> u8 {
                Nakie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nale {
            #[inline(always)]
            fn from(val: u8) -> Nale {
                Nale::from_bits(val)
            }
        }
        impl From<Nale> for u8 {
            #[inline(always)]
            fn from(val: Nale) -> u8 {
                Nale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nf {
            #[inline(always)]
            fn from(val: u8) -> Nf {
                Nf::from_bits(val)
            }
        }
        impl From<Nf> for u8 {
            #[inline(always)]
            fn from(val: Nf) -> u8 {
                Nf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfe {
            #[inline(always)]
            fn from(val: u8) -> Nfe {
                Nfe::from_bits(val)
            }
        }
        impl From<Nfe> for u8 {
            #[inline(always)]
            fn from(val: Nfe) -> u8 {
                Nfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdrf {
            #[inline(always)]
            fn from(val: u8) -> Rdrf {
                Rdrf::from_bits(val)
            }
        }
        impl From<Rdrf> for u8 {
            #[inline(always)]
            fn from(val: Rdrf) -> u8 {
                Rdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdrfs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdrfs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdrfs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdrfs {
            #[inline(always)]
            fn from(val: u8) -> Rdrfs {
                Rdrfs::from_bits(val)
            }
        }
        impl From<Rdrfs> for u8 {
            #[inline(always)]
            fn from(val: Rdrfs) -> u8 {
                Rdrfs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rie {
            #[inline(always)]
            fn from(val: u8) -> Rie {
                Rie::from_bits(val)
            }
        }
        impl From<Rie> for u8 {
            #[inline(always)]
            fn from(val: Rie) -> u8 {
                Rie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rs {
            #[inline(always)]
            fn from(val: u8) -> Rs {
                Rs::from_bits(val)
            }
        }
        impl From<Rs> for u8 {
            #[inline(always)]
            fn from(val: Rs) -> u8 {
                Rs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sale {
            #[inline(always)]
            fn from(val: u8) -> Sale {
                Sale::from_bits(val)
            }
        }
        impl From<Sale> for u8 {
            #[inline(always)]
            fn from(val: Sale) -> u8 {
                Sale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sar0e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sar0e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sar0e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sar0e {
            #[inline(always)]
            fn from(val: u8) -> Sar0e {
                Sar0e::from_bits(val)
            }
        }
        impl From<Sar0e> for u8 {
            #[inline(always)]
            fn from(val: Sar0e) -> u8 {
                Sar0e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sar1e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sar1e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sar1e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sar1e {
            #[inline(always)]
            fn from(val: u8) -> Sar1e {
                Sar1e::from_bits(val)
            }
        }
        impl From<Sar1e> for u8 {
            #[inline(always)]
            fn from(val: Sar1e) -> u8 {
                Sar1e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sar2e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sar2e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sar2e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sar2e {
            #[inline(always)]
            fn from(val: u8) -> Sar2e {
                Sar2e::from_bits(val)
            }
        }
        impl From<Sar2e> for u8 {
            #[inline(always)]
            fn from(val: Sar2e) -> u8 {
                Sar2e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scle {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scle {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scle {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scle {
            #[inline(always)]
            fn from(val: u8) -> Scle {
                Scle::from_bits(val)
            }
        }
        impl From<Scle> for u8 {
            #[inline(always)]
            fn from(val: Scle) -> u8 {
                Scle::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scli {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scli {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scli {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scli {
            #[inline(always)]
            fn from(val: u8) -> Scli {
                Scli::from_bits(val)
            }
        }
        impl From<Scli> for u8 {
            #[inline(always)]
            fn from(val: Scli) -> u8 {
                Scli::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sclo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sclo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sclo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sclo {
            #[inline(always)]
            fn from(val: u8) -> Sclo {
                Sclo::from_bits(val)
            }
        }
        impl From<Sclo> for u8 {
            #[inline(always)]
            fn from(val: Sclo) -> u8 {
                Sclo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdai {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdai {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdai {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdai {
            #[inline(always)]
            fn from(val: u8) -> Sdai {
                Sdai::from_bits(val)
            }
        }
        impl From<Sdai> for u8 {
            #[inline(always)]
            fn from(val: Sdai) -> u8 {
                Sdai::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdao {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdao {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdao {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdao {
            #[inline(always)]
            fn from(val: u8) -> Sdao {
                Sdao::from_bits(val)
            }
        }
        impl From<Sdao> for u8 {
            #[inline(always)]
            fn from(val: Sdao) -> u8 {
                Sdao::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sddl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sddl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sddl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sddl {
            #[inline(always)]
            fn from(val: u8) -> Sddl {
                Sddl::from_bits(val)
            }
        }
        impl From<Sddl> for u8 {
            #[inline(always)]
            fn from(val: Sddl) -> u8 {
                Sddl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smbs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smbs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smbs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smbs {
            #[inline(always)]
            fn from(val: u8) -> Smbs {
                Smbs::from_bits(val)
            }
        }
        impl From<Smbs> for u8 {
            #[inline(always)]
            fn from(val: Smbs) -> u8 {
                Smbs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sowp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sowp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sowp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sowp {
            #[inline(always)]
            fn from(val: u8) -> Sowp {
                Sowp::from_bits(val)
            }
        }
        impl From<Sowp> for u8 {
            #[inline(always)]
            fn from(val: Sowp) -> u8 {
                Sowp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sp {
            #[inline(always)]
            fn from(val: u8) -> Sp {
                Sp::from_bits(val)
            }
        }
        impl From<Sp> for u8 {
            #[inline(always)]
            fn from(val: Sp) -> u8 {
                Sp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spie {
            #[inline(always)]
            fn from(val: u8) -> Spie {
                Spie::from_bits(val)
            }
        }
        impl From<Spie> for u8 {
            #[inline(always)]
            fn from(val: Spie) -> u8 {
                Spie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum St {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl St {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> St {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for St {
            #[inline(always)]
            fn from(val: u8) -> St {
                St::from_bits(val)
            }
        }
        impl From<St> for u8 {
            #[inline(always)]
            fn from(val: St) -> u8 {
                St::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Start {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Start {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Start {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Start {
            #[inline(always)]
            fn from(val: u8) -> Start {
                Start::from_bits(val)
            }
        }
        impl From<Start> for u8 {
            #[inline(always)]
            fn from(val: Start) -> u8 {
                Start::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stie {
            #[inline(always)]
            fn from(val: u8) -> Stie {
                Stie::from_bits(val)
            }
        }
        impl From<Stie> for u8 {
            #[inline(always)]
            fn from(val: Stie) -> u8 {
                Stie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stop {
            #[inline(always)]
            fn from(val: u8) -> Stop {
                Stop::from_bits(val)
            }
        }
        impl From<Stop> for u8 {
            #[inline(always)]
            fn from(val: Stop) -> u8 {
                Stop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdre {
            #[inline(always)]
            fn from(val: u8) -> Tdre {
                Tdre::from_bits(val)
            }
        }
        impl From<Tdre> for u8 {
            #[inline(always)]
            fn from(val: Tdre) -> u8 {
                Tdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teie {
            #[inline(always)]
            fn from(val: u8) -> Teie {
                Teie::from_bits(val)
            }
        }
        impl From<Teie> for u8 {
            #[inline(always)]
            fn from(val: Teie) -> u8 {
                Teie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tend {
            #[inline(always)]
            fn from(val: u8) -> Tend {
                Tend::from_bits(val)
            }
        }
        impl From<Tend> for u8 {
            #[inline(always)]
            fn from(val: Tend) -> u8 {
                Tend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tie {
            #[inline(always)]
            fn from(val: u8) -> Tie {
                Tie::from_bits(val)
            }
        }
        impl From<Tie> for u8 {
            #[inline(always)]
            fn from(val: Tie) -> u8 {
                Tie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmoe {
            #[inline(always)]
            fn from(val: u8) -> Tmoe {
                Tmoe::from_bits(val)
            }
        }
        impl From<Tmoe> for u8 {
            #[inline(always)]
            fn from(val: Tmoe) -> u8 {
                Tmoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmof {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmof {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmof {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmof {
            #[inline(always)]
            fn from(val: u8) -> Tmof {
                Tmof::from_bits(val)
            }
        }
        impl From<Tmof> for u8 {
            #[inline(always)]
            fn from(val: Tmof) -> u8 {
                Tmof::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmoh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmoh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmoh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmoh {
            #[inline(always)]
            fn from(val: u8) -> Tmoh {
                Tmoh::from_bits(val)
            }
        }
        impl From<Tmoh> for u8 {
            #[inline(always)]
            fn from(val: Tmoh) -> u8 {
                Tmoh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmoie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmoie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmoie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmoie {
            #[inline(always)]
            fn from(val: u8) -> Tmoie {
                Tmoie::from_bits(val)
            }
        }
        impl From<Tmoie> for u8 {
            #[inline(always)]
            fn from(val: Tmoie) -> u8 {
                Tmoie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmol {
            #[inline(always)]
            fn from(val: u8) -> Tmol {
                Tmol::from_bits(val)
            }
        }
        impl From<Tmol> for u8 {
            #[inline(always)]
            fn from(val: Tmol) -> u8 {
                Tmol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmos {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tmos {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmos {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmos {
            #[inline(always)]
            fn from(val: u8) -> Tmos {
                Tmos::from_bits(val)
            }
        }
        impl From<Tmos> for u8 {
            #[inline(always)]
            fn from(val: Tmos) -> u8 {
                Tmos::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trs {
            #[inline(always)]
            fn from(val: u8) -> Trs {
                Trs::from_bits(val)
            }
        }
        impl From<Trs> for u8 {
            #[inline(always)]
            fn from(val: Trs) -> u8 {
                Trs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wait {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wait {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wait {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wait {
            #[inline(always)]
            fn from(val: u8) -> Wait {
                Wait::from_bits(val)
            }
        }
        impl From<Wait> for u8 {
            #[inline(always)]
            fn from(val: Wait) -> u8 {
                Wait::to_bits(val)
            }
        }
    }
}
pub mod iic0wu {
    #[doc = "Inter,Integrated Circuit 0 Wake,up Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iic0wu {
        ptr: *mut u8,
    }
    unsafe impl Send for Iic0wu {}
    unsafe impl Sync for Iic0wu {}
    impl Iic0wu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "I2C Bus Wakeup Unit Register"]
        #[inline(always)]
        pub const fn icwur(self) -> crate::common::Reg<regs::Icwur, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "I2C Bus Wakeup Unit Register 2"]
        #[inline(always)]
        pub const fn icwur2(self) -> crate::common::Reg<regs::Icwur2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "I2C Bus Wakeup Unit Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icwur(pub u8);
        impl Icwur {
            #[doc = "Wakeup Analog Filter Additional Selection"]
            #[inline(always)]
            pub const fn wuafa(&self) -> super::vals::Wuafa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Wuafa::from_bits(val as u8)
            }
            #[doc = "Wakeup Analog Filter Additional Selection"]
            #[inline(always)]
            pub fn set_wuafa(&mut self, val: super::vals::Wuafa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "ACK Bit for Wakeup Mode"]
            #[inline(always)]
            pub const fn wuack(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "ACK Bit for Wakeup Mode"]
            #[inline(always)]
            pub fn set_wuack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "Wakeup Event Occurrence Flag"]
            #[inline(always)]
            pub const fn wuf(&self) -> super::vals::Wuf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Wuf::from_bits(val as u8)
            }
            #[doc = "Wakeup Event Occurrence Flag"]
            #[inline(always)]
            pub fn set_wuf(&mut self, val: super::vals::Wuf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Wakeup Interrupt Request Enable"]
            #[inline(always)]
            pub const fn wuie(&self) -> super::vals::Wuie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Wuie::from_bits(val as u8)
            }
            #[doc = "Wakeup Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_wuie(&mut self, val: super::vals::Wuie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Wakeup Function Enable"]
            #[inline(always)]
            pub const fn wue(&self) -> super::vals::Wue {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wue::from_bits(val as u8)
            }
            #[doc = "Wakeup Function Enable"]
            #[inline(always)]
            pub fn set_wue(&mut self, val: super::vals::Wue) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Icwur {
            #[inline(always)]
            fn default() -> Icwur {
                Icwur(0)
            }
        }
        impl core::fmt::Debug for Icwur {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icwur")
                    .field("wuafa", &self.wuafa())
                    .field("wuack", &self.wuack())
                    .field("wuf", &self.wuf())
                    .field("wuie", &self.wuie())
                    .field("wue", &self.wue())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icwur {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icwur {{ wuafa: {:?}, wuack: {=bool:?}, wuf: {:?}, wuie: {:?}, wue: {:?} }}",
                    self.wuafa(),
                    self.wuack(),
                    self.wuf(),
                    self.wuie(),
                    self.wue()
                )
            }
        }
        #[doc = "I2C Bus Wakeup Unit Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icwur2(pub u8);
        impl Icwur2 {
            #[doc = "Wakeup Function Synchronous Enable"]
            #[inline(always)]
            pub const fn wusen(&self) -> super::vals::Wusen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Wusen::from_bits(val as u8)
            }
            #[doc = "Wakeup Function Synchronous Enable"]
            #[inline(always)]
            pub fn set_wusen(&mut self, val: super::vals::Wusen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Wakeup Function Asynchronous Operation Status Flag"]
            #[inline(always)]
            pub const fn wuasyf(&self) -> super::vals::Wuasyf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wuasyf::from_bits(val as u8)
            }
            #[doc = "Wakeup Function Asynchronous Operation Status Flag"]
            #[inline(always)]
            pub fn set_wuasyf(&mut self, val: super::vals::Wuasyf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Wakeup Function Synchronous Operation Status Flag"]
            #[inline(always)]
            pub const fn wusyf(&self) -> super::vals::Wusyf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Wusyf::from_bits(val as u8)
            }
            #[doc = "Wakeup Function Synchronous Operation Status Flag"]
            #[inline(always)]
            pub fn set_wusyf(&mut self, val: super::vals::Wusyf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Icwur2 {
            #[inline(always)]
            fn default() -> Icwur2 {
                Icwur2(0)
            }
        }
        impl core::fmt::Debug for Icwur2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icwur2")
                    .field("wusen", &self.wusen())
                    .field("wuasyf", &self.wuasyf())
                    .field("wusyf", &self.wusyf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icwur2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icwur2 {{ wusen: {:?}, wuasyf: {:?}, wusyf: {:?} }}",
                    self.wusen(),
                    self.wuasyf(),
                    self.wusyf()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wuafa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wuafa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wuafa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wuafa {
            #[inline(always)]
            fn from(val: u8) -> Wuafa {
                Wuafa::from_bits(val)
            }
        }
        impl From<Wuafa> for u8 {
            #[inline(always)]
            fn from(val: Wuafa) -> u8 {
                Wuafa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wuasyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wuasyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wuasyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wuasyf {
            #[inline(always)]
            fn from(val: u8) -> Wuasyf {
                Wuasyf::from_bits(val)
            }
        }
        impl From<Wuasyf> for u8 {
            #[inline(always)]
            fn from(val: Wuasyf) -> u8 {
                Wuasyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wue {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wue {
            #[inline(always)]
            fn from(val: u8) -> Wue {
                Wue::from_bits(val)
            }
        }
        impl From<Wue> for u8 {
            #[inline(always)]
            fn from(val: Wue) -> u8 {
                Wue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wuf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wuf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wuf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wuf {
            #[inline(always)]
            fn from(val: u8) -> Wuf {
                Wuf::from_bits(val)
            }
        }
        impl From<Wuf> for u8 {
            #[inline(always)]
            fn from(val: Wuf) -> u8 {
                Wuf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wuie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wuie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wuie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wuie {
            #[inline(always)]
            fn from(val: u8) -> Wuie {
                Wuie::from_bits(val)
            }
        }
        impl From<Wuie> for u8 {
            #[inline(always)]
            fn from(val: Wuie) -> u8 {
                Wuie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wusen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wusen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wusen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wusen {
            #[inline(always)]
            fn from(val: u8) -> Wusen {
                Wusen::from_bits(val)
            }
        }
        impl From<Wusen> for u8 {
            #[inline(always)]
            fn from(val: Wusen) -> u8 {
                Wusen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wusyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wusyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wusyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wusyf {
            #[inline(always)]
            fn from(val: u8) -> Wusyf {
                Wusyf::from_bits(val)
            }
        }
        impl From<Wusyf> for u8 {
            #[inline(always)]
            fn from(val: Wusyf) -> u8 {
                Wusyf::to_bits(val)
            }
        }
    }
}
pub mod iwdt {
    #[doc = "Independent Watchdog Timer"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iwdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Iwdt {}
    unsafe impl Sync for Iwdt {}
    impl Iwdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IWDT Refresh Register"]
        #[inline(always)]
        pub const fn iwdtrr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "IWDT Status Register"]
        #[inline(always)]
        pub const fn iwdtsr(self) -> crate::common::Reg<regs::Iwdtsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "IWDT Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iwdtsr(pub u16);
        impl Iwdtsr {
            #[doc = "Down,counter Value"]
            #[inline(always)]
            pub const fn cntval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Down,counter Value"]
            #[inline(always)]
            pub fn set_cntval(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u16) & 0x3fff) << 0usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn undff(&self) -> super::vals::Undff {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Undff::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_undff(&mut self, val: super::vals::Undff) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub const fn refef(&self) -> super::vals::Refef {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Refef::from_bits(val as u8)
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub fn set_refef(&mut self, val: super::vals::Refef) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Iwdtsr {
            #[inline(always)]
            fn default() -> Iwdtsr {
                Iwdtsr(0)
            }
        }
        impl core::fmt::Debug for Iwdtsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iwdtsr")
                    .field("cntval", &self.cntval())
                    .field("undff", &self.undff())
                    .field("refef", &self.refef())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iwdtsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Iwdtsr {{ cntval: {=u16:?}, undff: {:?}, refef: {:?} }}",
                    self.cntval(),
                    self.undff(),
                    self.refef()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Refef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refef {
            #[inline(always)]
            fn from(val: u8) -> Refef {
                Refef::from_bits(val)
            }
        }
        impl From<Refef> for u8 {
            #[inline(always)]
            fn from(val: Refef) -> u8 {
                Refef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Undff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Undff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Undff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Undff {
            #[inline(always)]
            fn from(val: u8) -> Undff {
                Undff::from_bits(val)
            }
        }
        impl From<Undff> for u8 {
            #[inline(always)]
            fn from(val: Undff) -> u8 {
                Undff::to_bits(val)
            }
        }
    }
}
pub mod macl {
    #[doc = "32-bit Multiply,Accumulator"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Macl {
        ptr: *mut u8,
    }
    unsafe impl Send for Macl {}
    unsafe impl Sync for Macl {}
    impl Macl {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Multiplication Data Register Bn"]
        #[inline(always)]
        pub const fn mulb(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 24usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
        #[doc = "Multiplication Result Register %s"]
        #[inline(always)]
        pub const fn mulrl(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 24usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize + n * 8usize) as _) }
        }
        #[doc = "Multiplication Result Register %s"]
        #[inline(always)]
        pub const fn mulrh(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 24usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc4usize + n * 8usize) as _) }
        }
        #[doc = "Multiplication Data Register A"]
        #[inline(always)]
        pub const fn mul32u(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Multiplication Data Register A"]
        #[inline(always)]
        pub const fn mul32s(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Multiplication Data Register A"]
        #[inline(always)]
        pub const fn mac32u(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Multiplication Data Register A"]
        #[inline(always)]
        pub const fn mac32s(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Multiplication Control Register"]
        #[inline(always)]
        pub const fn mulc(self) -> crate::common::Reg<regs::Mulc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Multiplication Result Clear Register"]
        #[inline(always)]
        pub const fn mulrclr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Multiplication Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mulc(pub u8);
        impl Mulc {
            #[doc = "Operation Processing Status Bit"]
            #[inline(always)]
            pub const fn mulst(&self) -> super::vals::Mulst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mulst::from_bits(val as u8)
            }
            #[doc = "Operation Processing Status Bit"]
            #[inline(always)]
            pub fn set_mulst(&mut self, val: super::vals::Mulst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Multiply,accumulation Result (accumulation value) Sign Flag"]
            #[inline(always)]
            pub const fn macsf(&self) -> super::vals::Macsf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Macsf::from_bits(val as u8)
            }
            #[doc = "Multiply,accumulation Result (accumulation value) Sign Flag"]
            #[inline(always)]
            pub fn set_macsf(&mut self, val: super::vals::Macsf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Multiply,accumulation Result (accumulation value) Overflow/Underflow Flag"]
            #[inline(always)]
            pub const fn macof(&self) -> super::vals::Macof {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Macof::from_bits(val as u8)
            }
            #[doc = "Multiply,accumulation Result (accumulation value) Overflow/Underflow Flag"]
            #[inline(always)]
            pub fn set_macof(&mut self, val: super::vals::Macof) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Fixed Point Mode Selection"]
            #[inline(always)]
            pub const fn mulfrac(&self) -> super::vals::Mulfrac {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mulfrac::from_bits(val as u8)
            }
            #[doc = "Fixed Point Mode Selection"]
            #[inline(always)]
            pub fn set_mulfrac(&mut self, val: super::vals::Mulfrac) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Signedness Selection"]
            #[inline(always)]
            pub const fn mulsm(&self) -> super::vals::Mulsm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mulsm::from_bits(val as u8)
            }
            #[doc = "Signedness Selection"]
            #[inline(always)]
            pub fn set_mulsm(&mut self, val: super::vals::Mulsm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Operation Mode Selection"]
            #[inline(always)]
            pub const fn macmode(&self) -> super::vals::Macmode {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Macmode::from_bits(val as u8)
            }
            #[doc = "Operation Mode Selection"]
            #[inline(always)]
            pub fn set_macmode(&mut self, val: super::vals::Macmode) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Mulc {
            #[inline(always)]
            fn default() -> Mulc {
                Mulc(0)
            }
        }
        impl core::fmt::Debug for Mulc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mulc")
                    .field("mulst", &self.mulst())
                    .field("macsf", &self.macsf())
                    .field("macof", &self.macof())
                    .field("mulfrac", &self.mulfrac())
                    .field("mulsm", &self.mulsm())
                    .field("macmode", &self.macmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mulc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mulc {{ mulst: {:?}, macsf: {:?}, macof: {:?}, mulfrac: {:?}, mulsm: {:?}, macmode: {:?} }}" , self . mulst () , self . macsf () , self . macof () , self . mulfrac () , self . mulsm () , self . macmode ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Macmode {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Macmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Macmode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Macmode {
            #[inline(always)]
            fn from(val: u8) -> Macmode {
                Macmode::from_bits(val)
            }
        }
        impl From<Macmode> for u8 {
            #[inline(always)]
            fn from(val: Macmode) -> u8 {
                Macmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Macof {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Macof {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Macof {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Macof {
            #[inline(always)]
            fn from(val: u8) -> Macof {
                Macof::from_bits(val)
            }
        }
        impl From<Macof> for u8 {
            #[inline(always)]
            fn from(val: Macof) -> u8 {
                Macof::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Macsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Macsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Macsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Macsf {
            #[inline(always)]
            fn from(val: u8) -> Macsf {
                Macsf::from_bits(val)
            }
        }
        impl From<Macsf> for u8 {
            #[inline(always)]
            fn from(val: Macsf) -> u8 {
                Macsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mulfrac {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mulfrac {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mulfrac {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mulfrac {
            #[inline(always)]
            fn from(val: u8) -> Mulfrac {
                Mulfrac::from_bits(val)
            }
        }
        impl From<Mulfrac> for u8 {
            #[inline(always)]
            fn from(val: Mulfrac) -> u8 {
                Mulfrac::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mulsm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mulsm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mulsm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mulsm {
            #[inline(always)]
            fn from(val: u8) -> Mulsm {
                Mulsm::from_bits(val)
            }
        }
        impl From<Mulsm> for u8 {
            #[inline(always)]
            fn from(val: Mulsm) -> u8 {
                Mulsm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mulst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mulst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mulst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mulst {
            #[inline(always)]
            fn from(val: u8) -> Mulst {
                Mulst::from_bits(val)
            }
        }
        impl From<Mulst> for u8 {
            #[inline(always)]
            fn from(val: Mulst) -> u8 {
                Mulst::to_bits(val)
            }
        }
    }
}
pub mod mmf {
    #[doc = "Memory Mirror Function"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mmf {
        ptr: *mut u8,
    }
    unsafe impl Send for Mmf {}
    unsafe impl Sync for Mmf {}
    impl Mmf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "MemMirror Special Function Register"]
        #[inline(always)]
        pub const fn mmsfr(self) -> crate::common::Reg<regs::Mmsfr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "MemMirror Enable Register"]
        #[inline(always)]
        pub const fn mmen(self) -> crate::common::Reg<regs::Mmen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "MemMirror Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmen(pub u32);
        impl Mmen {
            #[doc = "Memory Mirror Function Enable"]
            #[inline(always)]
            pub const fn en(&self) -> super::vals::En {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::En::from_bits(val as u8)
            }
            #[doc = "Memory Mirror Function Enable"]
            #[inline(always)]
            pub fn set_en(&mut self, val: super::vals::En) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "MMEN Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "MMEN Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Mmen {
            #[inline(always)]
            fn default() -> Mmen {
                Mmen(0)
            }
        }
        impl core::fmt::Debug for Mmen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmen")
                    .field("en", &self.en())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmen {{ en: {:?}, key: {=u8:?} }}",
                    self.en(),
                    self.key()
                )
            }
        }
        #[doc = "MemMirror Special Function Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmsfr(pub u32);
        impl Mmsfr {
            #[doc = "Memory Mirror Address"]
            #[inline(always)]
            pub const fn memmiraddr(&self) -> u16 {
                let val = (self.0 >> 7usize) & 0xffff;
                val as u16
            }
            #[doc = "Memory Mirror Address"]
            #[inline(always)]
            pub fn set_memmiraddr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 7usize)) | (((val as u32) & 0xffff) << 7usize);
            }
            #[doc = "MMSFR Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "MMSFR Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Mmsfr {
            #[inline(always)]
            fn default() -> Mmsfr {
                Mmsfr(0)
            }
        }
        impl core::fmt::Debug for Mmsfr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmsfr")
                    .field("memmiraddr", &self.memmiraddr())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmsfr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmsfr {{ memmiraddr: {=u16:?}, key: {=u8:?} }}",
                    self.memmiraddr(),
                    self.key()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En {
            #[inline(always)]
            fn from(val: u8) -> En {
                En::from_bits(val)
            }
        }
        impl From<En> for u8 {
            #[inline(always)]
            fn from(val: En) -> u8 {
                En::to_bits(val)
            }
        }
    }
}
pub mod mstp {
    #[doc = "Module Stop Control A, B, C, D"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mstp {
        ptr: *mut u8,
    }
    unsafe impl Send for Mstp {}
    unsafe impl Sync for Mstp {}
    impl Mstp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Module Stop Control Register B"]
        #[inline(always)]
        pub const fn mstpcrb(self) -> crate::common::Reg<regs::Mstpcrb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Module Stop Control Register C"]
        #[inline(always)]
        pub const fn mstpcrc(self) -> crate::common::Reg<regs::Mstpcrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Module Stop Control Register D"]
        #[inline(always)]
        pub const fn mstpcrd(self) -> crate::common::Reg<regs::Mstpcrd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Low Speed Module R/W Disable Control Register"]
        #[inline(always)]
        pub const fn lsmrwdis(self) -> crate::common::Reg<regs::Lsmrwdis, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Low Speed Module R/W Disable Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsmrwdis(pub u16);
        impl Lsmrwdis {
            #[doc = "RTC Register R/W Enable Control"]
            #[inline(always)]
            pub const fn rtcrwdis(&self) -> super::vals::Rtcrwdis {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rtcrwdis::from_bits(val as u8)
            }
            #[doc = "RTC Register R/W Enable Control"]
            #[inline(always)]
            pub fn set_rtcrwdis(&mut self, val: super::vals::Rtcrwdis) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT Operate Clock Control"]
            #[inline(always)]
            pub const fn wdtdis(&self) -> super::vals::Wdtdis {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtdis::from_bits(val as u8)
            }
            #[doc = "WDT Operate Clock Control"]
            #[inline(always)]
            pub fn set_wdtdis(&mut self, val: super::vals::Wdtdis) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "IWDT Register Clock Control"]
            #[inline(always)]
            pub const fn iwdtids(&self) -> super::vals::Iwdtids {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Iwdtids::from_bits(val as u8)
            }
            #[doc = "IWDT Register Clock Control"]
            #[inline(always)]
            pub fn set_iwdtids(&mut self, val: super::vals::Iwdtids) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Write Enable for bits \\[2:0\\]"]
            #[inline(always)]
            pub const fn wren(&self) -> super::vals::Wren {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wren::from_bits(val as u8)
            }
            #[doc = "Write Enable for bits \\[2:0\\]"]
            #[inline(always)]
            pub fn set_wren(&mut self, val: super::vals::Wren) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "LSMRWDIS Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "LSMRWDIS Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Lsmrwdis {
            #[inline(always)]
            fn default() -> Lsmrwdis {
                Lsmrwdis(0)
            }
        }
        impl core::fmt::Debug for Lsmrwdis {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsmrwdis")
                    .field("rtcrwdis", &self.rtcrwdis())
                    .field("wdtdis", &self.wdtdis())
                    .field("iwdtids", &self.iwdtids())
                    .field("wren", &self.wren())
                    .field("prkey", &self.prkey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsmrwdis {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Lsmrwdis {{ rtcrwdis: {:?}, wdtdis: {:?}, iwdtids: {:?}, wren: {:?}, prkey: {=u8:?} }}" , self . rtcrwdis () , self . wdtdis () , self . iwdtids () , self . wren () , self . prkey ())
            }
        }
        #[doc = "Module Stop Control Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrb(pub u32);
        impl Mstpcrb {
            #[doc = "I2C Bus Interface 1 Module Stop"]
            #[inline(always)]
            pub const fn mstpb8(&self) -> super::vals::Mstpb8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mstpb8::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface 1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb8(&mut self, val: super::vals::Mstpb8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "I2C Bus Interface 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb9(&self) -> super::vals::Mstpb9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Mstpb9::from_bits(val as u8)
            }
            #[doc = "I2C Bus Interface 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb9(&mut self, val: super::vals::Mstpb9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Serial Peripheral Interface 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb19(&self) -> super::vals::Mstpb19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Mstpb19::from_bits(val as u8)
            }
            #[doc = "Serial Peripheral Interface 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb19(&mut self, val: super::vals::Mstpb19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Serial Communication Interface 9 Module Stop"]
            #[inline(always)]
            pub const fn mstpb22(&self) -> super::vals::Mstpb22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Mstpb22::from_bits(val as u8)
            }
            #[doc = "Serial Communication Interface 9 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb22(&mut self, val: super::vals::Mstpb22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Serial Communication Interface 3 Module Stop"]
            #[inline(always)]
            pub const fn mstpb28(&self) -> super::vals::Mstpb28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Mstpb28::from_bits(val as u8)
            }
            #[doc = "Serial Communication Interface 3 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb28(&mut self, val: super::vals::Mstpb28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Serial Communication Interface 2 Module Stop"]
            #[inline(always)]
            pub const fn mstpb29(&self) -> super::vals::Mstpb29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Mstpb29::from_bits(val as u8)
            }
            #[doc = "Serial Communication Interface 2 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb29(&mut self, val: super::vals::Mstpb29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Serial Communication Interface 1 Module Stop"]
            #[inline(always)]
            pub const fn mstpb30(&self) -> super::vals::Mstpb30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Mstpb30::from_bits(val as u8)
            }
            #[doc = "Serial Communication Interface 1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb30(&mut self, val: super::vals::Mstpb30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Serial Communication Interface 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb31(&self) -> super::vals::Mstpb31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mstpb31::from_bits(val as u8)
            }
            #[doc = "Serial Communication Interface 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb31(&mut self, val: super::vals::Mstpb31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Mstpcrb {
            #[inline(always)]
            fn default() -> Mstpcrb {
                Mstpcrb(0)
            }
        }
        impl core::fmt::Debug for Mstpcrb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrb")
                    .field("mstpb8", &self.mstpb8())
                    .field("mstpb9", &self.mstpb9())
                    .field("mstpb19", &self.mstpb19())
                    .field("mstpb22", &self.mstpb22())
                    .field("mstpb28", &self.mstpb28())
                    .field("mstpb29", &self.mstpb29())
                    .field("mstpb30", &self.mstpb30())
                    .field("mstpb31", &self.mstpb31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrb {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mstpcrb {{ mstpb8: {:?}, mstpb9: {:?}, mstpb19: {:?}, mstpb22: {:?}, mstpb28: {:?}, mstpb29: {:?}, mstpb30: {:?}, mstpb31: {:?} }}" , self . mstpb8 () , self . mstpb9 () , self . mstpb19 () , self . mstpb22 () , self . mstpb28 () , self . mstpb29 () , self . mstpb30 () , self . mstpb31 ())
            }
        }
        #[doc = "Module Stop Control Register C"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrc(pub u32);
        impl Mstpcrc {
            #[doc = "Clock Frequency Accuracy Measurement Circuit Module Stop"]
            #[inline(always)]
            pub const fn mstpc0(&self) -> super::vals::Mstpc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mstpc0::from_bits(val as u8)
            }
            #[doc = "Clock Frequency Accuracy Measurement Circuit Module Stop"]
            #[inline(always)]
            pub fn set_mstpc0(&mut self, val: super::vals::Mstpc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Cyclic Redundancy Check Calculator Module Stop"]
            #[inline(always)]
            pub const fn mstpc1(&self) -> super::vals::Mstpc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mstpc1::from_bits(val as u8)
            }
            #[doc = "Cyclic Redundancy Check Calculator Module Stop"]
            #[inline(always)]
            pub fn set_mstpc1(&mut self, val: super::vals::Mstpc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Segment LCD Controller Module Stop"]
            #[inline(always)]
            pub const fn mstpc4(&self) -> super::vals::Mstpc4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mstpc4::from_bits(val as u8)
            }
            #[doc = "Segment LCD Controller Module Stop"]
            #[inline(always)]
            pub fn set_mstpc4(&mut self, val: super::vals::Mstpc4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Data Operation Circuit Module Stop"]
            #[inline(always)]
            pub const fn mstpc13(&self) -> super::vals::Mstpc13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Mstpc13::from_bits(val as u8)
            }
            #[doc = "Data Operation Circuit Module Stop"]
            #[inline(always)]
            pub fn set_mstpc13(&mut self, val: super::vals::Mstpc13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Event Link Controller Module Stop"]
            #[inline(always)]
            pub const fn mstpc14(&self) -> super::vals::Mstpc14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Mstpc14::from_bits(val as u8)
            }
            #[doc = "Event Link Controller Module Stop"]
            #[inline(always)]
            pub fn set_mstpc14(&mut self, val: super::vals::Mstpc14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "32-bit Multiply,Accumulator Module Stop"]
            #[inline(always)]
            pub const fn mstpc15(&self) -> super::vals::Mstpc15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Mstpc15::from_bits(val as u8)
            }
            #[doc = "32-bit Multiply,Accumulator Module Stop"]
            #[inline(always)]
            pub fn set_mstpc15(&mut self, val: super::vals::Mstpc15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "True Random Number Generator Module Stop"]
            #[inline(always)]
            pub const fn mstpc28(&self) -> super::vals::Mstpc28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Mstpc28::from_bits(val as u8)
            }
            #[doc = "True Random Number Generator Module Stop"]
            #[inline(always)]
            pub fn set_mstpc28(&mut self, val: super::vals::Mstpc28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "AES Module Stop"]
            #[inline(always)]
            pub const fn mstpc31(&self) -> super::vals::Mstpc31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mstpc31::from_bits(val as u8)
            }
            #[doc = "AES Module Stop"]
            #[inline(always)]
            pub fn set_mstpc31(&mut self, val: super::vals::Mstpc31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Mstpcrc {
            #[inline(always)]
            fn default() -> Mstpcrc {
                Mstpcrc(0)
            }
        }
        impl core::fmt::Debug for Mstpcrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrc")
                    .field("mstpc0", &self.mstpc0())
                    .field("mstpc1", &self.mstpc1())
                    .field("mstpc4", &self.mstpc4())
                    .field("mstpc13", &self.mstpc13())
                    .field("mstpc14", &self.mstpc14())
                    .field("mstpc15", &self.mstpc15())
                    .field("mstpc28", &self.mstpc28())
                    .field("mstpc31", &self.mstpc31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mstpcrc {{ mstpc0: {:?}, mstpc1: {:?}, mstpc4: {:?}, mstpc13: {:?}, mstpc14: {:?}, mstpc15: {:?}, mstpc28: {:?}, mstpc31: {:?} }}" , self . mstpc0 () , self . mstpc1 () , self . mstpc4 () , self . mstpc13 () , self . mstpc14 () , self . mstpc15 () , self . mstpc28 () , self . mstpc31 ())
            }
        }
        #[doc = "Module Stop Control Register D"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrd(pub u32);
        impl Mstpcrd {
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 3 Module Stop"]
            #[inline(always)]
            pub const fn mstpd0(&self) -> super::vals::Mstpd0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mstpd0::from_bits(val as u8)
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 3 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd0(&mut self, val: super::vals::Mstpd0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 2 Module Stop"]
            #[inline(always)]
            pub const fn mstpd1(&self) -> super::vals::Mstpd1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mstpd1::from_bits(val as u8)
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 2 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd1(&mut self, val: super::vals::Mstpd1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "32-bit Low Power Asynchronous General Purpose Timer 1 Module Stop"]
            #[inline(always)]
            pub const fn mstpd2(&self) -> super::vals::Mstpd2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mstpd2::from_bits(val as u8)
            }
            #[doc = "32-bit Low Power Asynchronous General Purpose Timer 1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd2(&mut self, val: super::vals::Mstpd2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "32-bit Low Power Asynchronous General Purpose Timer 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpd3(&self) -> super::vals::Mstpd3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mstpd3::from_bits(val as u8)
            }
            #[doc = "32-bit Low Power Asynchronous General Purpose Timer 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd3(&mut self, val: super::vals::Mstpd3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "General PWM Timer 164 to 169 and PWM Delay Generation Circuit Module Stop"]
            #[inline(always)]
            pub const fn mstpd6(&self) -> super::vals::Mstpd6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mstpd6::from_bits(val as u8)
            }
            #[doc = "General PWM Timer 164 to 169 and PWM Delay Generation Circuit Module Stop"]
            #[inline(always)]
            pub fn set_mstpd6(&mut self, val: super::vals::Mstpd6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 7 Module Stop"]
            #[inline(always)]
            pub const fn mstpd7(&self) -> super::vals::Mstpd7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Mstpd7::from_bits(val as u8)
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 7 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd7(&mut self, val: super::vals::Mstpd7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 6 Module Stop"]
            #[inline(always)]
            pub const fn mstpd8(&self) -> super::vals::Mstpd8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mstpd8::from_bits(val as u8)
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 6 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd8(&mut self, val: super::vals::Mstpd8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 5 Module Stop"]
            #[inline(always)]
            pub const fn mstpd9(&self) -> super::vals::Mstpd9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Mstpd9::from_bits(val as u8)
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 5 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd9(&mut self, val: super::vals::Mstpd9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 4 Module Stop"]
            #[inline(always)]
            pub const fn mstpd10(&self) -> super::vals::Mstpd10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Mstpd10::from_bits(val as u8)
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 4 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd10(&mut self, val: super::vals::Mstpd10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Port Output Enable for GPT Module Stop"]
            #[inline(always)]
            pub const fn mstpd14(&self) -> super::vals::Mstpd14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Mstpd14::from_bits(val as u8)
            }
            #[doc = "Port Output Enable for GPT Module Stop"]
            #[inline(always)]
            pub fn set_mstpd14(&mut self, val: super::vals::Mstpd14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "12-bit A/D Converter Module Stop"]
            #[inline(always)]
            pub const fn mstpd16(&self) -> super::vals::Mstpd16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Mstpd16::from_bits(val as u8)
            }
            #[doc = "12-bit A/D Converter Module Stop"]
            #[inline(always)]
            pub fn set_mstpd16(&mut self, val: super::vals::Mstpd16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "24-bit Sigma,Delta A/D Converter Module Stop"]
            #[inline(always)]
            pub const fn mstpd17(&self) -> super::vals::Mstpd17 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Mstpd17::from_bits(val as u8)
            }
            #[doc = "24-bit Sigma,Delta A/D Converter Module Stop"]
            #[inline(always)]
            pub fn set_mstpd17(&mut self, val: super::vals::Mstpd17) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 1 Module Stop"]
            #[inline(always)]
            pub const fn mstpd18(&self) -> super::vals::Mstpd18 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Mstpd18::from_bits(val as u8)
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd18(&mut self, val: super::vals::Mstpd18) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpd19(&self) -> super::vals::Mstpd19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Mstpd19::from_bits(val as u8)
            }
            #[doc = "16-bit Low Power Asynchronous General Purpose Timer 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd19(&mut self, val: super::vals::Mstpd19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Mstpcrd {
            #[inline(always)]
            fn default() -> Mstpcrd {
                Mstpcrd(0)
            }
        }
        impl core::fmt::Debug for Mstpcrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrd")
                    .field("mstpd0", &self.mstpd0())
                    .field("mstpd1", &self.mstpd1())
                    .field("mstpd2", &self.mstpd2())
                    .field("mstpd3", &self.mstpd3())
                    .field("mstpd6", &self.mstpd6())
                    .field("mstpd7", &self.mstpd7())
                    .field("mstpd8", &self.mstpd8())
                    .field("mstpd9", &self.mstpd9())
                    .field("mstpd10", &self.mstpd10())
                    .field("mstpd14", &self.mstpd14())
                    .field("mstpd16", &self.mstpd16())
                    .field("mstpd17", &self.mstpd17())
                    .field("mstpd18", &self.mstpd18())
                    .field("mstpd19", &self.mstpd19())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrd {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mstpcrd {{ mstpd0: {:?}, mstpd1: {:?}, mstpd2: {:?}, mstpd3: {:?}, mstpd6: {:?}, mstpd7: {:?}, mstpd8: {:?}, mstpd9: {:?}, mstpd10: {:?}, mstpd14: {:?}, mstpd16: {:?}, mstpd17: {:?}, mstpd18: {:?}, mstpd19: {:?} }}" , self . mstpd0 () , self . mstpd1 () , self . mstpd2 () , self . mstpd3 () , self . mstpd6 () , self . mstpd7 () , self . mstpd8 () , self . mstpd9 () , self . mstpd10 () , self . mstpd14 () , self . mstpd16 () , self . mstpd17 () , self . mstpd18 () , self . mstpd19 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtids {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtids {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtids {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtids {
            #[inline(always)]
            fn from(val: u8) -> Iwdtids {
                Iwdtids::from_bits(val)
            }
        }
        impl From<Iwdtids> for u8 {
            #[inline(always)]
            fn from(val: Iwdtids) -> u8 {
                Iwdtids::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb19 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb19 {
                Mstpb19::from_bits(val)
            }
        }
        impl From<Mstpb19> for u8 {
            #[inline(always)]
            fn from(val: Mstpb19) -> u8 {
                Mstpb19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb22 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb22 {
                Mstpb22::from_bits(val)
            }
        }
        impl From<Mstpb22> for u8 {
            #[inline(always)]
            fn from(val: Mstpb22) -> u8 {
                Mstpb22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb28 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb28 {
                Mstpb28::from_bits(val)
            }
        }
        impl From<Mstpb28> for u8 {
            #[inline(always)]
            fn from(val: Mstpb28) -> u8 {
                Mstpb28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb29 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb29 {
                Mstpb29::from_bits(val)
            }
        }
        impl From<Mstpb29> for u8 {
            #[inline(always)]
            fn from(val: Mstpb29) -> u8 {
                Mstpb29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb30 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb30 {
                Mstpb30::from_bits(val)
            }
        }
        impl From<Mstpb30> for u8 {
            #[inline(always)]
            fn from(val: Mstpb30) -> u8 {
                Mstpb30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb31 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb31 {
                Mstpb31::from_bits(val)
            }
        }
        impl From<Mstpb31> for u8 {
            #[inline(always)]
            fn from(val: Mstpb31) -> u8 {
                Mstpb31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb8 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb8 {
                Mstpb8::from_bits(val)
            }
        }
        impl From<Mstpb8> for u8 {
            #[inline(always)]
            fn from(val: Mstpb8) -> u8 {
                Mstpb8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb9 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb9 {
                Mstpb9::from_bits(val)
            }
        }
        impl From<Mstpb9> for u8 {
            #[inline(always)]
            fn from(val: Mstpb9) -> u8 {
                Mstpb9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc0 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc0 {
                Mstpc0::from_bits(val)
            }
        }
        impl From<Mstpc0> for u8 {
            #[inline(always)]
            fn from(val: Mstpc0) -> u8 {
                Mstpc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc1 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc1 {
                Mstpc1::from_bits(val)
            }
        }
        impl From<Mstpc1> for u8 {
            #[inline(always)]
            fn from(val: Mstpc1) -> u8 {
                Mstpc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc13 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc13 {
                Mstpc13::from_bits(val)
            }
        }
        impl From<Mstpc13> for u8 {
            #[inline(always)]
            fn from(val: Mstpc13) -> u8 {
                Mstpc13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc14 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc14 {
                Mstpc14::from_bits(val)
            }
        }
        impl From<Mstpc14> for u8 {
            #[inline(always)]
            fn from(val: Mstpc14) -> u8 {
                Mstpc14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc15 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc15 {
                Mstpc15::from_bits(val)
            }
        }
        impl From<Mstpc15> for u8 {
            #[inline(always)]
            fn from(val: Mstpc15) -> u8 {
                Mstpc15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc28 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc28 {
                Mstpc28::from_bits(val)
            }
        }
        impl From<Mstpc28> for u8 {
            #[inline(always)]
            fn from(val: Mstpc28) -> u8 {
                Mstpc28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc31 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc31 {
                Mstpc31::from_bits(val)
            }
        }
        impl From<Mstpc31> for u8 {
            #[inline(always)]
            fn from(val: Mstpc31) -> u8 {
                Mstpc31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc4 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc4 {
                Mstpc4::from_bits(val)
            }
        }
        impl From<Mstpc4> for u8 {
            #[inline(always)]
            fn from(val: Mstpc4) -> u8 {
                Mstpc4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd0 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd0 {
                Mstpd0::from_bits(val)
            }
        }
        impl From<Mstpd0> for u8 {
            #[inline(always)]
            fn from(val: Mstpd0) -> u8 {
                Mstpd0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd1 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd1 {
                Mstpd1::from_bits(val)
            }
        }
        impl From<Mstpd1> for u8 {
            #[inline(always)]
            fn from(val: Mstpd1) -> u8 {
                Mstpd1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd10 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd10 {
                Mstpd10::from_bits(val)
            }
        }
        impl From<Mstpd10> for u8 {
            #[inline(always)]
            fn from(val: Mstpd10) -> u8 {
                Mstpd10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd14 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd14 {
                Mstpd14::from_bits(val)
            }
        }
        impl From<Mstpd14> for u8 {
            #[inline(always)]
            fn from(val: Mstpd14) -> u8 {
                Mstpd14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd16 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd16 {
                Mstpd16::from_bits(val)
            }
        }
        impl From<Mstpd16> for u8 {
            #[inline(always)]
            fn from(val: Mstpd16) -> u8 {
                Mstpd16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd17 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd17 {
                Mstpd17::from_bits(val)
            }
        }
        impl From<Mstpd17> for u8 {
            #[inline(always)]
            fn from(val: Mstpd17) -> u8 {
                Mstpd17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd18 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd18 {
                Mstpd18::from_bits(val)
            }
        }
        impl From<Mstpd18> for u8 {
            #[inline(always)]
            fn from(val: Mstpd18) -> u8 {
                Mstpd18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd19 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd19 {
                Mstpd19::from_bits(val)
            }
        }
        impl From<Mstpd19> for u8 {
            #[inline(always)]
            fn from(val: Mstpd19) -> u8 {
                Mstpd19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd2 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd2 {
                Mstpd2::from_bits(val)
            }
        }
        impl From<Mstpd2> for u8 {
            #[inline(always)]
            fn from(val: Mstpd2) -> u8 {
                Mstpd2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd3 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd3 {
                Mstpd3::from_bits(val)
            }
        }
        impl From<Mstpd3> for u8 {
            #[inline(always)]
            fn from(val: Mstpd3) -> u8 {
                Mstpd3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd6 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd6 {
                Mstpd6::from_bits(val)
            }
        }
        impl From<Mstpd6> for u8 {
            #[inline(always)]
            fn from(val: Mstpd6) -> u8 {
                Mstpd6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd7 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd7 {
                Mstpd7::from_bits(val)
            }
        }
        impl From<Mstpd7> for u8 {
            #[inline(always)]
            fn from(val: Mstpd7) -> u8 {
                Mstpd7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd8 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd8 {
                Mstpd8::from_bits(val)
            }
        }
        impl From<Mstpd8> for u8 {
            #[inline(always)]
            fn from(val: Mstpd8) -> u8 {
                Mstpd8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd9 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd9 {
                Mstpd9::from_bits(val)
            }
        }
        impl From<Mstpd9> for u8 {
            #[inline(always)]
            fn from(val: Mstpd9) -> u8 {
                Mstpd9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcrwdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcrwdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcrwdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcrwdis {
            #[inline(always)]
            fn from(val: u8) -> Rtcrwdis {
                Rtcrwdis::from_bits(val)
            }
        }
        impl From<Rtcrwdis> for u8 {
            #[inline(always)]
            fn from(val: Rtcrwdis) -> u8 {
                Rtcrwdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtdis {
            #[inline(always)]
            fn from(val: u8) -> Wdtdis {
                Wdtdis::from_bits(val)
            }
        }
        impl From<Wdtdis> for u8 {
            #[inline(always)]
            fn from(val: Wdtdis) -> u8 {
                Wdtdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wren {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wren {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wren {
            #[inline(always)]
            fn from(val: u8) -> Wren {
                Wren::from_bits(val)
            }
        }
        impl From<Wren> for u8 {
            #[inline(always)]
            fn from(val: Wren) -> u8 {
                Wren::to_bits(val)
            }
        }
    }
}
pub mod pfs {
    #[doc = "Pmn Pin Function Control Register"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pfs {
        ptr: *mut u8,
    }
    unsafe impl Send for Pfs {}
    unsafe impl Sync for Pfs {}
    impl Pfs {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p00pfs(self, n: usize) -> crate::common::Reg<regs::P00pfs, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p00pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P00pfsHa, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize + n * 4usize) as _) }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p00pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P00pfsBy, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize + n * 4usize) as _) }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p00pfs_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P00pfs1, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p00pfs_ha_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P00pfsHa1, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize + n * 4usize) as _) }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p00pfs_by_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P00pfsBy1, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13usize + n * 4usize) as _) }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs(self, n: usize) -> crate::common::Reg<regs::P0pfs, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize + n * 4usize) as _) }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P0pfsHa, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2ausize + n * 4usize) as _) }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P0pfsBy, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2busize + n * 4usize) as _) }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p10pfs(self, n: usize) -> crate::common::Reg<regs::P10pfs, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 4usize) as _) }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p10pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P10pfsHa, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x42usize + n * 4usize) as _) }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p10pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P10pfsBy, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x43usize + n * 4usize) as _) }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p108pfs(self) -> crate::common::Reg<regs::P108pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p108pfs_ha(self) -> crate::common::Reg<regs::P108pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x62usize) as _) }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p108pfs_by(self) -> crate::common::Reg<regs::P108pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x63usize) as _) }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p109pfs(self) -> crate::common::Reg<regs::P109pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p109pfs_ha(self) -> crate::common::Reg<regs::P109pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x66usize) as _) }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p109pfs_by(self) -> crate::common::Reg<regs::P109pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x67usize) as _) }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p1pfs(self, n: usize) -> crate::common::Reg<regs::P1pfs, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize + n * 4usize) as _) }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p1pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P1pfsHa, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6ausize + n * 4usize) as _) }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p1pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P1pfsBy, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6busize + n * 4usize) as _) }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p200pfs(self) -> crate::common::Reg<regs::P200pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p200pfs_ha(self) -> crate::common::Reg<regs::P200pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x82usize) as _) }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p200pfs_by(self) -> crate::common::Reg<regs::P200pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x83usize) as _) }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p201pfs(self) -> crate::common::Reg<regs::P201pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p201pfs_ha(self) -> crate::common::Reg<regs::P201pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x86usize) as _) }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p201pfs_by(self) -> crate::common::Reg<regs::P201pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x87usize) as _) }
        }
        #[doc = "Port 20%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p20pfs(self, n: usize) -> crate::common::Reg<regs::P20pfs, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize + n * 4usize) as _) }
        }
        #[doc = "Port 20%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p20pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P20pfsHa, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8eusize + n * 4usize) as _) }
        }
        #[doc = "Port 20%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p20pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P20pfsBy, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8fusize + n * 4usize) as _) }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p2pfs(self, n: usize) -> crate::common::Reg<regs::P2pfs, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize + n * 4usize) as _) }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p2pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P2pfsHa, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xaausize + n * 4usize) as _) }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p2pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P2pfsBy, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xabusize + n * 4usize) as _) }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p300pfs(self) -> crate::common::Reg<regs::P300pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p300pfs_ha(self) -> crate::common::Reg<regs::P300pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc2usize) as _) }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p300pfs_by(self) -> crate::common::Reg<regs::P300pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc3usize) as _) }
        }
        #[doc = "Port 30%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p30pfs(self, n: usize) -> crate::common::Reg<regs::P30pfs, crate::common::RW> {
            assert!(n < 9usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc4usize + n * 4usize) as _) }
        }
        #[doc = "Port 30%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p30pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P30pfsHa, crate::common::RW> {
            assert!(n < 9usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc6usize + n * 4usize) as _) }
        }
        #[doc = "Port 30%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p30pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P30pfsBy, crate::common::RW> {
            assert!(n < 9usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc7usize + n * 4usize) as _) }
        }
        #[doc = "Port 3%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p3pfs(self, n: usize) -> crate::common::Reg<regs::P3pfs, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe8usize + n * 4usize) as _) }
        }
        #[doc = "Port 3%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p3pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P3pfsHa, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xeausize + n * 4usize) as _) }
        }
        #[doc = "Port 3%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p3pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P3pfsBy, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xebusize + n * 4usize) as _) }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p40pfs(self, n: usize) -> crate::common::Reg<regs::P40pfs, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p40pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P40pfsHa, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize + n * 4usize) as _) }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p40pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P40pfsBy, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0103usize + n * 4usize) as _) }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p40pfs_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P40pfs1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize + n * 4usize) as _) }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p40pfs_ha_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P40pfsHa1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0122usize + n * 4usize) as _) }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p40pfs_by_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P40pfsBy1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0123usize + n * 4usize) as _) }
        }
        #[doc = "Port 4%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p4pfs(self, n: usize) -> crate::common::Reg<regs::P4pfs, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize + n * 4usize) as _) }
        }
        #[doc = "Port 4%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p4pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P4pfsHa, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012ausize + n * 4usize) as _) }
        }
        #[doc = "Port 4%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p4pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P4pfsBy, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012busize + n * 4usize) as _) }
        }
        #[doc = "Port 50%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p50pfs(self, n: usize) -> crate::common::Reg<regs::P50pfs, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize + n * 4usize) as _) }
        }
        #[doc = "Port 50%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p50pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P50pfsHa, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0142usize + n * 4usize) as _) }
        }
        #[doc = "Port 50%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p50pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P50pfsBy, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0143usize + n * 4usize) as _) }
        }
        #[doc = "Port 600 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p600pfs(self) -> crate::common::Reg<regs::P600pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Port 600 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p600pfs_ha(self) -> crate::common::Reg<regs::P600pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0182usize) as _) }
        }
        #[doc = "Port 600 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p600pfs_by(self) -> crate::common::Reg<regs::P600pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0183usize) as _) }
        }
        #[doc = "VL1 Select Control Register"]
        #[inline(always)]
        pub const fn vl1sel(self) -> crate::common::Reg<regs::Vl1sel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0185usize) as _) }
        }
        #[doc = "Write,Protect Register"]
        #[inline(always)]
        pub const fn pwpr(self) -> crate::common::Reg<regs::Pwpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0503usize) as _) }
        }
        #[doc = "Port Read Wait Control Register"]
        #[inline(always)]
        pub const fn prwcntr(self) -> crate::common::Reg<regs::Prwcntr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050fusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port 00%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P00pfs(pub u32);
        impl P00pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P00pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P00pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P00pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P00pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P00pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P00pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P00pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P00pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P00pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P00pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P00pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P00pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P00pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P00pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P00pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P00pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P00pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P00pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P00pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P00pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P00pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P00pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P00pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P00pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P00pfs {
            #[inline(always)]
            fn default() -> P00pfs {
                P00pfs(0)
            }
        }
        impl core::fmt::Debug for P00pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P00pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P00pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P00pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P00pfs1(pub u32);
        impl P00pfs1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P00pfs1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P00pfs1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P00pfs1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P00pfs1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P00pfs1Pidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P00pfs1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P00pfs1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P00pfs1Pdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P00pfs1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P00pfs1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P00pfs1Pcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P00pfs1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P00pfs1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P00pfs1Ncodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P00pfs1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P00pfs1Isel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P00pfs1Isel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P00pfs1Isel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P00pfs1Asel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P00pfs1Asel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P00pfs1Asel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P00pfs1Pmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P00pfs1Pmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P00pfs1Pmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P00pfs1 {
            #[inline(always)]
            fn default() -> P00pfs1 {
                P00pfs1(0)
            }
        }
        impl core::fmt::Debug for P00pfs1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P00pfs1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P00pfs1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P00pfs1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P00pfsBy(pub u8);
        impl P00pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P00pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P00pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P00pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P00pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P00pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P00pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P00pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P00pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P00pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P00pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P00pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P00pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P00pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P00pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P00pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P00pfsBy {
            #[inline(always)]
            fn default() -> P00pfsBy {
                P00pfsBy(0)
            }
        }
        impl core::fmt::Debug for P00pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P00pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P00pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P00pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P00pfsBy1(pub u8);
        impl P00pfsBy1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P00pfsBy1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P00pfsBy1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P00pfsBy1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P00pfsBy1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P00pfsBy1Pidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P00pfsBy1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P00pfsBy1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P00pfsBy1Pdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P00pfsBy1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P00pfsBy1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P00pfsBy1Pcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P00pfsBy1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P00pfsBy1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P00pfsBy1Ncodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P00pfsBy1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P00pfsBy1 {
            #[inline(always)]
            fn default() -> P00pfsBy1 {
                P00pfsBy1(0)
            }
        }
        impl core::fmt::Debug for P00pfsBy1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P00pfsBy1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P00pfsBy1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P00pfsBy1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P00pfsHa(pub u16);
        impl P00pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P00pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P00pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P00pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P00pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P00pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P00pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P00pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P00pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P00pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P00pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P00pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P00pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P00pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P00pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P00pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P00pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P00pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P00pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P00pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P00pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P00pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P00pfsHa {
            #[inline(always)]
            fn default() -> P00pfsHa {
                P00pfsHa(0)
            }
        }
        impl core::fmt::Debug for P00pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P00pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P00pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P00pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 00%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P00pfsHa1(pub u16);
        impl P00pfsHa1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P00pfsHa1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P00pfsHa1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P00pfsHa1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P00pfsHa1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P00pfsHa1Pidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P00pfsHa1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P00pfsHa1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P00pfsHa1Pdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P00pfsHa1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P00pfsHa1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P00pfsHa1Pcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P00pfsHa1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P00pfsHa1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P00pfsHa1Ncodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P00pfsHa1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P00pfsHa1Isel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P00pfsHa1Isel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P00pfsHa1Isel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P00pfsHa1Asel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P00pfsHa1Asel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P00pfsHa1Asel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P00pfsHa1 {
            #[inline(always)]
            fn default() -> P00pfsHa1 {
                P00pfsHa1(0)
            }
        }
        impl core::fmt::Debug for P00pfsHa1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P00pfsHa1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P00pfsHa1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P00pfsHa1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfs(pub u32);
        impl P0pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P0pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P0pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P0pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P0pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P0pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P0pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P0pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P0pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P0pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P0pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P0pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P0pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P0pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P0pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P0pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P0pfs {
            #[inline(always)]
            fn default() -> P0pfs {
                P0pfs(0)
            }
        }
        impl core::fmt::Debug for P0pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P0pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfsBy(pub u8);
        impl P0pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P0pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P0pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P0pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P0pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P0pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P0pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P0pfsBy {
            #[inline(always)]
            fn default() -> P0pfsBy {
                P0pfsBy(0)
            }
        }
        impl core::fmt::Debug for P0pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P0pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfsHa(pub u16);
        impl P0pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P0pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P0pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P0pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P0pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P0pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P0pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P0pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P0pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P0pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P0pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P0pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P0pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P0pfsHa {
            #[inline(always)]
            fn default() -> P0pfsHa {
                P0pfsHa(0)
            }
        }
        impl core::fmt::Debug for P0pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P0pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P108pfs(pub u32);
        impl P108pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P108pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P108pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P108pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P108pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P108pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P108pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P108pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P108pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P108pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P108pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P108pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P108pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P108pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P108pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P108pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P108pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P108pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P108pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P108pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P108pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P108pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P108pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P108pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P108pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P108pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P108pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P108pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P108pfs {
            #[inline(always)]
            fn default() -> P108pfs {
                P108pfs(0)
            }
        }
        impl core::fmt::Debug for P108pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P108pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P108pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P108pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P108pfsBy(pub u8);
        impl P108pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P108pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P108pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P108pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P108pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P108pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P108pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P108pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P108pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P108pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P108pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P108pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P108pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P108pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P108pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P108pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P108pfsBy {
            #[inline(always)]
            fn default() -> P108pfsBy {
                P108pfsBy(0)
            }
        }
        impl core::fmt::Debug for P108pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P108pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P108pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P108pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P108pfsHa(pub u16);
        impl P108pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P108pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P108pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P108pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P108pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P108pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P108pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P108pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P108pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P108pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P108pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P108pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P108pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P108pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P108pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P108pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P108pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P108pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P108pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P108pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P108pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P108pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P108pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P108pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P108pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P108pfsHa {
            #[inline(always)]
            fn default() -> P108pfsHa {
                P108pfsHa(0)
            }
        }
        impl core::fmt::Debug for P108pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P108pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P108pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P108pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P109pfs(pub u32);
        impl P109pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P109pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P109pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P109pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P109pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P109pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P109pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P109pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P109pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P109pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P109pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P109pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P109pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P109pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P109pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P109pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P109pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P109pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P109pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P109pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P109pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P109pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P109pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P109pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P109pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P109pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P109pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P109pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P109pfs {
            #[inline(always)]
            fn default() -> P109pfs {
                P109pfs(0)
            }
        }
        impl core::fmt::Debug for P109pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P109pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P109pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P109pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P109pfsBy(pub u8);
        impl P109pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P109pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P109pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P109pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P109pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P109pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P109pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P109pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P109pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P109pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P109pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P109pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P109pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P109pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P109pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P109pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P109pfsBy {
            #[inline(always)]
            fn default() -> P109pfsBy {
                P109pfsBy(0)
            }
        }
        impl core::fmt::Debug for P109pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P109pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P109pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P109pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P109pfsHa(pub u16);
        impl P109pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P109pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P109pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P109pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P109pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P109pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P109pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P109pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P109pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P109pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P109pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P109pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P109pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P109pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P109pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P109pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P109pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P109pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P109pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P109pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P109pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P109pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P109pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P109pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P109pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P109pfsHa {
            #[inline(always)]
            fn default() -> P109pfsHa {
                P109pfsHa(0)
            }
        }
        impl core::fmt::Debug for P109pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P109pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P109pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P109pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P10pfs(pub u32);
        impl P10pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P10pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P10pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P10pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P10pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P10pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P10pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P10pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P10pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P10pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P10pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P10pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P10pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P10pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P10pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P10pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P10pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P10pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P10pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P10pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P10pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P10pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P10pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P10pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P10pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P10pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P10pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P10pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P10pfs {
            #[inline(always)]
            fn default() -> P10pfs {
                P10pfs(0)
            }
        }
        impl core::fmt::Debug for P10pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P10pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P10pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P10pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P10pfsBy(pub u8);
        impl P10pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P10pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P10pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P10pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P10pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P10pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P10pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P10pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P10pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P10pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P10pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P10pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P10pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P10pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P10pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P10pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P10pfsBy {
            #[inline(always)]
            fn default() -> P10pfsBy {
                P10pfsBy(0)
            }
        }
        impl core::fmt::Debug for P10pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P10pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P10pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P10pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P10pfsHa(pub u16);
        impl P10pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P10pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P10pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P10pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P10pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P10pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P10pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P10pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P10pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P10pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P10pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P10pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P10pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P10pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P10pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P10pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P10pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P10pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P10pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P10pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P10pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P10pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P10pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P10pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P10pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P10pfsHa {
            #[inline(always)]
            fn default() -> P10pfsHa {
                P10pfsHa(0)
            }
        }
        impl core::fmt::Debug for P10pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P10pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P10pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P10pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P1pfs(pub u32);
        impl P1pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P1pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P1pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P1pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P1pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P1pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P1pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P1pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P1pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P1pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P1pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P1pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P1pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P1pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P1pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P1pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P1pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P1pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P1pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P1pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P1pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P1pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P1pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P1pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P1pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P1pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P1pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P1pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P1pfs {
            #[inline(always)]
            fn default() -> P1pfs {
                P1pfs(0)
            }
        }
        impl core::fmt::Debug for P1pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P1pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P1pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P1pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P1pfsBy(pub u8);
        impl P1pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P1pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P1pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P1pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P1pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P1pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P1pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P1pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P1pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P1pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P1pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P1pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P1pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P1pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P1pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P1pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P1pfsBy {
            #[inline(always)]
            fn default() -> P1pfsBy {
                P1pfsBy(0)
            }
        }
        impl core::fmt::Debug for P1pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P1pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P1pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P1pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P1pfsHa(pub u16);
        impl P1pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P1pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P1pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P1pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P1pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P1pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P1pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P1pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P1pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P1pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P1pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P1pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P1pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P1pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P1pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P1pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P1pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P1pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P1pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P1pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P1pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P1pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P1pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P1pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P1pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P1pfsHa {
            #[inline(always)]
            fn default() -> P1pfsHa {
                P1pfsHa(0)
            }
        }
        impl core::fmt::Debug for P1pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P1pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P1pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P1pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P200pfs(pub u32);
        impl P200pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P200pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P200pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P200pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P200pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P200pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P200pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P200pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P200pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P200pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P200pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P200pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P200pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P200pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P200pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P200pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P200pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P200pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P200pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P200pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P200pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P200pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P200pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P200pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P200pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P200pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P200pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P200pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P200pfs {
            #[inline(always)]
            fn default() -> P200pfs {
                P200pfs(0)
            }
        }
        impl core::fmt::Debug for P200pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P200pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P200pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P200pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P200pfsBy(pub u8);
        impl P200pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P200pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P200pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P200pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P200pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P200pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P200pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P200pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P200pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P200pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P200pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P200pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P200pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P200pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P200pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P200pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P200pfsBy {
            #[inline(always)]
            fn default() -> P200pfsBy {
                P200pfsBy(0)
            }
        }
        impl core::fmt::Debug for P200pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P200pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P200pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P200pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P200pfsHa(pub u16);
        impl P200pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P200pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P200pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P200pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P200pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P200pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P200pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P200pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P200pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P200pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P200pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P200pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P200pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P200pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P200pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P200pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P200pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P200pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P200pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P200pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P200pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P200pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P200pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P200pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P200pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P200pfsHa {
            #[inline(always)]
            fn default() -> P200pfsHa {
                P200pfsHa(0)
            }
        }
        impl core::fmt::Debug for P200pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P200pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P200pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P200pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P201pfs(pub u32);
        impl P201pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P201pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P201pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P201pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P201pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P201pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P201pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P201pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P201pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P201pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P201pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P201pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P201pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P201pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P201pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P201pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P201pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P201pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P201pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P201pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P201pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P201pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P201pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P201pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P201pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P201pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P201pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P201pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P201pfs {
            #[inline(always)]
            fn default() -> P201pfs {
                P201pfs(0)
            }
        }
        impl core::fmt::Debug for P201pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P201pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P201pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P201pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P201pfsBy(pub u8);
        impl P201pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P201pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P201pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P201pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P201pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P201pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P201pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P201pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P201pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P201pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P201pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P201pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P201pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P201pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P201pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P201pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P201pfsBy {
            #[inline(always)]
            fn default() -> P201pfsBy {
                P201pfsBy(0)
            }
        }
        impl core::fmt::Debug for P201pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P201pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P201pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P201pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P201pfsHa(pub u16);
        impl P201pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P201pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P201pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P201pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P201pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P201pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P201pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P201pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P201pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P201pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P201pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P201pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P201pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P201pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P201pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P201pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P201pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P201pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P201pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P201pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P201pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P201pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P201pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P201pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P201pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P201pfsHa {
            #[inline(always)]
            fn default() -> P201pfsHa {
                P201pfsHa(0)
            }
        }
        impl core::fmt::Debug for P201pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P201pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P201pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P201pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 20%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P20pfs(pub u32);
        impl P20pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P20pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P20pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P20pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P20pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P20pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P20pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P20pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P20pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P20pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P20pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P20pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P20pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P20pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P20pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P20pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P20pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P20pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P20pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P20pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P20pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P20pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P20pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P20pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P20pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P20pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P20pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P20pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P20pfs {
            #[inline(always)]
            fn default() -> P20pfs {
                P20pfs(0)
            }
        }
        impl core::fmt::Debug for P20pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P20pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P20pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P20pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 20%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P20pfsBy(pub u8);
        impl P20pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P20pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P20pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P20pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P20pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P20pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P20pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P20pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P20pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P20pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P20pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P20pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P20pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P20pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P20pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P20pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P20pfsBy {
            #[inline(always)]
            fn default() -> P20pfsBy {
                P20pfsBy(0)
            }
        }
        impl core::fmt::Debug for P20pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P20pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P20pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P20pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 20%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P20pfsHa(pub u16);
        impl P20pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P20pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P20pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P20pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P20pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P20pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P20pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P20pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P20pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P20pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P20pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P20pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P20pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P20pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P20pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P20pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P20pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P20pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P20pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P20pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P20pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P20pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P20pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P20pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P20pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P20pfsHa {
            #[inline(always)]
            fn default() -> P20pfsHa {
                P20pfsHa(0)
            }
        }
        impl core::fmt::Debug for P20pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P20pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P20pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P20pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P2pfs(pub u32);
        impl P2pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P2pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P2pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P2pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P2pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P2pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P2pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P2pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P2pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P2pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P2pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P2pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P2pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P2pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P2pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P2pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P2pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P2pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P2pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P2pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P2pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P2pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P2pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P2pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P2pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P2pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P2pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P2pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P2pfs {
            #[inline(always)]
            fn default() -> P2pfs {
                P2pfs(0)
            }
        }
        impl core::fmt::Debug for P2pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P2pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P2pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P2pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P2pfsBy(pub u8);
        impl P2pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P2pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P2pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P2pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P2pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P2pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P2pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P2pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P2pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P2pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P2pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P2pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P2pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P2pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P2pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P2pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P2pfsBy {
            #[inline(always)]
            fn default() -> P2pfsBy {
                P2pfsBy(0)
            }
        }
        impl core::fmt::Debug for P2pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P2pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P2pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P2pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 2%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P2pfsHa(pub u16);
        impl P2pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P2pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P2pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P2pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P2pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P2pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P2pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P2pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P2pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P2pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P2pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P2pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P2pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P2pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P2pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P2pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P2pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P2pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P2pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P2pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P2pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P2pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P2pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P2pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P2pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P2pfsHa {
            #[inline(always)]
            fn default() -> P2pfsHa {
                P2pfsHa(0)
            }
        }
        impl core::fmt::Debug for P2pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P2pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P2pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P2pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P300pfs(pub u32);
        impl P300pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P300pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P300pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P300pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P300pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P300pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P300pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P300pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P300pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P300pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P300pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P300pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P300pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P300pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P300pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P300pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P300pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P300pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P300pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P300pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P300pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P300pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P300pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P300pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P300pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P300pfs {
            #[inline(always)]
            fn default() -> P300pfs {
                P300pfs(0)
            }
        }
        impl core::fmt::Debug for P300pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P300pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P300pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P300pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P300pfsBy(pub u8);
        impl P300pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P300pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P300pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P300pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P300pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P300pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P300pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P300pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P300pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P300pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P300pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P300pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P300pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P300pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P300pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P300pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P300pfsBy {
            #[inline(always)]
            fn default() -> P300pfsBy {
                P300pfsBy(0)
            }
        }
        impl core::fmt::Debug for P300pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P300pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P300pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P300pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P300pfsHa(pub u16);
        impl P300pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P300pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P300pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P300pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P300pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P300pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P300pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P300pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P300pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P300pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P300pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P300pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P300pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P300pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P300pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P300pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P300pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P300pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P300pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P300pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P300pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P300pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P300pfsHa {
            #[inline(always)]
            fn default() -> P300pfsHa {
                P300pfsHa(0)
            }
        }
        impl core::fmt::Debug for P300pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P300pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P300pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P300pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 30%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P30pfs(pub u32);
        impl P30pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P30pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P30pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P30pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P30pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P30pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P30pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P30pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P30pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P30pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P30pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P30pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P30pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P30pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P30pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P30pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P30pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P30pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P30pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P30pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P30pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P30pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P30pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P30pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P30pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P30pfs {
            #[inline(always)]
            fn default() -> P30pfs {
                P30pfs(0)
            }
        }
        impl core::fmt::Debug for P30pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P30pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P30pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P30pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 30%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P30pfsBy(pub u8);
        impl P30pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P30pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P30pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P30pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P30pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P30pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P30pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P30pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P30pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P30pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P30pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P30pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P30pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P30pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P30pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P30pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P30pfsBy {
            #[inline(always)]
            fn default() -> P30pfsBy {
                P30pfsBy(0)
            }
        }
        impl core::fmt::Debug for P30pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P30pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P30pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P30pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 30%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P30pfsHa(pub u16);
        impl P30pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P30pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P30pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P30pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P30pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P30pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P30pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P30pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P30pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P30pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P30pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P30pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P30pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P30pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P30pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P30pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P30pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P30pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P30pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P30pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P30pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P30pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P30pfsHa {
            #[inline(always)]
            fn default() -> P30pfsHa {
                P30pfsHa(0)
            }
        }
        impl core::fmt::Debug for P30pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P30pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P30pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P30pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 3%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P3pfs(pub u32);
        impl P3pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P3pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P3pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P3pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P3pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P3pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P3pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P3pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P3pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P3pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P3pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P3pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P3pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P3pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P3pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P3pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P3pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P3pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P3pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P3pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P3pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P3pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P3pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P3pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P3pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P3pfs {
            #[inline(always)]
            fn default() -> P3pfs {
                P3pfs(0)
            }
        }
        impl core::fmt::Debug for P3pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P3pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P3pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P3pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 3%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P3pfsBy(pub u8);
        impl P3pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P3pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P3pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P3pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P3pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P3pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P3pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P3pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P3pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P3pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P3pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P3pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P3pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P3pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P3pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P3pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P3pfsBy {
            #[inline(always)]
            fn default() -> P3pfsBy {
                P3pfsBy(0)
            }
        }
        impl core::fmt::Debug for P3pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P3pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P3pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P3pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 3%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P3pfsHa(pub u16);
        impl P3pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P3pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P3pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P3pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P3pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P3pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P3pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P3pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P3pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P3pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P3pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P3pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P3pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P3pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P3pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P3pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P3pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P3pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P3pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P3pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P3pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P3pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P3pfsHa {
            #[inline(always)]
            fn default() -> P3pfsHa {
                P3pfsHa(0)
            }
        }
        impl core::fmt::Debug for P3pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P3pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P3pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P3pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P40pfs(pub u32);
        impl P40pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P40pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P40pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P40pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P40pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P40pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P40pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P40pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P40pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P40pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P40pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P40pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P40pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P40pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P40pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P40pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P40pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P40pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P40pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P40pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P40pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P40pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P40pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P40pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P40pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P40pfs {
            #[inline(always)]
            fn default() -> P40pfs {
                P40pfs(0)
            }
        }
        impl core::fmt::Debug for P40pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P40pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P40pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P40pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P40pfs1(pub u32);
        impl P40pfs1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P40pfs1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P40pfs1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P40pfs1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P40pfs1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P40pfs1Pidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P40pfs1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P40pfs1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P40pfs1Pdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P40pfs1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P40pfs1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P40pfs1Pcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P40pfs1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P40pfs1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P40pfs1Ncodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P40pfs1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P40pfs1Isel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P40pfs1Isel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P40pfs1Isel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P40pfs1Asel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P40pfs1Asel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P40pfs1Asel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P40pfs1Pmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P40pfs1Pmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P40pfs1Pmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P40pfs1 {
            #[inline(always)]
            fn default() -> P40pfs1 {
                P40pfs1(0)
            }
        }
        impl core::fmt::Debug for P40pfs1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P40pfs1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P40pfs1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P40pfs1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P40pfsBy(pub u8);
        impl P40pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P40pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P40pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P40pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P40pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P40pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P40pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P40pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P40pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P40pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P40pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P40pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P40pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P40pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P40pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P40pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P40pfsBy {
            #[inline(always)]
            fn default() -> P40pfsBy {
                P40pfsBy(0)
            }
        }
        impl core::fmt::Debug for P40pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P40pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P40pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P40pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P40pfsBy1(pub u8);
        impl P40pfsBy1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P40pfsBy1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P40pfsBy1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P40pfsBy1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P40pfsBy1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P40pfsBy1Pidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P40pfsBy1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P40pfsBy1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P40pfsBy1Pdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P40pfsBy1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P40pfsBy1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P40pfsBy1Pcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P40pfsBy1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P40pfsBy1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P40pfsBy1Ncodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P40pfsBy1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P40pfsBy1 {
            #[inline(always)]
            fn default() -> P40pfsBy1 {
                P40pfsBy1(0)
            }
        }
        impl core::fmt::Debug for P40pfsBy1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P40pfsBy1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P40pfsBy1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P40pfsBy1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P40pfsHa(pub u16);
        impl P40pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P40pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P40pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P40pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P40pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P40pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P40pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P40pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P40pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P40pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P40pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P40pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P40pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P40pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P40pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P40pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P40pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P40pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P40pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P40pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P40pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P40pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P40pfsHa {
            #[inline(always)]
            fn default() -> P40pfsHa {
                P40pfsHa(0)
            }
        }
        impl core::fmt::Debug for P40pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P40pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P40pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P40pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P40pfsHa1(pub u16);
        impl P40pfsHa1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P40pfsHa1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P40pfsHa1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P40pfsHa1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P40pfsHa1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P40pfsHa1Pidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P40pfsHa1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P40pfsHa1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P40pfsHa1Pdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P40pfsHa1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P40pfsHa1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P40pfsHa1Pcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P40pfsHa1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P40pfsHa1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P40pfsHa1Ncodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P40pfsHa1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P40pfsHa1Isel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P40pfsHa1Isel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P40pfsHa1Isel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P40pfsHa1Asel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P40pfsHa1Asel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P40pfsHa1Asel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P40pfsHa1 {
            #[inline(always)]
            fn default() -> P40pfsHa1 {
                P40pfsHa1(0)
            }
        }
        impl core::fmt::Debug for P40pfsHa1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P40pfsHa1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P40pfsHa1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P40pfsHa1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 4%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P4pfs(pub u32);
        impl P4pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P4pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P4pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P4pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P4pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P4pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P4pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P4pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P4pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P4pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P4pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P4pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P4pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P4pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P4pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P4pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P4pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P4pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P4pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P4pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P4pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P4pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P4pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P4pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P4pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P4pfs {
            #[inline(always)]
            fn default() -> P4pfs {
                P4pfs(0)
            }
        }
        impl core::fmt::Debug for P4pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P4pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P4pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P4pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 4%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P4pfsBy(pub u8);
        impl P4pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P4pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P4pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P4pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P4pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P4pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P4pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P4pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P4pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P4pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P4pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P4pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P4pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P4pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P4pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P4pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P4pfsBy {
            #[inline(always)]
            fn default() -> P4pfsBy {
                P4pfsBy(0)
            }
        }
        impl core::fmt::Debug for P4pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P4pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P4pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P4pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 4%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P4pfsHa(pub u16);
        impl P4pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P4pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P4pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P4pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P4pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P4pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P4pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P4pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P4pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P4pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P4pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P4pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P4pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P4pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P4pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P4pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P4pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P4pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P4pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P4pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P4pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P4pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P4pfsHa {
            #[inline(always)]
            fn default() -> P4pfsHa {
                P4pfsHa(0)
            }
        }
        impl core::fmt::Debug for P4pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P4pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P4pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P4pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 50%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P50pfs(pub u32);
        impl P50pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P50pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P50pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P50pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P50pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P50pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P50pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P50pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P50pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P50pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P50pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P50pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P50pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P50pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P50pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P50pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P50pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P50pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P50pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P50pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P50pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P50pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P50pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P50pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P50pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P50pfs {
            #[inline(always)]
            fn default() -> P50pfs {
                P50pfs(0)
            }
        }
        impl core::fmt::Debug for P50pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P50pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P50pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P50pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 50%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P50pfsBy(pub u8);
        impl P50pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P50pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P50pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P50pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P50pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P50pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P50pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P50pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P50pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P50pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P50pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P50pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P50pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P50pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P50pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P50pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P50pfsBy {
            #[inline(always)]
            fn default() -> P50pfsBy {
                P50pfsBy(0)
            }
        }
        impl core::fmt::Debug for P50pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P50pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P50pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P50pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 50%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P50pfsHa(pub u16);
        impl P50pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P50pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P50pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P50pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P50pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P50pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P50pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P50pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P50pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P50pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P50pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P50pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P50pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P50pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P50pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P50pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P50pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P50pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P50pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P50pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P50pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P50pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P50pfsHa {
            #[inline(always)]
            fn default() -> P50pfsHa {
                P50pfsHa(0)
            }
        }
        impl core::fmt::Debug for P50pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P50pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P50pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P50pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 600 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P600pfs(pub u32);
        impl P600pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P600pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P600pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P600pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P600pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P600pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P600pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P600pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P600pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P600pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P600pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P600pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P600pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P600pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P600pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P600pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P600pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P600pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P600pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P600pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P600pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P600pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P600pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P600pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P600pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P600pfs {
            #[inline(always)]
            fn default() -> P600pfs {
                P600pfs(0)
            }
        }
        impl core::fmt::Debug for P600pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P600pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P600pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P600pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 600 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P600pfsBy(pub u8);
        impl P600pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P600pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P600pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P600pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P600pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P600pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P600pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P600pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P600pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P600pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P600pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P600pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P600pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P600pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P600pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P600pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P600pfsBy {
            #[inline(always)]
            fn default() -> P600pfsBy {
                P600pfsBy(0)
            }
        }
        impl core::fmt::Debug for P600pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P600pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P600pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P600pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 600 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P600pfsHa(pub u16);
        impl P600pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P600pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P600pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P600pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P600pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P600pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P600pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P600pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P600pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P600pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P600pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P600pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P600pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P600pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P600pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P600pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P600pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P600pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P600pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P600pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P600pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P600pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P600pfsHa {
            #[inline(always)]
            fn default() -> P600pfsHa {
                P600pfsHa(0)
            }
        }
        impl core::fmt::Debug for P600pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P600pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P600pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P600pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port Read Wait Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prwcntr(pub u8);
        impl Prwcntr {
            #[doc = "Wait Cycle Control"]
            #[inline(always)]
            pub const fn wait(&self) -> super::vals::Wait {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Wait::from_bits(val as u8)
            }
            #[doc = "Wait Cycle Control"]
            #[inline(always)]
            pub fn set_wait(&mut self, val: super::vals::Wait) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Prwcntr {
            #[inline(always)]
            fn default() -> Prwcntr {
                Prwcntr(0)
            }
        }
        impl core::fmt::Debug for Prwcntr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prwcntr")
                    .field("wait", &self.wait())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prwcntr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prwcntr {{ wait: {:?} }}", self.wait())
            }
        }
        #[doc = "Write,Protect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwpr(pub u8);
        impl Pwpr {
            #[doc = "PmnPFS Register Write Enable"]
            #[inline(always)]
            pub const fn pfswe(&self) -> super::vals::Pfswe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pfswe::from_bits(val as u8)
            }
            #[doc = "PmnPFS Register Write Enable"]
            #[inline(always)]
            pub fn set_pfswe(&mut self, val: super::vals::Pfswe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "PFSWE Bit Write Disable"]
            #[inline(always)]
            pub const fn b0wi(&self) -> super::vals::B0wi {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::B0wi::from_bits(val as u8)
            }
            #[doc = "PFSWE Bit Write Disable"]
            #[inline(always)]
            pub fn set_b0wi(&mut self, val: super::vals::B0wi) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Pwpr {
            #[inline(always)]
            fn default() -> Pwpr {
                Pwpr(0)
            }
        }
        impl core::fmt::Debug for Pwpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwpr")
                    .field("pfswe", &self.pfswe())
                    .field("b0wi", &self.b0wi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pwpr {{ pfswe: {:?}, b0wi: {:?} }}",
                    self.pfswe(),
                    self.b0wi()
                )
            }
        }
        #[doc = "VL1 Select Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vl1sel(pub u8);
        impl Vl1sel {
            #[doc = "VL1 Voltage Connection Switching Control"]
            #[inline(always)]
            pub const fn selvl(&self) -> super::vals::Selvl {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Selvl::from_bits(val as u8)
            }
            #[doc = "VL1 Voltage Connection Switching Control"]
            #[inline(always)]
            pub fn set_selvl(&mut self, val: super::vals::Selvl) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Vl1sel {
            #[inline(always)]
            fn default() -> Vl1sel {
                Vl1sel(0)
            }
        }
        impl core::fmt::Debug for Vl1sel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vl1sel")
                    .field("selvl", &self.selvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vl1sel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Vl1sel {{ selvl: {:?} }}", self.selvl())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum B0wi {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl B0wi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> B0wi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for B0wi {
            #[inline(always)]
            fn from(val: u8) -> B0wi {
                B0wi::from_bits(val)
            }
        }
        impl From<B0wi> for u8 {
            #[inline(always)]
            fn from(val: B0wi) -> u8 {
                B0wi::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfs1Asel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfs1Asel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfs1Asel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfs1Asel {
            #[inline(always)]
            fn from(val: u8) -> P00pfs1Asel {
                P00pfs1Asel::from_bits(val)
            }
        }
        impl From<P00pfs1Asel> for u8 {
            #[inline(always)]
            fn from(val: P00pfs1Asel) -> u8 {
                P00pfs1Asel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfs1Isel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfs1Isel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfs1Isel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfs1Isel {
            #[inline(always)]
            fn from(val: u8) -> P00pfs1Isel {
                P00pfs1Isel::from_bits(val)
            }
        }
        impl From<P00pfs1Isel> for u8 {
            #[inline(always)]
            fn from(val: P00pfs1Isel) -> u8 {
                P00pfs1Isel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfs1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfs1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfs1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfs1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfs1Ncodr {
                P00pfs1Ncodr::from_bits(val)
            }
        }
        impl From<P00pfs1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfs1Ncodr) -> u8 {
                P00pfs1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfs1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfs1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfs1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfs1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P00pfs1Pcr {
                P00pfs1Pcr::from_bits(val)
            }
        }
        impl From<P00pfs1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P00pfs1Pcr) -> u8 {
                P00pfs1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfs1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfs1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfs1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfs1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P00pfs1Pdr {
                P00pfs1Pdr::from_bits(val)
            }
        }
        impl From<P00pfs1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P00pfs1Pdr) -> u8 {
                P00pfs1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfs1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfs1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfs1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfs1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P00pfs1Pidr {
                P00pfs1Pidr::from_bits(val)
            }
        }
        impl From<P00pfs1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P00pfs1Pidr) -> u8 {
                P00pfs1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfs1Pmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfs1Pmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfs1Pmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfs1Pmr {
            #[inline(always)]
            fn from(val: u8) -> P00pfs1Pmr {
                P00pfs1Pmr::from_bits(val)
            }
        }
        impl From<P00pfs1Pmr> for u8 {
            #[inline(always)]
            fn from(val: P00pfs1Pmr) -> u8 {
                P00pfs1Pmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfs1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfs1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfs1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfs1Podr {
            #[inline(always)]
            fn from(val: u8) -> P00pfs1Podr {
                P00pfs1Podr::from_bits(val)
            }
        }
        impl From<P00pfs1Podr> for u8 {
            #[inline(always)]
            fn from(val: P00pfs1Podr) -> u8 {
                P00pfs1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P00pfsAsel {
                P00pfsAsel::from_bits(val)
            }
        }
        impl From<P00pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P00pfsAsel) -> u8 {
                P00pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsBy1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsBy1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsBy1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsBy1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsBy1Ncodr {
                P00pfsBy1Ncodr::from_bits(val)
            }
        }
        impl From<P00pfsBy1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsBy1Ncodr) -> u8 {
                P00pfsBy1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsBy1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsBy1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsBy1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsBy1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsBy1Pcr {
                P00pfsBy1Pcr::from_bits(val)
            }
        }
        impl From<P00pfsBy1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsBy1Pcr) -> u8 {
                P00pfsBy1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsBy1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsBy1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsBy1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsBy1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsBy1Pdr {
                P00pfsBy1Pdr::from_bits(val)
            }
        }
        impl From<P00pfsBy1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsBy1Pdr) -> u8 {
                P00pfsBy1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsBy1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsBy1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsBy1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsBy1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsBy1Pidr {
                P00pfsBy1Pidr::from_bits(val)
            }
        }
        impl From<P00pfsBy1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsBy1Pidr) -> u8 {
                P00pfsBy1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsBy1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsBy1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsBy1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsBy1Podr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsBy1Podr {
                P00pfsBy1Podr::from_bits(val)
            }
        }
        impl From<P00pfsBy1Podr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsBy1Podr) -> u8 {
                P00pfsBy1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsByNcodr {
                P00pfsByNcodr::from_bits(val)
            }
        }
        impl From<P00pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsByNcodr) -> u8 {
                P00pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsByPcr {
                P00pfsByPcr::from_bits(val)
            }
        }
        impl From<P00pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsByPcr) -> u8 {
                P00pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsByPdr {
                P00pfsByPdr::from_bits(val)
            }
        }
        impl From<P00pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsByPdr) -> u8 {
                P00pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsByPidr {
                P00pfsByPidr::from_bits(val)
            }
        }
        impl From<P00pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsByPidr) -> u8 {
                P00pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsByPodr {
                P00pfsByPodr::from_bits(val)
            }
        }
        impl From<P00pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsByPodr) -> u8 {
                P00pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHa1Asel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHa1Asel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHa1Asel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHa1Asel {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHa1Asel {
                P00pfsHa1Asel::from_bits(val)
            }
        }
        impl From<P00pfsHa1Asel> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHa1Asel) -> u8 {
                P00pfsHa1Asel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHa1Isel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHa1Isel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHa1Isel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHa1Isel {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHa1Isel {
                P00pfsHa1Isel::from_bits(val)
            }
        }
        impl From<P00pfsHa1Isel> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHa1Isel) -> u8 {
                P00pfsHa1Isel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHa1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHa1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHa1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHa1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHa1Ncodr {
                P00pfsHa1Ncodr::from_bits(val)
            }
        }
        impl From<P00pfsHa1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHa1Ncodr) -> u8 {
                P00pfsHa1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHa1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHa1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHa1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHa1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHa1Pcr {
                P00pfsHa1Pcr::from_bits(val)
            }
        }
        impl From<P00pfsHa1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHa1Pcr) -> u8 {
                P00pfsHa1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHa1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHa1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHa1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHa1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHa1Pdr {
                P00pfsHa1Pdr::from_bits(val)
            }
        }
        impl From<P00pfsHa1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHa1Pdr) -> u8 {
                P00pfsHa1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHa1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHa1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHa1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHa1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHa1Pidr {
                P00pfsHa1Pidr::from_bits(val)
            }
        }
        impl From<P00pfsHa1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHa1Pidr) -> u8 {
                P00pfsHa1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHa1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHa1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHa1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHa1Podr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHa1Podr {
                P00pfsHa1Podr::from_bits(val)
            }
        }
        impl From<P00pfsHa1Podr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHa1Podr) -> u8 {
                P00pfsHa1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHaAsel {
                P00pfsHaAsel::from_bits(val)
            }
        }
        impl From<P00pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHaAsel) -> u8 {
                P00pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHaIsel {
                P00pfsHaIsel::from_bits(val)
            }
        }
        impl From<P00pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHaIsel) -> u8 {
                P00pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHaNcodr {
                P00pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P00pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHaNcodr) -> u8 {
                P00pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHaPcr {
                P00pfsHaPcr::from_bits(val)
            }
        }
        impl From<P00pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHaPcr) -> u8 {
                P00pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHaPdr {
                P00pfsHaPdr::from_bits(val)
            }
        }
        impl From<P00pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHaPdr) -> u8 {
                P00pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHaPidr {
                P00pfsHaPidr::from_bits(val)
            }
        }
        impl From<P00pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHaPidr) -> u8 {
                P00pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsHaPodr {
                P00pfsHaPodr::from_bits(val)
            }
        }
        impl From<P00pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsHaPodr) -> u8 {
                P00pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P00pfsIsel {
                P00pfsIsel::from_bits(val)
            }
        }
        impl From<P00pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P00pfsIsel) -> u8 {
                P00pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsNcodr {
                P00pfsNcodr::from_bits(val)
            }
        }
        impl From<P00pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsNcodr) -> u8 {
                P00pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsPcr {
                P00pfsPcr::from_bits(val)
            }
        }
        impl From<P00pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsPcr) -> u8 {
                P00pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsPdr {
                P00pfsPdr::from_bits(val)
            }
        }
        impl From<P00pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsPdr) -> u8 {
                P00pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsPidr {
                P00pfsPidr::from_bits(val)
            }
        }
        impl From<P00pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsPidr) -> u8 {
                P00pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsPmr {
                P00pfsPmr::from_bits(val)
            }
        }
        impl From<P00pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsPmr) -> u8 {
                P00pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P00pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P00pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P00pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P00pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P00pfsPodr {
                P00pfsPodr::from_bits(val)
            }
        }
        impl From<P00pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P00pfsPodr) -> u8 {
                P00pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsAsel {
                P0pfsAsel::from_bits(val)
            }
        }
        impl From<P0pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsAsel) -> u8 {
                P0pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByNcodr {
                P0pfsByNcodr::from_bits(val)
            }
        }
        impl From<P0pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByNcodr) -> u8 {
                P0pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByPcr {
                P0pfsByPcr::from_bits(val)
            }
        }
        impl From<P0pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByPcr) -> u8 {
                P0pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByPdr {
                P0pfsByPdr::from_bits(val)
            }
        }
        impl From<P0pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByPdr) -> u8 {
                P0pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByPidr {
                P0pfsByPidr::from_bits(val)
            }
        }
        impl From<P0pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByPidr) -> u8 {
                P0pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByPodr {
                P0pfsByPodr::from_bits(val)
            }
        }
        impl From<P0pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByPodr) -> u8 {
                P0pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaAsel {
                P0pfsHaAsel::from_bits(val)
            }
        }
        impl From<P0pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaAsel) -> u8 {
                P0pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaIsel {
                P0pfsHaIsel::from_bits(val)
            }
        }
        impl From<P0pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaIsel) -> u8 {
                P0pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaNcodr {
                P0pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P0pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaNcodr) -> u8 {
                P0pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaPcr {
                P0pfsHaPcr::from_bits(val)
            }
        }
        impl From<P0pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaPcr) -> u8 {
                P0pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaPdr {
                P0pfsHaPdr::from_bits(val)
            }
        }
        impl From<P0pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaPdr) -> u8 {
                P0pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaPidr {
                P0pfsHaPidr::from_bits(val)
            }
        }
        impl From<P0pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaPidr) -> u8 {
                P0pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaPodr {
                P0pfsHaPodr::from_bits(val)
            }
        }
        impl From<P0pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaPodr) -> u8 {
                P0pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsIsel {
                P0pfsIsel::from_bits(val)
            }
        }
        impl From<P0pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsIsel) -> u8 {
                P0pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsNcodr {
                P0pfsNcodr::from_bits(val)
            }
        }
        impl From<P0pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsNcodr) -> u8 {
                P0pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPcr {
                P0pfsPcr::from_bits(val)
            }
        }
        impl From<P0pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPcr) -> u8 {
                P0pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPdr {
                P0pfsPdr::from_bits(val)
            }
        }
        impl From<P0pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPdr) -> u8 {
                P0pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPidr {
                P0pfsPidr::from_bits(val)
            }
        }
        impl From<P0pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPidr) -> u8 {
                P0pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPmr {
                P0pfsPmr::from_bits(val)
            }
        }
        impl From<P0pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPmr) -> u8 {
                P0pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPodr {
                P0pfsPodr::from_bits(val)
            }
        }
        impl From<P0pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPodr) -> u8 {
                P0pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P108pfsAsel {
                P108pfsAsel::from_bits(val)
            }
        }
        impl From<P108pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P108pfsAsel) -> u8 {
                P108pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByNcodr {
                P108pfsByNcodr::from_bits(val)
            }
        }
        impl From<P108pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByNcodr) -> u8 {
                P108pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByPcr {
                P108pfsByPcr::from_bits(val)
            }
        }
        impl From<P108pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByPcr) -> u8 {
                P108pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByPdr {
                P108pfsByPdr::from_bits(val)
            }
        }
        impl From<P108pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByPdr) -> u8 {
                P108pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByPidr {
                P108pfsByPidr::from_bits(val)
            }
        }
        impl From<P108pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByPidr) -> u8 {
                P108pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByPodr {
                P108pfsByPodr::from_bits(val)
            }
        }
        impl From<P108pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByPodr) -> u8 {
                P108pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P108pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsEofr {
                P108pfsEofr::from_bits(val)
            }
        }
        impl From<P108pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsEofr) -> u8 {
                P108pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaAsel {
                P108pfsHaAsel::from_bits(val)
            }
        }
        impl From<P108pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaAsel) -> u8 {
                P108pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P108pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaEofr {
                P108pfsHaEofr::from_bits(val)
            }
        }
        impl From<P108pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaEofr) -> u8 {
                P108pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaIsel {
                P108pfsHaIsel::from_bits(val)
            }
        }
        impl From<P108pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaIsel) -> u8 {
                P108pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaNcodr {
                P108pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P108pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaNcodr) -> u8 {
                P108pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaPcr {
                P108pfsHaPcr::from_bits(val)
            }
        }
        impl From<P108pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaPcr) -> u8 {
                P108pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaPdr {
                P108pfsHaPdr::from_bits(val)
            }
        }
        impl From<P108pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaPdr) -> u8 {
                P108pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaPidr {
                P108pfsHaPidr::from_bits(val)
            }
        }
        impl From<P108pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaPidr) -> u8 {
                P108pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaPodr {
                P108pfsHaPodr::from_bits(val)
            }
        }
        impl From<P108pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaPodr) -> u8 {
                P108pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P108pfsIsel {
                P108pfsIsel::from_bits(val)
            }
        }
        impl From<P108pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P108pfsIsel) -> u8 {
                P108pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsNcodr {
                P108pfsNcodr::from_bits(val)
            }
        }
        impl From<P108pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsNcodr) -> u8 {
                P108pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPcr {
                P108pfsPcr::from_bits(val)
            }
        }
        impl From<P108pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPcr) -> u8 {
                P108pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPdr {
                P108pfsPdr::from_bits(val)
            }
        }
        impl From<P108pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPdr) -> u8 {
                P108pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPidr {
                P108pfsPidr::from_bits(val)
            }
        }
        impl From<P108pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPidr) -> u8 {
                P108pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPmr {
                P108pfsPmr::from_bits(val)
            }
        }
        impl From<P108pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPmr) -> u8 {
                P108pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPodr {
                P108pfsPodr::from_bits(val)
            }
        }
        impl From<P108pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPodr) -> u8 {
                P108pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P109pfsAsel {
                P109pfsAsel::from_bits(val)
            }
        }
        impl From<P109pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P109pfsAsel) -> u8 {
                P109pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByNcodr {
                P109pfsByNcodr::from_bits(val)
            }
        }
        impl From<P109pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByNcodr) -> u8 {
                P109pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByPcr {
                P109pfsByPcr::from_bits(val)
            }
        }
        impl From<P109pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByPcr) -> u8 {
                P109pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByPdr {
                P109pfsByPdr::from_bits(val)
            }
        }
        impl From<P109pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByPdr) -> u8 {
                P109pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByPidr {
                P109pfsByPidr::from_bits(val)
            }
        }
        impl From<P109pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByPidr) -> u8 {
                P109pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByPodr {
                P109pfsByPodr::from_bits(val)
            }
        }
        impl From<P109pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByPodr) -> u8 {
                P109pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P109pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsEofr {
                P109pfsEofr::from_bits(val)
            }
        }
        impl From<P109pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsEofr) -> u8 {
                P109pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaAsel {
                P109pfsHaAsel::from_bits(val)
            }
        }
        impl From<P109pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaAsel) -> u8 {
                P109pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P109pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaEofr {
                P109pfsHaEofr::from_bits(val)
            }
        }
        impl From<P109pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaEofr) -> u8 {
                P109pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaIsel {
                P109pfsHaIsel::from_bits(val)
            }
        }
        impl From<P109pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaIsel) -> u8 {
                P109pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaNcodr {
                P109pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P109pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaNcodr) -> u8 {
                P109pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaPcr {
                P109pfsHaPcr::from_bits(val)
            }
        }
        impl From<P109pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaPcr) -> u8 {
                P109pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaPdr {
                P109pfsHaPdr::from_bits(val)
            }
        }
        impl From<P109pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaPdr) -> u8 {
                P109pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaPidr {
                P109pfsHaPidr::from_bits(val)
            }
        }
        impl From<P109pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaPidr) -> u8 {
                P109pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaPodr {
                P109pfsHaPodr::from_bits(val)
            }
        }
        impl From<P109pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaPodr) -> u8 {
                P109pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P109pfsIsel {
                P109pfsIsel::from_bits(val)
            }
        }
        impl From<P109pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P109pfsIsel) -> u8 {
                P109pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsNcodr {
                P109pfsNcodr::from_bits(val)
            }
        }
        impl From<P109pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsNcodr) -> u8 {
                P109pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPcr {
                P109pfsPcr::from_bits(val)
            }
        }
        impl From<P109pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPcr) -> u8 {
                P109pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPdr {
                P109pfsPdr::from_bits(val)
            }
        }
        impl From<P109pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPdr) -> u8 {
                P109pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPidr {
                P109pfsPidr::from_bits(val)
            }
        }
        impl From<P109pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPidr) -> u8 {
                P109pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPmr {
                P109pfsPmr::from_bits(val)
            }
        }
        impl From<P109pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPmr) -> u8 {
                P109pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPodr {
                P109pfsPodr::from_bits(val)
            }
        }
        impl From<P109pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPodr) -> u8 {
                P109pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsAsel {
                P10pfsAsel::from_bits(val)
            }
        }
        impl From<P10pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsAsel) -> u8 {
                P10pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByNcodr {
                P10pfsByNcodr::from_bits(val)
            }
        }
        impl From<P10pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByNcodr) -> u8 {
                P10pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByPcr {
                P10pfsByPcr::from_bits(val)
            }
        }
        impl From<P10pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByPcr) -> u8 {
                P10pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByPdr {
                P10pfsByPdr::from_bits(val)
            }
        }
        impl From<P10pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByPdr) -> u8 {
                P10pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByPidr {
                P10pfsByPidr::from_bits(val)
            }
        }
        impl From<P10pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByPidr) -> u8 {
                P10pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByPodr {
                P10pfsByPodr::from_bits(val)
            }
        }
        impl From<P10pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByPodr) -> u8 {
                P10pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P10pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsEofr {
                P10pfsEofr::from_bits(val)
            }
        }
        impl From<P10pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsEofr) -> u8 {
                P10pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaAsel {
                P10pfsHaAsel::from_bits(val)
            }
        }
        impl From<P10pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaAsel) -> u8 {
                P10pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P10pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaEofr {
                P10pfsHaEofr::from_bits(val)
            }
        }
        impl From<P10pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaEofr) -> u8 {
                P10pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaIsel {
                P10pfsHaIsel::from_bits(val)
            }
        }
        impl From<P10pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaIsel) -> u8 {
                P10pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaNcodr {
                P10pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P10pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaNcodr) -> u8 {
                P10pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaPcr {
                P10pfsHaPcr::from_bits(val)
            }
        }
        impl From<P10pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaPcr) -> u8 {
                P10pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaPdr {
                P10pfsHaPdr::from_bits(val)
            }
        }
        impl From<P10pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaPdr) -> u8 {
                P10pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaPidr {
                P10pfsHaPidr::from_bits(val)
            }
        }
        impl From<P10pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaPidr) -> u8 {
                P10pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaPodr {
                P10pfsHaPodr::from_bits(val)
            }
        }
        impl From<P10pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaPodr) -> u8 {
                P10pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsIsel {
                P10pfsIsel::from_bits(val)
            }
        }
        impl From<P10pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsIsel) -> u8 {
                P10pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsNcodr {
                P10pfsNcodr::from_bits(val)
            }
        }
        impl From<P10pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsNcodr) -> u8 {
                P10pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPcr {
                P10pfsPcr::from_bits(val)
            }
        }
        impl From<P10pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPcr) -> u8 {
                P10pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPdr {
                P10pfsPdr::from_bits(val)
            }
        }
        impl From<P10pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPdr) -> u8 {
                P10pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPidr {
                P10pfsPidr::from_bits(val)
            }
        }
        impl From<P10pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPidr) -> u8 {
                P10pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPmr {
                P10pfsPmr::from_bits(val)
            }
        }
        impl From<P10pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPmr) -> u8 {
                P10pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPodr {
                P10pfsPodr::from_bits(val)
            }
        }
        impl From<P10pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPodr) -> u8 {
                P10pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P1pfsAsel {
                P1pfsAsel::from_bits(val)
            }
        }
        impl From<P1pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P1pfsAsel) -> u8 {
                P1pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByNcodr {
                P1pfsByNcodr::from_bits(val)
            }
        }
        impl From<P1pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByNcodr) -> u8 {
                P1pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByPcr {
                P1pfsByPcr::from_bits(val)
            }
        }
        impl From<P1pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByPcr) -> u8 {
                P1pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByPdr {
                P1pfsByPdr::from_bits(val)
            }
        }
        impl From<P1pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByPdr) -> u8 {
                P1pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByPidr {
                P1pfsByPidr::from_bits(val)
            }
        }
        impl From<P1pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByPidr) -> u8 {
                P1pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByPodr {
                P1pfsByPodr::from_bits(val)
            }
        }
        impl From<P1pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByPodr) -> u8 {
                P1pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P1pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsEofr {
                P1pfsEofr::from_bits(val)
            }
        }
        impl From<P1pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsEofr) -> u8 {
                P1pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaAsel {
                P1pfsHaAsel::from_bits(val)
            }
        }
        impl From<P1pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaAsel) -> u8 {
                P1pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P1pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaEofr {
                P1pfsHaEofr::from_bits(val)
            }
        }
        impl From<P1pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaEofr) -> u8 {
                P1pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaIsel {
                P1pfsHaIsel::from_bits(val)
            }
        }
        impl From<P1pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaIsel) -> u8 {
                P1pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaNcodr {
                P1pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P1pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaNcodr) -> u8 {
                P1pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaPcr {
                P1pfsHaPcr::from_bits(val)
            }
        }
        impl From<P1pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaPcr) -> u8 {
                P1pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaPdr {
                P1pfsHaPdr::from_bits(val)
            }
        }
        impl From<P1pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaPdr) -> u8 {
                P1pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaPidr {
                P1pfsHaPidr::from_bits(val)
            }
        }
        impl From<P1pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaPidr) -> u8 {
                P1pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaPodr {
                P1pfsHaPodr::from_bits(val)
            }
        }
        impl From<P1pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaPodr) -> u8 {
                P1pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P1pfsIsel {
                P1pfsIsel::from_bits(val)
            }
        }
        impl From<P1pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P1pfsIsel) -> u8 {
                P1pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsNcodr {
                P1pfsNcodr::from_bits(val)
            }
        }
        impl From<P1pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsNcodr) -> u8 {
                P1pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPcr {
                P1pfsPcr::from_bits(val)
            }
        }
        impl From<P1pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPcr) -> u8 {
                P1pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPdr {
                P1pfsPdr::from_bits(val)
            }
        }
        impl From<P1pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPdr) -> u8 {
                P1pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPidr {
                P1pfsPidr::from_bits(val)
            }
        }
        impl From<P1pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPidr) -> u8 {
                P1pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPmr {
                P1pfsPmr::from_bits(val)
            }
        }
        impl From<P1pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPmr) -> u8 {
                P1pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPodr {
                P1pfsPodr::from_bits(val)
            }
        }
        impl From<P1pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPodr) -> u8 {
                P1pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P200pfsAsel {
                P200pfsAsel::from_bits(val)
            }
        }
        impl From<P200pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P200pfsAsel) -> u8 {
                P200pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByNcodr {
                P200pfsByNcodr::from_bits(val)
            }
        }
        impl From<P200pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByNcodr) -> u8 {
                P200pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByPcr {
                P200pfsByPcr::from_bits(val)
            }
        }
        impl From<P200pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByPcr) -> u8 {
                P200pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByPdr {
                P200pfsByPdr::from_bits(val)
            }
        }
        impl From<P200pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByPdr) -> u8 {
                P200pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByPidr {
                P200pfsByPidr::from_bits(val)
            }
        }
        impl From<P200pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByPidr) -> u8 {
                P200pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByPodr {
                P200pfsByPodr::from_bits(val)
            }
        }
        impl From<P200pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByPodr) -> u8 {
                P200pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P200pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsEofr {
                P200pfsEofr::from_bits(val)
            }
        }
        impl From<P200pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsEofr) -> u8 {
                P200pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaAsel {
                P200pfsHaAsel::from_bits(val)
            }
        }
        impl From<P200pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaAsel) -> u8 {
                P200pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P200pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaEofr {
                P200pfsHaEofr::from_bits(val)
            }
        }
        impl From<P200pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaEofr) -> u8 {
                P200pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaIsel {
                P200pfsHaIsel::from_bits(val)
            }
        }
        impl From<P200pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaIsel) -> u8 {
                P200pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaNcodr {
                P200pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P200pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaNcodr) -> u8 {
                P200pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaPcr {
                P200pfsHaPcr::from_bits(val)
            }
        }
        impl From<P200pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaPcr) -> u8 {
                P200pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaPdr {
                P200pfsHaPdr::from_bits(val)
            }
        }
        impl From<P200pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaPdr) -> u8 {
                P200pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaPidr {
                P200pfsHaPidr::from_bits(val)
            }
        }
        impl From<P200pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaPidr) -> u8 {
                P200pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaPodr {
                P200pfsHaPodr::from_bits(val)
            }
        }
        impl From<P200pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaPodr) -> u8 {
                P200pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P200pfsIsel {
                P200pfsIsel::from_bits(val)
            }
        }
        impl From<P200pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P200pfsIsel) -> u8 {
                P200pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsNcodr {
                P200pfsNcodr::from_bits(val)
            }
        }
        impl From<P200pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsNcodr) -> u8 {
                P200pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPcr {
                P200pfsPcr::from_bits(val)
            }
        }
        impl From<P200pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPcr) -> u8 {
                P200pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPdr {
                P200pfsPdr::from_bits(val)
            }
        }
        impl From<P200pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPdr) -> u8 {
                P200pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPidr {
                P200pfsPidr::from_bits(val)
            }
        }
        impl From<P200pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPidr) -> u8 {
                P200pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPmr {
                P200pfsPmr::from_bits(val)
            }
        }
        impl From<P200pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPmr) -> u8 {
                P200pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPodr {
                P200pfsPodr::from_bits(val)
            }
        }
        impl From<P200pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPodr) -> u8 {
                P200pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P201pfsAsel {
                P201pfsAsel::from_bits(val)
            }
        }
        impl From<P201pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P201pfsAsel) -> u8 {
                P201pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByNcodr {
                P201pfsByNcodr::from_bits(val)
            }
        }
        impl From<P201pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByNcodr) -> u8 {
                P201pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByPcr {
                P201pfsByPcr::from_bits(val)
            }
        }
        impl From<P201pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByPcr) -> u8 {
                P201pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByPdr {
                P201pfsByPdr::from_bits(val)
            }
        }
        impl From<P201pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByPdr) -> u8 {
                P201pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByPidr {
                P201pfsByPidr::from_bits(val)
            }
        }
        impl From<P201pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByPidr) -> u8 {
                P201pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByPodr {
                P201pfsByPodr::from_bits(val)
            }
        }
        impl From<P201pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByPodr) -> u8 {
                P201pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P201pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsEofr {
                P201pfsEofr::from_bits(val)
            }
        }
        impl From<P201pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsEofr) -> u8 {
                P201pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaAsel {
                P201pfsHaAsel::from_bits(val)
            }
        }
        impl From<P201pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaAsel) -> u8 {
                P201pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P201pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaEofr {
                P201pfsHaEofr::from_bits(val)
            }
        }
        impl From<P201pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaEofr) -> u8 {
                P201pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaIsel {
                P201pfsHaIsel::from_bits(val)
            }
        }
        impl From<P201pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaIsel) -> u8 {
                P201pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaNcodr {
                P201pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P201pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaNcodr) -> u8 {
                P201pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaPcr {
                P201pfsHaPcr::from_bits(val)
            }
        }
        impl From<P201pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaPcr) -> u8 {
                P201pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaPdr {
                P201pfsHaPdr::from_bits(val)
            }
        }
        impl From<P201pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaPdr) -> u8 {
                P201pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaPidr {
                P201pfsHaPidr::from_bits(val)
            }
        }
        impl From<P201pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaPidr) -> u8 {
                P201pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaPodr {
                P201pfsHaPodr::from_bits(val)
            }
        }
        impl From<P201pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaPodr) -> u8 {
                P201pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P201pfsIsel {
                P201pfsIsel::from_bits(val)
            }
        }
        impl From<P201pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P201pfsIsel) -> u8 {
                P201pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsNcodr {
                P201pfsNcodr::from_bits(val)
            }
        }
        impl From<P201pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsNcodr) -> u8 {
                P201pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPcr {
                P201pfsPcr::from_bits(val)
            }
        }
        impl From<P201pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPcr) -> u8 {
                P201pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPdr {
                P201pfsPdr::from_bits(val)
            }
        }
        impl From<P201pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPdr) -> u8 {
                P201pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPidr {
                P201pfsPidr::from_bits(val)
            }
        }
        impl From<P201pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPidr) -> u8 {
                P201pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPmr {
                P201pfsPmr::from_bits(val)
            }
        }
        impl From<P201pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPmr) -> u8 {
                P201pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPodr {
                P201pfsPodr::from_bits(val)
            }
        }
        impl From<P201pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPodr) -> u8 {
                P201pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P20pfsAsel {
                P20pfsAsel::from_bits(val)
            }
        }
        impl From<P20pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P20pfsAsel) -> u8 {
                P20pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsByNcodr {
                P20pfsByNcodr::from_bits(val)
            }
        }
        impl From<P20pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsByNcodr) -> u8 {
                P20pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsByPcr {
                P20pfsByPcr::from_bits(val)
            }
        }
        impl From<P20pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsByPcr) -> u8 {
                P20pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsByPdr {
                P20pfsByPdr::from_bits(val)
            }
        }
        impl From<P20pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsByPdr) -> u8 {
                P20pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsByPidr {
                P20pfsByPidr::from_bits(val)
            }
        }
        impl From<P20pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsByPidr) -> u8 {
                P20pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsByPodr {
                P20pfsByPodr::from_bits(val)
            }
        }
        impl From<P20pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsByPodr) -> u8 {
                P20pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P20pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsEofr {
                P20pfsEofr::from_bits(val)
            }
        }
        impl From<P20pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsEofr) -> u8 {
                P20pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P20pfsHaAsel {
                P20pfsHaAsel::from_bits(val)
            }
        }
        impl From<P20pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P20pfsHaAsel) -> u8 {
                P20pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P20pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsHaEofr {
                P20pfsHaEofr::from_bits(val)
            }
        }
        impl From<P20pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsHaEofr) -> u8 {
                P20pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P20pfsHaIsel {
                P20pfsHaIsel::from_bits(val)
            }
        }
        impl From<P20pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P20pfsHaIsel) -> u8 {
                P20pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsHaNcodr {
                P20pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P20pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsHaNcodr) -> u8 {
                P20pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsHaPcr {
                P20pfsHaPcr::from_bits(val)
            }
        }
        impl From<P20pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsHaPcr) -> u8 {
                P20pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsHaPdr {
                P20pfsHaPdr::from_bits(val)
            }
        }
        impl From<P20pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsHaPdr) -> u8 {
                P20pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsHaPidr {
                P20pfsHaPidr::from_bits(val)
            }
        }
        impl From<P20pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsHaPidr) -> u8 {
                P20pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsHaPodr {
                P20pfsHaPodr::from_bits(val)
            }
        }
        impl From<P20pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsHaPodr) -> u8 {
                P20pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P20pfsIsel {
                P20pfsIsel::from_bits(val)
            }
        }
        impl From<P20pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P20pfsIsel) -> u8 {
                P20pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsNcodr {
                P20pfsNcodr::from_bits(val)
            }
        }
        impl From<P20pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsNcodr) -> u8 {
                P20pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsPcr {
                P20pfsPcr::from_bits(val)
            }
        }
        impl From<P20pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsPcr) -> u8 {
                P20pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsPdr {
                P20pfsPdr::from_bits(val)
            }
        }
        impl From<P20pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsPdr) -> u8 {
                P20pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsPidr {
                P20pfsPidr::from_bits(val)
            }
        }
        impl From<P20pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsPidr) -> u8 {
                P20pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsPmr {
                P20pfsPmr::from_bits(val)
            }
        }
        impl From<P20pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsPmr) -> u8 {
                P20pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P20pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P20pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P20pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P20pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P20pfsPodr {
                P20pfsPodr::from_bits(val)
            }
        }
        impl From<P20pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P20pfsPodr) -> u8 {
                P20pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P2pfsAsel {
                P2pfsAsel::from_bits(val)
            }
        }
        impl From<P2pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P2pfsAsel) -> u8 {
                P2pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsByNcodr {
                P2pfsByNcodr::from_bits(val)
            }
        }
        impl From<P2pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsByNcodr) -> u8 {
                P2pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsByPcr {
                P2pfsByPcr::from_bits(val)
            }
        }
        impl From<P2pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsByPcr) -> u8 {
                P2pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsByPdr {
                P2pfsByPdr::from_bits(val)
            }
        }
        impl From<P2pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsByPdr) -> u8 {
                P2pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsByPidr {
                P2pfsByPidr::from_bits(val)
            }
        }
        impl From<P2pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsByPidr) -> u8 {
                P2pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsByPodr {
                P2pfsByPodr::from_bits(val)
            }
        }
        impl From<P2pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsByPodr) -> u8 {
                P2pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P2pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsEofr {
                P2pfsEofr::from_bits(val)
            }
        }
        impl From<P2pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsEofr) -> u8 {
                P2pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P2pfsHaAsel {
                P2pfsHaAsel::from_bits(val)
            }
        }
        impl From<P2pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P2pfsHaAsel) -> u8 {
                P2pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P2pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsHaEofr {
                P2pfsHaEofr::from_bits(val)
            }
        }
        impl From<P2pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsHaEofr) -> u8 {
                P2pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P2pfsHaIsel {
                P2pfsHaIsel::from_bits(val)
            }
        }
        impl From<P2pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P2pfsHaIsel) -> u8 {
                P2pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsHaNcodr {
                P2pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P2pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsHaNcodr) -> u8 {
                P2pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsHaPcr {
                P2pfsHaPcr::from_bits(val)
            }
        }
        impl From<P2pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsHaPcr) -> u8 {
                P2pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsHaPdr {
                P2pfsHaPdr::from_bits(val)
            }
        }
        impl From<P2pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsHaPdr) -> u8 {
                P2pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsHaPidr {
                P2pfsHaPidr::from_bits(val)
            }
        }
        impl From<P2pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsHaPidr) -> u8 {
                P2pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsHaPodr {
                P2pfsHaPodr::from_bits(val)
            }
        }
        impl From<P2pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsHaPodr) -> u8 {
                P2pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P2pfsIsel {
                P2pfsIsel::from_bits(val)
            }
        }
        impl From<P2pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P2pfsIsel) -> u8 {
                P2pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsNcodr {
                P2pfsNcodr::from_bits(val)
            }
        }
        impl From<P2pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsNcodr) -> u8 {
                P2pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsPcr {
                P2pfsPcr::from_bits(val)
            }
        }
        impl From<P2pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsPcr) -> u8 {
                P2pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsPdr {
                P2pfsPdr::from_bits(val)
            }
        }
        impl From<P2pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsPdr) -> u8 {
                P2pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsPidr {
                P2pfsPidr::from_bits(val)
            }
        }
        impl From<P2pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsPidr) -> u8 {
                P2pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsPmr {
                P2pfsPmr::from_bits(val)
            }
        }
        impl From<P2pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsPmr) -> u8 {
                P2pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P2pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P2pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P2pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P2pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P2pfsPodr {
                P2pfsPodr::from_bits(val)
            }
        }
        impl From<P2pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P2pfsPodr) -> u8 {
                P2pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P300pfsAsel {
                P300pfsAsel::from_bits(val)
            }
        }
        impl From<P300pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P300pfsAsel) -> u8 {
                P300pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByNcodr {
                P300pfsByNcodr::from_bits(val)
            }
        }
        impl From<P300pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByNcodr) -> u8 {
                P300pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByPcr {
                P300pfsByPcr::from_bits(val)
            }
        }
        impl From<P300pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByPcr) -> u8 {
                P300pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByPdr {
                P300pfsByPdr::from_bits(val)
            }
        }
        impl From<P300pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByPdr) -> u8 {
                P300pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByPidr {
                P300pfsByPidr::from_bits(val)
            }
        }
        impl From<P300pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByPidr) -> u8 {
                P300pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByPodr {
                P300pfsByPodr::from_bits(val)
            }
        }
        impl From<P300pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByPodr) -> u8 {
                P300pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaAsel {
                P300pfsHaAsel::from_bits(val)
            }
        }
        impl From<P300pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaAsel) -> u8 {
                P300pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaIsel {
                P300pfsHaIsel::from_bits(val)
            }
        }
        impl From<P300pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaIsel) -> u8 {
                P300pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaNcodr {
                P300pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P300pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaNcodr) -> u8 {
                P300pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaPcr {
                P300pfsHaPcr::from_bits(val)
            }
        }
        impl From<P300pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaPcr) -> u8 {
                P300pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaPdr {
                P300pfsHaPdr::from_bits(val)
            }
        }
        impl From<P300pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaPdr) -> u8 {
                P300pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaPidr {
                P300pfsHaPidr::from_bits(val)
            }
        }
        impl From<P300pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaPidr) -> u8 {
                P300pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaPodr {
                P300pfsHaPodr::from_bits(val)
            }
        }
        impl From<P300pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaPodr) -> u8 {
                P300pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P300pfsIsel {
                P300pfsIsel::from_bits(val)
            }
        }
        impl From<P300pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P300pfsIsel) -> u8 {
                P300pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsNcodr {
                P300pfsNcodr::from_bits(val)
            }
        }
        impl From<P300pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsNcodr) -> u8 {
                P300pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPcr {
                P300pfsPcr::from_bits(val)
            }
        }
        impl From<P300pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPcr) -> u8 {
                P300pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPdr {
                P300pfsPdr::from_bits(val)
            }
        }
        impl From<P300pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPdr) -> u8 {
                P300pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPidr {
                P300pfsPidr::from_bits(val)
            }
        }
        impl From<P300pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPidr) -> u8 {
                P300pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPmr {
                P300pfsPmr::from_bits(val)
            }
        }
        impl From<P300pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPmr) -> u8 {
                P300pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPodr {
                P300pfsPodr::from_bits(val)
            }
        }
        impl From<P300pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPodr) -> u8 {
                P300pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P30pfsAsel {
                P30pfsAsel::from_bits(val)
            }
        }
        impl From<P30pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P30pfsAsel) -> u8 {
                P30pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsByNcodr {
                P30pfsByNcodr::from_bits(val)
            }
        }
        impl From<P30pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsByNcodr) -> u8 {
                P30pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsByPcr {
                P30pfsByPcr::from_bits(val)
            }
        }
        impl From<P30pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsByPcr) -> u8 {
                P30pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsByPdr {
                P30pfsByPdr::from_bits(val)
            }
        }
        impl From<P30pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsByPdr) -> u8 {
                P30pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsByPidr {
                P30pfsByPidr::from_bits(val)
            }
        }
        impl From<P30pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsByPidr) -> u8 {
                P30pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsByPodr {
                P30pfsByPodr::from_bits(val)
            }
        }
        impl From<P30pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsByPodr) -> u8 {
                P30pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P30pfsHaAsel {
                P30pfsHaAsel::from_bits(val)
            }
        }
        impl From<P30pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P30pfsHaAsel) -> u8 {
                P30pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P30pfsHaIsel {
                P30pfsHaIsel::from_bits(val)
            }
        }
        impl From<P30pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P30pfsHaIsel) -> u8 {
                P30pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsHaNcodr {
                P30pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P30pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsHaNcodr) -> u8 {
                P30pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsHaPcr {
                P30pfsHaPcr::from_bits(val)
            }
        }
        impl From<P30pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsHaPcr) -> u8 {
                P30pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsHaPdr {
                P30pfsHaPdr::from_bits(val)
            }
        }
        impl From<P30pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsHaPdr) -> u8 {
                P30pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsHaPidr {
                P30pfsHaPidr::from_bits(val)
            }
        }
        impl From<P30pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsHaPidr) -> u8 {
                P30pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsHaPodr {
                P30pfsHaPodr::from_bits(val)
            }
        }
        impl From<P30pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsHaPodr) -> u8 {
                P30pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P30pfsIsel {
                P30pfsIsel::from_bits(val)
            }
        }
        impl From<P30pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P30pfsIsel) -> u8 {
                P30pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsNcodr {
                P30pfsNcodr::from_bits(val)
            }
        }
        impl From<P30pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsNcodr) -> u8 {
                P30pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsPcr {
                P30pfsPcr::from_bits(val)
            }
        }
        impl From<P30pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsPcr) -> u8 {
                P30pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsPdr {
                P30pfsPdr::from_bits(val)
            }
        }
        impl From<P30pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsPdr) -> u8 {
                P30pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsPidr {
                P30pfsPidr::from_bits(val)
            }
        }
        impl From<P30pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsPidr) -> u8 {
                P30pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsPmr {
                P30pfsPmr::from_bits(val)
            }
        }
        impl From<P30pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsPmr) -> u8 {
                P30pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P30pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P30pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P30pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P30pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P30pfsPodr {
                P30pfsPodr::from_bits(val)
            }
        }
        impl From<P30pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P30pfsPodr) -> u8 {
                P30pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P3pfsAsel {
                P3pfsAsel::from_bits(val)
            }
        }
        impl From<P3pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P3pfsAsel) -> u8 {
                P3pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsByNcodr {
                P3pfsByNcodr::from_bits(val)
            }
        }
        impl From<P3pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsByNcodr) -> u8 {
                P3pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsByPcr {
                P3pfsByPcr::from_bits(val)
            }
        }
        impl From<P3pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsByPcr) -> u8 {
                P3pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsByPdr {
                P3pfsByPdr::from_bits(val)
            }
        }
        impl From<P3pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsByPdr) -> u8 {
                P3pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsByPidr {
                P3pfsByPidr::from_bits(val)
            }
        }
        impl From<P3pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsByPidr) -> u8 {
                P3pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsByPodr {
                P3pfsByPodr::from_bits(val)
            }
        }
        impl From<P3pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsByPodr) -> u8 {
                P3pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P3pfsHaAsel {
                P3pfsHaAsel::from_bits(val)
            }
        }
        impl From<P3pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P3pfsHaAsel) -> u8 {
                P3pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P3pfsHaIsel {
                P3pfsHaIsel::from_bits(val)
            }
        }
        impl From<P3pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P3pfsHaIsel) -> u8 {
                P3pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsHaNcodr {
                P3pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P3pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsHaNcodr) -> u8 {
                P3pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsHaPcr {
                P3pfsHaPcr::from_bits(val)
            }
        }
        impl From<P3pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsHaPcr) -> u8 {
                P3pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsHaPdr {
                P3pfsHaPdr::from_bits(val)
            }
        }
        impl From<P3pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsHaPdr) -> u8 {
                P3pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsHaPidr {
                P3pfsHaPidr::from_bits(val)
            }
        }
        impl From<P3pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsHaPidr) -> u8 {
                P3pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsHaPodr {
                P3pfsHaPodr::from_bits(val)
            }
        }
        impl From<P3pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsHaPodr) -> u8 {
                P3pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P3pfsIsel {
                P3pfsIsel::from_bits(val)
            }
        }
        impl From<P3pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P3pfsIsel) -> u8 {
                P3pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsNcodr {
                P3pfsNcodr::from_bits(val)
            }
        }
        impl From<P3pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsNcodr) -> u8 {
                P3pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsPcr {
                P3pfsPcr::from_bits(val)
            }
        }
        impl From<P3pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsPcr) -> u8 {
                P3pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsPdr {
                P3pfsPdr::from_bits(val)
            }
        }
        impl From<P3pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsPdr) -> u8 {
                P3pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsPidr {
                P3pfsPidr::from_bits(val)
            }
        }
        impl From<P3pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsPidr) -> u8 {
                P3pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsPmr {
                P3pfsPmr::from_bits(val)
            }
        }
        impl From<P3pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsPmr) -> u8 {
                P3pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P3pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P3pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P3pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P3pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P3pfsPodr {
                P3pfsPodr::from_bits(val)
            }
        }
        impl From<P3pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P3pfsPodr) -> u8 {
                P3pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfs1Asel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfs1Asel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfs1Asel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfs1Asel {
            #[inline(always)]
            fn from(val: u8) -> P40pfs1Asel {
                P40pfs1Asel::from_bits(val)
            }
        }
        impl From<P40pfs1Asel> for u8 {
            #[inline(always)]
            fn from(val: P40pfs1Asel) -> u8 {
                P40pfs1Asel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfs1Isel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfs1Isel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfs1Isel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfs1Isel {
            #[inline(always)]
            fn from(val: u8) -> P40pfs1Isel {
                P40pfs1Isel::from_bits(val)
            }
        }
        impl From<P40pfs1Isel> for u8 {
            #[inline(always)]
            fn from(val: P40pfs1Isel) -> u8 {
                P40pfs1Isel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfs1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfs1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfs1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfs1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfs1Ncodr {
                P40pfs1Ncodr::from_bits(val)
            }
        }
        impl From<P40pfs1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfs1Ncodr) -> u8 {
                P40pfs1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfs1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfs1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfs1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfs1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P40pfs1Pcr {
                P40pfs1Pcr::from_bits(val)
            }
        }
        impl From<P40pfs1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P40pfs1Pcr) -> u8 {
                P40pfs1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfs1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfs1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfs1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfs1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P40pfs1Pdr {
                P40pfs1Pdr::from_bits(val)
            }
        }
        impl From<P40pfs1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P40pfs1Pdr) -> u8 {
                P40pfs1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfs1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfs1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfs1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfs1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P40pfs1Pidr {
                P40pfs1Pidr::from_bits(val)
            }
        }
        impl From<P40pfs1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P40pfs1Pidr) -> u8 {
                P40pfs1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfs1Pmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfs1Pmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfs1Pmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfs1Pmr {
            #[inline(always)]
            fn from(val: u8) -> P40pfs1Pmr {
                P40pfs1Pmr::from_bits(val)
            }
        }
        impl From<P40pfs1Pmr> for u8 {
            #[inline(always)]
            fn from(val: P40pfs1Pmr) -> u8 {
                P40pfs1Pmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfs1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfs1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfs1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfs1Podr {
            #[inline(always)]
            fn from(val: u8) -> P40pfs1Podr {
                P40pfs1Podr::from_bits(val)
            }
        }
        impl From<P40pfs1Podr> for u8 {
            #[inline(always)]
            fn from(val: P40pfs1Podr) -> u8 {
                P40pfs1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsAsel {
                P40pfsAsel::from_bits(val)
            }
        }
        impl From<P40pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsAsel) -> u8 {
                P40pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsBy1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsBy1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsBy1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsBy1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsBy1Ncodr {
                P40pfsBy1Ncodr::from_bits(val)
            }
        }
        impl From<P40pfsBy1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsBy1Ncodr) -> u8 {
                P40pfsBy1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsBy1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsBy1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsBy1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsBy1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsBy1Pcr {
                P40pfsBy1Pcr::from_bits(val)
            }
        }
        impl From<P40pfsBy1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsBy1Pcr) -> u8 {
                P40pfsBy1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsBy1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsBy1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsBy1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsBy1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsBy1Pdr {
                P40pfsBy1Pdr::from_bits(val)
            }
        }
        impl From<P40pfsBy1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsBy1Pdr) -> u8 {
                P40pfsBy1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsBy1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsBy1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsBy1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsBy1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsBy1Pidr {
                P40pfsBy1Pidr::from_bits(val)
            }
        }
        impl From<P40pfsBy1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsBy1Pidr) -> u8 {
                P40pfsBy1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsBy1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsBy1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsBy1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsBy1Podr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsBy1Podr {
                P40pfsBy1Podr::from_bits(val)
            }
        }
        impl From<P40pfsBy1Podr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsBy1Podr) -> u8 {
                P40pfsBy1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByNcodr {
                P40pfsByNcodr::from_bits(val)
            }
        }
        impl From<P40pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByNcodr) -> u8 {
                P40pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByPcr {
                P40pfsByPcr::from_bits(val)
            }
        }
        impl From<P40pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByPcr) -> u8 {
                P40pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByPdr {
                P40pfsByPdr::from_bits(val)
            }
        }
        impl From<P40pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByPdr) -> u8 {
                P40pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByPidr {
                P40pfsByPidr::from_bits(val)
            }
        }
        impl From<P40pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByPidr) -> u8 {
                P40pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByPodr {
                P40pfsByPodr::from_bits(val)
            }
        }
        impl From<P40pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByPodr) -> u8 {
                P40pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHa1Asel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHa1Asel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHa1Asel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHa1Asel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHa1Asel {
                P40pfsHa1Asel::from_bits(val)
            }
        }
        impl From<P40pfsHa1Asel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHa1Asel) -> u8 {
                P40pfsHa1Asel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHa1Isel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHa1Isel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHa1Isel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHa1Isel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHa1Isel {
                P40pfsHa1Isel::from_bits(val)
            }
        }
        impl From<P40pfsHa1Isel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHa1Isel) -> u8 {
                P40pfsHa1Isel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHa1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHa1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHa1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHa1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHa1Ncodr {
                P40pfsHa1Ncodr::from_bits(val)
            }
        }
        impl From<P40pfsHa1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHa1Ncodr) -> u8 {
                P40pfsHa1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHa1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHa1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHa1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHa1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHa1Pcr {
                P40pfsHa1Pcr::from_bits(val)
            }
        }
        impl From<P40pfsHa1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHa1Pcr) -> u8 {
                P40pfsHa1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHa1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHa1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHa1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHa1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHa1Pdr {
                P40pfsHa1Pdr::from_bits(val)
            }
        }
        impl From<P40pfsHa1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHa1Pdr) -> u8 {
                P40pfsHa1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHa1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHa1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHa1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHa1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHa1Pidr {
                P40pfsHa1Pidr::from_bits(val)
            }
        }
        impl From<P40pfsHa1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHa1Pidr) -> u8 {
                P40pfsHa1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHa1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHa1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHa1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHa1Podr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHa1Podr {
                P40pfsHa1Podr::from_bits(val)
            }
        }
        impl From<P40pfsHa1Podr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHa1Podr) -> u8 {
                P40pfsHa1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaAsel {
                P40pfsHaAsel::from_bits(val)
            }
        }
        impl From<P40pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaAsel) -> u8 {
                P40pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaIsel {
                P40pfsHaIsel::from_bits(val)
            }
        }
        impl From<P40pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaIsel) -> u8 {
                P40pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaNcodr {
                P40pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P40pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaNcodr) -> u8 {
                P40pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaPcr {
                P40pfsHaPcr::from_bits(val)
            }
        }
        impl From<P40pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaPcr) -> u8 {
                P40pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaPdr {
                P40pfsHaPdr::from_bits(val)
            }
        }
        impl From<P40pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaPdr) -> u8 {
                P40pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaPidr {
                P40pfsHaPidr::from_bits(val)
            }
        }
        impl From<P40pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaPidr) -> u8 {
                P40pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaPodr {
                P40pfsHaPodr::from_bits(val)
            }
        }
        impl From<P40pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaPodr) -> u8 {
                P40pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsIsel {
                P40pfsIsel::from_bits(val)
            }
        }
        impl From<P40pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsIsel) -> u8 {
                P40pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsNcodr {
                P40pfsNcodr::from_bits(val)
            }
        }
        impl From<P40pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsNcodr) -> u8 {
                P40pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPcr {
                P40pfsPcr::from_bits(val)
            }
        }
        impl From<P40pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPcr) -> u8 {
                P40pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPdr {
                P40pfsPdr::from_bits(val)
            }
        }
        impl From<P40pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPdr) -> u8 {
                P40pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPidr {
                P40pfsPidr::from_bits(val)
            }
        }
        impl From<P40pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPidr) -> u8 {
                P40pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPmr {
                P40pfsPmr::from_bits(val)
            }
        }
        impl From<P40pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPmr) -> u8 {
                P40pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPodr {
                P40pfsPodr::from_bits(val)
            }
        }
        impl From<P40pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPodr) -> u8 {
                P40pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P4pfsAsel {
                P4pfsAsel::from_bits(val)
            }
        }
        impl From<P4pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P4pfsAsel) -> u8 {
                P4pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsByNcodr {
                P4pfsByNcodr::from_bits(val)
            }
        }
        impl From<P4pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsByNcodr) -> u8 {
                P4pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsByPcr {
                P4pfsByPcr::from_bits(val)
            }
        }
        impl From<P4pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsByPcr) -> u8 {
                P4pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsByPdr {
                P4pfsByPdr::from_bits(val)
            }
        }
        impl From<P4pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsByPdr) -> u8 {
                P4pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsByPidr {
                P4pfsByPidr::from_bits(val)
            }
        }
        impl From<P4pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsByPidr) -> u8 {
                P4pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsByPodr {
                P4pfsByPodr::from_bits(val)
            }
        }
        impl From<P4pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsByPodr) -> u8 {
                P4pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P4pfsHaAsel {
                P4pfsHaAsel::from_bits(val)
            }
        }
        impl From<P4pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P4pfsHaAsel) -> u8 {
                P4pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P4pfsHaIsel {
                P4pfsHaIsel::from_bits(val)
            }
        }
        impl From<P4pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P4pfsHaIsel) -> u8 {
                P4pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsHaNcodr {
                P4pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P4pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsHaNcodr) -> u8 {
                P4pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsHaPcr {
                P4pfsHaPcr::from_bits(val)
            }
        }
        impl From<P4pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsHaPcr) -> u8 {
                P4pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsHaPdr {
                P4pfsHaPdr::from_bits(val)
            }
        }
        impl From<P4pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsHaPdr) -> u8 {
                P4pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsHaPidr {
                P4pfsHaPidr::from_bits(val)
            }
        }
        impl From<P4pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsHaPidr) -> u8 {
                P4pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsHaPodr {
                P4pfsHaPodr::from_bits(val)
            }
        }
        impl From<P4pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsHaPodr) -> u8 {
                P4pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P4pfsIsel {
                P4pfsIsel::from_bits(val)
            }
        }
        impl From<P4pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P4pfsIsel) -> u8 {
                P4pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsNcodr {
                P4pfsNcodr::from_bits(val)
            }
        }
        impl From<P4pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsNcodr) -> u8 {
                P4pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsPcr {
                P4pfsPcr::from_bits(val)
            }
        }
        impl From<P4pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsPcr) -> u8 {
                P4pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsPdr {
                P4pfsPdr::from_bits(val)
            }
        }
        impl From<P4pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsPdr) -> u8 {
                P4pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsPidr {
                P4pfsPidr::from_bits(val)
            }
        }
        impl From<P4pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsPidr) -> u8 {
                P4pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsPmr {
                P4pfsPmr::from_bits(val)
            }
        }
        impl From<P4pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsPmr) -> u8 {
                P4pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P4pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P4pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P4pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P4pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P4pfsPodr {
                P4pfsPodr::from_bits(val)
            }
        }
        impl From<P4pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P4pfsPodr) -> u8 {
                P4pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P50pfsAsel {
                P50pfsAsel::from_bits(val)
            }
        }
        impl From<P50pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P50pfsAsel) -> u8 {
                P50pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsByNcodr {
                P50pfsByNcodr::from_bits(val)
            }
        }
        impl From<P50pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsByNcodr) -> u8 {
                P50pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsByPcr {
                P50pfsByPcr::from_bits(val)
            }
        }
        impl From<P50pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsByPcr) -> u8 {
                P50pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsByPdr {
                P50pfsByPdr::from_bits(val)
            }
        }
        impl From<P50pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsByPdr) -> u8 {
                P50pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsByPidr {
                P50pfsByPidr::from_bits(val)
            }
        }
        impl From<P50pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsByPidr) -> u8 {
                P50pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsByPodr {
                P50pfsByPodr::from_bits(val)
            }
        }
        impl From<P50pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsByPodr) -> u8 {
                P50pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P50pfsHaAsel {
                P50pfsHaAsel::from_bits(val)
            }
        }
        impl From<P50pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P50pfsHaAsel) -> u8 {
                P50pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P50pfsHaIsel {
                P50pfsHaIsel::from_bits(val)
            }
        }
        impl From<P50pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P50pfsHaIsel) -> u8 {
                P50pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsHaNcodr {
                P50pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P50pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsHaNcodr) -> u8 {
                P50pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsHaPcr {
                P50pfsHaPcr::from_bits(val)
            }
        }
        impl From<P50pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsHaPcr) -> u8 {
                P50pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsHaPdr {
                P50pfsHaPdr::from_bits(val)
            }
        }
        impl From<P50pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsHaPdr) -> u8 {
                P50pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsHaPidr {
                P50pfsHaPidr::from_bits(val)
            }
        }
        impl From<P50pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsHaPidr) -> u8 {
                P50pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsHaPodr {
                P50pfsHaPodr::from_bits(val)
            }
        }
        impl From<P50pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsHaPodr) -> u8 {
                P50pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P50pfsIsel {
                P50pfsIsel::from_bits(val)
            }
        }
        impl From<P50pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P50pfsIsel) -> u8 {
                P50pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsNcodr {
                P50pfsNcodr::from_bits(val)
            }
        }
        impl From<P50pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsNcodr) -> u8 {
                P50pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsPcr {
                P50pfsPcr::from_bits(val)
            }
        }
        impl From<P50pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsPcr) -> u8 {
                P50pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsPdr {
                P50pfsPdr::from_bits(val)
            }
        }
        impl From<P50pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsPdr) -> u8 {
                P50pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsPidr {
                P50pfsPidr::from_bits(val)
            }
        }
        impl From<P50pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsPidr) -> u8 {
                P50pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsPmr {
                P50pfsPmr::from_bits(val)
            }
        }
        impl From<P50pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsPmr) -> u8 {
                P50pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P50pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P50pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P50pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P50pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P50pfsPodr {
                P50pfsPodr::from_bits(val)
            }
        }
        impl From<P50pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P50pfsPodr) -> u8 {
                P50pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P600pfsAsel {
                P600pfsAsel::from_bits(val)
            }
        }
        impl From<P600pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P600pfsAsel) -> u8 {
                P600pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsByNcodr {
                P600pfsByNcodr::from_bits(val)
            }
        }
        impl From<P600pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsByNcodr) -> u8 {
                P600pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsByPcr {
                P600pfsByPcr::from_bits(val)
            }
        }
        impl From<P600pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsByPcr) -> u8 {
                P600pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsByPdr {
                P600pfsByPdr::from_bits(val)
            }
        }
        impl From<P600pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsByPdr) -> u8 {
                P600pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsByPidr {
                P600pfsByPidr::from_bits(val)
            }
        }
        impl From<P600pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsByPidr) -> u8 {
                P600pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsByPodr {
                P600pfsByPodr::from_bits(val)
            }
        }
        impl From<P600pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsByPodr) -> u8 {
                P600pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P600pfsHaAsel {
                P600pfsHaAsel::from_bits(val)
            }
        }
        impl From<P600pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P600pfsHaAsel) -> u8 {
                P600pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P600pfsHaIsel {
                P600pfsHaIsel::from_bits(val)
            }
        }
        impl From<P600pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P600pfsHaIsel) -> u8 {
                P600pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsHaNcodr {
                P600pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P600pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsHaNcodr) -> u8 {
                P600pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsHaPcr {
                P600pfsHaPcr::from_bits(val)
            }
        }
        impl From<P600pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsHaPcr) -> u8 {
                P600pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsHaPdr {
                P600pfsHaPdr::from_bits(val)
            }
        }
        impl From<P600pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsHaPdr) -> u8 {
                P600pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsHaPidr {
                P600pfsHaPidr::from_bits(val)
            }
        }
        impl From<P600pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsHaPidr) -> u8 {
                P600pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsHaPodr {
                P600pfsHaPodr::from_bits(val)
            }
        }
        impl From<P600pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsHaPodr) -> u8 {
                P600pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P600pfsIsel {
                P600pfsIsel::from_bits(val)
            }
        }
        impl From<P600pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P600pfsIsel) -> u8 {
                P600pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsNcodr {
                P600pfsNcodr::from_bits(val)
            }
        }
        impl From<P600pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsNcodr) -> u8 {
                P600pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsPcr {
                P600pfsPcr::from_bits(val)
            }
        }
        impl From<P600pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsPcr) -> u8 {
                P600pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsPdr {
                P600pfsPdr::from_bits(val)
            }
        }
        impl From<P600pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsPdr) -> u8 {
                P600pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsPidr {
                P600pfsPidr::from_bits(val)
            }
        }
        impl From<P600pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsPidr) -> u8 {
                P600pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsPmr {
                P600pfsPmr::from_bits(val)
            }
        }
        impl From<P600pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsPmr) -> u8 {
                P600pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P600pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P600pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P600pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P600pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P600pfsPodr {
                P600pfsPodr::from_bits(val)
            }
        }
        impl From<P600pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P600pfsPodr) -> u8 {
                P600pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pfswe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pfswe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pfswe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pfswe {
            #[inline(always)]
            fn from(val: u8) -> Pfswe {
                Pfswe::from_bits(val)
            }
        }
        impl From<Pfswe> for u8 {
            #[inline(always)]
            fn from(val: Pfswe) -> u8 {
                Pfswe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Selvl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Selvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Selvl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Selvl {
            #[inline(always)]
            fn from(val: u8) -> Selvl {
                Selvl::from_bits(val)
            }
        }
        impl From<Selvl> for u8 {
            #[inline(always)]
            fn from(val: Selvl) -> u8 {
                Selvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wait {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Wait {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wait {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wait {
            #[inline(always)]
            fn from(val: u8) -> Wait {
                Wait::from_bits(val)
            }
        }
        impl From<Wait> for u8 {
            #[inline(always)]
            fn from(val: Wait) -> u8 {
                Wait::to_bits(val)
            }
        }
    }
}
pub mod poeg {
    #[doc = "Port Output Enable Module for GPT"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Poeg {
        ptr: *mut u8,
    }
    unsafe impl Send for Poeg {}
    unsafe impl Sync for Poeg {}
    impl Poeg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "POEG Group A Setting Register"]
        #[inline(always)]
        pub const fn poegga(self) -> crate::common::Reg<regs::Poegga, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "POEG Group B Setting Register"]
        #[inline(always)]
        pub const fn poeggb(self) -> crate::common::Reg<regs::Poeggb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "POEG Group A Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Poegga(pub u32);
        impl Poegga {
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub const fn pidf(&self) -> super::vals::PoeggaPidf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PoeggaPidf::from_bits(val as u8)
            }
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub fn set_pidf(&mut self, val: super::vals::PoeggaPidf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Detection Flag for GPT Output,Disable Request"]
            #[inline(always)]
            pub const fn iocf(&self) -> super::vals::PoeggaIocf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PoeggaIocf::from_bits(val as u8)
            }
            #[doc = "Detection Flag for GPT Output,Disable Request"]
            #[inline(always)]
            pub fn set_iocf(&mut self, val: super::vals::PoeggaIocf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub const fn ostpf(&self) -> super::vals::PoeggaOstpf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PoeggaOstpf::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub fn set_ostpf(&mut self, val: super::vals::PoeggaOstpf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub const fn ssf(&self) -> super::vals::PoeggaSsf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PoeggaSsf::from_bits(val as u8)
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub fn set_ssf(&mut self, val: super::vals::PoeggaSsf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Port Input Detection Enable"]
            #[inline(always)]
            pub const fn pide(&self) -> super::vals::PoeggaPide {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PoeggaPide::from_bits(val as u8)
            }
            #[doc = "Port Input Detection Enable"]
            #[inline(always)]
            pub fn set_pide(&mut self, val: super::vals::PoeggaPide) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable for GPT Output,Disable Request"]
            #[inline(always)]
            pub const fn ioce(&self) -> super::vals::PoeggaIoce {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PoeggaIoce::from_bits(val as u8)
            }
            #[doc = "Enable for GPT Output,Disable Request"]
            #[inline(always)]
            pub fn set_ioce(&mut self, val: super::vals::PoeggaIoce) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Oscillation Stop Detection Enable"]
            #[inline(always)]
            pub const fn ostpe(&self) -> super::vals::PoeggaOstpe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PoeggaOstpe::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Enable"]
            #[inline(always)]
            pub fn set_ostpe(&mut self, val: super::vals::PoeggaOstpe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "GTETRGn Input Status Flag"]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::PoeggaSt {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::PoeggaSt::from_bits(val as u8)
            }
            #[doc = "GTETRGn Input Status Flag"]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::PoeggaSt) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "GTETRGn Input Reverse"]
            #[inline(always)]
            pub const fn inv(&self) -> super::vals::PoeggaInv {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::PoeggaInv::from_bits(val as u8)
            }
            #[doc = "GTETRGn Input Reverse"]
            #[inline(always)]
            pub fn set_inv(&mut self, val: super::vals::PoeggaInv) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::PoeggaNfen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::PoeggaNfen::from_bits(val as u8)
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::PoeggaNfen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::PoeggaNfcs {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PoeggaNfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::PoeggaNfcs) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Poegga {
            #[inline(always)]
            fn default() -> Poegga {
                Poegga(0)
            }
        }
        impl core::fmt::Debug for Poegga {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Poegga")
                    .field("pidf", &self.pidf())
                    .field("iocf", &self.iocf())
                    .field("ostpf", &self.ostpf())
                    .field("ssf", &self.ssf())
                    .field("pide", &self.pide())
                    .field("ioce", &self.ioce())
                    .field("ostpe", &self.ostpe())
                    .field("st", &self.st())
                    .field("inv", &self.inv())
                    .field("nfen", &self.nfen())
                    .field("nfcs", &self.nfcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Poegga {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Poegga {{ pidf: {:?}, iocf: {:?}, ostpf: {:?}, ssf: {:?}, pide: {:?}, ioce: {:?}, ostpe: {:?}, st: {:?}, inv: {:?}, nfen: {:?}, nfcs: {:?} }}" , self . pidf () , self . iocf () , self . ostpf () , self . ssf () , self . pide () , self . ioce () , self . ostpe () , self . st () , self . inv () , self . nfen () , self . nfcs ())
            }
        }
        #[doc = "POEG Group B Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Poeggb(pub u32);
        impl Poeggb {
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub const fn pidf(&self) -> super::vals::PoeggbPidf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PoeggbPidf::from_bits(val as u8)
            }
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub fn set_pidf(&mut self, val: super::vals::PoeggbPidf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Detection Flag for GPT Output,Disable Request"]
            #[inline(always)]
            pub const fn iocf(&self) -> super::vals::PoeggbIocf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PoeggbIocf::from_bits(val as u8)
            }
            #[doc = "Detection Flag for GPT Output,Disable Request"]
            #[inline(always)]
            pub fn set_iocf(&mut self, val: super::vals::PoeggbIocf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub const fn ostpf(&self) -> super::vals::PoeggbOstpf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PoeggbOstpf::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub fn set_ostpf(&mut self, val: super::vals::PoeggbOstpf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub const fn ssf(&self) -> super::vals::PoeggbSsf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PoeggbSsf::from_bits(val as u8)
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub fn set_ssf(&mut self, val: super::vals::PoeggbSsf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Port Input Detection Enable"]
            #[inline(always)]
            pub const fn pide(&self) -> super::vals::PoeggbPide {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PoeggbPide::from_bits(val as u8)
            }
            #[doc = "Port Input Detection Enable"]
            #[inline(always)]
            pub fn set_pide(&mut self, val: super::vals::PoeggbPide) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable for GPT Output,Disable Request"]
            #[inline(always)]
            pub const fn ioce(&self) -> super::vals::PoeggbIoce {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PoeggbIoce::from_bits(val as u8)
            }
            #[doc = "Enable for GPT Output,Disable Request"]
            #[inline(always)]
            pub fn set_ioce(&mut self, val: super::vals::PoeggbIoce) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Oscillation Stop Detection Enable"]
            #[inline(always)]
            pub const fn ostpe(&self) -> super::vals::PoeggbOstpe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PoeggbOstpe::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Enable"]
            #[inline(always)]
            pub fn set_ostpe(&mut self, val: super::vals::PoeggbOstpe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "GTETRGn Input Status Flag"]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::PoeggbSt {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::PoeggbSt::from_bits(val as u8)
            }
            #[doc = "GTETRGn Input Status Flag"]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::PoeggbSt) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "GTETRGn Input Reverse"]
            #[inline(always)]
            pub const fn inv(&self) -> super::vals::PoeggbInv {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::PoeggbInv::from_bits(val as u8)
            }
            #[doc = "GTETRGn Input Reverse"]
            #[inline(always)]
            pub fn set_inv(&mut self, val: super::vals::PoeggbInv) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::PoeggbNfen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::PoeggbNfen::from_bits(val as u8)
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::PoeggbNfen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::PoeggbNfcs {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PoeggbNfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::PoeggbNfcs) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Poeggb {
            #[inline(always)]
            fn default() -> Poeggb {
                Poeggb(0)
            }
        }
        impl core::fmt::Debug for Poeggb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Poeggb")
                    .field("pidf", &self.pidf())
                    .field("iocf", &self.iocf())
                    .field("ostpf", &self.ostpf())
                    .field("ssf", &self.ssf())
                    .field("pide", &self.pide())
                    .field("ioce", &self.ioce())
                    .field("ostpe", &self.ostpe())
                    .field("st", &self.st())
                    .field("inv", &self.inv())
                    .field("nfen", &self.nfen())
                    .field("nfcs", &self.nfcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Poeggb {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Poeggb {{ pidf: {:?}, iocf: {:?}, ostpf: {:?}, ssf: {:?}, pide: {:?}, ioce: {:?}, ostpe: {:?}, st: {:?}, inv: {:?}, nfen: {:?}, nfcs: {:?} }}" , self . pidf () , self . iocf () , self . ostpf () , self . ssf () , self . pide () , self . ioce () , self . ostpe () , self . st () , self . inv () , self . nfen () , self . nfcs ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaInv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaInv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaInv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaInv {
            #[inline(always)]
            fn from(val: u8) -> PoeggaInv {
                PoeggaInv::from_bits(val)
            }
        }
        impl From<PoeggaInv> for u8 {
            #[inline(always)]
            fn from(val: PoeggaInv) -> u8 {
                PoeggaInv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaIoce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaIoce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaIoce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaIoce {
            #[inline(always)]
            fn from(val: u8) -> PoeggaIoce {
                PoeggaIoce::from_bits(val)
            }
        }
        impl From<PoeggaIoce> for u8 {
            #[inline(always)]
            fn from(val: PoeggaIoce) -> u8 {
                PoeggaIoce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaIocf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaIocf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaIocf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaIocf {
            #[inline(always)]
            fn from(val: u8) -> PoeggaIocf {
                PoeggaIocf::from_bits(val)
            }
        }
        impl From<PoeggaIocf> for u8 {
            #[inline(always)]
            fn from(val: PoeggaIocf) -> u8 {
                PoeggaIocf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaNfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PoeggaNfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaNfcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaNfcs {
            #[inline(always)]
            fn from(val: u8) -> PoeggaNfcs {
                PoeggaNfcs::from_bits(val)
            }
        }
        impl From<PoeggaNfcs> for u8 {
            #[inline(always)]
            fn from(val: PoeggaNfcs) -> u8 {
                PoeggaNfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaNfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaNfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaNfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaNfen {
            #[inline(always)]
            fn from(val: u8) -> PoeggaNfen {
                PoeggaNfen::from_bits(val)
            }
        }
        impl From<PoeggaNfen> for u8 {
            #[inline(always)]
            fn from(val: PoeggaNfen) -> u8 {
                PoeggaNfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaOstpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaOstpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaOstpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaOstpe {
            #[inline(always)]
            fn from(val: u8) -> PoeggaOstpe {
                PoeggaOstpe::from_bits(val)
            }
        }
        impl From<PoeggaOstpe> for u8 {
            #[inline(always)]
            fn from(val: PoeggaOstpe) -> u8 {
                PoeggaOstpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaOstpf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaOstpf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaOstpf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaOstpf {
            #[inline(always)]
            fn from(val: u8) -> PoeggaOstpf {
                PoeggaOstpf::from_bits(val)
            }
        }
        impl From<PoeggaOstpf> for u8 {
            #[inline(always)]
            fn from(val: PoeggaOstpf) -> u8 {
                PoeggaOstpf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaPide {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaPide {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaPide {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaPide {
            #[inline(always)]
            fn from(val: u8) -> PoeggaPide {
                PoeggaPide::from_bits(val)
            }
        }
        impl From<PoeggaPide> for u8 {
            #[inline(always)]
            fn from(val: PoeggaPide) -> u8 {
                PoeggaPide::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaPidf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaPidf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaPidf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaPidf {
            #[inline(always)]
            fn from(val: u8) -> PoeggaPidf {
                PoeggaPidf::from_bits(val)
            }
        }
        impl From<PoeggaPidf> for u8 {
            #[inline(always)]
            fn from(val: PoeggaPidf) -> u8 {
                PoeggaPidf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaSsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaSsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaSsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaSsf {
            #[inline(always)]
            fn from(val: u8) -> PoeggaSsf {
                PoeggaSsf::from_bits(val)
            }
        }
        impl From<PoeggaSsf> for u8 {
            #[inline(always)]
            fn from(val: PoeggaSsf) -> u8 {
                PoeggaSsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaSt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaSt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaSt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaSt {
            #[inline(always)]
            fn from(val: u8) -> PoeggaSt {
                PoeggaSt::from_bits(val)
            }
        }
        impl From<PoeggaSt> for u8 {
            #[inline(always)]
            fn from(val: PoeggaSt) -> u8 {
                PoeggaSt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbInv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbInv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbInv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbInv {
            #[inline(always)]
            fn from(val: u8) -> PoeggbInv {
                PoeggbInv::from_bits(val)
            }
        }
        impl From<PoeggbInv> for u8 {
            #[inline(always)]
            fn from(val: PoeggbInv) -> u8 {
                PoeggbInv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbIoce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbIoce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbIoce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbIoce {
            #[inline(always)]
            fn from(val: u8) -> PoeggbIoce {
                PoeggbIoce::from_bits(val)
            }
        }
        impl From<PoeggbIoce> for u8 {
            #[inline(always)]
            fn from(val: PoeggbIoce) -> u8 {
                PoeggbIoce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbIocf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbIocf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbIocf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbIocf {
            #[inline(always)]
            fn from(val: u8) -> PoeggbIocf {
                PoeggbIocf::from_bits(val)
            }
        }
        impl From<PoeggbIocf> for u8 {
            #[inline(always)]
            fn from(val: PoeggbIocf) -> u8 {
                PoeggbIocf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbNfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PoeggbNfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbNfcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbNfcs {
            #[inline(always)]
            fn from(val: u8) -> PoeggbNfcs {
                PoeggbNfcs::from_bits(val)
            }
        }
        impl From<PoeggbNfcs> for u8 {
            #[inline(always)]
            fn from(val: PoeggbNfcs) -> u8 {
                PoeggbNfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbNfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbNfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbNfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbNfen {
            #[inline(always)]
            fn from(val: u8) -> PoeggbNfen {
                PoeggbNfen::from_bits(val)
            }
        }
        impl From<PoeggbNfen> for u8 {
            #[inline(always)]
            fn from(val: PoeggbNfen) -> u8 {
                PoeggbNfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbOstpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbOstpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbOstpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbOstpe {
            #[inline(always)]
            fn from(val: u8) -> PoeggbOstpe {
                PoeggbOstpe::from_bits(val)
            }
        }
        impl From<PoeggbOstpe> for u8 {
            #[inline(always)]
            fn from(val: PoeggbOstpe) -> u8 {
                PoeggbOstpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbOstpf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbOstpf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbOstpf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbOstpf {
            #[inline(always)]
            fn from(val: u8) -> PoeggbOstpf {
                PoeggbOstpf::from_bits(val)
            }
        }
        impl From<PoeggbOstpf> for u8 {
            #[inline(always)]
            fn from(val: PoeggbOstpf) -> u8 {
                PoeggbOstpf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbPide {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbPide {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbPide {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbPide {
            #[inline(always)]
            fn from(val: u8) -> PoeggbPide {
                PoeggbPide::from_bits(val)
            }
        }
        impl From<PoeggbPide> for u8 {
            #[inline(always)]
            fn from(val: PoeggbPide) -> u8 {
                PoeggbPide::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbPidf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbPidf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbPidf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbPidf {
            #[inline(always)]
            fn from(val: u8) -> PoeggbPidf {
                PoeggbPidf::from_bits(val)
            }
        }
        impl From<PoeggbPidf> for u8 {
            #[inline(always)]
            fn from(val: PoeggbPidf) -> u8 {
                PoeggbPidf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbSsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbSsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbSsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbSsf {
            #[inline(always)]
            fn from(val: u8) -> PoeggbSsf {
                PoeggbSsf::from_bits(val)
            }
        }
        impl From<PoeggbSsf> for u8 {
            #[inline(always)]
            fn from(val: PoeggbSsf) -> u8 {
                PoeggbSsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbSt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbSt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbSt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbSt {
            #[inline(always)]
            fn from(val: u8) -> PoeggbSt {
                PoeggbSt::from_bits(val)
            }
        }
        impl From<PoeggbSt> for u8 {
            #[inline(always)]
            fn from(val: PoeggbSt) -> u8 {
                PoeggbSt::to_bits(val)
            }
        }
    }
}
pub mod port0 {
    #[doc = "Port 0 Control Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port0 {}
    unsafe impl Sync for Port0 {}
    impl Port0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pcntr1(self) -> crate::common::Reg<regs::Pcntr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn podr(self) -> crate::common::Reg<regs::Podr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pdr(self) -> crate::common::Reg<regs::Pdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn eidr(self) -> crate::common::Reg<regs::Eidr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pcntr2(self) -> crate::common::Reg<regs::Pcntr2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pidr(self) -> crate::common::Reg<regs::Pidr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn pcntr3(self) -> crate::common::Reg<regs::Pcntr3, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn porr(self) -> crate::common::Reg<regs::Porr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn posr(self) -> crate::common::Reg<regs::Posr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eidr(pub u16);
        impl Eidr {
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr00(&self) -> super::vals::EidrEidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EidrEidr00::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr00(&mut self, val: super::vals::EidrEidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr01(&self) -> super::vals::EidrEidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::EidrEidr01::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr01(&mut self, val: super::vals::EidrEidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr02(&self) -> super::vals::EidrEidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::EidrEidr02::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr02(&mut self, val: super::vals::EidrEidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr03(&self) -> super::vals::EidrEidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::EidrEidr03::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr03(&mut self, val: super::vals::EidrEidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr04(&self) -> super::vals::EidrEidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::EidrEidr04::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr04(&mut self, val: super::vals::EidrEidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr05(&self) -> super::vals::EidrEidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::EidrEidr05::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr05(&mut self, val: super::vals::EidrEidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr06(&self) -> super::vals::EidrEidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::EidrEidr06::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr06(&mut self, val: super::vals::EidrEidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr07(&self) -> super::vals::EidrEidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::EidrEidr07::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr07(&mut self, val: super::vals::EidrEidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr08(&self) -> super::vals::EidrEidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::EidrEidr08::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr08(&mut self, val: super::vals::EidrEidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr09(&self) -> super::vals::EidrEidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::EidrEidr09::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr09(&mut self, val: super::vals::EidrEidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr10(&self) -> super::vals::EidrEidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::EidrEidr10::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr10(&mut self, val: super::vals::EidrEidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr11(&self) -> super::vals::EidrEidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::EidrEidr11::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr11(&mut self, val: super::vals::EidrEidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr12(&self) -> super::vals::EidrEidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::EidrEidr12::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr12(&mut self, val: super::vals::EidrEidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr13(&self) -> super::vals::EidrEidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::EidrEidr13::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr13(&mut self, val: super::vals::EidrEidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr14(&self) -> super::vals::EidrEidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::EidrEidr14::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr14(&mut self, val: super::vals::EidrEidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr15(&self) -> super::vals::EidrEidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::EidrEidr15::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr15(&mut self, val: super::vals::EidrEidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Eidr {
            #[inline(always)]
            fn default() -> Eidr {
                Eidr(0)
            }
        }
        impl core::fmt::Debug for Eidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eidr")
                    .field("eidr00", &self.eidr00())
                    .field("eidr01", &self.eidr01())
                    .field("eidr02", &self.eidr02())
                    .field("eidr03", &self.eidr03())
                    .field("eidr04", &self.eidr04())
                    .field("eidr05", &self.eidr05())
                    .field("eidr06", &self.eidr06())
                    .field("eidr07", &self.eidr07())
                    .field("eidr08", &self.eidr08())
                    .field("eidr09", &self.eidr09())
                    .field("eidr10", &self.eidr10())
                    .field("eidr11", &self.eidr11())
                    .field("eidr12", &self.eidr12())
                    .field("eidr13", &self.eidr13())
                    .field("eidr14", &self.eidr14())
                    .field("eidr15", &self.eidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eidr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eidr {{ eidr00: {:?}, eidr01: {:?}, eidr02: {:?}, eidr03: {:?}, eidr04: {:?}, eidr05: {:?}, eidr06: {:?}, eidr07: {:?}, eidr08: {:?}, eidr09: {:?}, eidr10: {:?}, eidr11: {:?}, eidr12: {:?}, eidr13: {:?}, eidr14: {:?}, eidr15: {:?} }}" , self . eidr00 () , self . eidr01 () , self . eidr02 () , self . eidr03 () , self . eidr04 () , self . eidr05 () , self . eidr06 () , self . eidr07 () , self . eidr08 () , self . eidr09 () , self . eidr10 () , self . eidr11 () , self . eidr12 () , self . eidr13 () , self . eidr14 () , self . eidr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr1(pub u32);
        impl Pcntr1 {
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::Pcntr1Pdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr1Pdr00::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::Pcntr1Pdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::Pcntr1Pdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr1Pdr01::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::Pcntr1Pdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr02(&self) -> super::vals::Pcntr1Pdr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr1Pdr02::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr02(&mut self, val: super::vals::Pcntr1Pdr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr03(&self) -> super::vals::Pcntr1Pdr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr1Pdr03::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr03(&mut self, val: super::vals::Pcntr1Pdr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr04(&self) -> super::vals::Pcntr1Pdr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr1Pdr04::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr04(&mut self, val: super::vals::Pcntr1Pdr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr05(&self) -> super::vals::Pcntr1Pdr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr1Pdr05::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr05(&mut self, val: super::vals::Pcntr1Pdr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr06(&self) -> super::vals::Pcntr1Pdr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr1Pdr06::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr06(&mut self, val: super::vals::Pcntr1Pdr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::Pcntr1Pdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr1Pdr07::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::Pcntr1Pdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::Pcntr1Pdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr1Pdr08::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::Pcntr1Pdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::Pcntr1Pdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr1Pdr09::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::Pcntr1Pdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::Pcntr1Pdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr1Pdr10::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::Pcntr1Pdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr11(&self) -> super::vals::Pcntr1Pdr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr1Pdr11::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr11(&mut self, val: super::vals::Pcntr1Pdr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::Pcntr1Pdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr1Pdr12::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::Pcntr1Pdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::Pcntr1Pdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr1Pdr13::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::Pcntr1Pdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::Pcntr1Pdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr1Pdr14::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::Pcntr1Pdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr15(&self) -> super::vals::Pcntr1Pdr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr1Pdr15::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr15(&mut self, val: super::vals::Pcntr1Pdr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::Pcntr1Podr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr1Podr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::Pcntr1Podr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::Pcntr1Podr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr1Podr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::Pcntr1Podr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr02(&self) -> super::vals::Pcntr1Podr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr1Podr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr02(&mut self, val: super::vals::Pcntr1Podr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr03(&self) -> super::vals::Pcntr1Podr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr1Podr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr03(&mut self, val: super::vals::Pcntr1Podr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr04(&self) -> super::vals::Pcntr1Podr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr1Podr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr04(&mut self, val: super::vals::Pcntr1Podr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr05(&self) -> super::vals::Pcntr1Podr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr1Podr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr05(&mut self, val: super::vals::Pcntr1Podr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr06(&self) -> super::vals::Pcntr1Podr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr1Podr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr06(&mut self, val: super::vals::Pcntr1Podr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::Pcntr1Podr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr1Podr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::Pcntr1Podr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::Pcntr1Podr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr1Podr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::Pcntr1Podr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::Pcntr1Podr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr1Podr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::Pcntr1Podr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::Pcntr1Podr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr1Podr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::Pcntr1Podr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr11(&self) -> super::vals::Pcntr1Podr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr1Podr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr11(&mut self, val: super::vals::Pcntr1Podr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::Pcntr1Podr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr1Podr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::Pcntr1Podr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::Pcntr1Podr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr1Podr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::Pcntr1Podr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::Pcntr1Podr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr1Podr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::Pcntr1Podr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr15(&self) -> super::vals::Pcntr1Podr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr1Podr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr15(&mut self, val: super::vals::Pcntr1Podr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr1 {
            #[inline(always)]
            fn default() -> Pcntr1 {
                Pcntr1(0)
            }
        }
        impl core::fmt::Debug for Pcntr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr1")
                    .field("pdr00", &self.pdr00())
                    .field("pdr01", &self.pdr01())
                    .field("pdr02", &self.pdr02())
                    .field("pdr03", &self.pdr03())
                    .field("pdr04", &self.pdr04())
                    .field("pdr05", &self.pdr05())
                    .field("pdr06", &self.pdr06())
                    .field("pdr07", &self.pdr07())
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr11", &self.pdr11())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .field("pdr15", &self.pdr15())
                    .field("podr00", &self.podr00())
                    .field("podr01", &self.podr01())
                    .field("podr02", &self.podr02())
                    .field("podr03", &self.podr03())
                    .field("podr04", &self.podr04())
                    .field("podr05", &self.podr05())
                    .field("podr06", &self.podr06())
                    .field("podr07", &self.podr07())
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr11", &self.podr11())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .field("podr15", &self.podr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr1 {{ pdr00: {:?}, pdr01: {:?}, pdr02: {:?}, pdr03: {:?}, pdr04: {:?}, pdr05: {:?}, pdr06: {:?}, pdr07: {:?}, pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr11: {:?}, pdr12: {:?}, pdr13: {:?}, pdr14: {:?}, pdr15: {:?}, podr00: {:?}, podr01: {:?}, podr02: {:?}, podr03: {:?}, podr04: {:?}, podr05: {:?}, podr06: {:?}, podr07: {:?}, podr08: {:?}, podr09: {:?}, podr10: {:?}, podr11: {:?}, podr12: {:?}, podr13: {:?}, podr14: {:?}, podr15: {:?} }}" , self . pdr00 () , self . pdr01 () , self . pdr02 () , self . pdr03 () , self . pdr04 () , self . pdr05 () , self . pdr06 () , self . pdr07 () , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr11 () , self . pdr12 () , self . pdr13 () , self . pdr14 () , self . pdr15 () , self . podr00 () , self . podr01 () , self . podr02 () , self . podr03 () , self . podr04 () , self . podr05 () , self . podr06 () , self . podr07 () , self . podr08 () , self . podr09 () , self . podr10 () , self . podr11 () , self . podr12 () , self . podr13 () , self . podr14 () , self . podr15 ())
            }
        }
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr2(pub u32);
        impl Pcntr2 {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::Pcntr2Pidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr2Pidr00::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::Pcntr2Pidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::Pcntr2Pidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr2Pidr01::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::Pcntr2Pidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr02(&self) -> super::vals::Pcntr2Pidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr2Pidr02::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr02(&mut self, val: super::vals::Pcntr2Pidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr03(&self) -> super::vals::Pcntr2Pidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr2Pidr03::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr03(&mut self, val: super::vals::Pcntr2Pidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr04(&self) -> super::vals::Pcntr2Pidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr2Pidr04::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr04(&mut self, val: super::vals::Pcntr2Pidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr05(&self) -> super::vals::Pcntr2Pidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr2Pidr05::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr05(&mut self, val: super::vals::Pcntr2Pidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr06(&self) -> super::vals::Pcntr2Pidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr2Pidr06::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr06(&mut self, val: super::vals::Pcntr2Pidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::Pcntr2Pidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr2Pidr07::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::Pcntr2Pidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::Pcntr2Pidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr2Pidr08::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::Pcntr2Pidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::Pcntr2Pidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr2Pidr09::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::Pcntr2Pidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::Pcntr2Pidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr2Pidr10::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::Pcntr2Pidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr11(&self) -> super::vals::Pcntr2Pidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr2Pidr11::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr11(&mut self, val: super::vals::Pcntr2Pidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::Pcntr2Pidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr2Pidr12::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::Pcntr2Pidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::Pcntr2Pidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr2Pidr13::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::Pcntr2Pidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::Pcntr2Pidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr2Pidr14::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::Pcntr2Pidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::Pcntr2Pidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr2Pidr15::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::Pcntr2Pidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr00(&self) -> super::vals::Pcntr2Eidr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr2Eidr00::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr00(&mut self, val: super::vals::Pcntr2Eidr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr01(&self) -> super::vals::Pcntr2Eidr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr2Eidr01::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr01(&mut self, val: super::vals::Pcntr2Eidr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr02(&self) -> super::vals::Pcntr2Eidr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr2Eidr02::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr02(&mut self, val: super::vals::Pcntr2Eidr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr03(&self) -> super::vals::Pcntr2Eidr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr2Eidr03::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr03(&mut self, val: super::vals::Pcntr2Eidr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr04(&self) -> super::vals::Pcntr2Eidr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr2Eidr04::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr04(&mut self, val: super::vals::Pcntr2Eidr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr05(&self) -> super::vals::Pcntr2Eidr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr2Eidr05::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr05(&mut self, val: super::vals::Pcntr2Eidr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr06(&self) -> super::vals::Pcntr2Eidr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr2Eidr06::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr06(&mut self, val: super::vals::Pcntr2Eidr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr07(&self) -> super::vals::Pcntr2Eidr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr2Eidr07::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr07(&mut self, val: super::vals::Pcntr2Eidr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr08(&self) -> super::vals::Pcntr2Eidr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr2Eidr08::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr08(&mut self, val: super::vals::Pcntr2Eidr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr09(&self) -> super::vals::Pcntr2Eidr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr2Eidr09::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr09(&mut self, val: super::vals::Pcntr2Eidr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr10(&self) -> super::vals::Pcntr2Eidr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr2Eidr10::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr10(&mut self, val: super::vals::Pcntr2Eidr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr11(&self) -> super::vals::Pcntr2Eidr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr2Eidr11::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr11(&mut self, val: super::vals::Pcntr2Eidr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr12(&self) -> super::vals::Pcntr2Eidr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr2Eidr12::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr12(&mut self, val: super::vals::Pcntr2Eidr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr13(&self) -> super::vals::Pcntr2Eidr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr2Eidr13::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr13(&mut self, val: super::vals::Pcntr2Eidr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr14(&self) -> super::vals::Pcntr2Eidr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr2Eidr14::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr14(&mut self, val: super::vals::Pcntr2Eidr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr15(&self) -> super::vals::Pcntr2Eidr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr2Eidr15::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr15(&mut self, val: super::vals::Pcntr2Eidr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr2 {
            #[inline(always)]
            fn default() -> Pcntr2 {
                Pcntr2(0)
            }
        }
        impl core::fmt::Debug for Pcntr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr2")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr02", &self.pidr02())
                    .field("pidr03", &self.pidr03())
                    .field("pidr04", &self.pidr04())
                    .field("pidr05", &self.pidr05())
                    .field("pidr06", &self.pidr06())
                    .field("pidr07", &self.pidr07())
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr11", &self.pidr11())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .field("eidr00", &self.eidr00())
                    .field("eidr01", &self.eidr01())
                    .field("eidr02", &self.eidr02())
                    .field("eidr03", &self.eidr03())
                    .field("eidr04", &self.eidr04())
                    .field("eidr05", &self.eidr05())
                    .field("eidr06", &self.eidr06())
                    .field("eidr07", &self.eidr07())
                    .field("eidr08", &self.eidr08())
                    .field("eidr09", &self.eidr09())
                    .field("eidr10", &self.eidr10())
                    .field("eidr11", &self.eidr11())
                    .field("eidr12", &self.eidr12())
                    .field("eidr13", &self.eidr13())
                    .field("eidr14", &self.eidr14())
                    .field("eidr15", &self.eidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr2 {{ pidr00: {:?}, pidr01: {:?}, pidr02: {:?}, pidr03: {:?}, pidr04: {:?}, pidr05: {:?}, pidr06: {:?}, pidr07: {:?}, pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr11: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?}, eidr00: {:?}, eidr01: {:?}, eidr02: {:?}, eidr03: {:?}, eidr04: {:?}, eidr05: {:?}, eidr06: {:?}, eidr07: {:?}, eidr08: {:?}, eidr09: {:?}, eidr10: {:?}, eidr11: {:?}, eidr12: {:?}, eidr13: {:?}, eidr14: {:?}, eidr15: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr02 () , self . pidr03 () , self . pidr04 () , self . pidr05 () , self . pidr06 () , self . pidr07 () , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr11 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 () , self . eidr00 () , self . eidr01 () , self . eidr02 () , self . eidr03 () , self . eidr04 () , self . eidr05 () , self . eidr06 () , self . eidr07 () , self . eidr08 () , self . eidr09 () , self . eidr10 () , self . eidr11 () , self . eidr12 () , self . eidr13 () , self . eidr14 () , self . eidr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr3(pub u32);
        impl Pcntr3 {
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::Pcntr3Posr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr3Posr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::Pcntr3Posr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::Pcntr3Posr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr3Posr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::Pcntr3Posr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr02(&self) -> super::vals::Pcntr3Posr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr3Posr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr02(&mut self, val: super::vals::Pcntr3Posr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr03(&self) -> super::vals::Pcntr3Posr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr3Posr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr03(&mut self, val: super::vals::Pcntr3Posr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr04(&self) -> super::vals::Pcntr3Posr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr3Posr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr04(&mut self, val: super::vals::Pcntr3Posr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr05(&self) -> super::vals::Pcntr3Posr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr3Posr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr05(&mut self, val: super::vals::Pcntr3Posr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr06(&self) -> super::vals::Pcntr3Posr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr3Posr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr06(&mut self, val: super::vals::Pcntr3Posr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::Pcntr3Posr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr3Posr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::Pcntr3Posr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::Pcntr3Posr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr3Posr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::Pcntr3Posr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::Pcntr3Posr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr3Posr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::Pcntr3Posr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::Pcntr3Posr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr3Posr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::Pcntr3Posr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr11(&self) -> super::vals::Pcntr3Posr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr3Posr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr11(&mut self, val: super::vals::Pcntr3Posr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::Pcntr3Posr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr3Posr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::Pcntr3Posr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::Pcntr3Posr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr3Posr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::Pcntr3Posr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::Pcntr3Posr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr3Posr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::Pcntr3Posr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr15(&self) -> super::vals::Pcntr3Posr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr3Posr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr15(&mut self, val: super::vals::Pcntr3Posr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::Pcntr3Porr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr3Porr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::Pcntr3Porr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::Pcntr3Porr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr3Porr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::Pcntr3Porr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr02(&self) -> super::vals::Pcntr3Porr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr3Porr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr02(&mut self, val: super::vals::Pcntr3Porr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr03(&self) -> super::vals::Pcntr3Porr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr3Porr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr03(&mut self, val: super::vals::Pcntr3Porr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr04(&self) -> super::vals::Pcntr3Porr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr3Porr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr04(&mut self, val: super::vals::Pcntr3Porr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr05(&self) -> super::vals::Pcntr3Porr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr3Porr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr05(&mut self, val: super::vals::Pcntr3Porr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr06(&self) -> super::vals::Pcntr3Porr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr3Porr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr06(&mut self, val: super::vals::Pcntr3Porr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::Pcntr3Porr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr3Porr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::Pcntr3Porr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::Pcntr3Porr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr3Porr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::Pcntr3Porr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::Pcntr3Porr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr3Porr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::Pcntr3Porr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::Pcntr3Porr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr3Porr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::Pcntr3Porr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr11(&self) -> super::vals::Pcntr3Porr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr3Porr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr11(&mut self, val: super::vals::Pcntr3Porr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::Pcntr3Porr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr3Porr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::Pcntr3Porr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::Pcntr3Porr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr3Porr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::Pcntr3Porr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::Pcntr3Porr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr3Porr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::Pcntr3Porr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr15(&self) -> super::vals::Pcntr3Porr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr3Porr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr15(&mut self, val: super::vals::Pcntr3Porr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr3 {
            #[inline(always)]
            fn default() -> Pcntr3 {
                Pcntr3(0)
            }
        }
        impl core::fmt::Debug for Pcntr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr3")
                    .field("posr00", &self.posr00())
                    .field("posr01", &self.posr01())
                    .field("posr02", &self.posr02())
                    .field("posr03", &self.posr03())
                    .field("posr04", &self.posr04())
                    .field("posr05", &self.posr05())
                    .field("posr06", &self.posr06())
                    .field("posr07", &self.posr07())
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr11", &self.posr11())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .field("posr15", &self.posr15())
                    .field("porr00", &self.porr00())
                    .field("porr01", &self.porr01())
                    .field("porr02", &self.porr02())
                    .field("porr03", &self.porr03())
                    .field("porr04", &self.porr04())
                    .field("porr05", &self.porr05())
                    .field("porr06", &self.porr06())
                    .field("porr07", &self.porr07())
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr11", &self.porr11())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .field("porr15", &self.porr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr3 {{ posr00: {:?}, posr01: {:?}, posr02: {:?}, posr03: {:?}, posr04: {:?}, posr05: {:?}, posr06: {:?}, posr07: {:?}, posr08: {:?}, posr09: {:?}, posr10: {:?}, posr11: {:?}, posr12: {:?}, posr13: {:?}, posr14: {:?}, posr15: {:?}, porr00: {:?}, porr01: {:?}, porr02: {:?}, porr03: {:?}, porr04: {:?}, porr05: {:?}, porr06: {:?}, porr07: {:?}, porr08: {:?}, porr09: {:?}, porr10: {:?}, porr11: {:?}, porr12: {:?}, porr13: {:?}, porr14: {:?}, porr15: {:?} }}" , self . posr00 () , self . posr01 () , self . posr02 () , self . posr03 () , self . posr04 () , self . posr05 () , self . posr06 () , self . posr07 () , self . posr08 () , self . posr09 () , self . posr10 () , self . posr11 () , self . posr12 () , self . posr13 () , self . posr14 () , self . posr15 () , self . porr00 () , self . porr01 () , self . porr02 () , self . porr03 () , self . porr04 () , self . porr05 () , self . porr06 () , self . porr07 () , self . porr08 () , self . porr09 () , self . porr10 () , self . porr11 () , self . porr12 () , self . porr13 () , self . porr14 () , self . porr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr(pub u16);
        impl Pdr {
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::PdrPdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PdrPdr00::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::PdrPdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::PdrPdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PdrPdr01::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::PdrPdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr02(&self) -> super::vals::PdrPdr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PdrPdr02::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr02(&mut self, val: super::vals::PdrPdr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr03(&self) -> super::vals::PdrPdr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PdrPdr03::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr03(&mut self, val: super::vals::PdrPdr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr04(&self) -> super::vals::PdrPdr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PdrPdr04::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr04(&mut self, val: super::vals::PdrPdr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr05(&self) -> super::vals::PdrPdr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PdrPdr05::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr05(&mut self, val: super::vals::PdrPdr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr06(&self) -> super::vals::PdrPdr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PdrPdr06::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr06(&mut self, val: super::vals::PdrPdr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::PdrPdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PdrPdr07::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::PdrPdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::PdrPdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PdrPdr08::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::PdrPdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::PdrPdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PdrPdr09::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::PdrPdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::PdrPdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PdrPdr10::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::PdrPdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr11(&self) -> super::vals::PdrPdr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PdrPdr11::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr11(&mut self, val: super::vals::PdrPdr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::PdrPdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PdrPdr12::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::PdrPdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::PdrPdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PdrPdr13::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::PdrPdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::PdrPdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PdrPdr14::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::PdrPdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr15(&self) -> super::vals::PdrPdr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PdrPdr15::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr15(&mut self, val: super::vals::PdrPdr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pdr {
            #[inline(always)]
            fn default() -> Pdr {
                Pdr(0)
            }
        }
        impl core::fmt::Debug for Pdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr")
                    .field("pdr00", &self.pdr00())
                    .field("pdr01", &self.pdr01())
                    .field("pdr02", &self.pdr02())
                    .field("pdr03", &self.pdr03())
                    .field("pdr04", &self.pdr04())
                    .field("pdr05", &self.pdr05())
                    .field("pdr06", &self.pdr06())
                    .field("pdr07", &self.pdr07())
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr11", &self.pdr11())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .field("pdr15", &self.pdr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pdr {{ pdr00: {:?}, pdr01: {:?}, pdr02: {:?}, pdr03: {:?}, pdr04: {:?}, pdr05: {:?}, pdr06: {:?}, pdr07: {:?}, pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr11: {:?}, pdr12: {:?}, pdr13: {:?}, pdr14: {:?}, pdr15: {:?} }}" , self . pdr00 () , self . pdr01 () , self . pdr02 () , self . pdr03 () , self . pdr04 () , self . pdr05 () , self . pdr06 () , self . pdr07 () , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr11 () , self . pdr12 () , self . pdr13 () , self . pdr14 () , self . pdr15 ())
            }
        }
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr(pub u16);
        impl Pidr {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::PidrPidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PidrPidr00::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::PidrPidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::PidrPidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PidrPidr01::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::PidrPidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr02(&self) -> super::vals::PidrPidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PidrPidr02::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr02(&mut self, val: super::vals::PidrPidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr03(&self) -> super::vals::PidrPidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PidrPidr03::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr03(&mut self, val: super::vals::PidrPidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr04(&self) -> super::vals::PidrPidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PidrPidr04::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr04(&mut self, val: super::vals::PidrPidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr05(&self) -> super::vals::PidrPidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PidrPidr05::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr05(&mut self, val: super::vals::PidrPidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr06(&self) -> super::vals::PidrPidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PidrPidr06::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr06(&mut self, val: super::vals::PidrPidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::PidrPidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PidrPidr07::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::PidrPidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::PidrPidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PidrPidr08::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::PidrPidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::PidrPidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PidrPidr09::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::PidrPidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::PidrPidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PidrPidr10::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::PidrPidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr11(&self) -> super::vals::PidrPidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PidrPidr11::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr11(&mut self, val: super::vals::PidrPidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::PidrPidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PidrPidr12::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::PidrPidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::PidrPidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PidrPidr13::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::PidrPidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::PidrPidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PidrPidr14::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::PidrPidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::PidrPidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PidrPidr15::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::PidrPidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pidr {
            #[inline(always)]
            fn default() -> Pidr {
                Pidr(0)
            }
        }
        impl core::fmt::Debug for Pidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr02", &self.pidr02())
                    .field("pidr03", &self.pidr03())
                    .field("pidr04", &self.pidr04())
                    .field("pidr05", &self.pidr05())
                    .field("pidr06", &self.pidr06())
                    .field("pidr07", &self.pidr07())
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr11", &self.pidr11())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pidr {{ pidr00: {:?}, pidr01: {:?}, pidr02: {:?}, pidr03: {:?}, pidr04: {:?}, pidr05: {:?}, pidr06: {:?}, pidr07: {:?}, pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr11: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr02 () , self . pidr03 () , self . pidr04 () , self . pidr05 () , self . pidr06 () , self . pidr07 () , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr11 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr(pub u16);
        impl Podr {
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::PodrPodr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PodrPodr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::PodrPodr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::PodrPodr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PodrPodr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::PodrPodr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr02(&self) -> super::vals::PodrPodr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PodrPodr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr02(&mut self, val: super::vals::PodrPodr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr03(&self) -> super::vals::PodrPodr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PodrPodr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr03(&mut self, val: super::vals::PodrPodr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr04(&self) -> super::vals::PodrPodr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PodrPodr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr04(&mut self, val: super::vals::PodrPodr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr05(&self) -> super::vals::PodrPodr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PodrPodr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr05(&mut self, val: super::vals::PodrPodr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr06(&self) -> super::vals::PodrPodr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PodrPodr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr06(&mut self, val: super::vals::PodrPodr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::PodrPodr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PodrPodr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::PodrPodr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::PodrPodr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PodrPodr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::PodrPodr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::PodrPodr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PodrPodr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::PodrPodr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::PodrPodr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PodrPodr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::PodrPodr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr11(&self) -> super::vals::PodrPodr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PodrPodr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr11(&mut self, val: super::vals::PodrPodr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::PodrPodr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PodrPodr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::PodrPodr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::PodrPodr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PodrPodr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::PodrPodr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::PodrPodr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PodrPodr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::PodrPodr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr15(&self) -> super::vals::PodrPodr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PodrPodr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr15(&mut self, val: super::vals::PodrPodr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Podr {
            #[inline(always)]
            fn default() -> Podr {
                Podr(0)
            }
        }
        impl core::fmt::Debug for Podr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr")
                    .field("podr00", &self.podr00())
                    .field("podr01", &self.podr01())
                    .field("podr02", &self.podr02())
                    .field("podr03", &self.podr03())
                    .field("podr04", &self.podr04())
                    .field("podr05", &self.podr05())
                    .field("podr06", &self.podr06())
                    .field("podr07", &self.podr07())
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr11", &self.podr11())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .field("podr15", &self.podr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Podr {{ podr00: {:?}, podr01: {:?}, podr02: {:?}, podr03: {:?}, podr04: {:?}, podr05: {:?}, podr06: {:?}, podr07: {:?}, podr08: {:?}, podr09: {:?}, podr10: {:?}, podr11: {:?}, podr12: {:?}, podr13: {:?}, podr14: {:?}, podr15: {:?} }}" , self . podr00 () , self . podr01 () , self . podr02 () , self . podr03 () , self . podr04 () , self . podr05 () , self . podr06 () , self . podr07 () , self . podr08 () , self . podr09 () , self . podr10 () , self . podr11 () , self . podr12 () , self . podr13 () , self . podr14 () , self . podr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr(pub u16);
        impl Porr {
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::PorrPorr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PorrPorr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::PorrPorr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::PorrPorr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PorrPorr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::PorrPorr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr02(&self) -> super::vals::PorrPorr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PorrPorr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr02(&mut self, val: super::vals::PorrPorr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr03(&self) -> super::vals::PorrPorr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PorrPorr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr03(&mut self, val: super::vals::PorrPorr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr04(&self) -> super::vals::PorrPorr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PorrPorr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr04(&mut self, val: super::vals::PorrPorr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr05(&self) -> super::vals::PorrPorr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PorrPorr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr05(&mut self, val: super::vals::PorrPorr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr06(&self) -> super::vals::PorrPorr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PorrPorr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr06(&mut self, val: super::vals::PorrPorr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::PorrPorr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PorrPorr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::PorrPorr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::PorrPorr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PorrPorr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::PorrPorr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::PorrPorr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PorrPorr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::PorrPorr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::PorrPorr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PorrPorr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::PorrPorr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr11(&self) -> super::vals::PorrPorr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PorrPorr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr11(&mut self, val: super::vals::PorrPorr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::PorrPorr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PorrPorr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::PorrPorr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::PorrPorr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PorrPorr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::PorrPorr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::PorrPorr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PorrPorr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::PorrPorr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr15(&self) -> super::vals::PorrPorr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PorrPorr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr15(&mut self, val: super::vals::PorrPorr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Porr {
            #[inline(always)]
            fn default() -> Porr {
                Porr(0)
            }
        }
        impl core::fmt::Debug for Porr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr")
                    .field("porr00", &self.porr00())
                    .field("porr01", &self.porr01())
                    .field("porr02", &self.porr02())
                    .field("porr03", &self.porr03())
                    .field("porr04", &self.porr04())
                    .field("porr05", &self.porr05())
                    .field("porr06", &self.porr06())
                    .field("porr07", &self.porr07())
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr11", &self.porr11())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .field("porr15", &self.porr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Porr {{ porr00: {:?}, porr01: {:?}, porr02: {:?}, porr03: {:?}, porr04: {:?}, porr05: {:?}, porr06: {:?}, porr07: {:?}, porr08: {:?}, porr09: {:?}, porr10: {:?}, porr11: {:?}, porr12: {:?}, porr13: {:?}, porr14: {:?}, porr15: {:?} }}" , self . porr00 () , self . porr01 () , self . porr02 () , self . porr03 () , self . porr04 () , self . porr05 () , self . porr06 () , self . porr07 () , self . porr08 () , self . porr09 () , self . porr10 () , self . porr11 () , self . porr12 () , self . porr13 () , self . porr14 () , self . porr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr(pub u16);
        impl Posr {
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::PosrPosr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PosrPosr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::PosrPosr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::PosrPosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PosrPosr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::PosrPosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr02(&self) -> super::vals::PosrPosr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PosrPosr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr02(&mut self, val: super::vals::PosrPosr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr03(&self) -> super::vals::PosrPosr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PosrPosr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr03(&mut self, val: super::vals::PosrPosr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr04(&self) -> super::vals::PosrPosr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PosrPosr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr04(&mut self, val: super::vals::PosrPosr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr05(&self) -> super::vals::PosrPosr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PosrPosr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr05(&mut self, val: super::vals::PosrPosr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr06(&self) -> super::vals::PosrPosr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PosrPosr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr06(&mut self, val: super::vals::PosrPosr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::PosrPosr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PosrPosr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::PosrPosr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::PosrPosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PosrPosr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::PosrPosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::PosrPosr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PosrPosr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::PosrPosr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::PosrPosr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PosrPosr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::PosrPosr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr11(&self) -> super::vals::PosrPosr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PosrPosr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr11(&mut self, val: super::vals::PosrPosr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::PosrPosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PosrPosr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::PosrPosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::PosrPosr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PosrPosr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::PosrPosr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::PosrPosr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PosrPosr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::PosrPosr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr15(&self) -> super::vals::PosrPosr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PosrPosr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr15(&mut self, val: super::vals::PosrPosr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Posr {
            #[inline(always)]
            fn default() -> Posr {
                Posr(0)
            }
        }
        impl core::fmt::Debug for Posr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr")
                    .field("posr00", &self.posr00())
                    .field("posr01", &self.posr01())
                    .field("posr02", &self.posr02())
                    .field("posr03", &self.posr03())
                    .field("posr04", &self.posr04())
                    .field("posr05", &self.posr05())
                    .field("posr06", &self.posr06())
                    .field("posr07", &self.posr07())
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr11", &self.posr11())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .field("posr15", &self.posr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Posr {{ posr00: {:?}, posr01: {:?}, posr02: {:?}, posr03: {:?}, posr04: {:?}, posr05: {:?}, posr06: {:?}, posr07: {:?}, posr08: {:?}, posr09: {:?}, posr10: {:?}, posr11: {:?}, posr12: {:?}, posr13: {:?}, posr14: {:?}, posr15: {:?} }}" , self . posr00 () , self . posr01 () , self . posr02 () , self . posr03 () , self . posr04 () , self . posr05 () , self . posr06 () , self . posr07 () , self . posr08 () , self . posr09 () , self . posr10 () , self . posr11 () , self . posr12 () , self . posr13 () , self . posr14 () , self . posr15 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr00 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr00 {
                EidrEidr00::from_bits(val)
            }
        }
        impl From<EidrEidr00> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr00) -> u8 {
                EidrEidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr01 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr01 {
                EidrEidr01::from_bits(val)
            }
        }
        impl From<EidrEidr01> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr01) -> u8 {
                EidrEidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr02 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr02 {
                EidrEidr02::from_bits(val)
            }
        }
        impl From<EidrEidr02> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr02) -> u8 {
                EidrEidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr03 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr03 {
                EidrEidr03::from_bits(val)
            }
        }
        impl From<EidrEidr03> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr03) -> u8 {
                EidrEidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr04 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr04 {
                EidrEidr04::from_bits(val)
            }
        }
        impl From<EidrEidr04> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr04) -> u8 {
                EidrEidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr05 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr05 {
                EidrEidr05::from_bits(val)
            }
        }
        impl From<EidrEidr05> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr05) -> u8 {
                EidrEidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr06 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr06 {
                EidrEidr06::from_bits(val)
            }
        }
        impl From<EidrEidr06> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr06) -> u8 {
                EidrEidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr07 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr07 {
                EidrEidr07::from_bits(val)
            }
        }
        impl From<EidrEidr07> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr07) -> u8 {
                EidrEidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr08 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr08 {
                EidrEidr08::from_bits(val)
            }
        }
        impl From<EidrEidr08> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr08) -> u8 {
                EidrEidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr09 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr09 {
                EidrEidr09::from_bits(val)
            }
        }
        impl From<EidrEidr09> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr09) -> u8 {
                EidrEidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr10 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr10 {
                EidrEidr10::from_bits(val)
            }
        }
        impl From<EidrEidr10> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr10) -> u8 {
                EidrEidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr11 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr11 {
                EidrEidr11::from_bits(val)
            }
        }
        impl From<EidrEidr11> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr11) -> u8 {
                EidrEidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr12 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr12 {
                EidrEidr12::from_bits(val)
            }
        }
        impl From<EidrEidr12> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr12) -> u8 {
                EidrEidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr13 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr13 {
                EidrEidr13::from_bits(val)
            }
        }
        impl From<EidrEidr13> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr13) -> u8 {
                EidrEidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr14 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr14 {
                EidrEidr14::from_bits(val)
            }
        }
        impl From<EidrEidr14> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr14) -> u8 {
                EidrEidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr15 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr15 {
                EidrEidr15::from_bits(val)
            }
        }
        impl From<EidrEidr15> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr15) -> u8 {
                EidrEidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr00 {
                Pcntr1Pdr00::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr00) -> u8 {
                Pcntr1Pdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr01 {
                Pcntr1Pdr01::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr01) -> u8 {
                Pcntr1Pdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr02 {
                Pcntr1Pdr02::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr02) -> u8 {
                Pcntr1Pdr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr03 {
                Pcntr1Pdr03::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr03) -> u8 {
                Pcntr1Pdr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr04 {
                Pcntr1Pdr04::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr04) -> u8 {
                Pcntr1Pdr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr05 {
                Pcntr1Pdr05::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr05) -> u8 {
                Pcntr1Pdr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr06 {
                Pcntr1Pdr06::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr06) -> u8 {
                Pcntr1Pdr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr07 {
                Pcntr1Pdr07::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr07) -> u8 {
                Pcntr1Pdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr08 {
                Pcntr1Pdr08::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr08) -> u8 {
                Pcntr1Pdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr09 {
                Pcntr1Pdr09::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr09) -> u8 {
                Pcntr1Pdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr10 {
                Pcntr1Pdr10::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr10) -> u8 {
                Pcntr1Pdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr11 {
                Pcntr1Pdr11::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr11) -> u8 {
                Pcntr1Pdr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr12 {
                Pcntr1Pdr12::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr12) -> u8 {
                Pcntr1Pdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr13 {
                Pcntr1Pdr13::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr13) -> u8 {
                Pcntr1Pdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr14 {
                Pcntr1Pdr14::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr14) -> u8 {
                Pcntr1Pdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr15 {
                Pcntr1Pdr15::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr15) -> u8 {
                Pcntr1Pdr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr00 {
                Pcntr1Podr00::from_bits(val)
            }
        }
        impl From<Pcntr1Podr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr00) -> u8 {
                Pcntr1Podr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr01 {
                Pcntr1Podr01::from_bits(val)
            }
        }
        impl From<Pcntr1Podr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr01) -> u8 {
                Pcntr1Podr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr02 {
                Pcntr1Podr02::from_bits(val)
            }
        }
        impl From<Pcntr1Podr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr02) -> u8 {
                Pcntr1Podr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr03 {
                Pcntr1Podr03::from_bits(val)
            }
        }
        impl From<Pcntr1Podr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr03) -> u8 {
                Pcntr1Podr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr04 {
                Pcntr1Podr04::from_bits(val)
            }
        }
        impl From<Pcntr1Podr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr04) -> u8 {
                Pcntr1Podr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr05 {
                Pcntr1Podr05::from_bits(val)
            }
        }
        impl From<Pcntr1Podr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr05) -> u8 {
                Pcntr1Podr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr06 {
                Pcntr1Podr06::from_bits(val)
            }
        }
        impl From<Pcntr1Podr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr06) -> u8 {
                Pcntr1Podr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr07 {
                Pcntr1Podr07::from_bits(val)
            }
        }
        impl From<Pcntr1Podr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr07) -> u8 {
                Pcntr1Podr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr08 {
                Pcntr1Podr08::from_bits(val)
            }
        }
        impl From<Pcntr1Podr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr08) -> u8 {
                Pcntr1Podr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr09 {
                Pcntr1Podr09::from_bits(val)
            }
        }
        impl From<Pcntr1Podr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr09) -> u8 {
                Pcntr1Podr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr10 {
                Pcntr1Podr10::from_bits(val)
            }
        }
        impl From<Pcntr1Podr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr10) -> u8 {
                Pcntr1Podr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr11 {
                Pcntr1Podr11::from_bits(val)
            }
        }
        impl From<Pcntr1Podr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr11) -> u8 {
                Pcntr1Podr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr12 {
                Pcntr1Podr12::from_bits(val)
            }
        }
        impl From<Pcntr1Podr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr12) -> u8 {
                Pcntr1Podr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr13 {
                Pcntr1Podr13::from_bits(val)
            }
        }
        impl From<Pcntr1Podr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr13) -> u8 {
                Pcntr1Podr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr14 {
                Pcntr1Podr14::from_bits(val)
            }
        }
        impl From<Pcntr1Podr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr14) -> u8 {
                Pcntr1Podr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr15 {
                Pcntr1Podr15::from_bits(val)
            }
        }
        impl From<Pcntr1Podr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr15) -> u8 {
                Pcntr1Podr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr00 {
                Pcntr2Eidr00::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr00) -> u8 {
                Pcntr2Eidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr01 {
                Pcntr2Eidr01::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr01) -> u8 {
                Pcntr2Eidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr02 {
                Pcntr2Eidr02::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr02) -> u8 {
                Pcntr2Eidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr03 {
                Pcntr2Eidr03::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr03) -> u8 {
                Pcntr2Eidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr04 {
                Pcntr2Eidr04::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr04) -> u8 {
                Pcntr2Eidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr05 {
                Pcntr2Eidr05::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr05) -> u8 {
                Pcntr2Eidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr06 {
                Pcntr2Eidr06::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr06) -> u8 {
                Pcntr2Eidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr07 {
                Pcntr2Eidr07::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr07) -> u8 {
                Pcntr2Eidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr08 {
                Pcntr2Eidr08::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr08) -> u8 {
                Pcntr2Eidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr09 {
                Pcntr2Eidr09::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr09) -> u8 {
                Pcntr2Eidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr10 {
                Pcntr2Eidr10::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr10) -> u8 {
                Pcntr2Eidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr11 {
                Pcntr2Eidr11::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr11) -> u8 {
                Pcntr2Eidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr12 {
                Pcntr2Eidr12::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr12) -> u8 {
                Pcntr2Eidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr13 {
                Pcntr2Eidr13::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr13) -> u8 {
                Pcntr2Eidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr14 {
                Pcntr2Eidr14::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr14) -> u8 {
                Pcntr2Eidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr15 {
                Pcntr2Eidr15::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr15) -> u8 {
                Pcntr2Eidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr00 {
                Pcntr2Pidr00::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr00) -> u8 {
                Pcntr2Pidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr01 {
                Pcntr2Pidr01::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr01) -> u8 {
                Pcntr2Pidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr02 {
                Pcntr2Pidr02::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr02) -> u8 {
                Pcntr2Pidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr03 {
                Pcntr2Pidr03::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr03) -> u8 {
                Pcntr2Pidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr04 {
                Pcntr2Pidr04::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr04) -> u8 {
                Pcntr2Pidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr05 {
                Pcntr2Pidr05::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr05) -> u8 {
                Pcntr2Pidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr06 {
                Pcntr2Pidr06::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr06) -> u8 {
                Pcntr2Pidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr07 {
                Pcntr2Pidr07::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr07) -> u8 {
                Pcntr2Pidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr08 {
                Pcntr2Pidr08::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr08) -> u8 {
                Pcntr2Pidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr09 {
                Pcntr2Pidr09::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr09) -> u8 {
                Pcntr2Pidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr10 {
                Pcntr2Pidr10::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr10) -> u8 {
                Pcntr2Pidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr11 {
                Pcntr2Pidr11::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr11) -> u8 {
                Pcntr2Pidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr12 {
                Pcntr2Pidr12::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr12) -> u8 {
                Pcntr2Pidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr13 {
                Pcntr2Pidr13::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr13) -> u8 {
                Pcntr2Pidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr14 {
                Pcntr2Pidr14::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr14) -> u8 {
                Pcntr2Pidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr15 {
                Pcntr2Pidr15::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr15) -> u8 {
                Pcntr2Pidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr00 {
                Pcntr3Porr00::from_bits(val)
            }
        }
        impl From<Pcntr3Porr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr00) -> u8 {
                Pcntr3Porr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr01 {
                Pcntr3Porr01::from_bits(val)
            }
        }
        impl From<Pcntr3Porr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr01) -> u8 {
                Pcntr3Porr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr02 {
                Pcntr3Porr02::from_bits(val)
            }
        }
        impl From<Pcntr3Porr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr02) -> u8 {
                Pcntr3Porr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr03 {
                Pcntr3Porr03::from_bits(val)
            }
        }
        impl From<Pcntr3Porr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr03) -> u8 {
                Pcntr3Porr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr04 {
                Pcntr3Porr04::from_bits(val)
            }
        }
        impl From<Pcntr3Porr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr04) -> u8 {
                Pcntr3Porr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr05 {
                Pcntr3Porr05::from_bits(val)
            }
        }
        impl From<Pcntr3Porr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr05) -> u8 {
                Pcntr3Porr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr06 {
                Pcntr3Porr06::from_bits(val)
            }
        }
        impl From<Pcntr3Porr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr06) -> u8 {
                Pcntr3Porr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr07 {
                Pcntr3Porr07::from_bits(val)
            }
        }
        impl From<Pcntr3Porr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr07) -> u8 {
                Pcntr3Porr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr08 {
                Pcntr3Porr08::from_bits(val)
            }
        }
        impl From<Pcntr3Porr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr08) -> u8 {
                Pcntr3Porr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr09 {
                Pcntr3Porr09::from_bits(val)
            }
        }
        impl From<Pcntr3Porr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr09) -> u8 {
                Pcntr3Porr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr10 {
                Pcntr3Porr10::from_bits(val)
            }
        }
        impl From<Pcntr3Porr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr10) -> u8 {
                Pcntr3Porr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr11 {
                Pcntr3Porr11::from_bits(val)
            }
        }
        impl From<Pcntr3Porr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr11) -> u8 {
                Pcntr3Porr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr12 {
                Pcntr3Porr12::from_bits(val)
            }
        }
        impl From<Pcntr3Porr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr12) -> u8 {
                Pcntr3Porr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr13 {
                Pcntr3Porr13::from_bits(val)
            }
        }
        impl From<Pcntr3Porr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr13) -> u8 {
                Pcntr3Porr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr14 {
                Pcntr3Porr14::from_bits(val)
            }
        }
        impl From<Pcntr3Porr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr14) -> u8 {
                Pcntr3Porr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr15 {
                Pcntr3Porr15::from_bits(val)
            }
        }
        impl From<Pcntr3Porr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr15) -> u8 {
                Pcntr3Porr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr00 {
                Pcntr3Posr00::from_bits(val)
            }
        }
        impl From<Pcntr3Posr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr00) -> u8 {
                Pcntr3Posr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr01 {
                Pcntr3Posr01::from_bits(val)
            }
        }
        impl From<Pcntr3Posr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr01) -> u8 {
                Pcntr3Posr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr02 {
                Pcntr3Posr02::from_bits(val)
            }
        }
        impl From<Pcntr3Posr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr02) -> u8 {
                Pcntr3Posr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr03 {
                Pcntr3Posr03::from_bits(val)
            }
        }
        impl From<Pcntr3Posr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr03) -> u8 {
                Pcntr3Posr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr04 {
                Pcntr3Posr04::from_bits(val)
            }
        }
        impl From<Pcntr3Posr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr04) -> u8 {
                Pcntr3Posr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr05 {
                Pcntr3Posr05::from_bits(val)
            }
        }
        impl From<Pcntr3Posr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr05) -> u8 {
                Pcntr3Posr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr06 {
                Pcntr3Posr06::from_bits(val)
            }
        }
        impl From<Pcntr3Posr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr06) -> u8 {
                Pcntr3Posr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr07 {
                Pcntr3Posr07::from_bits(val)
            }
        }
        impl From<Pcntr3Posr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr07) -> u8 {
                Pcntr3Posr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr08 {
                Pcntr3Posr08::from_bits(val)
            }
        }
        impl From<Pcntr3Posr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr08) -> u8 {
                Pcntr3Posr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr09 {
                Pcntr3Posr09::from_bits(val)
            }
        }
        impl From<Pcntr3Posr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr09) -> u8 {
                Pcntr3Posr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr10 {
                Pcntr3Posr10::from_bits(val)
            }
        }
        impl From<Pcntr3Posr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr10) -> u8 {
                Pcntr3Posr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr11 {
                Pcntr3Posr11::from_bits(val)
            }
        }
        impl From<Pcntr3Posr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr11) -> u8 {
                Pcntr3Posr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr12 {
                Pcntr3Posr12::from_bits(val)
            }
        }
        impl From<Pcntr3Posr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr12) -> u8 {
                Pcntr3Posr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr13 {
                Pcntr3Posr13::from_bits(val)
            }
        }
        impl From<Pcntr3Posr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr13) -> u8 {
                Pcntr3Posr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr14 {
                Pcntr3Posr14::from_bits(val)
            }
        }
        impl From<Pcntr3Posr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr14) -> u8 {
                Pcntr3Posr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr15 {
                Pcntr3Posr15::from_bits(val)
            }
        }
        impl From<Pcntr3Posr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr15) -> u8 {
                Pcntr3Posr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr00 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr00 {
                PdrPdr00::from_bits(val)
            }
        }
        impl From<PdrPdr00> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr00) -> u8 {
                PdrPdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr01 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr01 {
                PdrPdr01::from_bits(val)
            }
        }
        impl From<PdrPdr01> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr01) -> u8 {
                PdrPdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr02 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr02 {
                PdrPdr02::from_bits(val)
            }
        }
        impl From<PdrPdr02> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr02) -> u8 {
                PdrPdr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr03 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr03 {
                PdrPdr03::from_bits(val)
            }
        }
        impl From<PdrPdr03> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr03) -> u8 {
                PdrPdr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr04 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr04 {
                PdrPdr04::from_bits(val)
            }
        }
        impl From<PdrPdr04> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr04) -> u8 {
                PdrPdr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr05 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr05 {
                PdrPdr05::from_bits(val)
            }
        }
        impl From<PdrPdr05> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr05) -> u8 {
                PdrPdr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr06 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr06 {
                PdrPdr06::from_bits(val)
            }
        }
        impl From<PdrPdr06> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr06) -> u8 {
                PdrPdr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr07 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr07 {
                PdrPdr07::from_bits(val)
            }
        }
        impl From<PdrPdr07> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr07) -> u8 {
                PdrPdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr08 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr08 {
                PdrPdr08::from_bits(val)
            }
        }
        impl From<PdrPdr08> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr08) -> u8 {
                PdrPdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr09 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr09 {
                PdrPdr09::from_bits(val)
            }
        }
        impl From<PdrPdr09> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr09) -> u8 {
                PdrPdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr10 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr10 {
                PdrPdr10::from_bits(val)
            }
        }
        impl From<PdrPdr10> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr10) -> u8 {
                PdrPdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr11 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr11 {
                PdrPdr11::from_bits(val)
            }
        }
        impl From<PdrPdr11> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr11) -> u8 {
                PdrPdr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr12 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr12 {
                PdrPdr12::from_bits(val)
            }
        }
        impl From<PdrPdr12> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr12) -> u8 {
                PdrPdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr13 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr13 {
                PdrPdr13::from_bits(val)
            }
        }
        impl From<PdrPdr13> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr13) -> u8 {
                PdrPdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr14 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr14 {
                PdrPdr14::from_bits(val)
            }
        }
        impl From<PdrPdr14> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr14) -> u8 {
                PdrPdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr15 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr15 {
                PdrPdr15::from_bits(val)
            }
        }
        impl From<PdrPdr15> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr15) -> u8 {
                PdrPdr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr00 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr00 {
                PidrPidr00::from_bits(val)
            }
        }
        impl From<PidrPidr00> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr00) -> u8 {
                PidrPidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr01 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr01 {
                PidrPidr01::from_bits(val)
            }
        }
        impl From<PidrPidr01> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr01) -> u8 {
                PidrPidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr02 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr02 {
                PidrPidr02::from_bits(val)
            }
        }
        impl From<PidrPidr02> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr02) -> u8 {
                PidrPidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr03 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr03 {
                PidrPidr03::from_bits(val)
            }
        }
        impl From<PidrPidr03> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr03) -> u8 {
                PidrPidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr04 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr04 {
                PidrPidr04::from_bits(val)
            }
        }
        impl From<PidrPidr04> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr04) -> u8 {
                PidrPidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr05 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr05 {
                PidrPidr05::from_bits(val)
            }
        }
        impl From<PidrPidr05> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr05) -> u8 {
                PidrPidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr06 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr06 {
                PidrPidr06::from_bits(val)
            }
        }
        impl From<PidrPidr06> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr06) -> u8 {
                PidrPidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr07 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr07 {
                PidrPidr07::from_bits(val)
            }
        }
        impl From<PidrPidr07> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr07) -> u8 {
                PidrPidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr08 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr08 {
                PidrPidr08::from_bits(val)
            }
        }
        impl From<PidrPidr08> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr08) -> u8 {
                PidrPidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr09 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr09 {
                PidrPidr09::from_bits(val)
            }
        }
        impl From<PidrPidr09> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr09) -> u8 {
                PidrPidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr10 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr10 {
                PidrPidr10::from_bits(val)
            }
        }
        impl From<PidrPidr10> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr10) -> u8 {
                PidrPidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr11 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr11 {
                PidrPidr11::from_bits(val)
            }
        }
        impl From<PidrPidr11> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr11) -> u8 {
                PidrPidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr12 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr12 {
                PidrPidr12::from_bits(val)
            }
        }
        impl From<PidrPidr12> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr12) -> u8 {
                PidrPidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr13 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr13 {
                PidrPidr13::from_bits(val)
            }
        }
        impl From<PidrPidr13> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr13) -> u8 {
                PidrPidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr14 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr14 {
                PidrPidr14::from_bits(val)
            }
        }
        impl From<PidrPidr14> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr14) -> u8 {
                PidrPidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr15 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr15 {
                PidrPidr15::from_bits(val)
            }
        }
        impl From<PidrPidr15> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr15) -> u8 {
                PidrPidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr00 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr00 {
                PodrPodr00::from_bits(val)
            }
        }
        impl From<PodrPodr00> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr00) -> u8 {
                PodrPodr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr01 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr01 {
                PodrPodr01::from_bits(val)
            }
        }
        impl From<PodrPodr01> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr01) -> u8 {
                PodrPodr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr02 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr02 {
                PodrPodr02::from_bits(val)
            }
        }
        impl From<PodrPodr02> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr02) -> u8 {
                PodrPodr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr03 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr03 {
                PodrPodr03::from_bits(val)
            }
        }
        impl From<PodrPodr03> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr03) -> u8 {
                PodrPodr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr04 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr04 {
                PodrPodr04::from_bits(val)
            }
        }
        impl From<PodrPodr04> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr04) -> u8 {
                PodrPodr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr05 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr05 {
                PodrPodr05::from_bits(val)
            }
        }
        impl From<PodrPodr05> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr05) -> u8 {
                PodrPodr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr06 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr06 {
                PodrPodr06::from_bits(val)
            }
        }
        impl From<PodrPodr06> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr06) -> u8 {
                PodrPodr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr07 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr07 {
                PodrPodr07::from_bits(val)
            }
        }
        impl From<PodrPodr07> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr07) -> u8 {
                PodrPodr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr08 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr08 {
                PodrPodr08::from_bits(val)
            }
        }
        impl From<PodrPodr08> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr08) -> u8 {
                PodrPodr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr09 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr09 {
                PodrPodr09::from_bits(val)
            }
        }
        impl From<PodrPodr09> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr09) -> u8 {
                PodrPodr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr10 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr10 {
                PodrPodr10::from_bits(val)
            }
        }
        impl From<PodrPodr10> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr10) -> u8 {
                PodrPodr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr11 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr11 {
                PodrPodr11::from_bits(val)
            }
        }
        impl From<PodrPodr11> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr11) -> u8 {
                PodrPodr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr12 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr12 {
                PodrPodr12::from_bits(val)
            }
        }
        impl From<PodrPodr12> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr12) -> u8 {
                PodrPodr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr13 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr13 {
                PodrPodr13::from_bits(val)
            }
        }
        impl From<PodrPodr13> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr13) -> u8 {
                PodrPodr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr14 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr14 {
                PodrPodr14::from_bits(val)
            }
        }
        impl From<PodrPodr14> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr14) -> u8 {
                PodrPodr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr15 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr15 {
                PodrPodr15::from_bits(val)
            }
        }
        impl From<PodrPodr15> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr15) -> u8 {
                PodrPodr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr00 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr00 {
                PorrPorr00::from_bits(val)
            }
        }
        impl From<PorrPorr00> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr00) -> u8 {
                PorrPorr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr01 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr01 {
                PorrPorr01::from_bits(val)
            }
        }
        impl From<PorrPorr01> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr01) -> u8 {
                PorrPorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr02 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr02 {
                PorrPorr02::from_bits(val)
            }
        }
        impl From<PorrPorr02> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr02) -> u8 {
                PorrPorr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr03 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr03 {
                PorrPorr03::from_bits(val)
            }
        }
        impl From<PorrPorr03> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr03) -> u8 {
                PorrPorr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr04 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr04 {
                PorrPorr04::from_bits(val)
            }
        }
        impl From<PorrPorr04> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr04) -> u8 {
                PorrPorr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr05 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr05 {
                PorrPorr05::from_bits(val)
            }
        }
        impl From<PorrPorr05> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr05) -> u8 {
                PorrPorr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr06 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr06 {
                PorrPorr06::from_bits(val)
            }
        }
        impl From<PorrPorr06> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr06) -> u8 {
                PorrPorr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr07 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr07 {
                PorrPorr07::from_bits(val)
            }
        }
        impl From<PorrPorr07> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr07) -> u8 {
                PorrPorr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr08 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr08 {
                PorrPorr08::from_bits(val)
            }
        }
        impl From<PorrPorr08> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr08) -> u8 {
                PorrPorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr09 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr09 {
                PorrPorr09::from_bits(val)
            }
        }
        impl From<PorrPorr09> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr09) -> u8 {
                PorrPorr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr10 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr10 {
                PorrPorr10::from_bits(val)
            }
        }
        impl From<PorrPorr10> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr10) -> u8 {
                PorrPorr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr11 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr11 {
                PorrPorr11::from_bits(val)
            }
        }
        impl From<PorrPorr11> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr11) -> u8 {
                PorrPorr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr12 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr12 {
                PorrPorr12::from_bits(val)
            }
        }
        impl From<PorrPorr12> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr12) -> u8 {
                PorrPorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr13 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr13 {
                PorrPorr13::from_bits(val)
            }
        }
        impl From<PorrPorr13> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr13) -> u8 {
                PorrPorr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr14 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr14 {
                PorrPorr14::from_bits(val)
            }
        }
        impl From<PorrPorr14> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr14) -> u8 {
                PorrPorr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr15 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr15 {
                PorrPorr15::from_bits(val)
            }
        }
        impl From<PorrPorr15> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr15) -> u8 {
                PorrPorr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr00 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr00 {
                PosrPosr00::from_bits(val)
            }
        }
        impl From<PosrPosr00> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr00) -> u8 {
                PosrPosr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr01 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr01 {
                PosrPosr01::from_bits(val)
            }
        }
        impl From<PosrPosr01> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr01) -> u8 {
                PosrPosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr02 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr02 {
                PosrPosr02::from_bits(val)
            }
        }
        impl From<PosrPosr02> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr02) -> u8 {
                PosrPosr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr03 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr03 {
                PosrPosr03::from_bits(val)
            }
        }
        impl From<PosrPosr03> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr03) -> u8 {
                PosrPosr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr04 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr04 {
                PosrPosr04::from_bits(val)
            }
        }
        impl From<PosrPosr04> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr04) -> u8 {
                PosrPosr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr05 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr05 {
                PosrPosr05::from_bits(val)
            }
        }
        impl From<PosrPosr05> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr05) -> u8 {
                PosrPosr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr06 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr06 {
                PosrPosr06::from_bits(val)
            }
        }
        impl From<PosrPosr06> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr06) -> u8 {
                PosrPosr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr07 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr07 {
                PosrPosr07::from_bits(val)
            }
        }
        impl From<PosrPosr07> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr07) -> u8 {
                PosrPosr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr08 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr08 {
                PosrPosr08::from_bits(val)
            }
        }
        impl From<PosrPosr08> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr08) -> u8 {
                PosrPosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr09 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr09 {
                PosrPosr09::from_bits(val)
            }
        }
        impl From<PosrPosr09> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr09) -> u8 {
                PosrPosr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr10 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr10 {
                PosrPosr10::from_bits(val)
            }
        }
        impl From<PosrPosr10> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr10) -> u8 {
                PosrPosr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr11 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr11 {
                PosrPosr11::from_bits(val)
            }
        }
        impl From<PosrPosr11> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr11) -> u8 {
                PosrPosr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr12 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr12 {
                PosrPosr12::from_bits(val)
            }
        }
        impl From<PosrPosr12> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr12) -> u8 {
                PosrPosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr13 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr13 {
                PosrPosr13::from_bits(val)
            }
        }
        impl From<PosrPosr13> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr13) -> u8 {
                PosrPosr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr14 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr14 {
                PosrPosr14::from_bits(val)
            }
        }
        impl From<PosrPosr14> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr14) -> u8 {
                PosrPosr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr15 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr15 {
                PosrPosr15::from_bits(val)
            }
        }
        impl From<PosrPosr15> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr15) -> u8 {
                PosrPosr15::to_bits(val)
            }
        }
    }
}
pub mod port1 {
    #[doc = "Port 1 Control Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port1 {}
    unsafe impl Sync for Port1 {}
    impl Port1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pcntr1(self) -> crate::common::Reg<regs::Pcntr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn podr(self) -> crate::common::Reg<regs::Podr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pdr(self) -> crate::common::Reg<regs::Pdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn eidr(self) -> crate::common::Reg<regs::Eidr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pcntr2(self) -> crate::common::Reg<regs::Pcntr2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pidr(self) -> crate::common::Reg<regs::Pidr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn pcntr3(self) -> crate::common::Reg<regs::Pcntr3, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn porr(self) -> crate::common::Reg<regs::Porr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn posr(self) -> crate::common::Reg<regs::Posr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Port Control Register 4"]
        #[inline(always)]
        pub const fn eorr(self) -> crate::common::Reg<regs::Eorr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Port Control Register 4"]
        #[inline(always)]
        pub const fn pcntr4(self) -> crate::common::Reg<regs::Pcntr4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Port Control Register 4"]
        #[inline(always)]
        pub const fn eosr(self) -> crate::common::Reg<regs::Eosr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eidr(pub u16);
        impl Eidr {
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr00(&self) -> super::vals::EidrEidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EidrEidr00::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr00(&mut self, val: super::vals::EidrEidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr01(&self) -> super::vals::EidrEidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::EidrEidr01::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr01(&mut self, val: super::vals::EidrEidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr02(&self) -> super::vals::EidrEidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::EidrEidr02::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr02(&mut self, val: super::vals::EidrEidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr03(&self) -> super::vals::EidrEidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::EidrEidr03::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr03(&mut self, val: super::vals::EidrEidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr04(&self) -> super::vals::EidrEidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::EidrEidr04::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr04(&mut self, val: super::vals::EidrEidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr05(&self) -> super::vals::EidrEidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::EidrEidr05::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr05(&mut self, val: super::vals::EidrEidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr06(&self) -> super::vals::EidrEidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::EidrEidr06::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr06(&mut self, val: super::vals::EidrEidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr07(&self) -> super::vals::EidrEidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::EidrEidr07::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr07(&mut self, val: super::vals::EidrEidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr08(&self) -> super::vals::EidrEidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::EidrEidr08::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr08(&mut self, val: super::vals::EidrEidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr09(&self) -> super::vals::EidrEidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::EidrEidr09::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr09(&mut self, val: super::vals::EidrEidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr10(&self) -> super::vals::EidrEidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::EidrEidr10::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr10(&mut self, val: super::vals::EidrEidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr11(&self) -> super::vals::EidrEidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::EidrEidr11::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr11(&mut self, val: super::vals::EidrEidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr12(&self) -> super::vals::EidrEidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::EidrEidr12::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr12(&mut self, val: super::vals::EidrEidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr13(&self) -> super::vals::EidrEidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::EidrEidr13::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr13(&mut self, val: super::vals::EidrEidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr14(&self) -> super::vals::EidrEidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::EidrEidr14::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr14(&mut self, val: super::vals::EidrEidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr15(&self) -> super::vals::EidrEidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::EidrEidr15::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr15(&mut self, val: super::vals::EidrEidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Eidr {
            #[inline(always)]
            fn default() -> Eidr {
                Eidr(0)
            }
        }
        impl core::fmt::Debug for Eidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eidr")
                    .field("eidr00", &self.eidr00())
                    .field("eidr01", &self.eidr01())
                    .field("eidr02", &self.eidr02())
                    .field("eidr03", &self.eidr03())
                    .field("eidr04", &self.eidr04())
                    .field("eidr05", &self.eidr05())
                    .field("eidr06", &self.eidr06())
                    .field("eidr07", &self.eidr07())
                    .field("eidr08", &self.eidr08())
                    .field("eidr09", &self.eidr09())
                    .field("eidr10", &self.eidr10())
                    .field("eidr11", &self.eidr11())
                    .field("eidr12", &self.eidr12())
                    .field("eidr13", &self.eidr13())
                    .field("eidr14", &self.eidr14())
                    .field("eidr15", &self.eidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eidr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eidr {{ eidr00: {:?}, eidr01: {:?}, eidr02: {:?}, eidr03: {:?}, eidr04: {:?}, eidr05: {:?}, eidr06: {:?}, eidr07: {:?}, eidr08: {:?}, eidr09: {:?}, eidr10: {:?}, eidr11: {:?}, eidr12: {:?}, eidr13: {:?}, eidr14: {:?}, eidr15: {:?} }}" , self . eidr00 () , self . eidr01 () , self . eidr02 () , self . eidr03 () , self . eidr04 () , self . eidr05 () , self . eidr06 () , self . eidr07 () , self . eidr08 () , self . eidr09 () , self . eidr10 () , self . eidr11 () , self . eidr12 () , self . eidr13 () , self . eidr14 () , self . eidr15 ())
            }
        }
        #[doc = "Port Control Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eorr(pub u16);
        impl Eorr {
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr00(&self) -> super::vals::EorrEorr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EorrEorr00::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr00(&mut self, val: super::vals::EorrEorr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr01(&self) -> super::vals::EorrEorr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::EorrEorr01::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr01(&mut self, val: super::vals::EorrEorr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr02(&self) -> super::vals::EorrEorr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::EorrEorr02::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr02(&mut self, val: super::vals::EorrEorr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr03(&self) -> super::vals::EorrEorr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::EorrEorr03::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr03(&mut self, val: super::vals::EorrEorr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr04(&self) -> super::vals::EorrEorr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::EorrEorr04::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr04(&mut self, val: super::vals::EorrEorr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr05(&self) -> super::vals::EorrEorr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::EorrEorr05::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr05(&mut self, val: super::vals::EorrEorr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr06(&self) -> super::vals::EorrEorr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::EorrEorr06::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr06(&mut self, val: super::vals::EorrEorr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr07(&self) -> super::vals::EorrEorr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::EorrEorr07::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr07(&mut self, val: super::vals::EorrEorr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr08(&self) -> super::vals::EorrEorr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::EorrEorr08::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr08(&mut self, val: super::vals::EorrEorr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr09(&self) -> super::vals::EorrEorr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::EorrEorr09::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr09(&mut self, val: super::vals::EorrEorr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr10(&self) -> super::vals::EorrEorr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::EorrEorr10::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr10(&mut self, val: super::vals::EorrEorr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr11(&self) -> super::vals::EorrEorr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::EorrEorr11::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr11(&mut self, val: super::vals::EorrEorr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr12(&self) -> super::vals::EorrEorr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::EorrEorr12::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr12(&mut self, val: super::vals::EorrEorr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr13(&self) -> super::vals::EorrEorr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::EorrEorr13::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr13(&mut self, val: super::vals::EorrEorr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr14(&self) -> super::vals::EorrEorr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::EorrEorr14::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr14(&mut self, val: super::vals::EorrEorr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr15(&self) -> super::vals::EorrEorr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::EorrEorr15::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr15(&mut self, val: super::vals::EorrEorr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Eorr {
            #[inline(always)]
            fn default() -> Eorr {
                Eorr(0)
            }
        }
        impl core::fmt::Debug for Eorr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eorr")
                    .field("eorr00", &self.eorr00())
                    .field("eorr01", &self.eorr01())
                    .field("eorr02", &self.eorr02())
                    .field("eorr03", &self.eorr03())
                    .field("eorr04", &self.eorr04())
                    .field("eorr05", &self.eorr05())
                    .field("eorr06", &self.eorr06())
                    .field("eorr07", &self.eorr07())
                    .field("eorr08", &self.eorr08())
                    .field("eorr09", &self.eorr09())
                    .field("eorr10", &self.eorr10())
                    .field("eorr11", &self.eorr11())
                    .field("eorr12", &self.eorr12())
                    .field("eorr13", &self.eorr13())
                    .field("eorr14", &self.eorr14())
                    .field("eorr15", &self.eorr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eorr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eorr {{ eorr00: {:?}, eorr01: {:?}, eorr02: {:?}, eorr03: {:?}, eorr04: {:?}, eorr05: {:?}, eorr06: {:?}, eorr07: {:?}, eorr08: {:?}, eorr09: {:?}, eorr10: {:?}, eorr11: {:?}, eorr12: {:?}, eorr13: {:?}, eorr14: {:?}, eorr15: {:?} }}" , self . eorr00 () , self . eorr01 () , self . eorr02 () , self . eorr03 () , self . eorr04 () , self . eorr05 () , self . eorr06 () , self . eorr07 () , self . eorr08 () , self . eorr09 () , self . eorr10 () , self . eorr11 () , self . eorr12 () , self . eorr13 () , self . eorr14 () , self . eorr15 ())
            }
        }
        #[doc = "Port Control Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eosr(pub u16);
        impl Eosr {
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr00(&self) -> super::vals::EosrEosr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EosrEosr00::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr00(&mut self, val: super::vals::EosrEosr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr01(&self) -> super::vals::EosrEosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::EosrEosr01::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr01(&mut self, val: super::vals::EosrEosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr02(&self) -> super::vals::EosrEosr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::EosrEosr02::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr02(&mut self, val: super::vals::EosrEosr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr03(&self) -> super::vals::EosrEosr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::EosrEosr03::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr03(&mut self, val: super::vals::EosrEosr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr04(&self) -> super::vals::EosrEosr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::EosrEosr04::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr04(&mut self, val: super::vals::EosrEosr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr05(&self) -> super::vals::EosrEosr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::EosrEosr05::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr05(&mut self, val: super::vals::EosrEosr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr06(&self) -> super::vals::EosrEosr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::EosrEosr06::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr06(&mut self, val: super::vals::EosrEosr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr07(&self) -> super::vals::EosrEosr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::EosrEosr07::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr07(&mut self, val: super::vals::EosrEosr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr08(&self) -> super::vals::EosrEosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::EosrEosr08::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr08(&mut self, val: super::vals::EosrEosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr09(&self) -> super::vals::EosrEosr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::EosrEosr09::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr09(&mut self, val: super::vals::EosrEosr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr10(&self) -> super::vals::EosrEosr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::EosrEosr10::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr10(&mut self, val: super::vals::EosrEosr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr11(&self) -> super::vals::EosrEosr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::EosrEosr11::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr11(&mut self, val: super::vals::EosrEosr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr12(&self) -> super::vals::EosrEosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::EosrEosr12::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr12(&mut self, val: super::vals::EosrEosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr13(&self) -> super::vals::EosrEosr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::EosrEosr13::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr13(&mut self, val: super::vals::EosrEosr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr14(&self) -> super::vals::EosrEosr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::EosrEosr14::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr14(&mut self, val: super::vals::EosrEosr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr15(&self) -> super::vals::EosrEosr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::EosrEosr15::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr15(&mut self, val: super::vals::EosrEosr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Eosr {
            #[inline(always)]
            fn default() -> Eosr {
                Eosr(0)
            }
        }
        impl core::fmt::Debug for Eosr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eosr")
                    .field("eosr00", &self.eosr00())
                    .field("eosr01", &self.eosr01())
                    .field("eosr02", &self.eosr02())
                    .field("eosr03", &self.eosr03())
                    .field("eosr04", &self.eosr04())
                    .field("eosr05", &self.eosr05())
                    .field("eosr06", &self.eosr06())
                    .field("eosr07", &self.eosr07())
                    .field("eosr08", &self.eosr08())
                    .field("eosr09", &self.eosr09())
                    .field("eosr10", &self.eosr10())
                    .field("eosr11", &self.eosr11())
                    .field("eosr12", &self.eosr12())
                    .field("eosr13", &self.eosr13())
                    .field("eosr14", &self.eosr14())
                    .field("eosr15", &self.eosr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eosr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eosr {{ eosr00: {:?}, eosr01: {:?}, eosr02: {:?}, eosr03: {:?}, eosr04: {:?}, eosr05: {:?}, eosr06: {:?}, eosr07: {:?}, eosr08: {:?}, eosr09: {:?}, eosr10: {:?}, eosr11: {:?}, eosr12: {:?}, eosr13: {:?}, eosr14: {:?}, eosr15: {:?} }}" , self . eosr00 () , self . eosr01 () , self . eosr02 () , self . eosr03 () , self . eosr04 () , self . eosr05 () , self . eosr06 () , self . eosr07 () , self . eosr08 () , self . eosr09 () , self . eosr10 () , self . eosr11 () , self . eosr12 () , self . eosr13 () , self . eosr14 () , self . eosr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr1(pub u32);
        impl Pcntr1 {
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::Pcntr1Pdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr1Pdr00::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::Pcntr1Pdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::Pcntr1Pdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr1Pdr01::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::Pcntr1Pdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr02(&self) -> super::vals::Pcntr1Pdr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr1Pdr02::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr02(&mut self, val: super::vals::Pcntr1Pdr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr03(&self) -> super::vals::Pcntr1Pdr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr1Pdr03::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr03(&mut self, val: super::vals::Pcntr1Pdr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr04(&self) -> super::vals::Pcntr1Pdr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr1Pdr04::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr04(&mut self, val: super::vals::Pcntr1Pdr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr05(&self) -> super::vals::Pcntr1Pdr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr1Pdr05::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr05(&mut self, val: super::vals::Pcntr1Pdr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr06(&self) -> super::vals::Pcntr1Pdr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr1Pdr06::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr06(&mut self, val: super::vals::Pcntr1Pdr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::Pcntr1Pdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr1Pdr07::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::Pcntr1Pdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::Pcntr1Pdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr1Pdr08::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::Pcntr1Pdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::Pcntr1Pdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr1Pdr09::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::Pcntr1Pdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::Pcntr1Pdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr1Pdr10::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::Pcntr1Pdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr11(&self) -> super::vals::Pcntr1Pdr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr1Pdr11::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr11(&mut self, val: super::vals::Pcntr1Pdr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::Pcntr1Pdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr1Pdr12::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::Pcntr1Pdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::Pcntr1Pdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr1Pdr13::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::Pcntr1Pdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::Pcntr1Pdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr1Pdr14::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::Pcntr1Pdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr15(&self) -> super::vals::Pcntr1Pdr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr1Pdr15::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr15(&mut self, val: super::vals::Pcntr1Pdr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::Pcntr1Podr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr1Podr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::Pcntr1Podr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::Pcntr1Podr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr1Podr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::Pcntr1Podr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr02(&self) -> super::vals::Pcntr1Podr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr1Podr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr02(&mut self, val: super::vals::Pcntr1Podr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr03(&self) -> super::vals::Pcntr1Podr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr1Podr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr03(&mut self, val: super::vals::Pcntr1Podr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr04(&self) -> super::vals::Pcntr1Podr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr1Podr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr04(&mut self, val: super::vals::Pcntr1Podr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr05(&self) -> super::vals::Pcntr1Podr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr1Podr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr05(&mut self, val: super::vals::Pcntr1Podr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr06(&self) -> super::vals::Pcntr1Podr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr1Podr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr06(&mut self, val: super::vals::Pcntr1Podr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::Pcntr1Podr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr1Podr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::Pcntr1Podr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::Pcntr1Podr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr1Podr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::Pcntr1Podr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::Pcntr1Podr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr1Podr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::Pcntr1Podr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::Pcntr1Podr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr1Podr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::Pcntr1Podr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr11(&self) -> super::vals::Pcntr1Podr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr1Podr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr11(&mut self, val: super::vals::Pcntr1Podr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::Pcntr1Podr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr1Podr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::Pcntr1Podr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::Pcntr1Podr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr1Podr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::Pcntr1Podr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::Pcntr1Podr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr1Podr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::Pcntr1Podr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr15(&self) -> super::vals::Pcntr1Podr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr1Podr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr15(&mut self, val: super::vals::Pcntr1Podr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr1 {
            #[inline(always)]
            fn default() -> Pcntr1 {
                Pcntr1(0)
            }
        }
        impl core::fmt::Debug for Pcntr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr1")
                    .field("pdr00", &self.pdr00())
                    .field("pdr01", &self.pdr01())
                    .field("pdr02", &self.pdr02())
                    .field("pdr03", &self.pdr03())
                    .field("pdr04", &self.pdr04())
                    .field("pdr05", &self.pdr05())
                    .field("pdr06", &self.pdr06())
                    .field("pdr07", &self.pdr07())
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr11", &self.pdr11())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .field("pdr15", &self.pdr15())
                    .field("podr00", &self.podr00())
                    .field("podr01", &self.podr01())
                    .field("podr02", &self.podr02())
                    .field("podr03", &self.podr03())
                    .field("podr04", &self.podr04())
                    .field("podr05", &self.podr05())
                    .field("podr06", &self.podr06())
                    .field("podr07", &self.podr07())
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr11", &self.podr11())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .field("podr15", &self.podr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr1 {{ pdr00: {:?}, pdr01: {:?}, pdr02: {:?}, pdr03: {:?}, pdr04: {:?}, pdr05: {:?}, pdr06: {:?}, pdr07: {:?}, pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr11: {:?}, pdr12: {:?}, pdr13: {:?}, pdr14: {:?}, pdr15: {:?}, podr00: {:?}, podr01: {:?}, podr02: {:?}, podr03: {:?}, podr04: {:?}, podr05: {:?}, podr06: {:?}, podr07: {:?}, podr08: {:?}, podr09: {:?}, podr10: {:?}, podr11: {:?}, podr12: {:?}, podr13: {:?}, podr14: {:?}, podr15: {:?} }}" , self . pdr00 () , self . pdr01 () , self . pdr02 () , self . pdr03 () , self . pdr04 () , self . pdr05 () , self . pdr06 () , self . pdr07 () , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr11 () , self . pdr12 () , self . pdr13 () , self . pdr14 () , self . pdr15 () , self . podr00 () , self . podr01 () , self . podr02 () , self . podr03 () , self . podr04 () , self . podr05 () , self . podr06 () , self . podr07 () , self . podr08 () , self . podr09 () , self . podr10 () , self . podr11 () , self . podr12 () , self . podr13 () , self . podr14 () , self . podr15 ())
            }
        }
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr2(pub u32);
        impl Pcntr2 {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::Pcntr2Pidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr2Pidr00::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::Pcntr2Pidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::Pcntr2Pidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr2Pidr01::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::Pcntr2Pidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr02(&self) -> super::vals::Pcntr2Pidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr2Pidr02::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr02(&mut self, val: super::vals::Pcntr2Pidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr03(&self) -> super::vals::Pcntr2Pidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr2Pidr03::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr03(&mut self, val: super::vals::Pcntr2Pidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr04(&self) -> super::vals::Pcntr2Pidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr2Pidr04::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr04(&mut self, val: super::vals::Pcntr2Pidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr05(&self) -> super::vals::Pcntr2Pidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr2Pidr05::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr05(&mut self, val: super::vals::Pcntr2Pidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr06(&self) -> super::vals::Pcntr2Pidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr2Pidr06::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr06(&mut self, val: super::vals::Pcntr2Pidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::Pcntr2Pidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr2Pidr07::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::Pcntr2Pidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::Pcntr2Pidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr2Pidr08::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::Pcntr2Pidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::Pcntr2Pidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr2Pidr09::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::Pcntr2Pidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::Pcntr2Pidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr2Pidr10::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::Pcntr2Pidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr11(&self) -> super::vals::Pcntr2Pidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr2Pidr11::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr11(&mut self, val: super::vals::Pcntr2Pidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::Pcntr2Pidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr2Pidr12::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::Pcntr2Pidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::Pcntr2Pidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr2Pidr13::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::Pcntr2Pidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::Pcntr2Pidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr2Pidr14::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::Pcntr2Pidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::Pcntr2Pidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr2Pidr15::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::Pcntr2Pidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr00(&self) -> super::vals::Pcntr2Eidr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr2Eidr00::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr00(&mut self, val: super::vals::Pcntr2Eidr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr01(&self) -> super::vals::Pcntr2Eidr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr2Eidr01::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr01(&mut self, val: super::vals::Pcntr2Eidr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr02(&self) -> super::vals::Pcntr2Eidr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr2Eidr02::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr02(&mut self, val: super::vals::Pcntr2Eidr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr03(&self) -> super::vals::Pcntr2Eidr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr2Eidr03::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr03(&mut self, val: super::vals::Pcntr2Eidr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr04(&self) -> super::vals::Pcntr2Eidr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr2Eidr04::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr04(&mut self, val: super::vals::Pcntr2Eidr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr05(&self) -> super::vals::Pcntr2Eidr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr2Eidr05::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr05(&mut self, val: super::vals::Pcntr2Eidr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr06(&self) -> super::vals::Pcntr2Eidr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr2Eidr06::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr06(&mut self, val: super::vals::Pcntr2Eidr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr07(&self) -> super::vals::Pcntr2Eidr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr2Eidr07::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr07(&mut self, val: super::vals::Pcntr2Eidr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr08(&self) -> super::vals::Pcntr2Eidr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr2Eidr08::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr08(&mut self, val: super::vals::Pcntr2Eidr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr09(&self) -> super::vals::Pcntr2Eidr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr2Eidr09::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr09(&mut self, val: super::vals::Pcntr2Eidr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr10(&self) -> super::vals::Pcntr2Eidr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr2Eidr10::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr10(&mut self, val: super::vals::Pcntr2Eidr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr11(&self) -> super::vals::Pcntr2Eidr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr2Eidr11::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr11(&mut self, val: super::vals::Pcntr2Eidr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr12(&self) -> super::vals::Pcntr2Eidr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr2Eidr12::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr12(&mut self, val: super::vals::Pcntr2Eidr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr13(&self) -> super::vals::Pcntr2Eidr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr2Eidr13::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr13(&mut self, val: super::vals::Pcntr2Eidr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr14(&self) -> super::vals::Pcntr2Eidr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr2Eidr14::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr14(&mut self, val: super::vals::Pcntr2Eidr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr15(&self) -> super::vals::Pcntr2Eidr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr2Eidr15::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr15(&mut self, val: super::vals::Pcntr2Eidr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr2 {
            #[inline(always)]
            fn default() -> Pcntr2 {
                Pcntr2(0)
            }
        }
        impl core::fmt::Debug for Pcntr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr2")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr02", &self.pidr02())
                    .field("pidr03", &self.pidr03())
                    .field("pidr04", &self.pidr04())
                    .field("pidr05", &self.pidr05())
                    .field("pidr06", &self.pidr06())
                    .field("pidr07", &self.pidr07())
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr11", &self.pidr11())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .field("eidr00", &self.eidr00())
                    .field("eidr01", &self.eidr01())
                    .field("eidr02", &self.eidr02())
                    .field("eidr03", &self.eidr03())
                    .field("eidr04", &self.eidr04())
                    .field("eidr05", &self.eidr05())
                    .field("eidr06", &self.eidr06())
                    .field("eidr07", &self.eidr07())
                    .field("eidr08", &self.eidr08())
                    .field("eidr09", &self.eidr09())
                    .field("eidr10", &self.eidr10())
                    .field("eidr11", &self.eidr11())
                    .field("eidr12", &self.eidr12())
                    .field("eidr13", &self.eidr13())
                    .field("eidr14", &self.eidr14())
                    .field("eidr15", &self.eidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr2 {{ pidr00: {:?}, pidr01: {:?}, pidr02: {:?}, pidr03: {:?}, pidr04: {:?}, pidr05: {:?}, pidr06: {:?}, pidr07: {:?}, pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr11: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?}, eidr00: {:?}, eidr01: {:?}, eidr02: {:?}, eidr03: {:?}, eidr04: {:?}, eidr05: {:?}, eidr06: {:?}, eidr07: {:?}, eidr08: {:?}, eidr09: {:?}, eidr10: {:?}, eidr11: {:?}, eidr12: {:?}, eidr13: {:?}, eidr14: {:?}, eidr15: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr02 () , self . pidr03 () , self . pidr04 () , self . pidr05 () , self . pidr06 () , self . pidr07 () , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr11 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 () , self . eidr00 () , self . eidr01 () , self . eidr02 () , self . eidr03 () , self . eidr04 () , self . eidr05 () , self . eidr06 () , self . eidr07 () , self . eidr08 () , self . eidr09 () , self . eidr10 () , self . eidr11 () , self . eidr12 () , self . eidr13 () , self . eidr14 () , self . eidr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr3(pub u32);
        impl Pcntr3 {
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::Pcntr3Posr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr3Posr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::Pcntr3Posr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::Pcntr3Posr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr3Posr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::Pcntr3Posr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr02(&self) -> super::vals::Pcntr3Posr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr3Posr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr02(&mut self, val: super::vals::Pcntr3Posr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr03(&self) -> super::vals::Pcntr3Posr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr3Posr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr03(&mut self, val: super::vals::Pcntr3Posr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr04(&self) -> super::vals::Pcntr3Posr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr3Posr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr04(&mut self, val: super::vals::Pcntr3Posr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr05(&self) -> super::vals::Pcntr3Posr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr3Posr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr05(&mut self, val: super::vals::Pcntr3Posr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr06(&self) -> super::vals::Pcntr3Posr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr3Posr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr06(&mut self, val: super::vals::Pcntr3Posr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::Pcntr3Posr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr3Posr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::Pcntr3Posr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::Pcntr3Posr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr3Posr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::Pcntr3Posr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::Pcntr3Posr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr3Posr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::Pcntr3Posr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::Pcntr3Posr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr3Posr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::Pcntr3Posr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr11(&self) -> super::vals::Pcntr3Posr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr3Posr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr11(&mut self, val: super::vals::Pcntr3Posr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::Pcntr3Posr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr3Posr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::Pcntr3Posr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::Pcntr3Posr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr3Posr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::Pcntr3Posr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::Pcntr3Posr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr3Posr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::Pcntr3Posr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr15(&self) -> super::vals::Pcntr3Posr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr3Posr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr15(&mut self, val: super::vals::Pcntr3Posr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::Pcntr3Porr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr3Porr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::Pcntr3Porr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::Pcntr3Porr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr3Porr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::Pcntr3Porr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr02(&self) -> super::vals::Pcntr3Porr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr3Porr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr02(&mut self, val: super::vals::Pcntr3Porr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr03(&self) -> super::vals::Pcntr3Porr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr3Porr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr03(&mut self, val: super::vals::Pcntr3Porr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr04(&self) -> super::vals::Pcntr3Porr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr3Porr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr04(&mut self, val: super::vals::Pcntr3Porr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr05(&self) -> super::vals::Pcntr3Porr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr3Porr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr05(&mut self, val: super::vals::Pcntr3Porr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr06(&self) -> super::vals::Pcntr3Porr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr3Porr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr06(&mut self, val: super::vals::Pcntr3Porr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::Pcntr3Porr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr3Porr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::Pcntr3Porr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::Pcntr3Porr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr3Porr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::Pcntr3Porr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::Pcntr3Porr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr3Porr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::Pcntr3Porr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::Pcntr3Porr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr3Porr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::Pcntr3Porr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr11(&self) -> super::vals::Pcntr3Porr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr3Porr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr11(&mut self, val: super::vals::Pcntr3Porr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::Pcntr3Porr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr3Porr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::Pcntr3Porr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::Pcntr3Porr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr3Porr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::Pcntr3Porr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::Pcntr3Porr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr3Porr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::Pcntr3Porr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr15(&self) -> super::vals::Pcntr3Porr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr3Porr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr15(&mut self, val: super::vals::Pcntr3Porr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr3 {
            #[inline(always)]
            fn default() -> Pcntr3 {
                Pcntr3(0)
            }
        }
        impl core::fmt::Debug for Pcntr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr3")
                    .field("posr00", &self.posr00())
                    .field("posr01", &self.posr01())
                    .field("posr02", &self.posr02())
                    .field("posr03", &self.posr03())
                    .field("posr04", &self.posr04())
                    .field("posr05", &self.posr05())
                    .field("posr06", &self.posr06())
                    .field("posr07", &self.posr07())
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr11", &self.posr11())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .field("posr15", &self.posr15())
                    .field("porr00", &self.porr00())
                    .field("porr01", &self.porr01())
                    .field("porr02", &self.porr02())
                    .field("porr03", &self.porr03())
                    .field("porr04", &self.porr04())
                    .field("porr05", &self.porr05())
                    .field("porr06", &self.porr06())
                    .field("porr07", &self.porr07())
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr11", &self.porr11())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .field("porr15", &self.porr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr3 {{ posr00: {:?}, posr01: {:?}, posr02: {:?}, posr03: {:?}, posr04: {:?}, posr05: {:?}, posr06: {:?}, posr07: {:?}, posr08: {:?}, posr09: {:?}, posr10: {:?}, posr11: {:?}, posr12: {:?}, posr13: {:?}, posr14: {:?}, posr15: {:?}, porr00: {:?}, porr01: {:?}, porr02: {:?}, porr03: {:?}, porr04: {:?}, porr05: {:?}, porr06: {:?}, porr07: {:?}, porr08: {:?}, porr09: {:?}, porr10: {:?}, porr11: {:?}, porr12: {:?}, porr13: {:?}, porr14: {:?}, porr15: {:?} }}" , self . posr00 () , self . posr01 () , self . posr02 () , self . posr03 () , self . posr04 () , self . posr05 () , self . posr06 () , self . posr07 () , self . posr08 () , self . posr09 () , self . posr10 () , self . posr11 () , self . posr12 () , self . posr13 () , self . posr14 () , self . posr15 () , self . porr00 () , self . porr01 () , self . porr02 () , self . porr03 () , self . porr04 () , self . porr05 () , self . porr06 () , self . porr07 () , self . porr08 () , self . porr09 () , self . porr10 () , self . porr11 () , self . porr12 () , self . porr13 () , self . porr14 () , self . porr15 ())
            }
        }
        #[doc = "Port Control Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr4(pub u32);
        impl Pcntr4 {
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr00(&self) -> super::vals::Pcntr4Eosr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr4Eosr00::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr00(&mut self, val: super::vals::Pcntr4Eosr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr01(&self) -> super::vals::Pcntr4Eosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr4Eosr01::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr01(&mut self, val: super::vals::Pcntr4Eosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr02(&self) -> super::vals::Pcntr4Eosr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr4Eosr02::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr02(&mut self, val: super::vals::Pcntr4Eosr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr03(&self) -> super::vals::Pcntr4Eosr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr4Eosr03::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr03(&mut self, val: super::vals::Pcntr4Eosr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr04(&self) -> super::vals::Pcntr4Eosr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr4Eosr04::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr04(&mut self, val: super::vals::Pcntr4Eosr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr05(&self) -> super::vals::Pcntr4Eosr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr4Eosr05::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr05(&mut self, val: super::vals::Pcntr4Eosr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr06(&self) -> super::vals::Pcntr4Eosr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr4Eosr06::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr06(&mut self, val: super::vals::Pcntr4Eosr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr07(&self) -> super::vals::Pcntr4Eosr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr4Eosr07::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr07(&mut self, val: super::vals::Pcntr4Eosr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr08(&self) -> super::vals::Pcntr4Eosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr4Eosr08::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr08(&mut self, val: super::vals::Pcntr4Eosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr09(&self) -> super::vals::Pcntr4Eosr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr4Eosr09::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr09(&mut self, val: super::vals::Pcntr4Eosr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr10(&self) -> super::vals::Pcntr4Eosr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr4Eosr10::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr10(&mut self, val: super::vals::Pcntr4Eosr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr11(&self) -> super::vals::Pcntr4Eosr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr4Eosr11::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr11(&mut self, val: super::vals::Pcntr4Eosr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr12(&self) -> super::vals::Pcntr4Eosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr4Eosr12::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr12(&mut self, val: super::vals::Pcntr4Eosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr13(&self) -> super::vals::Pcntr4Eosr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr4Eosr13::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr13(&mut self, val: super::vals::Pcntr4Eosr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr14(&self) -> super::vals::Pcntr4Eosr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr4Eosr14::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr14(&mut self, val: super::vals::Pcntr4Eosr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr15(&self) -> super::vals::Pcntr4Eosr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr4Eosr15::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr15(&mut self, val: super::vals::Pcntr4Eosr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr00(&self) -> super::vals::Pcntr4Eorr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr4Eorr00::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr00(&mut self, val: super::vals::Pcntr4Eorr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr01(&self) -> super::vals::Pcntr4Eorr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr4Eorr01::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr01(&mut self, val: super::vals::Pcntr4Eorr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr02(&self) -> super::vals::Pcntr4Eorr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr4Eorr02::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr02(&mut self, val: super::vals::Pcntr4Eorr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr03(&self) -> super::vals::Pcntr4Eorr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr4Eorr03::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr03(&mut self, val: super::vals::Pcntr4Eorr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr04(&self) -> super::vals::Pcntr4Eorr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr4Eorr04::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr04(&mut self, val: super::vals::Pcntr4Eorr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr05(&self) -> super::vals::Pcntr4Eorr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr4Eorr05::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr05(&mut self, val: super::vals::Pcntr4Eorr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr06(&self) -> super::vals::Pcntr4Eorr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr4Eorr06::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr06(&mut self, val: super::vals::Pcntr4Eorr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr07(&self) -> super::vals::Pcntr4Eorr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr4Eorr07::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr07(&mut self, val: super::vals::Pcntr4Eorr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr08(&self) -> super::vals::Pcntr4Eorr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr4Eorr08::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr08(&mut self, val: super::vals::Pcntr4Eorr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr09(&self) -> super::vals::Pcntr4Eorr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr4Eorr09::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr09(&mut self, val: super::vals::Pcntr4Eorr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr10(&self) -> super::vals::Pcntr4Eorr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr4Eorr10::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr10(&mut self, val: super::vals::Pcntr4Eorr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr11(&self) -> super::vals::Pcntr4Eorr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr4Eorr11::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr11(&mut self, val: super::vals::Pcntr4Eorr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr12(&self) -> super::vals::Pcntr4Eorr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr4Eorr12::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr12(&mut self, val: super::vals::Pcntr4Eorr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr13(&self) -> super::vals::Pcntr4Eorr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr4Eorr13::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr13(&mut self, val: super::vals::Pcntr4Eorr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr14(&self) -> super::vals::Pcntr4Eorr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr4Eorr14::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr14(&mut self, val: super::vals::Pcntr4Eorr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr15(&self) -> super::vals::Pcntr4Eorr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr4Eorr15::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr15(&mut self, val: super::vals::Pcntr4Eorr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr4 {
            #[inline(always)]
            fn default() -> Pcntr4 {
                Pcntr4(0)
            }
        }
        impl core::fmt::Debug for Pcntr4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr4")
                    .field("eosr00", &self.eosr00())
                    .field("eosr01", &self.eosr01())
                    .field("eosr02", &self.eosr02())
                    .field("eosr03", &self.eosr03())
                    .field("eosr04", &self.eosr04())
                    .field("eosr05", &self.eosr05())
                    .field("eosr06", &self.eosr06())
                    .field("eosr07", &self.eosr07())
                    .field("eosr08", &self.eosr08())
                    .field("eosr09", &self.eosr09())
                    .field("eosr10", &self.eosr10())
                    .field("eosr11", &self.eosr11())
                    .field("eosr12", &self.eosr12())
                    .field("eosr13", &self.eosr13())
                    .field("eosr14", &self.eosr14())
                    .field("eosr15", &self.eosr15())
                    .field("eorr00", &self.eorr00())
                    .field("eorr01", &self.eorr01())
                    .field("eorr02", &self.eorr02())
                    .field("eorr03", &self.eorr03())
                    .field("eorr04", &self.eorr04())
                    .field("eorr05", &self.eorr05())
                    .field("eorr06", &self.eorr06())
                    .field("eorr07", &self.eorr07())
                    .field("eorr08", &self.eorr08())
                    .field("eorr09", &self.eorr09())
                    .field("eorr10", &self.eorr10())
                    .field("eorr11", &self.eorr11())
                    .field("eorr12", &self.eorr12())
                    .field("eorr13", &self.eorr13())
                    .field("eorr14", &self.eorr14())
                    .field("eorr15", &self.eorr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr4 {{ eosr00: {:?}, eosr01: {:?}, eosr02: {:?}, eosr03: {:?}, eosr04: {:?}, eosr05: {:?}, eosr06: {:?}, eosr07: {:?}, eosr08: {:?}, eosr09: {:?}, eosr10: {:?}, eosr11: {:?}, eosr12: {:?}, eosr13: {:?}, eosr14: {:?}, eosr15: {:?}, eorr00: {:?}, eorr01: {:?}, eorr02: {:?}, eorr03: {:?}, eorr04: {:?}, eorr05: {:?}, eorr06: {:?}, eorr07: {:?}, eorr08: {:?}, eorr09: {:?}, eorr10: {:?}, eorr11: {:?}, eorr12: {:?}, eorr13: {:?}, eorr14: {:?}, eorr15: {:?} }}" , self . eosr00 () , self . eosr01 () , self . eosr02 () , self . eosr03 () , self . eosr04 () , self . eosr05 () , self . eosr06 () , self . eosr07 () , self . eosr08 () , self . eosr09 () , self . eosr10 () , self . eosr11 () , self . eosr12 () , self . eosr13 () , self . eosr14 () , self . eosr15 () , self . eorr00 () , self . eorr01 () , self . eorr02 () , self . eorr03 () , self . eorr04 () , self . eorr05 () , self . eorr06 () , self . eorr07 () , self . eorr08 () , self . eorr09 () , self . eorr10 () , self . eorr11 () , self . eorr12 () , self . eorr13 () , self . eorr14 () , self . eorr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr(pub u16);
        impl Pdr {
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::PdrPdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PdrPdr00::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::PdrPdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::PdrPdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PdrPdr01::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::PdrPdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr02(&self) -> super::vals::PdrPdr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PdrPdr02::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr02(&mut self, val: super::vals::PdrPdr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr03(&self) -> super::vals::PdrPdr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PdrPdr03::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr03(&mut self, val: super::vals::PdrPdr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr04(&self) -> super::vals::PdrPdr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PdrPdr04::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr04(&mut self, val: super::vals::PdrPdr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr05(&self) -> super::vals::PdrPdr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PdrPdr05::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr05(&mut self, val: super::vals::PdrPdr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr06(&self) -> super::vals::PdrPdr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PdrPdr06::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr06(&mut self, val: super::vals::PdrPdr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::PdrPdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PdrPdr07::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::PdrPdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::PdrPdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PdrPdr08::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::PdrPdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::PdrPdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PdrPdr09::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::PdrPdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::PdrPdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PdrPdr10::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::PdrPdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr11(&self) -> super::vals::PdrPdr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PdrPdr11::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr11(&mut self, val: super::vals::PdrPdr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::PdrPdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PdrPdr12::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::PdrPdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::PdrPdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PdrPdr13::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::PdrPdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::PdrPdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PdrPdr14::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::PdrPdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr15(&self) -> super::vals::PdrPdr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PdrPdr15::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr15(&mut self, val: super::vals::PdrPdr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pdr {
            #[inline(always)]
            fn default() -> Pdr {
                Pdr(0)
            }
        }
        impl core::fmt::Debug for Pdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr")
                    .field("pdr00", &self.pdr00())
                    .field("pdr01", &self.pdr01())
                    .field("pdr02", &self.pdr02())
                    .field("pdr03", &self.pdr03())
                    .field("pdr04", &self.pdr04())
                    .field("pdr05", &self.pdr05())
                    .field("pdr06", &self.pdr06())
                    .field("pdr07", &self.pdr07())
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr11", &self.pdr11())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .field("pdr15", &self.pdr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pdr {{ pdr00: {:?}, pdr01: {:?}, pdr02: {:?}, pdr03: {:?}, pdr04: {:?}, pdr05: {:?}, pdr06: {:?}, pdr07: {:?}, pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr11: {:?}, pdr12: {:?}, pdr13: {:?}, pdr14: {:?}, pdr15: {:?} }}" , self . pdr00 () , self . pdr01 () , self . pdr02 () , self . pdr03 () , self . pdr04 () , self . pdr05 () , self . pdr06 () , self . pdr07 () , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr11 () , self . pdr12 () , self . pdr13 () , self . pdr14 () , self . pdr15 ())
            }
        }
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr(pub u16);
        impl Pidr {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::PidrPidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PidrPidr00::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::PidrPidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::PidrPidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PidrPidr01::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::PidrPidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr02(&self) -> super::vals::PidrPidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PidrPidr02::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr02(&mut self, val: super::vals::PidrPidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr03(&self) -> super::vals::PidrPidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PidrPidr03::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr03(&mut self, val: super::vals::PidrPidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr04(&self) -> super::vals::PidrPidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PidrPidr04::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr04(&mut self, val: super::vals::PidrPidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr05(&self) -> super::vals::PidrPidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PidrPidr05::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr05(&mut self, val: super::vals::PidrPidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr06(&self) -> super::vals::PidrPidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PidrPidr06::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr06(&mut self, val: super::vals::PidrPidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::PidrPidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PidrPidr07::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::PidrPidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::PidrPidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PidrPidr08::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::PidrPidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::PidrPidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PidrPidr09::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::PidrPidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::PidrPidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PidrPidr10::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::PidrPidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr11(&self) -> super::vals::PidrPidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PidrPidr11::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr11(&mut self, val: super::vals::PidrPidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::PidrPidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PidrPidr12::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::PidrPidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::PidrPidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PidrPidr13::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::PidrPidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::PidrPidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PidrPidr14::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::PidrPidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::PidrPidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PidrPidr15::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::PidrPidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pidr {
            #[inline(always)]
            fn default() -> Pidr {
                Pidr(0)
            }
        }
        impl core::fmt::Debug for Pidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr02", &self.pidr02())
                    .field("pidr03", &self.pidr03())
                    .field("pidr04", &self.pidr04())
                    .field("pidr05", &self.pidr05())
                    .field("pidr06", &self.pidr06())
                    .field("pidr07", &self.pidr07())
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr11", &self.pidr11())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pidr {{ pidr00: {:?}, pidr01: {:?}, pidr02: {:?}, pidr03: {:?}, pidr04: {:?}, pidr05: {:?}, pidr06: {:?}, pidr07: {:?}, pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr11: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr02 () , self . pidr03 () , self . pidr04 () , self . pidr05 () , self . pidr06 () , self . pidr07 () , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr11 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr(pub u16);
        impl Podr {
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::PodrPodr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PodrPodr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::PodrPodr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::PodrPodr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PodrPodr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::PodrPodr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr02(&self) -> super::vals::PodrPodr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PodrPodr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr02(&mut self, val: super::vals::PodrPodr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr03(&self) -> super::vals::PodrPodr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PodrPodr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr03(&mut self, val: super::vals::PodrPodr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr04(&self) -> super::vals::PodrPodr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PodrPodr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr04(&mut self, val: super::vals::PodrPodr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr05(&self) -> super::vals::PodrPodr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PodrPodr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr05(&mut self, val: super::vals::PodrPodr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr06(&self) -> super::vals::PodrPodr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PodrPodr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr06(&mut self, val: super::vals::PodrPodr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::PodrPodr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PodrPodr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::PodrPodr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::PodrPodr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PodrPodr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::PodrPodr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::PodrPodr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PodrPodr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::PodrPodr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::PodrPodr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PodrPodr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::PodrPodr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr11(&self) -> super::vals::PodrPodr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PodrPodr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr11(&mut self, val: super::vals::PodrPodr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::PodrPodr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PodrPodr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::PodrPodr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::PodrPodr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PodrPodr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::PodrPodr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::PodrPodr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PodrPodr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::PodrPodr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr15(&self) -> super::vals::PodrPodr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PodrPodr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr15(&mut self, val: super::vals::PodrPodr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Podr {
            #[inline(always)]
            fn default() -> Podr {
                Podr(0)
            }
        }
        impl core::fmt::Debug for Podr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr")
                    .field("podr00", &self.podr00())
                    .field("podr01", &self.podr01())
                    .field("podr02", &self.podr02())
                    .field("podr03", &self.podr03())
                    .field("podr04", &self.podr04())
                    .field("podr05", &self.podr05())
                    .field("podr06", &self.podr06())
                    .field("podr07", &self.podr07())
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr11", &self.podr11())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .field("podr15", &self.podr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Podr {{ podr00: {:?}, podr01: {:?}, podr02: {:?}, podr03: {:?}, podr04: {:?}, podr05: {:?}, podr06: {:?}, podr07: {:?}, podr08: {:?}, podr09: {:?}, podr10: {:?}, podr11: {:?}, podr12: {:?}, podr13: {:?}, podr14: {:?}, podr15: {:?} }}" , self . podr00 () , self . podr01 () , self . podr02 () , self . podr03 () , self . podr04 () , self . podr05 () , self . podr06 () , self . podr07 () , self . podr08 () , self . podr09 () , self . podr10 () , self . podr11 () , self . podr12 () , self . podr13 () , self . podr14 () , self . podr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr(pub u16);
        impl Porr {
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::PorrPorr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PorrPorr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::PorrPorr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::PorrPorr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PorrPorr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::PorrPorr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr02(&self) -> super::vals::PorrPorr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PorrPorr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr02(&mut self, val: super::vals::PorrPorr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr03(&self) -> super::vals::PorrPorr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PorrPorr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr03(&mut self, val: super::vals::PorrPorr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr04(&self) -> super::vals::PorrPorr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PorrPorr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr04(&mut self, val: super::vals::PorrPorr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr05(&self) -> super::vals::PorrPorr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PorrPorr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr05(&mut self, val: super::vals::PorrPorr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr06(&self) -> super::vals::PorrPorr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PorrPorr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr06(&mut self, val: super::vals::PorrPorr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::PorrPorr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PorrPorr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::PorrPorr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::PorrPorr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PorrPorr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::PorrPorr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::PorrPorr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PorrPorr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::PorrPorr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::PorrPorr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PorrPorr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::PorrPorr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr11(&self) -> super::vals::PorrPorr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PorrPorr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr11(&mut self, val: super::vals::PorrPorr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::PorrPorr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PorrPorr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::PorrPorr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::PorrPorr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PorrPorr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::PorrPorr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::PorrPorr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PorrPorr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::PorrPorr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr15(&self) -> super::vals::PorrPorr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PorrPorr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr15(&mut self, val: super::vals::PorrPorr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Porr {
            #[inline(always)]
            fn default() -> Porr {
                Porr(0)
            }
        }
        impl core::fmt::Debug for Porr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr")
                    .field("porr00", &self.porr00())
                    .field("porr01", &self.porr01())
                    .field("porr02", &self.porr02())
                    .field("porr03", &self.porr03())
                    .field("porr04", &self.porr04())
                    .field("porr05", &self.porr05())
                    .field("porr06", &self.porr06())
                    .field("porr07", &self.porr07())
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr11", &self.porr11())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .field("porr15", &self.porr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Porr {{ porr00: {:?}, porr01: {:?}, porr02: {:?}, porr03: {:?}, porr04: {:?}, porr05: {:?}, porr06: {:?}, porr07: {:?}, porr08: {:?}, porr09: {:?}, porr10: {:?}, porr11: {:?}, porr12: {:?}, porr13: {:?}, porr14: {:?}, porr15: {:?} }}" , self . porr00 () , self . porr01 () , self . porr02 () , self . porr03 () , self . porr04 () , self . porr05 () , self . porr06 () , self . porr07 () , self . porr08 () , self . porr09 () , self . porr10 () , self . porr11 () , self . porr12 () , self . porr13 () , self . porr14 () , self . porr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr(pub u16);
        impl Posr {
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::PosrPosr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PosrPosr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::PosrPosr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::PosrPosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PosrPosr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::PosrPosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr02(&self) -> super::vals::PosrPosr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PosrPosr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr02(&mut self, val: super::vals::PosrPosr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr03(&self) -> super::vals::PosrPosr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PosrPosr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr03(&mut self, val: super::vals::PosrPosr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr04(&self) -> super::vals::PosrPosr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PosrPosr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr04(&mut self, val: super::vals::PosrPosr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr05(&self) -> super::vals::PosrPosr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PosrPosr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr05(&mut self, val: super::vals::PosrPosr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr06(&self) -> super::vals::PosrPosr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PosrPosr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr06(&mut self, val: super::vals::PosrPosr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::PosrPosr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PosrPosr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::PosrPosr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::PosrPosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PosrPosr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::PosrPosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::PosrPosr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PosrPosr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::PosrPosr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::PosrPosr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PosrPosr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::PosrPosr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr11(&self) -> super::vals::PosrPosr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PosrPosr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr11(&mut self, val: super::vals::PosrPosr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::PosrPosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PosrPosr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::PosrPosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::PosrPosr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PosrPosr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::PosrPosr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::PosrPosr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PosrPosr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::PosrPosr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr15(&self) -> super::vals::PosrPosr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PosrPosr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr15(&mut self, val: super::vals::PosrPosr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Posr {
            #[inline(always)]
            fn default() -> Posr {
                Posr(0)
            }
        }
        impl core::fmt::Debug for Posr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr")
                    .field("posr00", &self.posr00())
                    .field("posr01", &self.posr01())
                    .field("posr02", &self.posr02())
                    .field("posr03", &self.posr03())
                    .field("posr04", &self.posr04())
                    .field("posr05", &self.posr05())
                    .field("posr06", &self.posr06())
                    .field("posr07", &self.posr07())
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr11", &self.posr11())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .field("posr15", &self.posr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Posr {{ posr00: {:?}, posr01: {:?}, posr02: {:?}, posr03: {:?}, posr04: {:?}, posr05: {:?}, posr06: {:?}, posr07: {:?}, posr08: {:?}, posr09: {:?}, posr10: {:?}, posr11: {:?}, posr12: {:?}, posr13: {:?}, posr14: {:?}, posr15: {:?} }}" , self . posr00 () , self . posr01 () , self . posr02 () , self . posr03 () , self . posr04 () , self . posr05 () , self . posr06 () , self . posr07 () , self . posr08 () , self . posr09 () , self . posr10 () , self . posr11 () , self . posr12 () , self . posr13 () , self . posr14 () , self . posr15 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr00 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr00 {
                EidrEidr00::from_bits(val)
            }
        }
        impl From<EidrEidr00> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr00) -> u8 {
                EidrEidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr01 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr01 {
                EidrEidr01::from_bits(val)
            }
        }
        impl From<EidrEidr01> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr01) -> u8 {
                EidrEidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr02 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr02 {
                EidrEidr02::from_bits(val)
            }
        }
        impl From<EidrEidr02> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr02) -> u8 {
                EidrEidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr03 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr03 {
                EidrEidr03::from_bits(val)
            }
        }
        impl From<EidrEidr03> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr03) -> u8 {
                EidrEidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr04 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr04 {
                EidrEidr04::from_bits(val)
            }
        }
        impl From<EidrEidr04> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr04) -> u8 {
                EidrEidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr05 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr05 {
                EidrEidr05::from_bits(val)
            }
        }
        impl From<EidrEidr05> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr05) -> u8 {
                EidrEidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr06 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr06 {
                EidrEidr06::from_bits(val)
            }
        }
        impl From<EidrEidr06> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr06) -> u8 {
                EidrEidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr07 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr07 {
                EidrEidr07::from_bits(val)
            }
        }
        impl From<EidrEidr07> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr07) -> u8 {
                EidrEidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr08 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr08 {
                EidrEidr08::from_bits(val)
            }
        }
        impl From<EidrEidr08> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr08) -> u8 {
                EidrEidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr09 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr09 {
                EidrEidr09::from_bits(val)
            }
        }
        impl From<EidrEidr09> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr09) -> u8 {
                EidrEidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr10 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr10 {
                EidrEidr10::from_bits(val)
            }
        }
        impl From<EidrEidr10> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr10) -> u8 {
                EidrEidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr11 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr11 {
                EidrEidr11::from_bits(val)
            }
        }
        impl From<EidrEidr11> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr11) -> u8 {
                EidrEidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr12 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr12 {
                EidrEidr12::from_bits(val)
            }
        }
        impl From<EidrEidr12> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr12) -> u8 {
                EidrEidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr13 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr13 {
                EidrEidr13::from_bits(val)
            }
        }
        impl From<EidrEidr13> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr13) -> u8 {
                EidrEidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr14 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr14 {
                EidrEidr14::from_bits(val)
            }
        }
        impl From<EidrEidr14> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr14) -> u8 {
                EidrEidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr15 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr15 {
                EidrEidr15::from_bits(val)
            }
        }
        impl From<EidrEidr15> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr15) -> u8 {
                EidrEidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr00 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr00 {
                EorrEorr00::from_bits(val)
            }
        }
        impl From<EorrEorr00> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr00) -> u8 {
                EorrEorr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr01 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr01 {
                EorrEorr01::from_bits(val)
            }
        }
        impl From<EorrEorr01> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr01) -> u8 {
                EorrEorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr02 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr02 {
                EorrEorr02::from_bits(val)
            }
        }
        impl From<EorrEorr02> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr02) -> u8 {
                EorrEorr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr03 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr03 {
                EorrEorr03::from_bits(val)
            }
        }
        impl From<EorrEorr03> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr03) -> u8 {
                EorrEorr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr04 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr04 {
                EorrEorr04::from_bits(val)
            }
        }
        impl From<EorrEorr04> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr04) -> u8 {
                EorrEorr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr05 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr05 {
                EorrEorr05::from_bits(val)
            }
        }
        impl From<EorrEorr05> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr05) -> u8 {
                EorrEorr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr06 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr06 {
                EorrEorr06::from_bits(val)
            }
        }
        impl From<EorrEorr06> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr06) -> u8 {
                EorrEorr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr07 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr07 {
                EorrEorr07::from_bits(val)
            }
        }
        impl From<EorrEorr07> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr07) -> u8 {
                EorrEorr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr08 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr08 {
                EorrEorr08::from_bits(val)
            }
        }
        impl From<EorrEorr08> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr08) -> u8 {
                EorrEorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr09 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr09 {
                EorrEorr09::from_bits(val)
            }
        }
        impl From<EorrEorr09> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr09) -> u8 {
                EorrEorr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr10 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr10 {
                EorrEorr10::from_bits(val)
            }
        }
        impl From<EorrEorr10> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr10) -> u8 {
                EorrEorr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr11 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr11 {
                EorrEorr11::from_bits(val)
            }
        }
        impl From<EorrEorr11> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr11) -> u8 {
                EorrEorr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr12 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr12 {
                EorrEorr12::from_bits(val)
            }
        }
        impl From<EorrEorr12> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr12) -> u8 {
                EorrEorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr13 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr13 {
                EorrEorr13::from_bits(val)
            }
        }
        impl From<EorrEorr13> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr13) -> u8 {
                EorrEorr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr14 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr14 {
                EorrEorr14::from_bits(val)
            }
        }
        impl From<EorrEorr14> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr14) -> u8 {
                EorrEorr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr15 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr15 {
                EorrEorr15::from_bits(val)
            }
        }
        impl From<EorrEorr15> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr15) -> u8 {
                EorrEorr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr00 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr00 {
                EosrEosr00::from_bits(val)
            }
        }
        impl From<EosrEosr00> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr00) -> u8 {
                EosrEosr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr01 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr01 {
                EosrEosr01::from_bits(val)
            }
        }
        impl From<EosrEosr01> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr01) -> u8 {
                EosrEosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr02 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr02 {
                EosrEosr02::from_bits(val)
            }
        }
        impl From<EosrEosr02> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr02) -> u8 {
                EosrEosr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr03 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr03 {
                EosrEosr03::from_bits(val)
            }
        }
        impl From<EosrEosr03> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr03) -> u8 {
                EosrEosr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr04 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr04 {
                EosrEosr04::from_bits(val)
            }
        }
        impl From<EosrEosr04> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr04) -> u8 {
                EosrEosr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr05 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr05 {
                EosrEosr05::from_bits(val)
            }
        }
        impl From<EosrEosr05> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr05) -> u8 {
                EosrEosr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr06 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr06 {
                EosrEosr06::from_bits(val)
            }
        }
        impl From<EosrEosr06> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr06) -> u8 {
                EosrEosr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr07 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr07 {
                EosrEosr07::from_bits(val)
            }
        }
        impl From<EosrEosr07> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr07) -> u8 {
                EosrEosr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr08 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr08 {
                EosrEosr08::from_bits(val)
            }
        }
        impl From<EosrEosr08> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr08) -> u8 {
                EosrEosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr09 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr09 {
                EosrEosr09::from_bits(val)
            }
        }
        impl From<EosrEosr09> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr09) -> u8 {
                EosrEosr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr10 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr10 {
                EosrEosr10::from_bits(val)
            }
        }
        impl From<EosrEosr10> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr10) -> u8 {
                EosrEosr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr11 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr11 {
                EosrEosr11::from_bits(val)
            }
        }
        impl From<EosrEosr11> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr11) -> u8 {
                EosrEosr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr12 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr12 {
                EosrEosr12::from_bits(val)
            }
        }
        impl From<EosrEosr12> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr12) -> u8 {
                EosrEosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr13 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr13 {
                EosrEosr13::from_bits(val)
            }
        }
        impl From<EosrEosr13> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr13) -> u8 {
                EosrEosr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr14 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr14 {
                EosrEosr14::from_bits(val)
            }
        }
        impl From<EosrEosr14> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr14) -> u8 {
                EosrEosr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr15 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr15 {
                EosrEosr15::from_bits(val)
            }
        }
        impl From<EosrEosr15> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr15) -> u8 {
                EosrEosr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr00 {
                Pcntr1Pdr00::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr00) -> u8 {
                Pcntr1Pdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr01 {
                Pcntr1Pdr01::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr01) -> u8 {
                Pcntr1Pdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr02 {
                Pcntr1Pdr02::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr02) -> u8 {
                Pcntr1Pdr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr03 {
                Pcntr1Pdr03::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr03) -> u8 {
                Pcntr1Pdr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr04 {
                Pcntr1Pdr04::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr04) -> u8 {
                Pcntr1Pdr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr05 {
                Pcntr1Pdr05::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr05) -> u8 {
                Pcntr1Pdr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr06 {
                Pcntr1Pdr06::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr06) -> u8 {
                Pcntr1Pdr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr07 {
                Pcntr1Pdr07::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr07) -> u8 {
                Pcntr1Pdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr08 {
                Pcntr1Pdr08::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr08) -> u8 {
                Pcntr1Pdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr09 {
                Pcntr1Pdr09::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr09) -> u8 {
                Pcntr1Pdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr10 {
                Pcntr1Pdr10::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr10) -> u8 {
                Pcntr1Pdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr11 {
                Pcntr1Pdr11::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr11) -> u8 {
                Pcntr1Pdr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr12 {
                Pcntr1Pdr12::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr12) -> u8 {
                Pcntr1Pdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr13 {
                Pcntr1Pdr13::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr13) -> u8 {
                Pcntr1Pdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr14 {
                Pcntr1Pdr14::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr14) -> u8 {
                Pcntr1Pdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr15 {
                Pcntr1Pdr15::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr15) -> u8 {
                Pcntr1Pdr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr00 {
                Pcntr1Podr00::from_bits(val)
            }
        }
        impl From<Pcntr1Podr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr00) -> u8 {
                Pcntr1Podr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr01 {
                Pcntr1Podr01::from_bits(val)
            }
        }
        impl From<Pcntr1Podr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr01) -> u8 {
                Pcntr1Podr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr02 {
                Pcntr1Podr02::from_bits(val)
            }
        }
        impl From<Pcntr1Podr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr02) -> u8 {
                Pcntr1Podr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr03 {
                Pcntr1Podr03::from_bits(val)
            }
        }
        impl From<Pcntr1Podr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr03) -> u8 {
                Pcntr1Podr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr04 {
                Pcntr1Podr04::from_bits(val)
            }
        }
        impl From<Pcntr1Podr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr04) -> u8 {
                Pcntr1Podr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr05 {
                Pcntr1Podr05::from_bits(val)
            }
        }
        impl From<Pcntr1Podr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr05) -> u8 {
                Pcntr1Podr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr06 {
                Pcntr1Podr06::from_bits(val)
            }
        }
        impl From<Pcntr1Podr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr06) -> u8 {
                Pcntr1Podr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr07 {
                Pcntr1Podr07::from_bits(val)
            }
        }
        impl From<Pcntr1Podr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr07) -> u8 {
                Pcntr1Podr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr08 {
                Pcntr1Podr08::from_bits(val)
            }
        }
        impl From<Pcntr1Podr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr08) -> u8 {
                Pcntr1Podr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr09 {
                Pcntr1Podr09::from_bits(val)
            }
        }
        impl From<Pcntr1Podr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr09) -> u8 {
                Pcntr1Podr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr10 {
                Pcntr1Podr10::from_bits(val)
            }
        }
        impl From<Pcntr1Podr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr10) -> u8 {
                Pcntr1Podr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr11 {
                Pcntr1Podr11::from_bits(val)
            }
        }
        impl From<Pcntr1Podr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr11) -> u8 {
                Pcntr1Podr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr12 {
                Pcntr1Podr12::from_bits(val)
            }
        }
        impl From<Pcntr1Podr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr12) -> u8 {
                Pcntr1Podr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr13 {
                Pcntr1Podr13::from_bits(val)
            }
        }
        impl From<Pcntr1Podr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr13) -> u8 {
                Pcntr1Podr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr14 {
                Pcntr1Podr14::from_bits(val)
            }
        }
        impl From<Pcntr1Podr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr14) -> u8 {
                Pcntr1Podr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr15 {
                Pcntr1Podr15::from_bits(val)
            }
        }
        impl From<Pcntr1Podr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr15) -> u8 {
                Pcntr1Podr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr00 {
                Pcntr2Eidr00::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr00) -> u8 {
                Pcntr2Eidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr01 {
                Pcntr2Eidr01::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr01) -> u8 {
                Pcntr2Eidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr02 {
                Pcntr2Eidr02::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr02) -> u8 {
                Pcntr2Eidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr03 {
                Pcntr2Eidr03::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr03) -> u8 {
                Pcntr2Eidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr04 {
                Pcntr2Eidr04::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr04) -> u8 {
                Pcntr2Eidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr05 {
                Pcntr2Eidr05::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr05) -> u8 {
                Pcntr2Eidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr06 {
                Pcntr2Eidr06::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr06) -> u8 {
                Pcntr2Eidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr07 {
                Pcntr2Eidr07::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr07) -> u8 {
                Pcntr2Eidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr08 {
                Pcntr2Eidr08::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr08) -> u8 {
                Pcntr2Eidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr09 {
                Pcntr2Eidr09::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr09) -> u8 {
                Pcntr2Eidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr10 {
                Pcntr2Eidr10::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr10) -> u8 {
                Pcntr2Eidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr11 {
                Pcntr2Eidr11::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr11) -> u8 {
                Pcntr2Eidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr12 {
                Pcntr2Eidr12::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr12) -> u8 {
                Pcntr2Eidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr13 {
                Pcntr2Eidr13::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr13) -> u8 {
                Pcntr2Eidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr14 {
                Pcntr2Eidr14::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr14) -> u8 {
                Pcntr2Eidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr15 {
                Pcntr2Eidr15::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr15) -> u8 {
                Pcntr2Eidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr00 {
                Pcntr2Pidr00::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr00) -> u8 {
                Pcntr2Pidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr01 {
                Pcntr2Pidr01::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr01) -> u8 {
                Pcntr2Pidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr02 {
                Pcntr2Pidr02::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr02) -> u8 {
                Pcntr2Pidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr03 {
                Pcntr2Pidr03::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr03) -> u8 {
                Pcntr2Pidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr04 {
                Pcntr2Pidr04::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr04) -> u8 {
                Pcntr2Pidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr05 {
                Pcntr2Pidr05::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr05) -> u8 {
                Pcntr2Pidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr06 {
                Pcntr2Pidr06::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr06) -> u8 {
                Pcntr2Pidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr07 {
                Pcntr2Pidr07::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr07) -> u8 {
                Pcntr2Pidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr08 {
                Pcntr2Pidr08::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr08) -> u8 {
                Pcntr2Pidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr09 {
                Pcntr2Pidr09::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr09) -> u8 {
                Pcntr2Pidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr10 {
                Pcntr2Pidr10::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr10) -> u8 {
                Pcntr2Pidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr11 {
                Pcntr2Pidr11::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr11) -> u8 {
                Pcntr2Pidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr12 {
                Pcntr2Pidr12::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr12) -> u8 {
                Pcntr2Pidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr13 {
                Pcntr2Pidr13::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr13) -> u8 {
                Pcntr2Pidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr14 {
                Pcntr2Pidr14::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr14) -> u8 {
                Pcntr2Pidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr15 {
                Pcntr2Pidr15::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr15) -> u8 {
                Pcntr2Pidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr00 {
                Pcntr3Porr00::from_bits(val)
            }
        }
        impl From<Pcntr3Porr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr00) -> u8 {
                Pcntr3Porr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr01 {
                Pcntr3Porr01::from_bits(val)
            }
        }
        impl From<Pcntr3Porr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr01) -> u8 {
                Pcntr3Porr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr02 {
                Pcntr3Porr02::from_bits(val)
            }
        }
        impl From<Pcntr3Porr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr02) -> u8 {
                Pcntr3Porr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr03 {
                Pcntr3Porr03::from_bits(val)
            }
        }
        impl From<Pcntr3Porr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr03) -> u8 {
                Pcntr3Porr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr04 {
                Pcntr3Porr04::from_bits(val)
            }
        }
        impl From<Pcntr3Porr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr04) -> u8 {
                Pcntr3Porr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr05 {
                Pcntr3Porr05::from_bits(val)
            }
        }
        impl From<Pcntr3Porr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr05) -> u8 {
                Pcntr3Porr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr06 {
                Pcntr3Porr06::from_bits(val)
            }
        }
        impl From<Pcntr3Porr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr06) -> u8 {
                Pcntr3Porr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr07 {
                Pcntr3Porr07::from_bits(val)
            }
        }
        impl From<Pcntr3Porr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr07) -> u8 {
                Pcntr3Porr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr08 {
                Pcntr3Porr08::from_bits(val)
            }
        }
        impl From<Pcntr3Porr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr08) -> u8 {
                Pcntr3Porr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr09 {
                Pcntr3Porr09::from_bits(val)
            }
        }
        impl From<Pcntr3Porr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr09) -> u8 {
                Pcntr3Porr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr10 {
                Pcntr3Porr10::from_bits(val)
            }
        }
        impl From<Pcntr3Porr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr10) -> u8 {
                Pcntr3Porr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr11 {
                Pcntr3Porr11::from_bits(val)
            }
        }
        impl From<Pcntr3Porr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr11) -> u8 {
                Pcntr3Porr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr12 {
                Pcntr3Porr12::from_bits(val)
            }
        }
        impl From<Pcntr3Porr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr12) -> u8 {
                Pcntr3Porr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr13 {
                Pcntr3Porr13::from_bits(val)
            }
        }
        impl From<Pcntr3Porr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr13) -> u8 {
                Pcntr3Porr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr14 {
                Pcntr3Porr14::from_bits(val)
            }
        }
        impl From<Pcntr3Porr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr14) -> u8 {
                Pcntr3Porr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr15 {
                Pcntr3Porr15::from_bits(val)
            }
        }
        impl From<Pcntr3Porr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr15) -> u8 {
                Pcntr3Porr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr00 {
                Pcntr3Posr00::from_bits(val)
            }
        }
        impl From<Pcntr3Posr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr00) -> u8 {
                Pcntr3Posr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr01 {
                Pcntr3Posr01::from_bits(val)
            }
        }
        impl From<Pcntr3Posr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr01) -> u8 {
                Pcntr3Posr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr02 {
                Pcntr3Posr02::from_bits(val)
            }
        }
        impl From<Pcntr3Posr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr02) -> u8 {
                Pcntr3Posr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr03 {
                Pcntr3Posr03::from_bits(val)
            }
        }
        impl From<Pcntr3Posr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr03) -> u8 {
                Pcntr3Posr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr04 {
                Pcntr3Posr04::from_bits(val)
            }
        }
        impl From<Pcntr3Posr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr04) -> u8 {
                Pcntr3Posr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr05 {
                Pcntr3Posr05::from_bits(val)
            }
        }
        impl From<Pcntr3Posr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr05) -> u8 {
                Pcntr3Posr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr06 {
                Pcntr3Posr06::from_bits(val)
            }
        }
        impl From<Pcntr3Posr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr06) -> u8 {
                Pcntr3Posr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr07 {
                Pcntr3Posr07::from_bits(val)
            }
        }
        impl From<Pcntr3Posr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr07) -> u8 {
                Pcntr3Posr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr08 {
                Pcntr3Posr08::from_bits(val)
            }
        }
        impl From<Pcntr3Posr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr08) -> u8 {
                Pcntr3Posr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr09 {
                Pcntr3Posr09::from_bits(val)
            }
        }
        impl From<Pcntr3Posr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr09) -> u8 {
                Pcntr3Posr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr10 {
                Pcntr3Posr10::from_bits(val)
            }
        }
        impl From<Pcntr3Posr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr10) -> u8 {
                Pcntr3Posr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr11 {
                Pcntr3Posr11::from_bits(val)
            }
        }
        impl From<Pcntr3Posr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr11) -> u8 {
                Pcntr3Posr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr12 {
                Pcntr3Posr12::from_bits(val)
            }
        }
        impl From<Pcntr3Posr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr12) -> u8 {
                Pcntr3Posr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr13 {
                Pcntr3Posr13::from_bits(val)
            }
        }
        impl From<Pcntr3Posr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr13) -> u8 {
                Pcntr3Posr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr14 {
                Pcntr3Posr14::from_bits(val)
            }
        }
        impl From<Pcntr3Posr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr14) -> u8 {
                Pcntr3Posr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr15 {
                Pcntr3Posr15::from_bits(val)
            }
        }
        impl From<Pcntr3Posr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr15) -> u8 {
                Pcntr3Posr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr00 {
                Pcntr4Eorr00::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr00) -> u8 {
                Pcntr4Eorr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr01 {
                Pcntr4Eorr01::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr01) -> u8 {
                Pcntr4Eorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr02 {
                Pcntr4Eorr02::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr02) -> u8 {
                Pcntr4Eorr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr03 {
                Pcntr4Eorr03::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr03) -> u8 {
                Pcntr4Eorr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr04 {
                Pcntr4Eorr04::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr04) -> u8 {
                Pcntr4Eorr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr05 {
                Pcntr4Eorr05::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr05) -> u8 {
                Pcntr4Eorr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr06 {
                Pcntr4Eorr06::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr06) -> u8 {
                Pcntr4Eorr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr07 {
                Pcntr4Eorr07::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr07) -> u8 {
                Pcntr4Eorr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr08 {
                Pcntr4Eorr08::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr08) -> u8 {
                Pcntr4Eorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr09 {
                Pcntr4Eorr09::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr09) -> u8 {
                Pcntr4Eorr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr10 {
                Pcntr4Eorr10::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr10) -> u8 {
                Pcntr4Eorr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr11 {
                Pcntr4Eorr11::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr11) -> u8 {
                Pcntr4Eorr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr12 {
                Pcntr4Eorr12::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr12) -> u8 {
                Pcntr4Eorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr13 {
                Pcntr4Eorr13::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr13) -> u8 {
                Pcntr4Eorr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr14 {
                Pcntr4Eorr14::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr14) -> u8 {
                Pcntr4Eorr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr15 {
                Pcntr4Eorr15::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr15) -> u8 {
                Pcntr4Eorr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr00 {
                Pcntr4Eosr00::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr00) -> u8 {
                Pcntr4Eosr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr01 {
                Pcntr4Eosr01::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr01) -> u8 {
                Pcntr4Eosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr02 {
                Pcntr4Eosr02::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr02) -> u8 {
                Pcntr4Eosr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr03 {
                Pcntr4Eosr03::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr03) -> u8 {
                Pcntr4Eosr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr04 {
                Pcntr4Eosr04::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr04) -> u8 {
                Pcntr4Eosr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr05 {
                Pcntr4Eosr05::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr05) -> u8 {
                Pcntr4Eosr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr06 {
                Pcntr4Eosr06::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr06) -> u8 {
                Pcntr4Eosr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr07 {
                Pcntr4Eosr07::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr07) -> u8 {
                Pcntr4Eosr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr08 {
                Pcntr4Eosr08::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr08) -> u8 {
                Pcntr4Eosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr09 {
                Pcntr4Eosr09::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr09) -> u8 {
                Pcntr4Eosr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr10 {
                Pcntr4Eosr10::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr10) -> u8 {
                Pcntr4Eosr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr11 {
                Pcntr4Eosr11::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr11) -> u8 {
                Pcntr4Eosr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr12 {
                Pcntr4Eosr12::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr12) -> u8 {
                Pcntr4Eosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr13 {
                Pcntr4Eosr13::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr13) -> u8 {
                Pcntr4Eosr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr14 {
                Pcntr4Eosr14::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr14) -> u8 {
                Pcntr4Eosr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr15 {
                Pcntr4Eosr15::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr15) -> u8 {
                Pcntr4Eosr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr00 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr00 {
                PdrPdr00::from_bits(val)
            }
        }
        impl From<PdrPdr00> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr00) -> u8 {
                PdrPdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr01 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr01 {
                PdrPdr01::from_bits(val)
            }
        }
        impl From<PdrPdr01> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr01) -> u8 {
                PdrPdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr02 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr02 {
                PdrPdr02::from_bits(val)
            }
        }
        impl From<PdrPdr02> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr02) -> u8 {
                PdrPdr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr03 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr03 {
                PdrPdr03::from_bits(val)
            }
        }
        impl From<PdrPdr03> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr03) -> u8 {
                PdrPdr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr04 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr04 {
                PdrPdr04::from_bits(val)
            }
        }
        impl From<PdrPdr04> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr04) -> u8 {
                PdrPdr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr05 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr05 {
                PdrPdr05::from_bits(val)
            }
        }
        impl From<PdrPdr05> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr05) -> u8 {
                PdrPdr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr06 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr06 {
                PdrPdr06::from_bits(val)
            }
        }
        impl From<PdrPdr06> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr06) -> u8 {
                PdrPdr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr07 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr07 {
                PdrPdr07::from_bits(val)
            }
        }
        impl From<PdrPdr07> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr07) -> u8 {
                PdrPdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr08 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr08 {
                PdrPdr08::from_bits(val)
            }
        }
        impl From<PdrPdr08> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr08) -> u8 {
                PdrPdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr09 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr09 {
                PdrPdr09::from_bits(val)
            }
        }
        impl From<PdrPdr09> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr09) -> u8 {
                PdrPdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr10 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr10 {
                PdrPdr10::from_bits(val)
            }
        }
        impl From<PdrPdr10> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr10) -> u8 {
                PdrPdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr11 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr11 {
                PdrPdr11::from_bits(val)
            }
        }
        impl From<PdrPdr11> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr11) -> u8 {
                PdrPdr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr12 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr12 {
                PdrPdr12::from_bits(val)
            }
        }
        impl From<PdrPdr12> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr12) -> u8 {
                PdrPdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr13 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr13 {
                PdrPdr13::from_bits(val)
            }
        }
        impl From<PdrPdr13> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr13) -> u8 {
                PdrPdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr14 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr14 {
                PdrPdr14::from_bits(val)
            }
        }
        impl From<PdrPdr14> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr14) -> u8 {
                PdrPdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr15 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr15 {
                PdrPdr15::from_bits(val)
            }
        }
        impl From<PdrPdr15> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr15) -> u8 {
                PdrPdr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr00 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr00 {
                PidrPidr00::from_bits(val)
            }
        }
        impl From<PidrPidr00> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr00) -> u8 {
                PidrPidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr01 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr01 {
                PidrPidr01::from_bits(val)
            }
        }
        impl From<PidrPidr01> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr01) -> u8 {
                PidrPidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr02 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr02 {
                PidrPidr02::from_bits(val)
            }
        }
        impl From<PidrPidr02> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr02) -> u8 {
                PidrPidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr03 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr03 {
                PidrPidr03::from_bits(val)
            }
        }
        impl From<PidrPidr03> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr03) -> u8 {
                PidrPidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr04 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr04 {
                PidrPidr04::from_bits(val)
            }
        }
        impl From<PidrPidr04> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr04) -> u8 {
                PidrPidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr05 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr05 {
                PidrPidr05::from_bits(val)
            }
        }
        impl From<PidrPidr05> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr05) -> u8 {
                PidrPidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr06 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr06 {
                PidrPidr06::from_bits(val)
            }
        }
        impl From<PidrPidr06> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr06) -> u8 {
                PidrPidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr07 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr07 {
                PidrPidr07::from_bits(val)
            }
        }
        impl From<PidrPidr07> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr07) -> u8 {
                PidrPidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr08 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr08 {
                PidrPidr08::from_bits(val)
            }
        }
        impl From<PidrPidr08> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr08) -> u8 {
                PidrPidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr09 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr09 {
                PidrPidr09::from_bits(val)
            }
        }
        impl From<PidrPidr09> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr09) -> u8 {
                PidrPidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr10 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr10 {
                PidrPidr10::from_bits(val)
            }
        }
        impl From<PidrPidr10> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr10) -> u8 {
                PidrPidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr11 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr11 {
                PidrPidr11::from_bits(val)
            }
        }
        impl From<PidrPidr11> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr11) -> u8 {
                PidrPidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr12 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr12 {
                PidrPidr12::from_bits(val)
            }
        }
        impl From<PidrPidr12> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr12) -> u8 {
                PidrPidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr13 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr13 {
                PidrPidr13::from_bits(val)
            }
        }
        impl From<PidrPidr13> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr13) -> u8 {
                PidrPidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr14 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr14 {
                PidrPidr14::from_bits(val)
            }
        }
        impl From<PidrPidr14> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr14) -> u8 {
                PidrPidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr15 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr15 {
                PidrPidr15::from_bits(val)
            }
        }
        impl From<PidrPidr15> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr15) -> u8 {
                PidrPidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr00 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr00 {
                PodrPodr00::from_bits(val)
            }
        }
        impl From<PodrPodr00> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr00) -> u8 {
                PodrPodr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr01 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr01 {
                PodrPodr01::from_bits(val)
            }
        }
        impl From<PodrPodr01> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr01) -> u8 {
                PodrPodr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr02 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr02 {
                PodrPodr02::from_bits(val)
            }
        }
        impl From<PodrPodr02> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr02) -> u8 {
                PodrPodr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr03 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr03 {
                PodrPodr03::from_bits(val)
            }
        }
        impl From<PodrPodr03> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr03) -> u8 {
                PodrPodr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr04 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr04 {
                PodrPodr04::from_bits(val)
            }
        }
        impl From<PodrPodr04> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr04) -> u8 {
                PodrPodr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr05 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr05 {
                PodrPodr05::from_bits(val)
            }
        }
        impl From<PodrPodr05> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr05) -> u8 {
                PodrPodr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr06 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr06 {
                PodrPodr06::from_bits(val)
            }
        }
        impl From<PodrPodr06> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr06) -> u8 {
                PodrPodr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr07 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr07 {
                PodrPodr07::from_bits(val)
            }
        }
        impl From<PodrPodr07> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr07) -> u8 {
                PodrPodr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr08 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr08 {
                PodrPodr08::from_bits(val)
            }
        }
        impl From<PodrPodr08> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr08) -> u8 {
                PodrPodr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr09 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr09 {
                PodrPodr09::from_bits(val)
            }
        }
        impl From<PodrPodr09> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr09) -> u8 {
                PodrPodr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr10 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr10 {
                PodrPodr10::from_bits(val)
            }
        }
        impl From<PodrPodr10> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr10) -> u8 {
                PodrPodr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr11 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr11 {
                PodrPodr11::from_bits(val)
            }
        }
        impl From<PodrPodr11> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr11) -> u8 {
                PodrPodr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr12 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr12 {
                PodrPodr12::from_bits(val)
            }
        }
        impl From<PodrPodr12> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr12) -> u8 {
                PodrPodr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr13 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr13 {
                PodrPodr13::from_bits(val)
            }
        }
        impl From<PodrPodr13> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr13) -> u8 {
                PodrPodr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr14 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr14 {
                PodrPodr14::from_bits(val)
            }
        }
        impl From<PodrPodr14> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr14) -> u8 {
                PodrPodr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr15 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr15 {
                PodrPodr15::from_bits(val)
            }
        }
        impl From<PodrPodr15> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr15) -> u8 {
                PodrPodr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr00 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr00 {
                PorrPorr00::from_bits(val)
            }
        }
        impl From<PorrPorr00> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr00) -> u8 {
                PorrPorr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr01 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr01 {
                PorrPorr01::from_bits(val)
            }
        }
        impl From<PorrPorr01> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr01) -> u8 {
                PorrPorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr02 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr02 {
                PorrPorr02::from_bits(val)
            }
        }
        impl From<PorrPorr02> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr02) -> u8 {
                PorrPorr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr03 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr03 {
                PorrPorr03::from_bits(val)
            }
        }
        impl From<PorrPorr03> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr03) -> u8 {
                PorrPorr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr04 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr04 {
                PorrPorr04::from_bits(val)
            }
        }
        impl From<PorrPorr04> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr04) -> u8 {
                PorrPorr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr05 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr05 {
                PorrPorr05::from_bits(val)
            }
        }
        impl From<PorrPorr05> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr05) -> u8 {
                PorrPorr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr06 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr06 {
                PorrPorr06::from_bits(val)
            }
        }
        impl From<PorrPorr06> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr06) -> u8 {
                PorrPorr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr07 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr07 {
                PorrPorr07::from_bits(val)
            }
        }
        impl From<PorrPorr07> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr07) -> u8 {
                PorrPorr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr08 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr08 {
                PorrPorr08::from_bits(val)
            }
        }
        impl From<PorrPorr08> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr08) -> u8 {
                PorrPorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr09 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr09 {
                PorrPorr09::from_bits(val)
            }
        }
        impl From<PorrPorr09> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr09) -> u8 {
                PorrPorr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr10 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr10 {
                PorrPorr10::from_bits(val)
            }
        }
        impl From<PorrPorr10> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr10) -> u8 {
                PorrPorr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr11 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr11 {
                PorrPorr11::from_bits(val)
            }
        }
        impl From<PorrPorr11> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr11) -> u8 {
                PorrPorr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr12 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr12 {
                PorrPorr12::from_bits(val)
            }
        }
        impl From<PorrPorr12> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr12) -> u8 {
                PorrPorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr13 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr13 {
                PorrPorr13::from_bits(val)
            }
        }
        impl From<PorrPorr13> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr13) -> u8 {
                PorrPorr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr14 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr14 {
                PorrPorr14::from_bits(val)
            }
        }
        impl From<PorrPorr14> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr14) -> u8 {
                PorrPorr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr15 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr15 {
                PorrPorr15::from_bits(val)
            }
        }
        impl From<PorrPorr15> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr15) -> u8 {
                PorrPorr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr00 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr00 {
                PosrPosr00::from_bits(val)
            }
        }
        impl From<PosrPosr00> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr00) -> u8 {
                PosrPosr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr01 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr01 {
                PosrPosr01::from_bits(val)
            }
        }
        impl From<PosrPosr01> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr01) -> u8 {
                PosrPosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr02 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr02 {
                PosrPosr02::from_bits(val)
            }
        }
        impl From<PosrPosr02> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr02) -> u8 {
                PosrPosr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr03 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr03 {
                PosrPosr03::from_bits(val)
            }
        }
        impl From<PosrPosr03> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr03) -> u8 {
                PosrPosr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr04 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr04 {
                PosrPosr04::from_bits(val)
            }
        }
        impl From<PosrPosr04> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr04) -> u8 {
                PosrPosr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr05 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr05 {
                PosrPosr05::from_bits(val)
            }
        }
        impl From<PosrPosr05> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr05) -> u8 {
                PosrPosr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr06 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr06 {
                PosrPosr06::from_bits(val)
            }
        }
        impl From<PosrPosr06> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr06) -> u8 {
                PosrPosr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr07 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr07 {
                PosrPosr07::from_bits(val)
            }
        }
        impl From<PosrPosr07> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr07) -> u8 {
                PosrPosr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr08 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr08 {
                PosrPosr08::from_bits(val)
            }
        }
        impl From<PosrPosr08> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr08) -> u8 {
                PosrPosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr09 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr09 {
                PosrPosr09::from_bits(val)
            }
        }
        impl From<PosrPosr09> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr09) -> u8 {
                PosrPosr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr10 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr10 {
                PosrPosr10::from_bits(val)
            }
        }
        impl From<PosrPosr10> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr10) -> u8 {
                PosrPosr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr11 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr11 {
                PosrPosr11::from_bits(val)
            }
        }
        impl From<PosrPosr11> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr11) -> u8 {
                PosrPosr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr12 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr12 {
                PosrPosr12::from_bits(val)
            }
        }
        impl From<PosrPosr12> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr12) -> u8 {
                PosrPosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr13 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr13 {
                PosrPosr13::from_bits(val)
            }
        }
        impl From<PosrPosr13> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr13) -> u8 {
                PosrPosr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr14 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr14 {
                PosrPosr14::from_bits(val)
            }
        }
        impl From<PosrPosr14> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr14) -> u8 {
                PosrPosr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr15 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr15 {
                PosrPosr15::from_bits(val)
            }
        }
        impl From<PosrPosr15> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr15) -> u8 {
                PosrPosr15::to_bits(val)
            }
        }
    }
}
pub mod rmpu {
    #[doc = "Renesas Memory Protection Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rmpu {
        ptr: *mut u8,
    }
    unsafe impl Send for Rmpu {}
    unsafe impl Sync for Rmpu {}
    impl Rmpu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Bus Master MPU Control Register"]
        #[inline(always)]
        pub const fn mmpuctla(self) -> crate::common::Reg<regs::Mmpuctla, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Group A Protection of Register"]
        #[inline(always)]
        pub const fn mmpupta(self) -> crate::common::Reg<regs::Mmpupta, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize) as _) }
        }
        #[doc = "Group A Region %s Access Control Register"]
        #[inline(always)]
        pub const fn mmpuaca(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Mmpuaca, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize + n * 16usize) as _) }
        }
        #[doc = "Group A Region %s Start Address Register"]
        #[inline(always)]
        pub const fn mmpusa(self, n: usize) -> crate::common::Reg<regs::Mmpusa, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize + n * 16usize) as _) }
        }
        #[doc = "Group A Region %s End Address Register"]
        #[inline(always)]
        pub const fn mmpuea(self, n: usize) -> crate::common::Reg<regs::Mmpuea, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize + n * 16usize) as _) }
        }
        #[doc = "Slave MPU Control Register"]
        #[inline(always)]
        pub const fn smpuctl(self) -> crate::common::Reg<regs::Smpuctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c00usize) as _) }
        }
        #[doc = "Access Control Register for Memory Bus 1"]
        #[inline(always)]
        pub const fn smpumbiu(self) -> crate::common::Reg<regs::Smpumbiu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c10usize) as _) }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 9"]
        #[inline(always)]
        pub const fn smpufbiu(self) -> crate::common::Reg<regs::Smpufbiu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c14usize) as _) }
        }
        #[doc = "Access Control Register for Memory Bus 4"]
        #[inline(always)]
        pub const fn smpusram0(self) -> crate::common::Reg<regs::Smpusram0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c18usize) as _) }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 1"]
        #[inline(always)]
        pub const fn smpup0biu(self) -> crate::common::Reg<regs::Smpup0biu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c20usize) as _) }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 3"]
        #[inline(always)]
        pub const fn smpup2biu(self) -> crate::common::Reg<regs::Smpup2biu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c24usize) as _) }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 7"]
        #[inline(always)]
        pub const fn smpup6biu(self) -> crate::common::Reg<regs::Smpup6biu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c28usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[inline(always)]
        pub const fn mspmpuoad(self) -> crate::common::Reg<regs::Mspmpuoad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d00usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[inline(always)]
        pub const fn mspmpuctl(self) -> crate::common::Reg<regs::Mspmpuctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d04usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[inline(always)]
        pub const fn mspmpupt(self) -> crate::common::Reg<regs::Mspmpupt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d06usize) as _) }
        }
        #[doc = "Main Stack Pointer (MSP) Monitor Start Address Register"]
        #[inline(always)]
        pub const fn mspmpusa(self) -> crate::common::Reg<regs::Mspmpusa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d08usize) as _) }
        }
        #[doc = "Main Stack Pointer (MSP) Monitor End Address Register"]
        #[inline(always)]
        pub const fn mspmpuea(self) -> crate::common::Reg<regs::Mspmpuea, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d0cusize) as _) }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[inline(always)]
        pub const fn pspmpuoad(self) -> crate::common::Reg<regs::Pspmpuoad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d10usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[inline(always)]
        pub const fn pspmpuctl(self) -> crate::common::Reg<regs::Pspmpuctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d14usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[inline(always)]
        pub const fn pspmpupt(self) -> crate::common::Reg<regs::Pspmpupt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d16usize) as _) }
        }
        #[doc = "Process Stack Pointer (PSP) Monitor Start Address Register"]
        #[inline(always)]
        pub const fn pspmpusa(self) -> crate::common::Reg<regs::Pspmpusa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d18usize) as _) }
        }
        #[doc = "Process Stack Pointer (PSP) Monitor End Address Register"]
        #[inline(always)]
        pub const fn pspmpuea(self) -> crate::common::Reg<regs::Pspmpuea, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Group A Region %s Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpuaca(pub u16);
        impl Mmpuaca {
            #[doc = "Region Enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::MmpuacaEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MmpuacaEnable::from_bits(val as u8)
            }
            #[doc = "Region Enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::MmpuacaEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Read Protection"]
            #[inline(always)]
            pub const fn rp(&self) -> super::vals::Rp {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rp::from_bits(val as u8)
            }
            #[doc = "Read Protection"]
            #[inline(always)]
            pub fn set_rp(&mut self, val: super::vals::Rp) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Write Protection"]
            #[inline(always)]
            pub const fn wp(&self) -> super::vals::Wp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Wp::from_bits(val as u8)
            }
            #[doc = "Write Protection"]
            #[inline(always)]
            pub fn set_wp(&mut self, val: super::vals::Wp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
        }
        impl Default for Mmpuaca {
            #[inline(always)]
            fn default() -> Mmpuaca {
                Mmpuaca(0)
            }
        }
        impl core::fmt::Debug for Mmpuaca {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpuaca")
                    .field("enable", &self.enable())
                    .field("rp", &self.rp())
                    .field("wp", &self.wp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpuaca {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpuaca {{ enable: {:?}, rp: {:?}, wp: {:?} }}",
                    self.enable(),
                    self.rp(),
                    self.wp()
                )
            }
        }
        #[doc = "Bus Master MPU Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpuctla(pub u16);
        impl Mmpuctla {
            #[doc = "Master Group Enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::MmpuctlaEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MmpuctlaEnable::from_bits(val as u8)
            }
            #[doc = "Master Group Enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::MmpuctlaEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::MmpuctlaOad {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::MmpuctlaOad::from_bits(val as u8)
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::MmpuctlaOad) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mmpuctla {
            #[inline(always)]
            fn default() -> Mmpuctla {
                Mmpuctla(0)
            }
        }
        impl core::fmt::Debug for Mmpuctla {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpuctla")
                    .field("enable", &self.enable())
                    .field("oad", &self.oad())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpuctla {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpuctla {{ enable: {:?}, oad: {:?}, key: {=u8:?} }}",
                    self.enable(),
                    self.oad(),
                    self.key()
                )
            }
        }
        #[doc = "Group A Region %s End Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpuea(pub u32);
        impl Mmpuea {
            #[doc = "Region End Address"]
            #[inline(always)]
            pub const fn mmpuea(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region End Address"]
            #[inline(always)]
            pub fn set_mmpuea(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mmpuea {
            #[inline(always)]
            fn default() -> Mmpuea {
                Mmpuea(0)
            }
        }
        impl core::fmt::Debug for Mmpuea {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpuea")
                    .field("mmpuea", &self.mmpuea())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpuea {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mmpuea {{ mmpuea: {=u32:?} }}", self.mmpuea())
            }
        }
        #[doc = "Group A Protection of Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpupta(pub u16);
        impl Mmpupta {
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::MmpuptaProtect {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MmpuptaProtect::from_bits(val as u8)
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::MmpuptaProtect) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mmpupta {
            #[inline(always)]
            fn default() -> Mmpupta {
                Mmpupta(0)
            }
        }
        impl core::fmt::Debug for Mmpupta {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpupta")
                    .field("protect", &self.protect())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpupta {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpupta {{ protect: {:?}, key: {=u8:?} }}",
                    self.protect(),
                    self.key()
                )
            }
        }
        #[doc = "Group A Region %s Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpusa(pub u32);
        impl Mmpusa {
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub const fn mmpusa(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub fn set_mmpusa(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mmpusa {
            #[inline(always)]
            fn default() -> Mmpusa {
                Mmpusa(0)
            }
        }
        impl core::fmt::Debug for Mmpusa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpusa")
                    .field("mmpusa", &self.mmpusa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpusa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mmpusa {{ mmpusa: {=u32:?} }}", self.mmpusa())
            }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpuctl(pub u16);
        impl Mspmpuctl {
            #[doc = "Stack Pointer Monitor Enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::MspmpuctlEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MspmpuctlEnable::from_bits(val as u8)
            }
            #[doc = "Stack Pointer Monitor Enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::MspmpuctlEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Stack Pointer Monitor Error Flag"]
            #[inline(always)]
            pub const fn error(&self) -> super::vals::MspmpuctlError {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::MspmpuctlError::from_bits(val as u8)
            }
            #[doc = "Stack Pointer Monitor Error Flag"]
            #[inline(always)]
            pub fn set_error(&mut self, val: super::vals::MspmpuctlError) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
        }
        impl Default for Mspmpuctl {
            #[inline(always)]
            fn default() -> Mspmpuctl {
                Mspmpuctl(0)
            }
        }
        impl core::fmt::Debug for Mspmpuctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpuctl")
                    .field("enable", &self.enable())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpuctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mspmpuctl {{ enable: {:?}, error: {:?} }}",
                    self.enable(),
                    self.error()
                )
            }
        }
        #[doc = "Main Stack Pointer (MSP) Monitor End Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpuea(pub u32);
        impl Mspmpuea {
            #[doc = "Region End Address"]
            #[inline(always)]
            pub const fn mspmpuea(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region End Address"]
            #[inline(always)]
            pub fn set_mspmpuea(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mspmpuea {
            #[inline(always)]
            fn default() -> Mspmpuea {
                Mspmpuea(0)
            }
        }
        impl core::fmt::Debug for Mspmpuea {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpuea")
                    .field("mspmpuea", &self.mspmpuea())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpuea {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mspmpuea {{ mspmpuea: {=u32:?} }}", self.mspmpuea())
            }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpuoad(pub u16);
        impl Mspmpuoad {
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::MspmpuoadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MspmpuoadOad::from_bits(val as u8)
            }
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::MspmpuoadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mspmpuoad {
            #[inline(always)]
            fn default() -> Mspmpuoad {
                Mspmpuoad(0)
            }
        }
        impl core::fmt::Debug for Mspmpuoad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpuoad")
                    .field("oad", &self.oad())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpuoad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mspmpuoad {{ oad: {:?}, key: {=u8:?} }}",
                    self.oad(),
                    self.key()
                )
            }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpupt(pub u16);
        impl Mspmpupt {
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::MspmpuptProtect {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MspmpuptProtect::from_bits(val as u8)
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::MspmpuptProtect) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mspmpupt {
            #[inline(always)]
            fn default() -> Mspmpupt {
                Mspmpupt(0)
            }
        }
        impl core::fmt::Debug for Mspmpupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpupt")
                    .field("protect", &self.protect())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mspmpupt {{ protect: {:?}, key: {=u8:?} }}",
                    self.protect(),
                    self.key()
                )
            }
        }
        #[doc = "Main Stack Pointer (MSP) Monitor Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpusa(pub u32);
        impl Mspmpusa {
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub const fn mspmpusa(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub fn set_mspmpusa(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mspmpusa {
            #[inline(always)]
            fn default() -> Mspmpusa {
                Mspmpusa(0)
            }
        }
        impl core::fmt::Debug for Mspmpusa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpusa")
                    .field("mspmpusa", &self.mspmpusa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpusa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mspmpusa {{ mspmpusa: {=u32:?} }}", self.mspmpusa())
            }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpuctl(pub u16);
        impl Pspmpuctl {
            #[doc = "Stack Pointer Monitor Enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::PspmpuctlEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PspmpuctlEnable::from_bits(val as u8)
            }
            #[doc = "Stack Pointer Monitor Enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::PspmpuctlEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Stack Pointer Monitor Error Flag"]
            #[inline(always)]
            pub const fn error(&self) -> super::vals::PspmpuctlError {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PspmpuctlError::from_bits(val as u8)
            }
            #[doc = "Stack Pointer Monitor Error Flag"]
            #[inline(always)]
            pub fn set_error(&mut self, val: super::vals::PspmpuctlError) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
        }
        impl Default for Pspmpuctl {
            #[inline(always)]
            fn default() -> Pspmpuctl {
                Pspmpuctl(0)
            }
        }
        impl core::fmt::Debug for Pspmpuctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpuctl")
                    .field("enable", &self.enable())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpuctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pspmpuctl {{ enable: {:?}, error: {:?} }}",
                    self.enable(),
                    self.error()
                )
            }
        }
        #[doc = "Process Stack Pointer (PSP) Monitor End Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpuea(pub u32);
        impl Pspmpuea {
            #[doc = "Region End Address"]
            #[inline(always)]
            pub const fn pspmpuea(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region End Address"]
            #[inline(always)]
            pub fn set_pspmpuea(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Pspmpuea {
            #[inline(always)]
            fn default() -> Pspmpuea {
                Pspmpuea(0)
            }
        }
        impl core::fmt::Debug for Pspmpuea {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpuea")
                    .field("pspmpuea", &self.pspmpuea())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpuea {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pspmpuea {{ pspmpuea: {=u32:?} }}", self.pspmpuea())
            }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpuoad(pub u16);
        impl Pspmpuoad {
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::PspmpuoadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PspmpuoadOad::from_bits(val as u8)
            }
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::PspmpuoadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Pspmpuoad {
            #[inline(always)]
            fn default() -> Pspmpuoad {
                Pspmpuoad(0)
            }
        }
        impl core::fmt::Debug for Pspmpuoad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpuoad")
                    .field("oad", &self.oad())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpuoad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pspmpuoad {{ oad: {:?}, key: {=u8:?} }}",
                    self.oad(),
                    self.key()
                )
            }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpupt(pub u16);
        impl Pspmpupt {
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::PspmpuptProtect {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PspmpuptProtect::from_bits(val as u8)
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::PspmpuptProtect) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Pspmpupt {
            #[inline(always)]
            fn default() -> Pspmpupt {
                Pspmpupt(0)
            }
        }
        impl core::fmt::Debug for Pspmpupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpupt")
                    .field("protect", &self.protect())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pspmpupt {{ protect: {:?}, key: {=u8:?} }}",
                    self.protect(),
                    self.key()
                )
            }
        }
        #[doc = "Process Stack Pointer (PSP) Monitor Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpusa(pub u32);
        impl Pspmpusa {
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub const fn pspmpusa(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub fn set_pspmpusa(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Pspmpusa {
            #[inline(always)]
            fn default() -> Pspmpusa {
                Pspmpusa(0)
            }
        }
        impl core::fmt::Debug for Pspmpusa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpusa")
                    .field("pspmpusa", &self.pspmpusa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpusa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pspmpusa {{ pspmpusa: {=u32:?} }}", self.pspmpusa())
            }
        }
        #[doc = "Slave MPU Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpuctl(pub u16);
        impl Smpuctl {
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::SmpuctlOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SmpuctlOad::from_bits(val as u8)
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::SmpuctlOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::SmpuctlProtect {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::SmpuctlProtect::from_bits(val as u8)
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::SmpuctlProtect) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Smpuctl {
            #[inline(always)]
            fn default() -> Smpuctl {
                Smpuctl(0)
            }
        }
        impl core::fmt::Debug for Smpuctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpuctl")
                    .field("oad", &self.oad())
                    .field("protect", &self.protect())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpuctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpuctl {{ oad: {:?}, protect: {:?}, key: {=u8:?} }}",
                    self.oad(),
                    self.protect(),
                    self.key()
                )
            }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 9"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpufbiu(pub u16);
        impl Smpufbiu {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::SmpufbiuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SmpufbiuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::SmpufbiuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::SmpufbiuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::SmpufbiuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::SmpufbiuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::SmpufbiuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SmpufbiuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::SmpufbiuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::SmpufbiuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SmpufbiuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::SmpufbiuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpufbiu {
            #[inline(always)]
            fn default() -> Smpufbiu {
                Smpufbiu(0)
            }
        }
        impl core::fmt::Debug for Smpufbiu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpufbiu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpufbiu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpufbiu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Memory Bus 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpumbiu(pub u16);
        impl Smpumbiu {
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::SmpumbiuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SmpumbiuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::SmpumbiuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::SmpumbiuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SmpumbiuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::SmpumbiuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpumbiu {
            #[inline(always)]
            fn default() -> Smpumbiu {
                Smpumbiu(0)
            }
        }
        impl core::fmt::Debug for Smpumbiu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpumbiu")
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpumbiu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpumbiu {{ rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpup0biu(pub u16);
        impl Smpup0biu {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::Smpup0biuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smpup0biuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::Smpup0biuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::Smpup0biuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Smpup0biuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::Smpup0biuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::Smpup0biuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Smpup0biuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::Smpup0biuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::Smpup0biuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smpup0biuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::Smpup0biuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpup0biu {
            #[inline(always)]
            fn default() -> Smpup0biu {
                Smpup0biu(0)
            }
        }
        impl core::fmt::Debug for Smpup0biu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpup0biu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpup0biu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpup0biu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpup2biu(pub u16);
        impl Smpup2biu {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::Smpup2biuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smpup2biuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::Smpup2biuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::Smpup2biuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Smpup2biuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::Smpup2biuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::Smpup2biuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Smpup2biuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::Smpup2biuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::Smpup2biuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smpup2biuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::Smpup2biuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpup2biu {
            #[inline(always)]
            fn default() -> Smpup2biu {
                Smpup2biu(0)
            }
        }
        impl core::fmt::Debug for Smpup2biu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpup2biu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpup2biu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpup2biu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 7"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpup6biu(pub u16);
        impl Smpup6biu {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::Smpup6biuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smpup6biuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::Smpup6biuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::Smpup6biuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Smpup6biuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::Smpup6biuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::Smpup6biuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Smpup6biuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::Smpup6biuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::Smpup6biuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smpup6biuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::Smpup6biuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpup6biu {
            #[inline(always)]
            fn default() -> Smpup6biu {
                Smpup6biu(0)
            }
        }
        impl core::fmt::Debug for Smpup6biu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpup6biu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpup6biu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpup6biu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Memory Bus 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpusram0(pub u16);
        impl Smpusram0 {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::Smpusram0Rpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smpusram0Rpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::Smpusram0Rpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::Smpusram0Wpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Smpusram0Wpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::Smpusram0Wpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::Smpusram0Rpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Smpusram0Rpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::Smpusram0Rpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::Smpusram0Wpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smpusram0Wpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::Smpusram0Wpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpusram0 {
            #[inline(always)]
            fn default() -> Smpusram0 {
                Smpusram0(0)
            }
        }
        impl core::fmt::Debug for Smpusram0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpusram0")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpusram0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpusram0 {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuacaEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuacaEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuacaEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuacaEnable {
            #[inline(always)]
            fn from(val: u8) -> MmpuacaEnable {
                MmpuacaEnable::from_bits(val)
            }
        }
        impl From<MmpuacaEnable> for u8 {
            #[inline(always)]
            fn from(val: MmpuacaEnable) -> u8 {
                MmpuacaEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuctlaEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuctlaEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuctlaEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuctlaEnable {
            #[inline(always)]
            fn from(val: u8) -> MmpuctlaEnable {
                MmpuctlaEnable::from_bits(val)
            }
        }
        impl From<MmpuctlaEnable> for u8 {
            #[inline(always)]
            fn from(val: MmpuctlaEnable) -> u8 {
                MmpuctlaEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuctlaOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuctlaOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuctlaOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuctlaOad {
            #[inline(always)]
            fn from(val: u8) -> MmpuctlaOad {
                MmpuctlaOad::from_bits(val)
            }
        }
        impl From<MmpuctlaOad> for u8 {
            #[inline(always)]
            fn from(val: MmpuctlaOad) -> u8 {
                MmpuctlaOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuptaProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuptaProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuptaProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuptaProtect {
            #[inline(always)]
            fn from(val: u8) -> MmpuptaProtect {
                MmpuptaProtect::from_bits(val)
            }
        }
        impl From<MmpuptaProtect> for u8 {
            #[inline(always)]
            fn from(val: MmpuptaProtect) -> u8 {
                MmpuptaProtect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuctlEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuctlEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuctlEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuctlEnable {
            #[inline(always)]
            fn from(val: u8) -> MspmpuctlEnable {
                MspmpuctlEnable::from_bits(val)
            }
        }
        impl From<MspmpuctlEnable> for u8 {
            #[inline(always)]
            fn from(val: MspmpuctlEnable) -> u8 {
                MspmpuctlEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuctlError {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuctlError {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuctlError {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuctlError {
            #[inline(always)]
            fn from(val: u8) -> MspmpuctlError {
                MspmpuctlError::from_bits(val)
            }
        }
        impl From<MspmpuctlError> for u8 {
            #[inline(always)]
            fn from(val: MspmpuctlError) -> u8 {
                MspmpuctlError::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuoadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuoadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuoadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuoadOad {
            #[inline(always)]
            fn from(val: u8) -> MspmpuoadOad {
                MspmpuoadOad::from_bits(val)
            }
        }
        impl From<MspmpuoadOad> for u8 {
            #[inline(always)]
            fn from(val: MspmpuoadOad) -> u8 {
                MspmpuoadOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuptProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuptProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuptProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuptProtect {
            #[inline(always)]
            fn from(val: u8) -> MspmpuptProtect {
                MspmpuptProtect::from_bits(val)
            }
        }
        impl From<MspmpuptProtect> for u8 {
            #[inline(always)]
            fn from(val: MspmpuptProtect) -> u8 {
                MspmpuptProtect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuctlEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuctlEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuctlEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuctlEnable {
            #[inline(always)]
            fn from(val: u8) -> PspmpuctlEnable {
                PspmpuctlEnable::from_bits(val)
            }
        }
        impl From<PspmpuctlEnable> for u8 {
            #[inline(always)]
            fn from(val: PspmpuctlEnable) -> u8 {
                PspmpuctlEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuctlError {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuctlError {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuctlError {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuctlError {
            #[inline(always)]
            fn from(val: u8) -> PspmpuctlError {
                PspmpuctlError::from_bits(val)
            }
        }
        impl From<PspmpuctlError> for u8 {
            #[inline(always)]
            fn from(val: PspmpuctlError) -> u8 {
                PspmpuctlError::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuoadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuoadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuoadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuoadOad {
            #[inline(always)]
            fn from(val: u8) -> PspmpuoadOad {
                PspmpuoadOad::from_bits(val)
            }
        }
        impl From<PspmpuoadOad> for u8 {
            #[inline(always)]
            fn from(val: PspmpuoadOad) -> u8 {
                PspmpuoadOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuptProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuptProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuptProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuptProtect {
            #[inline(always)]
            fn from(val: u8) -> PspmpuptProtect {
                PspmpuptProtect::from_bits(val)
            }
        }
        impl From<PspmpuptProtect> for u8 {
            #[inline(always)]
            fn from(val: PspmpuptProtect) -> u8 {
                PspmpuptProtect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rp {
            #[inline(always)]
            fn from(val: u8) -> Rp {
                Rp::from_bits(val)
            }
        }
        impl From<Rp> for u8 {
            #[inline(always)]
            fn from(val: Rp) -> u8 {
                Rp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpuctlOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpuctlOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpuctlOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpuctlOad {
            #[inline(always)]
            fn from(val: u8) -> SmpuctlOad {
                SmpuctlOad::from_bits(val)
            }
        }
        impl From<SmpuctlOad> for u8 {
            #[inline(always)]
            fn from(val: SmpuctlOad) -> u8 {
                SmpuctlOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpuctlProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpuctlProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpuctlProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpuctlProtect {
            #[inline(always)]
            fn from(val: u8) -> SmpuctlProtect {
                SmpuctlProtect::from_bits(val)
            }
        }
        impl From<SmpuctlProtect> for u8 {
            #[inline(always)]
            fn from(val: SmpuctlProtect) -> u8 {
                SmpuctlProtect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuRpcpu {
                SmpufbiuRpcpu::from_bits(val)
            }
        }
        impl From<SmpufbiuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuRpcpu) -> u8 {
                SmpufbiuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuRpgrpa {
                SmpufbiuRpgrpa::from_bits(val)
            }
        }
        impl From<SmpufbiuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuRpgrpa) -> u8 {
                SmpufbiuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuWpcpu {
                SmpufbiuWpcpu::from_bits(val)
            }
        }
        impl From<SmpufbiuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuWpcpu) -> u8 {
                SmpufbiuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuWpgrpa {
                SmpufbiuWpgrpa::from_bits(val)
            }
        }
        impl From<SmpufbiuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuWpgrpa) -> u8 {
                SmpufbiuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpumbiuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpumbiuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpumbiuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpumbiuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpumbiuRpgrpa {
                SmpumbiuRpgrpa::from_bits(val)
            }
        }
        impl From<SmpumbiuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpumbiuRpgrpa) -> u8 {
                SmpumbiuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpumbiuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpumbiuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpumbiuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpumbiuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpumbiuWpgrpa {
                SmpumbiuWpgrpa::from_bits(val)
            }
        }
        impl From<SmpumbiuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpumbiuWpgrpa) -> u8 {
                SmpumbiuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup0biuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup0biuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup0biuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup0biuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup0biuRpcpu {
                Smpup0biuRpcpu::from_bits(val)
            }
        }
        impl From<Smpup0biuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup0biuRpcpu) -> u8 {
                Smpup0biuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup0biuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup0biuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup0biuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup0biuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup0biuRpgrpa {
                Smpup0biuRpgrpa::from_bits(val)
            }
        }
        impl From<Smpup0biuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup0biuRpgrpa) -> u8 {
                Smpup0biuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup0biuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup0biuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup0biuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup0biuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup0biuWpcpu {
                Smpup0biuWpcpu::from_bits(val)
            }
        }
        impl From<Smpup0biuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup0biuWpcpu) -> u8 {
                Smpup0biuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup0biuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup0biuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup0biuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup0biuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup0biuWpgrpa {
                Smpup0biuWpgrpa::from_bits(val)
            }
        }
        impl From<Smpup0biuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup0biuWpgrpa) -> u8 {
                Smpup0biuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup2biuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup2biuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup2biuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup2biuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup2biuRpcpu {
                Smpup2biuRpcpu::from_bits(val)
            }
        }
        impl From<Smpup2biuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup2biuRpcpu) -> u8 {
                Smpup2biuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup2biuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup2biuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup2biuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup2biuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup2biuRpgrpa {
                Smpup2biuRpgrpa::from_bits(val)
            }
        }
        impl From<Smpup2biuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup2biuRpgrpa) -> u8 {
                Smpup2biuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup2biuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup2biuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup2biuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup2biuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup2biuWpcpu {
                Smpup2biuWpcpu::from_bits(val)
            }
        }
        impl From<Smpup2biuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup2biuWpcpu) -> u8 {
                Smpup2biuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup2biuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup2biuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup2biuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup2biuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup2biuWpgrpa {
                Smpup2biuWpgrpa::from_bits(val)
            }
        }
        impl From<Smpup2biuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup2biuWpgrpa) -> u8 {
                Smpup2biuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup6biuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup6biuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup6biuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup6biuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup6biuRpcpu {
                Smpup6biuRpcpu::from_bits(val)
            }
        }
        impl From<Smpup6biuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup6biuRpcpu) -> u8 {
                Smpup6biuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup6biuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup6biuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup6biuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup6biuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup6biuRpgrpa {
                Smpup6biuRpgrpa::from_bits(val)
            }
        }
        impl From<Smpup6biuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup6biuRpgrpa) -> u8 {
                Smpup6biuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup6biuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup6biuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup6biuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup6biuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup6biuWpcpu {
                Smpup6biuWpcpu::from_bits(val)
            }
        }
        impl From<Smpup6biuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup6biuWpcpu) -> u8 {
                Smpup6biuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup6biuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup6biuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup6biuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup6biuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup6biuWpgrpa {
                Smpup6biuWpgrpa::from_bits(val)
            }
        }
        impl From<Smpup6biuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup6biuWpgrpa) -> u8 {
                Smpup6biuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Rpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Rpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Rpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Rpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Rpcpu {
                Smpusram0Rpcpu::from_bits(val)
            }
        }
        impl From<Smpusram0Rpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Rpcpu) -> u8 {
                Smpusram0Rpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Rpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Rpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Rpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Rpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Rpgrpa {
                Smpusram0Rpgrpa::from_bits(val)
            }
        }
        impl From<Smpusram0Rpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Rpgrpa) -> u8 {
                Smpusram0Rpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Wpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Wpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Wpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Wpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Wpcpu {
                Smpusram0Wpcpu::from_bits(val)
            }
        }
        impl From<Smpusram0Wpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Wpcpu) -> u8 {
                Smpusram0Wpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Wpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Wpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Wpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Wpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Wpgrpa {
                Smpusram0Wpgrpa::from_bits(val)
            }
        }
        impl From<Smpusram0Wpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Wpgrpa) -> u8 {
                Smpusram0Wpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wp {
            #[inline(always)]
            fn from(val: u8) -> Wp {
                Wp::from_bits(val)
            }
        }
        impl From<Wp> for u8 {
            #[inline(always)]
            fn from(val: Wp) -> u8 {
                Wp::to_bits(val)
            }
        }
    }
}
pub mod rtc {
    #[doc = "Realtime Clock"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtc {}
    unsafe impl Sync for Rtc {}
    impl Rtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "64-Hz Counter"]
        #[inline(always)]
        pub const fn r64cnt(self) -> crate::common::Reg<regs::R64cnt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Binary Counter %s"]
        #[inline(always)]
        pub const fn bcnt(self, n: usize) -> crate::common::Reg<regs::Bcnt, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize + n * 2usize) as _) }
        }
        #[doc = "Second Counter (in Calendar Count Mode)"]
        #[inline(always)]
        pub const fn rseccnt(self) -> crate::common::Reg<regs::Rseccnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Minute Counter (in Calendar Count Mode)"]
        #[inline(always)]
        pub const fn rmincnt(self) -> crate::common::Reg<regs::Rmincnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Hour Counter (in Calendar Count Mode)"]
        #[inline(always)]
        pub const fn rhrcnt(self) -> crate::common::Reg<regs::Rhrcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Day,of,Week Counter (in Calendar Count Mode)"]
        #[inline(always)]
        pub const fn rwkcnt(self) -> crate::common::Reg<regs::Rwkcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Day Counter"]
        #[inline(always)]
        pub const fn rdaycnt(self) -> crate::common::Reg<regs::Rdaycnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Month Counter"]
        #[inline(always)]
        pub const fn rmoncnt(self) -> crate::common::Reg<regs::Rmoncnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Year Counter"]
        #[inline(always)]
        pub const fn ryrcnt(self) -> crate::common::Reg<regs::Ryrcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Binary Counter 0 Alarm Register %s"]
        #[inline(always)]
        pub const fn bcnt0ar(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Bcnt0ar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 32usize) as _) }
        }
        #[doc = "Second Alarm Register %s"]
        #[inline(always)]
        pub const fn rsecar(self, n: usize) -> crate::common::Reg<regs::Rsecar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 32usize) as _) }
        }
        #[doc = "Binary Counter 1 Alarm Register %s"]
        #[inline(always)]
        pub const fn bcnt1ar(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Bcnt1ar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize + n * 32usize) as _) }
        }
        #[doc = "Minute Alarm Register %s"]
        #[inline(always)]
        pub const fn rminar(self, n: usize) -> crate::common::Reg<regs::Rminar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize + n * 32usize) as _) }
        }
        #[doc = "Binary Counter 2 Alarm Register %s"]
        #[inline(always)]
        pub const fn bcnt2ar(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Bcnt2ar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize + n * 32usize) as _) }
        }
        #[doc = "Hour Alarm Register %s"]
        #[inline(always)]
        pub const fn rhrar(self, n: usize) -> crate::common::Reg<regs::Rhrar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize + n * 32usize) as _) }
        }
        #[doc = "Binary Counter 3 Alarm Register %s"]
        #[inline(always)]
        pub const fn bcnt3ar(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Bcnt3ar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize + n * 32usize) as _) }
        }
        #[doc = "Day of Week Alarm Register %s"]
        #[inline(always)]
        pub const fn rwkar(self, n: usize) -> crate::common::Reg<regs::Rwkar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize + n * 32usize) as _) }
        }
        #[doc = "Binary Counter m Alarm Enable Register %s"]
        #[inline(always)]
        pub const fn bcnt0aer(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Bcnt0aer, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 32usize) as _) }
        }
        #[doc = "Date Alarm Register %s"]
        #[inline(always)]
        pub const fn rdayar(self, n: usize) -> crate::common::Reg<regs::Rdayar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 32usize) as _) }
        }
        #[doc = "Binary Counter m Alarm Enable Register %s"]
        #[inline(always)]
        pub const fn bcnt1aer(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Bcnt1aer, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize + n * 32usize) as _) }
        }
        #[doc = "Month Alarm Register %s"]
        #[inline(always)]
        pub const fn rmonar(self, n: usize) -> crate::common::Reg<regs::Rmonar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize + n * 32usize) as _) }
        }
        #[doc = "Binary Counter 2 Alarm Enable Register %s"]
        #[inline(always)]
        pub const fn bcnt2aer(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Bcnt2aer, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize + n * 32usize) as _) }
        }
        #[doc = "Year Alarm Register %s"]
        #[inline(always)]
        pub const fn ryrar(self, n: usize) -> crate::common::Reg<regs::Ryrar, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize + n * 32usize) as _) }
        }
        #[doc = "Binary Counter 3 Alarm Enable Register %s"]
        #[inline(always)]
        pub const fn bcnt3aer(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Bcnt3aer, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1eusize + n * 32usize) as _) }
        }
        #[doc = "Year Alarm Enable Register %s"]
        #[inline(always)]
        pub const fn ryraren(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Ryraren, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1eusize + n * 32usize) as _) }
        }
        #[doc = "RTC Control Register 1"]
        #[inline(always)]
        pub const fn rcr1(self) -> crate::common::Reg<regs::Rcr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x22usize) as _) }
        }
        #[doc = "RTC Control Register 2 (in Calendar Count Mode)"]
        #[inline(always)]
        pub const fn rcr2(self) -> crate::common::Reg<regs::Rcr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "RTC Control Register 2 (in Binary Count Mode)"]
        #[inline(always)]
        pub const fn rcr2_bcnt(self) -> crate::common::Reg<regs::Rcr2Bcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "RTC Control Register 4"]
        #[inline(always)]
        pub const fn rcr4(self) -> crate::common::Reg<regs::Rcr4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Time Error Adjustment Register"]
        #[inline(always)]
        pub const fn radj(self) -> crate::common::Reg<regs::Radj, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2eusize) as _) }
        }
        #[doc = "Time Capture Control Register %s"]
        #[inline(always)]
        pub const fn rtccr(self, n: usize) -> crate::common::Reg<regs::Rtccr, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 2usize) as _) }
        }
        #[doc = "BCNT0 Capture Register %s"]
        #[inline(always)]
        pub const fn bcnt0cp(self, n: usize) -> crate::common::Reg<u8, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x52usize + n * 16usize) as _) }
        }
        #[doc = "Second Capture Register %s"]
        #[inline(always)]
        pub const fn rseccp(self, n: usize) -> crate::common::Reg<regs::Rseccp, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x52usize + n * 16usize) as _) }
        }
        #[doc = "BCNT1 Capture Register %s"]
        #[inline(always)]
        pub const fn bcnt1cp(self, n: usize) -> crate::common::Reg<u8, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize + n * 16usize) as _) }
        }
        #[doc = "Minute Capture Register %s"]
        #[inline(always)]
        pub const fn rmincp(self, n: usize) -> crate::common::Reg<regs::Rmincp, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize + n * 16usize) as _) }
        }
        #[doc = "BCNT2 Capture Register %s"]
        #[inline(always)]
        pub const fn bcnt2cp(self, n: usize) -> crate::common::Reg<u8, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x56usize + n * 16usize) as _) }
        }
        #[doc = "Hour Capture Register %s"]
        #[inline(always)]
        pub const fn rhrcp(self, n: usize) -> crate::common::Reg<regs::Rhrcp, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x56usize + n * 16usize) as _) }
        }
        #[doc = "BCNT3 Capture Register %s"]
        #[inline(always)]
        pub const fn bcnt3cp(self, n: usize) -> crate::common::Reg<u8, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5ausize + n * 16usize) as _) }
        }
        #[doc = "Date Capture Register %s"]
        #[inline(always)]
        pub const fn rdaycp(self, n: usize) -> crate::common::Reg<regs::Rdaycp, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5ausize + n * 16usize) as _) }
        }
        #[doc = "Month Capture Register %s"]
        #[inline(always)]
        pub const fn rmoncp(self, n: usize) -> crate::common::Reg<regs::Rmoncp, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize + n * 16usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Binary Counter %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt(pub u8);
        impl Bcnt {
            #[doc = "Binary Counter"]
            #[inline(always)]
            pub const fn bcnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Binary Counter"]
            #[inline(always)]
            pub fn set_bcnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt {
            #[inline(always)]
            fn default() -> Bcnt {
                Bcnt(0)
            }
        }
        impl core::fmt::Debug for Bcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt").field("bcnt", &self.bcnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt {{ bcnt: {=u8:?} }}", self.bcnt())
            }
        }
        #[doc = "Binary Counter m Alarm Enable Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt0aer(pub u8);
        impl Bcnt0aer {
            #[doc = "Setting the alarm enable associated with the 32-bit binary counter"]
            #[inline(always)]
            pub const fn enb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Setting the alarm enable associated with the 32-bit binary counter"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt0aer {
            #[inline(always)]
            fn default() -> Bcnt0aer {
                Bcnt0aer(0)
            }
        }
        impl core::fmt::Debug for Bcnt0aer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt0aer")
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt0aer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt0aer {{ enb: {=u8:?} }}", self.enb())
            }
        }
        #[doc = "Binary Counter 0 Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt0ar(pub u8);
        impl Bcnt0ar {
            #[doc = "Alarm register associated with the 32-bit binary counter"]
            #[inline(always)]
            pub const fn bcntar(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Alarm register associated with the 32-bit binary counter"]
            #[inline(always)]
            pub fn set_bcntar(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt0ar {
            #[inline(always)]
            fn default() -> Bcnt0ar {
                Bcnt0ar(0)
            }
        }
        impl core::fmt::Debug for Bcnt0ar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt0ar")
                    .field("bcntar", &self.bcntar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt0ar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt0ar {{ bcntar: {=u8:?} }}", self.bcntar())
            }
        }
        #[doc = "Binary Counter m Alarm Enable Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt1aer(pub u8);
        impl Bcnt1aer {
            #[doc = "Setting the alarm enable associated with the 32-bit binary counter"]
            #[inline(always)]
            pub const fn enb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Setting the alarm enable associated with the 32-bit binary counter"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt1aer {
            #[inline(always)]
            fn default() -> Bcnt1aer {
                Bcnt1aer(0)
            }
        }
        impl core::fmt::Debug for Bcnt1aer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt1aer")
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt1aer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt1aer {{ enb: {=u8:?} }}", self.enb())
            }
        }
        #[doc = "Binary Counter 1 Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt1ar(pub u8);
        impl Bcnt1ar {
            #[doc = "Alarm register associated with the 32-bit binary counter"]
            #[inline(always)]
            pub const fn bcntar(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Alarm register associated with the 32-bit binary counter"]
            #[inline(always)]
            pub fn set_bcntar(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt1ar {
            #[inline(always)]
            fn default() -> Bcnt1ar {
                Bcnt1ar(0)
            }
        }
        impl core::fmt::Debug for Bcnt1ar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt1ar")
                    .field("bcntar", &self.bcntar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt1ar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt1ar {{ bcntar: {=u8:?} }}", self.bcntar())
            }
        }
        #[doc = "Binary Counter 2 Alarm Enable Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt2aer(pub u16);
        impl Bcnt2aer {
            #[doc = "Setting the alarm enable associated with the 32-bit binary counter"]
            #[inline(always)]
            pub const fn enb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Setting the alarm enable associated with the 32-bit binary counter"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt2aer {
            #[inline(always)]
            fn default() -> Bcnt2aer {
                Bcnt2aer(0)
            }
        }
        impl core::fmt::Debug for Bcnt2aer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt2aer")
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt2aer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt2aer {{ enb: {=u8:?} }}", self.enb())
            }
        }
        #[doc = "Binary Counter 2 Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt2ar(pub u8);
        impl Bcnt2ar {
            #[doc = "Alarm register associated with the 32-bit binary counter"]
            #[inline(always)]
            pub const fn bcntar(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Alarm register associated with the 32-bit binary counter"]
            #[inline(always)]
            pub fn set_bcntar(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt2ar {
            #[inline(always)]
            fn default() -> Bcnt2ar {
                Bcnt2ar(0)
            }
        }
        impl core::fmt::Debug for Bcnt2ar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt2ar")
                    .field("bcntar", &self.bcntar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt2ar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt2ar {{ bcntar: {=u8:?} }}", self.bcntar())
            }
        }
        #[doc = "Binary Counter 3 Alarm Enable Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt3aer(pub u8);
        impl Bcnt3aer {
            #[doc = "Setting the alarm enable associated with the 32-bit binary counter"]
            #[inline(always)]
            pub const fn enb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Setting the alarm enable associated with the 32-bit binary counter"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt3aer {
            #[inline(always)]
            fn default() -> Bcnt3aer {
                Bcnt3aer(0)
            }
        }
        impl core::fmt::Debug for Bcnt3aer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt3aer")
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt3aer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt3aer {{ enb: {=u8:?} }}", self.enb())
            }
        }
        #[doc = "Binary Counter 3 Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcnt3ar(pub u8);
        impl Bcnt3ar {
            #[doc = "Alarm register associated with the 32-bit binary counter"]
            #[inline(always)]
            pub const fn bcntar(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Alarm register associated with the 32-bit binary counter"]
            #[inline(always)]
            pub fn set_bcntar(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcnt3ar {
            #[inline(always)]
            fn default() -> Bcnt3ar {
                Bcnt3ar(0)
            }
        }
        impl core::fmt::Debug for Bcnt3ar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcnt3ar")
                    .field("bcntar", &self.bcntar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcnt3ar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcnt3ar {{ bcntar: {=u8:?} }}", self.bcntar())
            }
        }
        #[doc = "64-Hz Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct R64cnt(pub u8);
        impl R64cnt {
            #[doc = "64-Hz Flag"]
            #[inline(always)]
            pub const fn f64hz(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "64-Hz Flag"]
            #[inline(always)]
            pub fn set_f64hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "32-Hz Flag"]
            #[inline(always)]
            pub const fn f32hz(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "32-Hz Flag"]
            #[inline(always)]
            pub fn set_f32hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "16-Hz Flag"]
            #[inline(always)]
            pub const fn f16hz(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "16-Hz Flag"]
            #[inline(always)]
            pub fn set_f16hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "8-Hz Flag"]
            #[inline(always)]
            pub const fn f8hz(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "8-Hz Flag"]
            #[inline(always)]
            pub fn set_f8hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "4-Hz Flag"]
            #[inline(always)]
            pub const fn f4hz(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "4-Hz Flag"]
            #[inline(always)]
            pub fn set_f4hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "2-Hz Flag"]
            #[inline(always)]
            pub const fn f2hz(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "2-Hz Flag"]
            #[inline(always)]
            pub fn set_f2hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "1-Hz Flag"]
            #[inline(always)]
            pub const fn f1hz(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "1-Hz Flag"]
            #[inline(always)]
            pub fn set_f1hz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
        }
        impl Default for R64cnt {
            #[inline(always)]
            fn default() -> R64cnt {
                R64cnt(0)
            }
        }
        impl core::fmt::Debug for R64cnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("R64cnt")
                    .field("f64hz", &self.f64hz())
                    .field("f32hz", &self.f32hz())
                    .field("f16hz", &self.f16hz())
                    .field("f8hz", &self.f8hz())
                    .field("f4hz", &self.f4hz())
                    .field("f2hz", &self.f2hz())
                    .field("f1hz", &self.f1hz())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for R64cnt {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "R64cnt {{ f64hz: {=bool:?}, f32hz: {=bool:?}, f16hz: {=bool:?}, f8hz: {=bool:?}, f4hz: {=bool:?}, f2hz: {=bool:?}, f1hz: {=bool:?} }}" , self . f64hz () , self . f32hz () , self . f16hz () , self . f8hz () , self . f4hz () , self . f2hz () , self . f1hz ())
            }
        }
        #[doc = "Time Error Adjustment Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Radj(pub u8);
        impl Radj {
            #[doc = "Adjustment Value"]
            #[inline(always)]
            pub const fn adj(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Adjustment Value"]
            #[inline(always)]
            pub fn set_adj(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "Plus,Minus"]
            #[inline(always)]
            pub const fn pmadj(&self) -> super::vals::Pmadj {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Pmadj::from_bits(val as u8)
            }
            #[doc = "Plus,Minus"]
            #[inline(always)]
            pub fn set_pmadj(&mut self, val: super::vals::Pmadj) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Radj {
            #[inline(always)]
            fn default() -> Radj {
                Radj(0)
            }
        }
        impl core::fmt::Debug for Radj {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Radj")
                    .field("adj", &self.adj())
                    .field("pmadj", &self.pmadj())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Radj {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Radj {{ adj: {=u8:?}, pmadj: {:?} }}",
                    self.adj(),
                    self.pmadj()
                )
            }
        }
        #[doc = "RTC Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rcr1(pub u8);
        impl Rcr1 {
            #[doc = "Alarm Interrupt Enable"]
            #[inline(always)]
            pub const fn aie(&self) -> super::vals::Aie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Aie::from_bits(val as u8)
            }
            #[doc = "Alarm Interrupt Enable"]
            #[inline(always)]
            pub fn set_aie(&mut self, val: super::vals::Aie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Carry Interrupt Enable"]
            #[inline(always)]
            pub const fn cie(&self) -> super::vals::Cie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cie::from_bits(val as u8)
            }
            #[doc = "Carry Interrupt Enable"]
            #[inline(always)]
            pub fn set_cie(&mut self, val: super::vals::Cie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Periodic Interrupt Enable"]
            #[inline(always)]
            pub const fn pie(&self) -> super::vals::Pie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pie::from_bits(val as u8)
            }
            #[doc = "Periodic Interrupt Enable"]
            #[inline(always)]
            pub fn set_pie(&mut self, val: super::vals::Pie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "RTCOUT Output Select"]
            #[inline(always)]
            pub const fn rtcos(&self) -> super::vals::Rtcos {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rtcos::from_bits(val as u8)
            }
            #[doc = "RTCOUT Output Select"]
            #[inline(always)]
            pub fn set_rtcos(&mut self, val: super::vals::Rtcos) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Periodic Interrupt Select"]
            #[inline(always)]
            pub const fn pes(&self) -> super::vals::Pes {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Pes::from_bits(val as u8)
            }
            #[doc = "Periodic Interrupt Select"]
            #[inline(always)]
            pub fn set_pes(&mut self, val: super::vals::Pes) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u8) & 0x0f) << 4usize);
            }
        }
        impl Default for Rcr1 {
            #[inline(always)]
            fn default() -> Rcr1 {
                Rcr1(0)
            }
        }
        impl core::fmt::Debug for Rcr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rcr1")
                    .field("aie", &self.aie())
                    .field("cie", &self.cie())
                    .field("pie", &self.pie())
                    .field("rtcos", &self.rtcos())
                    .field("pes", &self.pes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rcr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rcr1 {{ aie: {:?}, cie: {:?}, pie: {:?}, rtcos: {:?}, pes: {:?} }}",
                    self.aie(),
                    self.cie(),
                    self.pie(),
                    self.rtcos(),
                    self.pes()
                )
            }
        }
        #[doc = "RTC Control Register 2 (in Calendar Count Mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rcr2(pub u8);
        impl Rcr2 {
            #[doc = "Start"]
            #[inline(always)]
            pub const fn start(&self) -> super::vals::Rcr2Start {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rcr2Start::from_bits(val as u8)
            }
            #[doc = "Start"]
            #[inline(always)]
            pub fn set_start(&mut self, val: super::vals::Rcr2Start) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "RTC Software Reset"]
            #[inline(always)]
            pub const fn reset(&self) -> super::vals::Rcr2Reset {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rcr2Reset::from_bits(val as u8)
            }
            #[doc = "RTC Software Reset"]
            #[inline(always)]
            pub fn set_reset(&mut self, val: super::vals::Rcr2Reset) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "30-Second Adjustment"]
            #[inline(always)]
            pub const fn adj30(&self) -> super::vals::Adj30 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Adj30::from_bits(val as u8)
            }
            #[doc = "30-Second Adjustment"]
            #[inline(always)]
            pub fn set_adj30(&mut self, val: super::vals::Adj30) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "RTCOUT Output Enable"]
            #[inline(always)]
            pub const fn rtcoe(&self) -> super::vals::Rcr2Rtcoe {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rcr2Rtcoe::from_bits(val as u8)
            }
            #[doc = "RTCOUT Output Enable"]
            #[inline(always)]
            pub fn set_rtcoe(&mut self, val: super::vals::Rcr2Rtcoe) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Automatic Adjustment Enable"]
            #[inline(always)]
            pub const fn aadje(&self) -> super::vals::Rcr2Aadje {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rcr2Aadje::from_bits(val as u8)
            }
            #[doc = "Automatic Adjustment Enable"]
            #[inline(always)]
            pub fn set_aadje(&mut self, val: super::vals::Rcr2Aadje) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Automatic Adjustment Period Select"]
            #[inline(always)]
            pub const fn aadjp(&self) -> super::vals::Rcr2Aadjp {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rcr2Aadjp::from_bits(val as u8)
            }
            #[doc = "Automatic Adjustment Period Select"]
            #[inline(always)]
            pub fn set_aadjp(&mut self, val: super::vals::Rcr2Aadjp) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Hours Mode"]
            #[inline(always)]
            pub const fn hr24(&self) -> super::vals::Hr24 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Hr24::from_bits(val as u8)
            }
            #[doc = "Hours Mode"]
            #[inline(always)]
            pub fn set_hr24(&mut self, val: super::vals::Hr24) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Count Mode Select"]
            #[inline(always)]
            pub const fn cntmd(&self) -> super::vals::Rcr2Cntmd {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rcr2Cntmd::from_bits(val as u8)
            }
            #[doc = "Count Mode Select"]
            #[inline(always)]
            pub fn set_cntmd(&mut self, val: super::vals::Rcr2Cntmd) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rcr2 {
            #[inline(always)]
            fn default() -> Rcr2 {
                Rcr2(0)
            }
        }
        impl core::fmt::Debug for Rcr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rcr2")
                    .field("start", &self.start())
                    .field("reset", &self.reset())
                    .field("adj30", &self.adj30())
                    .field("rtcoe", &self.rtcoe())
                    .field("aadje", &self.aadje())
                    .field("aadjp", &self.aadjp())
                    .field("hr24", &self.hr24())
                    .field("cntmd", &self.cntmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rcr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rcr2 {{ start: {:?}, reset: {:?}, adj30: {:?}, rtcoe: {:?}, aadje: {:?}, aadjp: {:?}, hr24: {:?}, cntmd: {:?} }}" , self . start () , self . reset () , self . adj30 () , self . rtcoe () , self . aadje () , self . aadjp () , self . hr24 () , self . cntmd ())
            }
        }
        #[doc = "RTC Control Register 2 (in Binary Count Mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rcr2Bcnt(pub u8);
        impl Rcr2Bcnt {
            #[doc = "Start"]
            #[inline(always)]
            pub const fn start(&self) -> super::vals::Rcr2BcntStart {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rcr2BcntStart::from_bits(val as u8)
            }
            #[doc = "Start"]
            #[inline(always)]
            pub fn set_start(&mut self, val: super::vals::Rcr2BcntStart) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "RTC Software Reset"]
            #[inline(always)]
            pub const fn reset(&self) -> super::vals::Rcr2BcntReset {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rcr2BcntReset::from_bits(val as u8)
            }
            #[doc = "RTC Software Reset"]
            #[inline(always)]
            pub fn set_reset(&mut self, val: super::vals::Rcr2BcntReset) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "RTCOUT Output Enable"]
            #[inline(always)]
            pub const fn rtcoe(&self) -> super::vals::Rcr2BcntRtcoe {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rcr2BcntRtcoe::from_bits(val as u8)
            }
            #[doc = "RTCOUT Output Enable"]
            #[inline(always)]
            pub fn set_rtcoe(&mut self, val: super::vals::Rcr2BcntRtcoe) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Automatic Adjustment Enable"]
            #[inline(always)]
            pub const fn aadje(&self) -> super::vals::Rcr2BcntAadje {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rcr2BcntAadje::from_bits(val as u8)
            }
            #[doc = "Automatic Adjustment Enable"]
            #[inline(always)]
            pub fn set_aadje(&mut self, val: super::vals::Rcr2BcntAadje) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Automatic Adjustment Period Select"]
            #[inline(always)]
            pub const fn aadjp(&self) -> super::vals::Rcr2BcntAadjp {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Rcr2BcntAadjp::from_bits(val as u8)
            }
            #[doc = "Automatic Adjustment Period Select"]
            #[inline(always)]
            pub fn set_aadjp(&mut self, val: super::vals::Rcr2BcntAadjp) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Count Mode Select"]
            #[inline(always)]
            pub const fn cntmd(&self) -> super::vals::Rcr2BcntCntmd {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rcr2BcntCntmd::from_bits(val as u8)
            }
            #[doc = "Count Mode Select"]
            #[inline(always)]
            pub fn set_cntmd(&mut self, val: super::vals::Rcr2BcntCntmd) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rcr2Bcnt {
            #[inline(always)]
            fn default() -> Rcr2Bcnt {
                Rcr2Bcnt(0)
            }
        }
        impl core::fmt::Debug for Rcr2Bcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rcr2Bcnt")
                    .field("start", &self.start())
                    .field("reset", &self.reset())
                    .field("rtcoe", &self.rtcoe())
                    .field("aadje", &self.aadje())
                    .field("aadjp", &self.aadjp())
                    .field("cntmd", &self.cntmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rcr2Bcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rcr2Bcnt {{ start: {:?}, reset: {:?}, rtcoe: {:?}, aadje: {:?}, aadjp: {:?}, cntmd: {:?} }}" , self . start () , self . reset () , self . rtcoe () , self . aadje () , self . aadjp () , self . cntmd ())
            }
        }
        #[doc = "RTC Control Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rcr4(pub u8);
        impl Rcr4 {
            #[doc = "0.5-second adjustment"]
            #[inline(always)]
            pub const fn adj500m(&self) -> super::vals::Adj500m {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Adj500m::from_bits(val as u8)
            }
            #[doc = "0.5-second adjustment"]
            #[inline(always)]
            pub fn set_adj500m(&mut self, val: super::vals::Adj500m) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Rcr4 {
            #[inline(always)]
            fn default() -> Rcr4 {
                Rcr4(0)
            }
        }
        impl core::fmt::Debug for Rcr4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rcr4")
                    .field("adj500m", &self.adj500m())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rcr4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rcr4 {{ adj500m: {:?} }}", self.adj500m())
            }
        }
        #[doc = "Date Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdayar(pub u8);
        impl Rdayar {
            #[doc = "1 Day"]
            #[inline(always)]
            pub const fn date1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1 Day"]
            #[inline(always)]
            pub fn set_date1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10 Days"]
            #[inline(always)]
            pub const fn date10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10 Days"]
            #[inline(always)]
            pub fn set_date10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RdayarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RdayarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RdayarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rdayar {
            #[inline(always)]
            fn default() -> Rdayar {
                Rdayar(0)
            }
        }
        impl core::fmt::Debug for Rdayar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdayar")
                    .field("date1", &self.date1())
                    .field("date10", &self.date10())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdayar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rdayar {{ date1: {=u8:?}, date10: {=u8:?}, enb: {:?} }}",
                    self.date1(),
                    self.date10(),
                    self.enb()
                )
            }
        }
        #[doc = "Day Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdaycnt(pub u8);
        impl Rdaycnt {
            #[doc = "1-Day Count"]
            #[inline(always)]
            pub const fn date1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Day Count"]
            #[inline(always)]
            pub fn set_date1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Day Count"]
            #[inline(always)]
            pub const fn date10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-Day Count"]
            #[inline(always)]
            pub fn set_date10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Rdaycnt {
            #[inline(always)]
            fn default() -> Rdaycnt {
                Rdaycnt(0)
            }
        }
        impl core::fmt::Debug for Rdaycnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdaycnt")
                    .field("date1", &self.date1())
                    .field("date10", &self.date10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdaycnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rdaycnt {{ date1: {=u8:?}, date10: {=u8:?} }}",
                    self.date1(),
                    self.date10()
                )
            }
        }
        #[doc = "Date Capture Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdaycp(pub u8);
        impl Rdaycp {
            #[doc = "1-Day Capture"]
            #[inline(always)]
            pub const fn date1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Day Capture"]
            #[inline(always)]
            pub fn set_date1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Day Capture"]
            #[inline(always)]
            pub const fn date10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-Day Capture"]
            #[inline(always)]
            pub fn set_date10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Rdaycp {
            #[inline(always)]
            fn default() -> Rdaycp {
                Rdaycp(0)
            }
        }
        impl core::fmt::Debug for Rdaycp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdaycp")
                    .field("date1", &self.date1())
                    .field("date10", &self.date10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdaycp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rdaycp {{ date1: {=u8:?}, date10: {=u8:?} }}",
                    self.date1(),
                    self.date10()
                )
            }
        }
        #[doc = "Hour Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rhrar(pub u8);
        impl Rhrar {
            #[doc = "1 Hour"]
            #[inline(always)]
            pub const fn hr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1 Hour"]
            #[inline(always)]
            pub fn set_hr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10 Hours"]
            #[inline(always)]
            pub const fn hr10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10 Hours"]
            #[inline(always)]
            pub fn set_hr10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "AM/PM select for alarm setting."]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::RhrarPm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::RhrarPm::from_bits(val as u8)
            }
            #[doc = "AM/PM select for alarm setting."]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::RhrarPm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RhrarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RhrarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RhrarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rhrar {
            #[inline(always)]
            fn default() -> Rhrar {
                Rhrar(0)
            }
        }
        impl core::fmt::Debug for Rhrar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rhrar")
                    .field("hr1", &self.hr1())
                    .field("hr10", &self.hr10())
                    .field("pm", &self.pm())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rhrar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rhrar {{ hr1: {=u8:?}, hr10: {=u8:?}, pm: {:?}, enb: {:?} }}",
                    self.hr1(),
                    self.hr10(),
                    self.pm(),
                    self.enb()
                )
            }
        }
        #[doc = "Hour Counter (in Calendar Count Mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rhrcnt(pub u8);
        impl Rhrcnt {
            #[doc = "1-Hour Count"]
            #[inline(always)]
            pub const fn hr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Hour Count"]
            #[inline(always)]
            pub fn set_hr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Hour Count"]
            #[inline(always)]
            pub const fn hr10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-Hour Count"]
            #[inline(always)]
            pub fn set_hr10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "AM/PM select for time counter setting."]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::RhrcntPm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::RhrcntPm::from_bits(val as u8)
            }
            #[doc = "AM/PM select for time counter setting."]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::RhrcntPm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Rhrcnt {
            #[inline(always)]
            fn default() -> Rhrcnt {
                Rhrcnt(0)
            }
        }
        impl core::fmt::Debug for Rhrcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rhrcnt")
                    .field("hr1", &self.hr1())
                    .field("hr10", &self.hr10())
                    .field("pm", &self.pm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rhrcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rhrcnt {{ hr1: {=u8:?}, hr10: {=u8:?}, pm: {:?} }}",
                    self.hr1(),
                    self.hr10(),
                    self.pm()
                )
            }
        }
        #[doc = "Hour Capture Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rhrcp(pub u8);
        impl Rhrcp {
            #[doc = "1-Hour Capture"]
            #[inline(always)]
            pub const fn hr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Hour Capture"]
            #[inline(always)]
            pub fn set_hr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Hour Capture"]
            #[inline(always)]
            pub const fn hr10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "10-Hour Capture"]
            #[inline(always)]
            pub fn set_hr10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
            #[doc = "PM"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::RhrcpPm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::RhrcpPm::from_bits(val as u8)
            }
            #[doc = "PM"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::RhrcpPm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Rhrcp {
            #[inline(always)]
            fn default() -> Rhrcp {
                Rhrcp(0)
            }
        }
        impl core::fmt::Debug for Rhrcp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rhrcp")
                    .field("hr1", &self.hr1())
                    .field("hr10", &self.hr10())
                    .field("pm", &self.pm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rhrcp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rhrcp {{ hr1: {=u8:?}, hr10: {=u8:?}, pm: {:?} }}",
                    self.hr1(),
                    self.hr10(),
                    self.pm()
                )
            }
        }
        #[doc = "Minute Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rminar(pub u8);
        impl Rminar {
            #[doc = "1 Minute"]
            #[inline(always)]
            pub const fn min1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1 Minute"]
            #[inline(always)]
            pub fn set_min1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10 Minutes"]
            #[inline(always)]
            pub const fn min10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10 Minutes"]
            #[inline(always)]
            pub fn set_min10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RminarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RminarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RminarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rminar {
            #[inline(always)]
            fn default() -> Rminar {
                Rminar(0)
            }
        }
        impl core::fmt::Debug for Rminar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rminar")
                    .field("min1", &self.min1())
                    .field("min10", &self.min10())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rminar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rminar {{ min1: {=u8:?}, min10: {=u8:?}, enb: {:?} }}",
                    self.min1(),
                    self.min10(),
                    self.enb()
                )
            }
        }
        #[doc = "Minute Counter (in Calendar Count Mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rmincnt(pub u8);
        impl Rmincnt {
            #[doc = "1-Minute Count"]
            #[inline(always)]
            pub const fn min1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Minute Count"]
            #[inline(always)]
            pub fn set_min1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Minute Count"]
            #[inline(always)]
            pub const fn min10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-Minute Count"]
            #[inline(always)]
            pub fn set_min10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Rmincnt {
            #[inline(always)]
            fn default() -> Rmincnt {
                Rmincnt(0)
            }
        }
        impl core::fmt::Debug for Rmincnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rmincnt")
                    .field("min1", &self.min1())
                    .field("min10", &self.min10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rmincnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rmincnt {{ min1: {=u8:?}, min10: {=u8:?} }}",
                    self.min1(),
                    self.min10()
                )
            }
        }
        #[doc = "Minute Capture Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rmincp(pub u8);
        impl Rmincp {
            #[doc = "1-Minute Capture"]
            #[inline(always)]
            pub const fn min1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Minute Capture"]
            #[inline(always)]
            pub fn set_min1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Minute Capture"]
            #[inline(always)]
            pub const fn min10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-Minute Capture"]
            #[inline(always)]
            pub fn set_min10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Rmincp {
            #[inline(always)]
            fn default() -> Rmincp {
                Rmincp(0)
            }
        }
        impl core::fmt::Debug for Rmincp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rmincp")
                    .field("min1", &self.min1())
                    .field("min10", &self.min10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rmincp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rmincp {{ min1: {=u8:?}, min10: {=u8:?} }}",
                    self.min1(),
                    self.min10()
                )
            }
        }
        #[doc = "Month Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rmonar(pub u8);
        impl Rmonar {
            #[doc = "1 Month"]
            #[inline(always)]
            pub const fn mon1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1 Month"]
            #[inline(always)]
            pub fn set_mon1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10 Months"]
            #[inline(always)]
            pub const fn mon10(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "10 Months"]
            #[inline(always)]
            pub fn set_mon10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RmonarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RmonarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RmonarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rmonar {
            #[inline(always)]
            fn default() -> Rmonar {
                Rmonar(0)
            }
        }
        impl core::fmt::Debug for Rmonar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rmonar")
                    .field("mon1", &self.mon1())
                    .field("mon10", &self.mon10())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rmonar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rmonar {{ mon1: {=u8:?}, mon10: {=bool:?}, enb: {:?} }}",
                    self.mon1(),
                    self.mon10(),
                    self.enb()
                )
            }
        }
        #[doc = "Month Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rmoncnt(pub u8);
        impl Rmoncnt {
            #[doc = "1-Month Count"]
            #[inline(always)]
            pub const fn mon1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Month Count"]
            #[inline(always)]
            pub fn set_mon1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Month Count"]
            #[inline(always)]
            pub const fn mon10(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "10-Month Count"]
            #[inline(always)]
            pub fn set_mon10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Rmoncnt {
            #[inline(always)]
            fn default() -> Rmoncnt {
                Rmoncnt(0)
            }
        }
        impl core::fmt::Debug for Rmoncnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rmoncnt")
                    .field("mon1", &self.mon1())
                    .field("mon10", &self.mon10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rmoncnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rmoncnt {{ mon1: {=u8:?}, mon10: {=bool:?} }}",
                    self.mon1(),
                    self.mon10()
                )
            }
        }
        #[doc = "Month Capture Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rmoncp(pub u8);
        impl Rmoncp {
            #[doc = "1-Month Capture"]
            #[inline(always)]
            pub const fn mon1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Month Capture"]
            #[inline(always)]
            pub fn set_mon1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Month Capture"]
            #[inline(always)]
            pub const fn mon10(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "10-Month Capture"]
            #[inline(always)]
            pub fn set_mon10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Rmoncp {
            #[inline(always)]
            fn default() -> Rmoncp {
                Rmoncp(0)
            }
        }
        impl core::fmt::Debug for Rmoncp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rmoncp")
                    .field("mon1", &self.mon1())
                    .field("mon10", &self.mon10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rmoncp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rmoncp {{ mon1: {=u8:?}, mon10: {=bool:?} }}",
                    self.mon1(),
                    self.mon10()
                )
            }
        }
        #[doc = "Second Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rsecar(pub u8);
        impl Rsecar {
            #[doc = "1 Second"]
            #[inline(always)]
            pub const fn sec1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1 Second"]
            #[inline(always)]
            pub fn set_sec1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10 Seconds"]
            #[inline(always)]
            pub const fn sec10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10 Seconds"]
            #[inline(always)]
            pub fn set_sec10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RsecarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RsecarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RsecarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rsecar {
            #[inline(always)]
            fn default() -> Rsecar {
                Rsecar(0)
            }
        }
        impl core::fmt::Debug for Rsecar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rsecar")
                    .field("sec1", &self.sec1())
                    .field("sec10", &self.sec10())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rsecar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rsecar {{ sec1: {=u8:?}, sec10: {=u8:?}, enb: {:?} }}",
                    self.sec1(),
                    self.sec10(),
                    self.enb()
                )
            }
        }
        #[doc = "Second Counter (in Calendar Count Mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rseccnt(pub u8);
        impl Rseccnt {
            #[doc = "1-Second Count"]
            #[inline(always)]
            pub const fn sec1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Second Count"]
            #[inline(always)]
            pub fn set_sec1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Second Count"]
            #[inline(always)]
            pub const fn sec10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-Second Count"]
            #[inline(always)]
            pub fn set_sec10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Rseccnt {
            #[inline(always)]
            fn default() -> Rseccnt {
                Rseccnt(0)
            }
        }
        impl core::fmt::Debug for Rseccnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rseccnt")
                    .field("sec1", &self.sec1())
                    .field("sec10", &self.sec10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rseccnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rseccnt {{ sec1: {=u8:?}, sec10: {=u8:?} }}",
                    self.sec1(),
                    self.sec10()
                )
            }
        }
        #[doc = "Second Capture Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rseccp(pub u8);
        impl Rseccp {
            #[doc = "1-Second Capture"]
            #[inline(always)]
            pub const fn sec1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Second Capture"]
            #[inline(always)]
            pub fn set_sec1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "10-Second Capture"]
            #[inline(always)]
            pub const fn sec10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "10-Second Capture"]
            #[inline(always)]
            pub fn set_sec10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Rseccp {
            #[inline(always)]
            fn default() -> Rseccp {
                Rseccp(0)
            }
        }
        impl core::fmt::Debug for Rseccp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rseccp")
                    .field("sec1", &self.sec1())
                    .field("sec10", &self.sec10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rseccp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rseccp {{ sec1: {=u8:?}, sec10: {=u8:?} }}",
                    self.sec1(),
                    self.sec10()
                )
            }
        }
        #[doc = "Time Capture Control Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rtccr(pub u8);
        impl Rtccr {
            #[doc = "Time Capture Control"]
            #[inline(always)]
            pub const fn tcct(&self) -> super::vals::Tcct {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Tcct::from_bits(val as u8)
            }
            #[doc = "Time Capture Control"]
            #[inline(always)]
            pub fn set_tcct(&mut self, val: super::vals::Tcct) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Time Capture Status"]
            #[inline(always)]
            pub const fn tcst(&self) -> super::vals::Tcst {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tcst::from_bits(val as u8)
            }
            #[doc = "Time Capture Status"]
            #[inline(always)]
            pub fn set_tcst(&mut self, val: super::vals::Tcst) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Time Capture Noise Filter Control"]
            #[inline(always)]
            pub const fn tcnf(&self) -> super::vals::Tcnf {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Tcnf::from_bits(val as u8)
            }
            #[doc = "Time Capture Noise Filter Control"]
            #[inline(always)]
            pub fn set_tcnf(&mut self, val: super::vals::Tcnf) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "Time Capture Event Input Pin Enable"]
            #[inline(always)]
            pub const fn tcen(&self) -> super::vals::Tcen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tcen::from_bits(val as u8)
            }
            #[doc = "Time Capture Event Input Pin Enable"]
            #[inline(always)]
            pub fn set_tcen(&mut self, val: super::vals::Tcen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rtccr {
            #[inline(always)]
            fn default() -> Rtccr {
                Rtccr(0)
            }
        }
        impl core::fmt::Debug for Rtccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rtccr")
                    .field("tcct", &self.tcct())
                    .field("tcst", &self.tcst())
                    .field("tcnf", &self.tcnf())
                    .field("tcen", &self.tcen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rtccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rtccr {{ tcct: {:?}, tcst: {:?}, tcnf: {:?}, tcen: {:?} }}",
                    self.tcct(),
                    self.tcst(),
                    self.tcnf(),
                    self.tcen()
                )
            }
        }
        #[doc = "Day of Week Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rwkar(pub u8);
        impl Rwkar {
            #[doc = "Day,of,Week Setting"]
            #[inline(always)]
            pub const fn dayw(&self) -> super::vals::RwkarDayw {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::RwkarDayw::from_bits(val as u8)
            }
            #[doc = "Day,of,Week Setting"]
            #[inline(always)]
            pub fn set_dayw(&mut self, val: super::vals::RwkarDayw) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RwkarEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RwkarEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RwkarEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Rwkar {
            #[inline(always)]
            fn default() -> Rwkar {
                Rwkar(0)
            }
        }
        impl core::fmt::Debug for Rwkar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rwkar")
                    .field("dayw", &self.dayw())
                    .field("enb", &self.enb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rwkar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rwkar {{ dayw: {:?}, enb: {:?} }}",
                    self.dayw(),
                    self.enb()
                )
            }
        }
        #[doc = "Day,of,Week Counter (in Calendar Count Mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rwkcnt(pub u8);
        impl Rwkcnt {
            #[doc = "Day,of,Week Counting"]
            #[inline(always)]
            pub const fn dayw(&self) -> super::vals::RwkcntDayw {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::RwkcntDayw::from_bits(val as u8)
            }
            #[doc = "Day,of,Week Counting"]
            #[inline(always)]
            pub fn set_dayw(&mut self, val: super::vals::RwkcntDayw) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Rwkcnt {
            #[inline(always)]
            fn default() -> Rwkcnt {
                Rwkcnt(0)
            }
        }
        impl core::fmt::Debug for Rwkcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rwkcnt")
                    .field("dayw", &self.dayw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rwkcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rwkcnt {{ dayw: {:?} }}", self.dayw())
            }
        }
        #[doc = "Year Alarm Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ryrar(pub u16);
        impl Ryrar {
            #[doc = "1 Year"]
            #[inline(always)]
            pub const fn yr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1 Year"]
            #[inline(always)]
            pub fn set_yr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "10 Years"]
            #[inline(always)]
            pub const fn yr10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "10 Years"]
            #[inline(always)]
            pub fn set_yr10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u16) & 0x0f) << 4usize);
            }
        }
        impl Default for Ryrar {
            #[inline(always)]
            fn default() -> Ryrar {
                Ryrar(0)
            }
        }
        impl core::fmt::Debug for Ryrar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ryrar")
                    .field("yr1", &self.yr1())
                    .field("yr10", &self.yr10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ryrar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ryrar {{ yr1: {=u8:?}, yr10: {=u8:?} }}",
                    self.yr1(),
                    self.yr10()
                )
            }
        }
        #[doc = "Year Alarm Enable Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ryraren(pub u8);
        impl Ryraren {
            #[doc = "ENB"]
            #[inline(always)]
            pub const fn enb(&self) -> super::vals::RyrarenEnb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::RyrarenEnb::from_bits(val as u8)
            }
            #[doc = "ENB"]
            #[inline(always)]
            pub fn set_enb(&mut self, val: super::vals::RyrarenEnb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ryraren {
            #[inline(always)]
            fn default() -> Ryraren {
                Ryraren(0)
            }
        }
        impl core::fmt::Debug for Ryraren {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ryraren").field("enb", &self.enb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ryraren {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ryraren {{ enb: {:?} }}", self.enb())
            }
        }
        #[doc = "Year Counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ryrcnt(pub u16);
        impl Ryrcnt {
            #[doc = "1-Year Count"]
            #[inline(always)]
            pub const fn yr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "1-Year Count"]
            #[inline(always)]
            pub fn set_yr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "10-Year Count"]
            #[inline(always)]
            pub const fn yr10(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "10-Year Count"]
            #[inline(always)]
            pub fn set_yr10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u16) & 0x0f) << 4usize);
            }
        }
        impl Default for Ryrcnt {
            #[inline(always)]
            fn default() -> Ryrcnt {
                Ryrcnt(0)
            }
        }
        impl core::fmt::Debug for Ryrcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ryrcnt")
                    .field("yr1", &self.yr1())
                    .field("yr10", &self.yr10())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ryrcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ryrcnt {{ yr1: {=u8:?}, yr10: {=u8:?} }}",
                    self.yr1(),
                    self.yr10()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adj30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adj30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adj30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adj30 {
            #[inline(always)]
            fn from(val: u8) -> Adj30 {
                Adj30::from_bits(val)
            }
        }
        impl From<Adj30> for u8 {
            #[inline(always)]
            fn from(val: Adj30) -> u8 {
                Adj30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adj500m {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adj500m {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adj500m {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adj500m {
            #[inline(always)]
            fn from(val: u8) -> Adj500m {
                Adj500m::from_bits(val)
            }
        }
        impl From<Adj500m> for u8 {
            #[inline(always)]
            fn from(val: Adj500m) -> u8 {
                Adj500m::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aie {
            #[inline(always)]
            fn from(val: u8) -> Aie {
                Aie::from_bits(val)
            }
        }
        impl From<Aie> for u8 {
            #[inline(always)]
            fn from(val: Aie) -> u8 {
                Aie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cie {
            #[inline(always)]
            fn from(val: u8) -> Cie {
                Cie::from_bits(val)
            }
        }
        impl From<Cie> for u8 {
            #[inline(always)]
            fn from(val: Cie) -> u8 {
                Cie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hr24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hr24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hr24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hr24 {
            #[inline(always)]
            fn from(val: u8) -> Hr24 {
                Hr24::from_bits(val)
            }
        }
        impl From<Hr24> for u8 {
            #[inline(always)]
            fn from(val: Hr24) -> u8 {
                Hr24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pes {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Pes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pes {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pes {
            #[inline(always)]
            fn from(val: u8) -> Pes {
                Pes::from_bits(val)
            }
        }
        impl From<Pes> for u8 {
            #[inline(always)]
            fn from(val: Pes) -> u8 {
                Pes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pie {
            #[inline(always)]
            fn from(val: u8) -> Pie {
                Pie::from_bits(val)
            }
        }
        impl From<Pie> for u8 {
            #[inline(always)]
            fn from(val: Pie) -> u8 {
                Pie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pmadj {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Pmadj {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pmadj {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pmadj {
            #[inline(always)]
            fn from(val: u8) -> Pmadj {
                Pmadj::from_bits(val)
            }
        }
        impl From<Pmadj> for u8 {
            #[inline(always)]
            fn from(val: Pmadj) -> u8 {
                Pmadj::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2Aadje {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2Aadje {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2Aadje {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2Aadje {
            #[inline(always)]
            fn from(val: u8) -> Rcr2Aadje {
                Rcr2Aadje::from_bits(val)
            }
        }
        impl From<Rcr2Aadje> for u8 {
            #[inline(always)]
            fn from(val: Rcr2Aadje) -> u8 {
                Rcr2Aadje::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2Aadjp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2Aadjp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2Aadjp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2Aadjp {
            #[inline(always)]
            fn from(val: u8) -> Rcr2Aadjp {
                Rcr2Aadjp::from_bits(val)
            }
        }
        impl From<Rcr2Aadjp> for u8 {
            #[inline(always)]
            fn from(val: Rcr2Aadjp) -> u8 {
                Rcr2Aadjp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2BcntAadje {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2BcntAadje {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2BcntAadje {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2BcntAadje {
            #[inline(always)]
            fn from(val: u8) -> Rcr2BcntAadje {
                Rcr2BcntAadje::from_bits(val)
            }
        }
        impl From<Rcr2BcntAadje> for u8 {
            #[inline(always)]
            fn from(val: Rcr2BcntAadje) -> u8 {
                Rcr2BcntAadje::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2BcntAadjp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2BcntAadjp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2BcntAadjp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2BcntAadjp {
            #[inline(always)]
            fn from(val: u8) -> Rcr2BcntAadjp {
                Rcr2BcntAadjp::from_bits(val)
            }
        }
        impl From<Rcr2BcntAadjp> for u8 {
            #[inline(always)]
            fn from(val: Rcr2BcntAadjp) -> u8 {
                Rcr2BcntAadjp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2BcntCntmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2BcntCntmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2BcntCntmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2BcntCntmd {
            #[inline(always)]
            fn from(val: u8) -> Rcr2BcntCntmd {
                Rcr2BcntCntmd::from_bits(val)
            }
        }
        impl From<Rcr2BcntCntmd> for u8 {
            #[inline(always)]
            fn from(val: Rcr2BcntCntmd) -> u8 {
                Rcr2BcntCntmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2BcntReset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2BcntReset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2BcntReset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2BcntReset {
            #[inline(always)]
            fn from(val: u8) -> Rcr2BcntReset {
                Rcr2BcntReset::from_bits(val)
            }
        }
        impl From<Rcr2BcntReset> for u8 {
            #[inline(always)]
            fn from(val: Rcr2BcntReset) -> u8 {
                Rcr2BcntReset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2BcntRtcoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2BcntRtcoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2BcntRtcoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2BcntRtcoe {
            #[inline(always)]
            fn from(val: u8) -> Rcr2BcntRtcoe {
                Rcr2BcntRtcoe::from_bits(val)
            }
        }
        impl From<Rcr2BcntRtcoe> for u8 {
            #[inline(always)]
            fn from(val: Rcr2BcntRtcoe) -> u8 {
                Rcr2BcntRtcoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2BcntStart {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2BcntStart {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2BcntStart {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2BcntStart {
            #[inline(always)]
            fn from(val: u8) -> Rcr2BcntStart {
                Rcr2BcntStart::from_bits(val)
            }
        }
        impl From<Rcr2BcntStart> for u8 {
            #[inline(always)]
            fn from(val: Rcr2BcntStart) -> u8 {
                Rcr2BcntStart::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2Cntmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2Cntmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2Cntmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2Cntmd {
            #[inline(always)]
            fn from(val: u8) -> Rcr2Cntmd {
                Rcr2Cntmd::from_bits(val)
            }
        }
        impl From<Rcr2Cntmd> for u8 {
            #[inline(always)]
            fn from(val: Rcr2Cntmd) -> u8 {
                Rcr2Cntmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2Reset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2Reset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2Reset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2Reset {
            #[inline(always)]
            fn from(val: u8) -> Rcr2Reset {
                Rcr2Reset::from_bits(val)
            }
        }
        impl From<Rcr2Reset> for u8 {
            #[inline(always)]
            fn from(val: Rcr2Reset) -> u8 {
                Rcr2Reset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2Rtcoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2Rtcoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2Rtcoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2Rtcoe {
            #[inline(always)]
            fn from(val: u8) -> Rcr2Rtcoe {
                Rcr2Rtcoe::from_bits(val)
            }
        }
        impl From<Rcr2Rtcoe> for u8 {
            #[inline(always)]
            fn from(val: Rcr2Rtcoe) -> u8 {
                Rcr2Rtcoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcr2Start {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rcr2Start {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcr2Start {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcr2Start {
            #[inline(always)]
            fn from(val: u8) -> Rcr2Start {
                Rcr2Start::from_bits(val)
            }
        }
        impl From<Rcr2Start> for u8 {
            #[inline(always)]
            fn from(val: Rcr2Start) -> u8 {
                Rcr2Start::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RdayarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RdayarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RdayarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RdayarEnb {
            #[inline(always)]
            fn from(val: u8) -> RdayarEnb {
                RdayarEnb::from_bits(val)
            }
        }
        impl From<RdayarEnb> for u8 {
            #[inline(always)]
            fn from(val: RdayarEnb) -> u8 {
                RdayarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RhrarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RhrarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RhrarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RhrarEnb {
            #[inline(always)]
            fn from(val: u8) -> RhrarEnb {
                RhrarEnb::from_bits(val)
            }
        }
        impl From<RhrarEnb> for u8 {
            #[inline(always)]
            fn from(val: RhrarEnb) -> u8 {
                RhrarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RhrarPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RhrarPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RhrarPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RhrarPm {
            #[inline(always)]
            fn from(val: u8) -> RhrarPm {
                RhrarPm::from_bits(val)
            }
        }
        impl From<RhrarPm> for u8 {
            #[inline(always)]
            fn from(val: RhrarPm) -> u8 {
                RhrarPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RhrcntPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RhrcntPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RhrcntPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RhrcntPm {
            #[inline(always)]
            fn from(val: u8) -> RhrcntPm {
                RhrcntPm::from_bits(val)
            }
        }
        impl From<RhrcntPm> for u8 {
            #[inline(always)]
            fn from(val: RhrcntPm) -> u8 {
                RhrcntPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RhrcpPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RhrcpPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RhrcpPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RhrcpPm {
            #[inline(always)]
            fn from(val: u8) -> RhrcpPm {
                RhrcpPm::from_bits(val)
            }
        }
        impl From<RhrcpPm> for u8 {
            #[inline(always)]
            fn from(val: RhrcpPm) -> u8 {
                RhrcpPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RminarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RminarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RminarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RminarEnb {
            #[inline(always)]
            fn from(val: u8) -> RminarEnb {
                RminarEnb::from_bits(val)
            }
        }
        impl From<RminarEnb> for u8 {
            #[inline(always)]
            fn from(val: RminarEnb) -> u8 {
                RminarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RmonarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RmonarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RmonarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RmonarEnb {
            #[inline(always)]
            fn from(val: u8) -> RmonarEnb {
                RmonarEnb::from_bits(val)
            }
        }
        impl From<RmonarEnb> for u8 {
            #[inline(always)]
            fn from(val: RmonarEnb) -> u8 {
                RmonarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RsecarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RsecarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RsecarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RsecarEnb {
            #[inline(always)]
            fn from(val: u8) -> RsecarEnb {
                RsecarEnb::from_bits(val)
            }
        }
        impl From<RsecarEnb> for u8 {
            #[inline(always)]
            fn from(val: RsecarEnb) -> u8 {
                RsecarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtcos {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rtcos {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtcos {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtcos {
            #[inline(always)]
            fn from(val: u8) -> Rtcos {
                Rtcos::from_bits(val)
            }
        }
        impl From<Rtcos> for u8 {
            #[inline(always)]
            fn from(val: Rtcos) -> u8 {
                Rtcos::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RwkarDayw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl RwkarDayw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RwkarDayw {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RwkarDayw {
            #[inline(always)]
            fn from(val: u8) -> RwkarDayw {
                RwkarDayw::from_bits(val)
            }
        }
        impl From<RwkarDayw> for u8 {
            #[inline(always)]
            fn from(val: RwkarDayw) -> u8 {
                RwkarDayw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RwkarEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RwkarEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RwkarEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RwkarEnb {
            #[inline(always)]
            fn from(val: u8) -> RwkarEnb {
                RwkarEnb::from_bits(val)
            }
        }
        impl From<RwkarEnb> for u8 {
            #[inline(always)]
            fn from(val: RwkarEnb) -> u8 {
                RwkarEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RwkcntDayw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl RwkcntDayw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RwkcntDayw {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RwkcntDayw {
            #[inline(always)]
            fn from(val: u8) -> RwkcntDayw {
                RwkcntDayw::from_bits(val)
            }
        }
        impl From<RwkcntDayw> for u8 {
            #[inline(always)]
            fn from(val: RwkcntDayw) -> u8 {
                RwkcntDayw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RyrarenEnb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl RyrarenEnb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RyrarenEnb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RyrarenEnb {
            #[inline(always)]
            fn from(val: u8) -> RyrarenEnb {
                RyrarenEnb::from_bits(val)
            }
        }
        impl From<RyrarenEnb> for u8 {
            #[inline(always)]
            fn from(val: RyrarenEnb) -> u8 {
                RyrarenEnb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcct {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tcct {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcct {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcct {
            #[inline(always)]
            fn from(val: u8) -> Tcct {
                Tcct::from_bits(val)
            }
        }
        impl From<Tcct> for u8 {
            #[inline(always)]
            fn from(val: Tcct) -> u8 {
                Tcct::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcen {
            #[inline(always)]
            fn from(val: u8) -> Tcen {
                Tcen::from_bits(val)
            }
        }
        impl From<Tcen> for u8 {
            #[inline(always)]
            fn from(val: Tcen) -> u8 {
                Tcen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcnf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tcnf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcnf {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcnf {
            #[inline(always)]
            fn from(val: u8) -> Tcnf {
                Tcnf::from_bits(val)
            }
        }
        impl From<Tcnf> for u8 {
            #[inline(always)]
            fn from(val: Tcnf) -> u8 {
                Tcnf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcst {
            #[inline(always)]
            fn from(val: u8) -> Tcst {
                Tcst::from_bits(val)
            }
        }
        impl From<Tcst> for u8 {
            #[inline(always)]
            fn from(val: Tcst) -> u8 {
                Tcst::to_bits(val)
            }
        }
    }
}
pub mod sci0 {
    #[doc = "Serial Communication Interface 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sci0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Sci0 {}
    unsafe impl Sync for Sci0 {}
    impl Sci0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Serial Mode Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn smr(self) -> crate::common::Reg<regs::Smr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn smr_smci(self) -> crate::common::Reg<regs::SmrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Bit Rate Register"]
        #[inline(always)]
        pub const fn brr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Serial Control Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<regs::Scr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn scr_smci(self) -> crate::common::Reg<regs::ScrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Transmit Data Register"]
        #[inline(always)]
        pub const fn tdr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Serial Status Register for Non,Smart Card Interface and Non,FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0)"]
        #[inline(always)]
        pub const fn ssr(self) -> crate::common::Reg<regs::Ssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Serial Status Register for Non,Smart Card Interface and FIFO Mode (SCMR.SMIF = 0, FCR.FM = 1)"]
        #[inline(always)]
        pub const fn ssr_fifo(self) -> crate::common::Reg<regs::SsrFifo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn ssr_smci(self) -> crate::common::Reg<regs::SsrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Receive Data Register"]
        #[inline(always)]
        pub const fn rdr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "Smart Card Mode Register"]
        #[inline(always)]
        pub const fn scmr(self) -> crate::common::Reg<regs::Scmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Serial Extended Mode Register"]
        #[inline(always)]
        pub const fn semr(self) -> crate::common::Reg<regs::Semr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Noise Filter Setting Register"]
        #[inline(always)]
        pub const fn snfr(self) -> crate::common::Reg<regs::Snfr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "IIC Mode Register 1"]
        #[inline(always)]
        pub const fn simr1(self) -> crate::common::Reg<regs::Simr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "IIC Mode Register 2"]
        #[inline(always)]
        pub const fn simr2(self) -> crate::common::Reg<regs::Simr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "IIC Mode Register 3"]
        #[inline(always)]
        pub const fn simr3(self) -> crate::common::Reg<regs::Simr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "IIC Status Register"]
        #[inline(always)]
        pub const fn sisr(self) -> crate::common::Reg<regs::Sisr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Mode Register"]
        #[inline(always)]
        pub const fn spmr(self) -> crate::common::Reg<regs::Spmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "Transmit FIFO Data Register"]
        #[inline(always)]
        pub const fn ftdrh(self) -> crate::common::Reg<regs::Ftdrh, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Transmit FIFO Data Register"]
        #[inline(always)]
        pub const fn ftdrhl(self) -> crate::common::Reg<regs::Ftdrhl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Transmit Data Register"]
        #[inline(always)]
        pub const fn tdrhl(self) -> crate::common::Reg<regs::Tdrhl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Transmit FIFO Data Register"]
        #[inline(always)]
        pub const fn ftdrl(self) -> crate::common::Reg<regs::Ftdrl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
        #[doc = "Receive FIFO Data Register"]
        #[inline(always)]
        pub const fn frdrh(self) -> crate::common::Reg<regs::Frdrh, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Receive FIFO Data Register"]
        #[inline(always)]
        pub const fn frdrhl(self) -> crate::common::Reg<regs::Frdrhl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Receive Data Register"]
        #[inline(always)]
        pub const fn rdrhl(self) -> crate::common::Reg<regs::Rdrhl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Receive FIFO Data Register"]
        #[inline(always)]
        pub const fn frdrl(self) -> crate::common::Reg<regs::Frdrl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
        #[doc = "Modulation Duty Register"]
        #[inline(always)]
        pub const fn mddr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "Data Compare Match Control Register"]
        #[inline(always)]
        pub const fn dccr(self) -> crate::common::Reg<regs::Dccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13usize) as _) }
        }
        #[doc = "FIFO Control Register"]
        #[inline(always)]
        pub const fn fcr(self) -> crate::common::Reg<regs::Fcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "FIFO Data Count Register"]
        #[inline(always)]
        pub const fn fdr(self) -> crate::common::Reg<regs::Fdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "Line Status Register"]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::Lsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Compare Match Data Register"]
        #[inline(always)]
        pub const fn cdr(self) -> crate::common::Reg<regs::Cdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "Serial Port Register"]
        #[inline(always)]
        pub const fn sptr(self) -> crate::common::Reg<regs::Sptr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Compare Match Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cdr(pub u16);
        impl Cdr {
            #[doc = "Compare Match Data"]
            #[inline(always)]
            pub const fn cmpd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Compare Match Data"]
            #[inline(always)]
            pub fn set_cmpd(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
        }
        impl Default for Cdr {
            #[inline(always)]
            fn default() -> Cdr {
                Cdr(0)
            }
        }
        impl core::fmt::Debug for Cdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cdr").field("cmpd", &self.cmpd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cdr {{ cmpd: {=u16:?} }}", self.cmpd())
            }
        }
        #[doc = "Data Compare Match Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dccr(pub u8);
        impl Dccr {
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub const fn dcmf(&self) -> super::vals::Dcmf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dcmf::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub fn set_dcmf(&mut self, val: super::vals::Dcmf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub const fn dper(&self) -> super::vals::Dper {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dper::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub fn set_dper(&mut self, val: super::vals::Dper) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub const fn dfer(&self) -> super::vals::Dfer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dfer::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub fn set_dfer(&mut self, val: super::vals::Dfer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "ID Frame Select"]
            #[inline(always)]
            pub const fn idsel(&self) -> super::vals::Idsel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Idsel::from_bits(val as u8)
            }
            #[doc = "ID Frame Select"]
            #[inline(always)]
            pub fn set_idsel(&mut self, val: super::vals::Idsel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Data Compare Match Enable"]
            #[inline(always)]
            pub const fn dcme(&self) -> super::vals::Dcme {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dcme::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Enable"]
            #[inline(always)]
            pub fn set_dcme(&mut self, val: super::vals::Dcme) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Dccr {
            #[inline(always)]
            fn default() -> Dccr {
                Dccr(0)
            }
        }
        impl core::fmt::Debug for Dccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dccr")
                    .field("dcmf", &self.dcmf())
                    .field("dper", &self.dper())
                    .field("dfer", &self.dfer())
                    .field("idsel", &self.idsel())
                    .field("dcme", &self.dcme())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dccr {{ dcmf: {:?}, dper: {:?}, dfer: {:?}, idsel: {:?}, dcme: {:?} }}",
                    self.dcmf(),
                    self.dper(),
                    self.dfer(),
                    self.idsel(),
                    self.dcme()
                )
            }
        }
        #[doc = "FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fcr(pub u16);
        impl Fcr {
            #[doc = "FIFO Mode Select"]
            #[inline(always)]
            pub const fn fm(&self) -> super::vals::Fm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fm::from_bits(val as u8)
            }
            #[doc = "FIFO Mode Select"]
            #[inline(always)]
            pub fn set_fm(&mut self, val: super::vals::Fm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Receive FIFO Data Register Reset"]
            #[inline(always)]
            pub const fn rfrst(&self) -> super::vals::Rfrst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rfrst::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Data Register Reset"]
            #[inline(always)]
            pub fn set_rfrst(&mut self, val: super::vals::Rfrst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Transmit FIFO Data Register Reset"]
            #[inline(always)]
            pub const fn tfrst(&self) -> super::vals::Tfrst {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tfrst::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Data Register Reset"]
            #[inline(always)]
            pub fn set_tfrst(&mut self, val: super::vals::Tfrst) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Receive Data Ready Error Select"]
            #[inline(always)]
            pub const fn dres(&self) -> super::vals::Dres {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dres::from_bits(val as u8)
            }
            #[doc = "Receive Data Ready Error Select"]
            #[inline(always)]
            pub fn set_dres(&mut self, val: super::vals::Dres) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Transmit FIFO Data Trigger Number"]
            #[inline(always)]
            pub const fn ttrg(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Transmit FIFO Data Trigger Number"]
            #[inline(always)]
            pub fn set_ttrg(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u16) & 0x0f) << 4usize);
            }
            #[doc = "Receive FIFO Data Trigger Number"]
            #[inline(always)]
            pub const fn rtrg(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Receive FIFO Data Trigger Number"]
            #[inline(always)]
            pub fn set_rtrg(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u16) & 0x0f) << 8usize);
            }
            #[doc = "RTS Output Active Trigger Number Select"]
            #[inline(always)]
            pub const fn rstrg(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "RTS Output Active Trigger Number Select"]
            #[inline(always)]
            pub fn set_rstrg(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u16) & 0x0f) << 12usize);
            }
        }
        impl Default for Fcr {
            #[inline(always)]
            fn default() -> Fcr {
                Fcr(0)
            }
        }
        impl core::fmt::Debug for Fcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fcr")
                    .field("fm", &self.fm())
                    .field("rfrst", &self.rfrst())
                    .field("tfrst", &self.tfrst())
                    .field("dres", &self.dres())
                    .field("ttrg", &self.ttrg())
                    .field("rtrg", &self.rtrg())
                    .field("rstrg", &self.rstrg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fcr {{ fm: {:?}, rfrst: {:?}, tfrst: {:?}, dres: {:?}, ttrg: {=u8:?}, rtrg: {=u8:?}, rstrg: {=u8:?} }}" , self . fm () , self . rfrst () , self . tfrst () , self . dres () , self . ttrg () , self . rtrg () , self . rstrg ())
            }
        }
        #[doc = "FIFO Data Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fdr(pub u16);
        impl Fdr {
            #[doc = "Receive FIFO Data Count"]
            #[inline(always)]
            pub const fn r(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Receive FIFO Data Count"]
            #[inline(always)]
            pub fn set_r(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u16) & 0x1f) << 0usize);
            }
            #[doc = "Transmit FIFO Data Count"]
            #[inline(always)]
            pub const fn t(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "Transmit FIFO Data Count"]
            #[inline(always)]
            pub fn set_t(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u16) & 0x1f) << 8usize);
            }
        }
        impl Default for Fdr {
            #[inline(always)]
            fn default() -> Fdr {
                Fdr(0)
            }
        }
        impl core::fmt::Debug for Fdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fdr")
                    .field("r", &self.r())
                    .field("t", &self.t())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fdr {{ r: {=u8:?}, t: {=u8:?} }}", self.r(), self.t())
            }
        }
        #[doc = "Receive FIFO Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frdrh(pub u8);
        impl Frdrh {
            #[doc = "Serial receive data"]
            #[inline(always)]
            pub const fn rdat(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Serial receive data"]
            #[inline(always)]
            pub fn set_rdat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor Bit Flag"]
            #[inline(always)]
            pub const fn mpb(&self) -> super::vals::FrdrhMpb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::FrdrhMpb::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Bit Flag"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: super::vals::FrdrhMpb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Receive Data Ready Flag"]
            #[inline(always)]
            pub const fn dr(&self) -> super::vals::FrdrhDr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::FrdrhDr::from_bits(val as u8)
            }
            #[doc = "Receive Data Ready Flag"]
            #[inline(always)]
            pub fn set_dr(&mut self, val: super::vals::FrdrhDr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::FrdrhPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::FrdrhPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::FrdrhPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::FrdrhFer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::FrdrhFer::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::FrdrhFer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::FrdrhOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::FrdrhOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::FrdrhOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive FIFO Data Full Flag"]
            #[inline(always)]
            pub const fn rdf(&self) -> super::vals::FrdrhRdf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::FrdrhRdf::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Data Full Flag"]
            #[inline(always)]
            pub fn set_rdf(&mut self, val: super::vals::FrdrhRdf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Frdrh {
            #[inline(always)]
            fn default() -> Frdrh {
                Frdrh(0)
            }
        }
        impl core::fmt::Debug for Frdrh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frdrh")
                    .field("rdat", &self.rdat())
                    .field("mpb", &self.mpb())
                    .field("dr", &self.dr())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdf", &self.rdf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frdrh {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Frdrh {{ rdat: {=bool:?}, mpb: {:?}, dr: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdf: {:?} }}" , self . rdat () , self . mpb () , self . dr () , self . per () , self . fer () , self . orer () , self . rdf ())
            }
        }
        #[doc = "Receive FIFO Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frdrhl(pub u16);
        impl Frdrhl {
            #[doc = "Serial receive data"]
            #[inline(always)]
            pub const fn rdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial receive data"]
            #[inline(always)]
            pub fn set_rdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "Multi,Processor Bit Flag"]
            #[inline(always)]
            pub const fn mpb(&self) -> super::vals::FrdrhlMpb {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::FrdrhlMpb::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Bit Flag"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: super::vals::FrdrhlMpb) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Receive Data Ready Flag"]
            #[inline(always)]
            pub const fn dr(&self) -> super::vals::FrdrhlDr {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::FrdrhlDr::from_bits(val as u8)
            }
            #[doc = "Receive Data Ready Flag"]
            #[inline(always)]
            pub fn set_dr(&mut self, val: super::vals::FrdrhlDr) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::FrdrhlPer {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::FrdrhlPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::FrdrhlPer) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::FrdrhlFer {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::FrdrhlFer::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::FrdrhlFer) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::FrdrhlOrer {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::FrdrhlOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::FrdrhlOrer) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Receive FIFO Data Full Flag"]
            #[inline(always)]
            pub const fn rdf(&self) -> super::vals::FrdrhlRdf {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::FrdrhlRdf::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Data Full Flag"]
            #[inline(always)]
            pub fn set_rdf(&mut self, val: super::vals::FrdrhlRdf) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
        }
        impl Default for Frdrhl {
            #[inline(always)]
            fn default() -> Frdrhl {
                Frdrhl(0)
            }
        }
        impl core::fmt::Debug for Frdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frdrhl")
                    .field("rdat", &self.rdat())
                    .field("mpb", &self.mpb())
                    .field("dr", &self.dr())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdf", &self.rdf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Frdrhl {{ rdat: {=u16:?}, mpb: {:?}, dr: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdf: {:?} }}" , self . rdat () , self . mpb () , self . dr () , self . per () , self . fer () , self . orer () , self . rdf ())
            }
        }
        #[doc = "Receive FIFO Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frdrl(pub u8);
        impl Frdrl {
            #[doc = "Serial receive data"]
            #[inline(always)]
            pub const fn rdat(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Serial receive data"]
            #[inline(always)]
            pub fn set_rdat(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Frdrl {
            #[inline(always)]
            fn default() -> Frdrl {
                Frdrl(0)
            }
        }
        impl core::fmt::Debug for Frdrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frdrl").field("rdat", &self.rdat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frdrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frdrl {{ rdat: {=u8:?} }}", self.rdat())
            }
        }
        #[doc = "Transmit FIFO Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ftdrh(pub u8);
        impl Ftdrh {
            #[doc = "Serial transmit data"]
            #[inline(always)]
            pub const fn tdat(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Serial transmit data"]
            #[inline(always)]
            pub fn set_tdat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor Transfer Bit Flag"]
            #[inline(always)]
            pub const fn mpbt(&self) -> super::vals::FtdrhMpbt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::FtdrhMpbt::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Transfer Bit Flag"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: super::vals::FtdrhMpbt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Ftdrh {
            #[inline(always)]
            fn default() -> Ftdrh {
                Ftdrh(0)
            }
        }
        impl core::fmt::Debug for Ftdrh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ftdrh")
                    .field("tdat", &self.tdat())
                    .field("mpbt", &self.mpbt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ftdrh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ftdrh {{ tdat: {=bool:?}, mpbt: {:?} }}",
                    self.tdat(),
                    self.mpbt()
                )
            }
        }
        #[doc = "Transmit FIFO Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ftdrhl(pub u16);
        impl Ftdrhl {
            #[doc = "Serial transmit data"]
            #[inline(always)]
            pub const fn tdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial transmit data"]
            #[inline(always)]
            pub fn set_tdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
            #[doc = "Multi,Processor Transfer Bit Flag"]
            #[inline(always)]
            pub const fn mpbt(&self) -> super::vals::FtdrhlMpbt {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::FtdrhlMpbt::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Transfer Bit Flag"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: super::vals::FtdrhlMpbt) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
        }
        impl Default for Ftdrhl {
            #[inline(always)]
            fn default() -> Ftdrhl {
                Ftdrhl(0)
            }
        }
        impl core::fmt::Debug for Ftdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ftdrhl")
                    .field("tdat", &self.tdat())
                    .field("mpbt", &self.mpbt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ftdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ftdrhl {{ tdat: {=u16:?}, mpbt: {:?} }}",
                    self.tdat(),
                    self.mpbt()
                )
            }
        }
        #[doc = "Transmit FIFO Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ftdrl(pub u8);
        impl Ftdrl {
            #[doc = "Serial transmit data"]
            #[inline(always)]
            pub const fn tdat(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Serial transmit data"]
            #[inline(always)]
            pub fn set_tdat(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ftdrl {
            #[inline(always)]
            fn default() -> Ftdrl {
                Ftdrl(0)
            }
        }
        impl core::fmt::Debug for Ftdrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ftdrl").field("tdat", &self.tdat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ftdrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ftdrl {{ tdat: {=u8:?} }}", self.tdat())
            }
        }
        #[doc = "Line Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsr(pub u16);
        impl Lsr {
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::LsrOrer {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::LsrOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::LsrOrer) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Framing Error Count"]
            #[inline(always)]
            pub const fn fnum(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x1f;
                val as u8
            }
            #[doc = "Framing Error Count"]
            #[inline(always)]
            pub fn set_fnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 2usize)) | (((val as u16) & 0x1f) << 2usize);
            }
            #[doc = "Parity Error Count"]
            #[inline(always)]
            pub const fn pnum(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "Parity Error Count"]
            #[inline(always)]
            pub fn set_pnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u16) & 0x1f) << 8usize);
            }
        }
        impl Default for Lsr {
            #[inline(always)]
            fn default() -> Lsr {
                Lsr(0)
            }
        }
        impl core::fmt::Debug for Lsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsr")
                    .field("orer", &self.orer())
                    .field("fnum", &self.fnum())
                    .field("pnum", &self.pnum())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lsr {{ orer: {:?}, fnum: {=u8:?}, pnum: {=u8:?} }}",
                    self.orer(),
                    self.fnum(),
                    self.pnum()
                )
            }
        }
        #[doc = "Receive Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdrhl(pub u16);
        impl Rdrhl {
            #[doc = "Serial Receive Data"]
            #[inline(always)]
            pub const fn rdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial Receive Data"]
            #[inline(always)]
            pub fn set_rdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
        }
        impl Default for Rdrhl {
            #[inline(always)]
            fn default() -> Rdrhl {
                Rdrhl(0)
            }
        }
        impl core::fmt::Debug for Rdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdrhl").field("rdat", &self.rdat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rdrhl {{ rdat: {=u16:?} }}", self.rdat())
            }
        }
        #[doc = "Smart Card Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scmr(pub u8);
        impl Scmr {
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub const fn smif(&self) -> super::vals::Smif {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smif::from_bits(val as u8)
            }
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub fn set_smif(&mut self, val: super::vals::Smif) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Transmitted/Received Data Invert"]
            #[inline(always)]
            pub const fn sinv(&self) -> super::vals::Sinv {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sinv::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data Invert"]
            #[inline(always)]
            pub fn set_sinv(&mut self, val: super::vals::Sinv) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmitted/Received Data Transfer Direction"]
            #[inline(always)]
            pub const fn sdir(&self) -> super::vals::Sdir {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sdir::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data Transfer Direction"]
            #[inline(always)]
            pub fn set_sdir(&mut self, val: super::vals::Sdir) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Character Length 1"]
            #[inline(always)]
            pub const fn chr1(&self) -> super::vals::Chr1 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Chr1::from_bits(val as u8)
            }
            #[doc = "Character Length 1"]
            #[inline(always)]
            pub fn set_chr1(&mut self, val: super::vals::Chr1) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Base Clock Pulse 2"]
            #[inline(always)]
            pub const fn bcp2(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Base Clock Pulse 2"]
            #[inline(always)]
            pub fn set_bcp2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scmr {
            #[inline(always)]
            fn default() -> Scmr {
                Scmr(0)
            }
        }
        impl core::fmt::Debug for Scmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scmr")
                    .field("smif", &self.smif())
                    .field("sinv", &self.sinv())
                    .field("sdir", &self.sdir())
                    .field("chr1", &self.chr1())
                    .field("bcp2", &self.bcp2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Scmr {{ smif: {:?}, sinv: {:?}, sdir: {:?}, chr1: {:?}, bcp2: {=bool:?} }}",
                    self.smif(),
                    self.sinv(),
                    self.sdir(),
                    self.chr1(),
                    self.bcp2()
                )
            }
        }
        #[doc = "Serial Control Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr(pub u8);
        impl Scr {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> super::vals::Teie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Teie::from_bits(val as u8)
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: super::vals::Teie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub const fn mpie(&self) -> super::vals::Mpie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mpie::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: super::vals::Mpie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scr {
            #[inline(always)]
            fn default() -> Scr {
                Scr(0)
            }
        }
        impl core::fmt::Debug for Scr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scr {{ cke: {:?}, teie: {:?}, mpie: {:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ScrSmci(pub u8);
        impl ScrSmci {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrSmciCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrSmciCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrSmciCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub const fn mpie(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrSmciRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrSmciRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrSmciRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrSmciTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrSmciTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrSmciTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrSmciRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrSmciRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrSmciRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrSmciTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrSmciTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrSmciTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for ScrSmci {
            #[inline(always)]
            fn default() -> ScrSmci {
                ScrSmci(0)
            }
        }
        impl core::fmt::Debug for ScrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ScrSmci")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ScrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ScrSmci {{ cke: {:?}, teie: {=bool:?}, mpie: {=bool:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Extended Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Semr(pub u8);
        impl Semr {
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub const fn brme(&self) -> super::vals::Brme {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Brme::from_bits(val as u8)
            }
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub fn set_brme(&mut self, val: super::vals::Brme) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select 1"]
            #[inline(always)]
            pub const fn abcse(&self) -> super::vals::Abcse {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Abcse::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select 1"]
            #[inline(always)]
            pub fn set_abcse(&mut self, val: super::vals::Abcse) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Asynchronous Mode Base Clock Select"]
            #[inline(always)]
            pub const fn abcs(&self) -> super::vals::Abcs {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Abcs::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Base Clock Select"]
            #[inline(always)]
            pub fn set_abcs(&mut self, val: super::vals::Abcs) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Digital Noise Filter Function Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::Nfen {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Nfen::from_bits(val as u8)
            }
            #[doc = "Digital Noise Filter Function Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::Nfen) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select"]
            #[inline(always)]
            pub const fn bgdm(&self) -> super::vals::Bgdm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Bgdm::from_bits(val as u8)
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select"]
            #[inline(always)]
            pub fn set_bgdm(&mut self, val: super::vals::Bgdm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select"]
            #[inline(always)]
            pub const fn rxdesel(&self) -> super::vals::Rxdesel {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rxdesel::from_bits(val as u8)
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select"]
            #[inline(always)]
            pub fn set_rxdesel(&mut self, val: super::vals::Rxdesel) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Semr {
            #[inline(always)]
            fn default() -> Semr {
                Semr(0)
            }
        }
        impl core::fmt::Debug for Semr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Semr")
                    .field("brme", &self.brme())
                    .field("abcse", &self.abcse())
                    .field("abcs", &self.abcs())
                    .field("nfen", &self.nfen())
                    .field("bgdm", &self.bgdm())
                    .field("rxdesel", &self.rxdesel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Semr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Semr {{ brme: {:?}, abcse: {:?}, abcs: {:?}, nfen: {:?}, bgdm: {:?}, rxdesel: {:?} }}" , self . brme () , self . abcse () , self . abcs () , self . nfen () , self . bgdm () , self . rxdesel ())
            }
        }
        #[doc = "IIC Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr1(pub u8);
        impl Simr1 {
            #[doc = "Simple IIC Mode Select"]
            #[inline(always)]
            pub const fn iicm(&self) -> super::vals::Iicm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicm::from_bits(val as u8)
            }
            #[doc = "Simple IIC Mode Select"]
            #[inline(always)]
            pub fn set_iicm(&mut self, val: super::vals::Iicm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SDAn Delay Output Select"]
            #[inline(always)]
            pub const fn iicdl(&self) -> super::vals::Iicdl {
                let val = (self.0 >> 3usize) & 0x1f;
                super::vals::Iicdl::from_bits(val as u8)
            }
            #[doc = "SDAn Delay Output Select"]
            #[inline(always)]
            pub fn set_iicdl(&mut self, val: super::vals::Iicdl) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val.to_bits() as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Simr1 {
            #[inline(always)]
            fn default() -> Simr1 {
                Simr1(0)
            }
        }
        impl core::fmt::Debug for Simr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr1")
                    .field("iicm", &self.iicm())
                    .field("iicdl", &self.iicdl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Simr1 {{ iicm: {:?}, iicdl: {:?} }}",
                    self.iicm(),
                    self.iicdl()
                )
            }
        }
        #[doc = "IIC Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr2(pub u8);
        impl Simr2 {
            #[doc = "IIC Interrupt Mode Select"]
            #[inline(always)]
            pub const fn iicintm(&self) -> super::vals::Iicintm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicintm::from_bits(val as u8)
            }
            #[doc = "IIC Interrupt Mode Select"]
            #[inline(always)]
            pub fn set_iicintm(&mut self, val: super::vals::Iicintm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub const fn iiccsc(&self) -> super::vals::Iiccsc {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iiccsc::from_bits(val as u8)
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub fn set_iiccsc(&mut self, val: super::vals::Iiccsc) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub const fn iicackt(&self) -> super::vals::Iicackt {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Iicackt::from_bits(val as u8)
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub fn set_iicackt(&mut self, val: super::vals::Iicackt) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Simr2 {
            #[inline(always)]
            fn default() -> Simr2 {
                Simr2(0)
            }
        }
        impl core::fmt::Debug for Simr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr2")
                    .field("iicintm", &self.iicintm())
                    .field("iiccsc", &self.iiccsc())
                    .field("iicackt", &self.iicackt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Simr2 {{ iicintm: {:?}, iiccsc: {:?}, iicackt: {:?} }}",
                    self.iicintm(),
                    self.iiccsc(),
                    self.iicackt()
                )
            }
        }
        #[doc = "IIC Mode Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr3(pub u8);
        impl Simr3 {
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub const fn iicstareq(&self) -> super::vals::Iicstareq {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicstareq::from_bits(val as u8)
            }
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub fn set_iicstareq(&mut self, val: super::vals::Iicstareq) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub const fn iicrstareq(&self) -> super::vals::Iicrstareq {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iicrstareq::from_bits(val as u8)
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub fn set_iicrstareq(&mut self, val: super::vals::Iicrstareq) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub const fn iicstpreq(&self) -> super::vals::Iicstpreq {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Iicstpreq::from_bits(val as u8)
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub fn set_iicstpreq(&mut self, val: super::vals::Iicstpreq) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag"]
            #[inline(always)]
            pub const fn iicstif(&self) -> super::vals::Iicstif {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Iicstif::from_bits(val as u8)
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag"]
            #[inline(always)]
            pub fn set_iicstif(&mut self, val: super::vals::Iicstif) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SDAn Output Select"]
            #[inline(always)]
            pub const fn iicsdas(&self) -> super::vals::Iicsdas {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Iicsdas::from_bits(val as u8)
            }
            #[doc = "SDAn Output Select"]
            #[inline(always)]
            pub fn set_iicsdas(&mut self, val: super::vals::Iicsdas) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "SCLn Output Select"]
            #[inline(always)]
            pub const fn iicscls(&self) -> super::vals::Iicscls {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Iicscls::from_bits(val as u8)
            }
            #[doc = "SCLn Output Select"]
            #[inline(always)]
            pub fn set_iicscls(&mut self, val: super::vals::Iicscls) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Simr3 {
            #[inline(always)]
            fn default() -> Simr3 {
                Simr3(0)
            }
        }
        impl core::fmt::Debug for Simr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr3")
                    .field("iicstareq", &self.iicstareq())
                    .field("iicrstareq", &self.iicrstareq())
                    .field("iicstpreq", &self.iicstpreq())
                    .field("iicstif", &self.iicstif())
                    .field("iicsdas", &self.iicsdas())
                    .field("iicscls", &self.iicscls())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Simr3 {{ iicstareq: {:?}, iicrstareq: {:?}, iicstpreq: {:?}, iicstif: {:?}, iicsdas: {:?}, iicscls: {:?} }}" , self . iicstareq () , self . iicrstareq () , self . iicstpreq () , self . iicstif () , self . iicsdas () , self . iicscls ())
            }
        }
        #[doc = "IIC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sisr(pub u8);
        impl Sisr {
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub const fn iicackr(&self) -> super::vals::Iicackr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicackr::from_bits(val as u8)
            }
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub fn set_iicackr(&mut self, val: super::vals::Iicackr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Sisr {
            #[inline(always)]
            fn default() -> Sisr {
                Sisr(0)
            }
        }
        impl core::fmt::Debug for Sisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sisr")
                    .field("iicackr", &self.iicackr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sisr {{ iicackr: {:?} }}", self.iicackr())
            }
        }
        #[doc = "Serial Mode Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr(pub u8);
        impl Smr {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Multi,Processor Mode"]
            #[inline(always)]
            pub const fn mp(&self) -> super::vals::Mp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mp::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Mode"]
            #[inline(always)]
            pub fn set_mp(&mut self, val: super::vals::Mp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Bit Length"]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::Stop {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Stop::from_bits(val as u8)
            }
            #[doc = "Stop Bit Length"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: super::vals::Stop) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub const fn pe(&self) -> super::vals::Pe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pe::from_bits(val as u8)
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: super::vals::Pe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Character Length"]
            #[inline(always)]
            pub const fn chr(&self) -> super::vals::Chr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Chr::from_bits(val as u8)
            }
            #[doc = "Character Length"]
            #[inline(always)]
            pub fn set_chr(&mut self, val: super::vals::Chr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Communication Mode"]
            #[inline(always)]
            pub const fn cm(&self) -> super::vals::Cm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cm::from_bits(val as u8)
            }
            #[doc = "Communication Mode"]
            #[inline(always)]
            pub fn set_cm(&mut self, val: super::vals::Cm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Smr {
            #[inline(always)]
            fn default() -> Smr {
                Smr(0)
            }
        }
        impl core::fmt::Debug for Smr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr")
                    .field("cks", &self.cks())
                    .field("mp", &self.mp())
                    .field("stop", &self.stop())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("chr", &self.chr())
                    .field("cm", &self.cm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smr {{ cks: {:?}, mp: {:?}, stop: {:?}, pm: {:?}, pe: {:?}, chr: {:?}, cm: {:?} }}" , self . cks () , self . mp () , self . stop () , self . pm () , self . pe () , self . chr () , self . cm ())
            }
        }
        #[doc = "Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SmrSmci(pub u8);
        impl SmrSmci {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrSmciCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrSmciCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrSmciCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub const fn bcp(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub fn set_bcp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrSmciPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrSmciPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrSmciPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub const fn blk(&self) -> super::vals::Blk {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Blk::from_bits(val as u8)
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub fn set_blk(&mut self, val: super::vals::Blk) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub const fn gm(&self) -> super::vals::Gm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Gm::from_bits(val as u8)
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub fn set_gm(&mut self, val: super::vals::Gm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SmrSmci {
            #[inline(always)]
            fn default() -> SmrSmci {
                SmrSmci(0)
            }
        }
        impl core::fmt::Debug for SmrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SmrSmci")
                    .field("cks", &self.cks())
                    .field("bcp", &self.bcp())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("blk", &self.blk())
                    .field("gm", &self.gm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SmrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SmrSmci {{ cks: {:?}, bcp: {=u8:?}, pm: {:?}, pe: {=bool:?}, blk: {:?}, gm: {:?} }}" , self . cks () , self . bcp () , self . pm () , self . pe () , self . blk () , self . gm ())
            }
        }
        #[doc = "Noise Filter Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snfr(pub u8);
        impl Snfr {
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::Nfcs {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Nfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::Nfcs) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Snfr {
            #[inline(always)]
            fn default() -> Snfr {
                Snfr(0)
            }
        }
        impl core::fmt::Debug for Snfr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snfr").field("nfcs", &self.nfcs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snfr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Snfr {{ nfcs: {:?} }}", self.nfcs())
            }
        }
        #[doc = "SPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spmr(pub u8);
        impl Spmr {
            #[doc = "SSn Pin Function Enable"]
            #[inline(always)]
            pub const fn sse(&self) -> super::vals::Sse {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sse::from_bits(val as u8)
            }
            #[doc = "SSn Pin Function Enable"]
            #[inline(always)]
            pub fn set_sse(&mut self, val: super::vals::Sse) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub const fn ctse(&self) -> super::vals::Ctse {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ctse::from_bits(val as u8)
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub fn set_ctse(&mut self, val: super::vals::Ctse) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub const fn mss(&self) -> super::vals::Mss {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mss::from_bits(val as u8)
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub fn set_mss(&mut self, val: super::vals::Mss) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub const fn mff(&self) -> super::vals::Mff {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mff::from_bits(val as u8)
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub fn set_mff(&mut self, val: super::vals::Mff) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub const fn ckpol(&self) -> super::vals::Ckpol {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ckpol::from_bits(val as u8)
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub fn set_ckpol(&mut self, val: super::vals::Ckpol) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub const fn ckph(&self) -> super::vals::Ckph {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ckph::from_bits(val as u8)
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub fn set_ckph(&mut self, val: super::vals::Ckph) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spmr {
            #[inline(always)]
            fn default() -> Spmr {
                Spmr(0)
            }
        }
        impl core::fmt::Debug for Spmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spmr")
                    .field("sse", &self.sse())
                    .field("ctse", &self.ctse())
                    .field("mss", &self.mss())
                    .field("mff", &self.mff())
                    .field("ckpol", &self.ckpol())
                    .field("ckph", &self.ckph())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spmr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spmr {{ sse: {:?}, ctse: {:?}, mss: {:?}, mff: {:?}, ckpol: {:?}, ckph: {:?} }}" , self . sse () , self . ctse () , self . mss () , self . mff () , self . ckpol () , self . ckph ())
            }
        }
        #[doc = "Serial Port Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sptr(pub u8);
        impl Sptr {
            #[doc = "Serial Input Data Monitor"]
            #[inline(always)]
            pub const fn rxdmon(&self) -> super::vals::Rxdmon {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rxdmon::from_bits(val as u8)
            }
            #[doc = "Serial Input Data Monitor"]
            #[inline(always)]
            pub fn set_rxdmon(&mut self, val: super::vals::Rxdmon) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Serial Port Break Data Select"]
            #[inline(always)]
            pub const fn spb2dt(&self) -> super::vals::Spb2dt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spb2dt::from_bits(val as u8)
            }
            #[doc = "Serial Port Break Data Select"]
            #[inline(always)]
            pub fn set_spb2dt(&mut self, val: super::vals::Spb2dt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Serial Port Break I/O"]
            #[inline(always)]
            pub const fn spb2io(&self) -> super::vals::Spb2io {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Spb2io::from_bits(val as u8)
            }
            #[doc = "Serial Port Break I/O"]
            #[inline(always)]
            pub fn set_spb2io(&mut self, val: super::vals::Spb2io) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Sptr {
            #[inline(always)]
            fn default() -> Sptr {
                Sptr(0)
            }
        }
        impl core::fmt::Debug for Sptr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sptr")
                    .field("rxdmon", &self.rxdmon())
                    .field("spb2dt", &self.spb2dt())
                    .field("spb2io", &self.spb2io())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sptr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sptr {{ rxdmon: {:?}, spb2dt: {:?}, spb2io: {:?} }}",
                    self.rxdmon(),
                    self.spb2dt(),
                    self.spb2io()
                )
            }
        }
        #[doc = "Serial Status Register for Non,Smart Card Interface and Non,FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr(pub u8);
        impl Ssr {
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub const fn mpbt(&self) -> super::vals::SsrMpbt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SsrMpbt::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: super::vals::SsrMpbt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub const fn mpb(&self) -> super::vals::SsrMpb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::SsrMpb::from_bits(val as u8)
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: super::vals::SsrMpb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::SsrFer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SsrFer::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::SsrFer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ssr {
            #[inline(always)]
            fn default() -> Ssr {
                Ssr(0)
            }
        }
        impl core::fmt::Debug for Ssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ssr {{ mpbt: {:?}, mpb: {:?}, tend: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . fer () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Serial Status Register for Non,Smart Card Interface and FIFO Mode (SCMR.SMIF = 0, FCR.FM = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SsrFifo(pub u8);
        impl SsrFifo {
            #[doc = "Receive Data Ready Flag"]
            #[inline(always)]
            pub const fn dr(&self) -> super::vals::SsrFifoDr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SsrFifoDr::from_bits(val as u8)
            }
            #[doc = "Receive Data Ready Flag"]
            #[inline(always)]
            pub fn set_dr(&mut self, val: super::vals::SsrFifoDr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrFifoTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrFifoTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrFifoTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrFifoPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrFifoPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrFifoPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::SsrFifoFer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SsrFifoFer::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::SsrFifoFer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrFifoOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrFifoOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrFifoOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive FIFO Data Full Flag"]
            #[inline(always)]
            pub const fn rdf(&self) -> super::vals::SsrFifoRdf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrFifoRdf::from_bits(val as u8)
            }
            #[doc = "Receive FIFO Data Full Flag"]
            #[inline(always)]
            pub fn set_rdf(&mut self, val: super::vals::SsrFifoRdf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Data Empty Flag"]
            #[inline(always)]
            pub const fn tdfe(&self) -> super::vals::Tdfe {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tdfe::from_bits(val as u8)
            }
            #[doc = "Transmit FIFO Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdfe(&mut self, val: super::vals::Tdfe) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SsrFifo {
            #[inline(always)]
            fn default() -> SsrFifo {
                SsrFifo(0)
            }
        }
        impl core::fmt::Debug for SsrFifo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SsrFifo")
                    .field("dr", &self.dr())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdf", &self.rdf())
                    .field("tdfe", &self.tdfe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SsrFifo {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SsrFifo {{ dr: {:?}, tend: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdf: {:?}, tdfe: {:?} }}" , self . dr () , self . tend () , self . per () , self . fer () , self . orer () , self . rdf () , self . tdfe ())
            }
        }
        #[doc = "Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SsrSmci(pub u8);
        impl SsrSmci {
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub const fn mpbt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub const fn mpb(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrSmciTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrSmciTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrSmciTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrSmciPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrSmciPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrSmciPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub const fn ers(&self) -> super::vals::Ers {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ers::from_bits(val as u8)
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub fn set_ers(&mut self, val: super::vals::Ers) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrSmciOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrSmciOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrSmciOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrSmciRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrSmciRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrSmciRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrSmciTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrSmciTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrSmciTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SsrSmci {
            #[inline(always)]
            fn default() -> SsrSmci {
                SsrSmci(0)
            }
        }
        impl core::fmt::Debug for SsrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SsrSmci")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("ers", &self.ers())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SsrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SsrSmci {{ mpbt: {=bool:?}, mpb: {=bool:?}, tend: {:?}, per: {:?}, ers: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . ers () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Transmit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tdrhl(pub u16);
        impl Tdrhl {
            #[doc = "Serial Transmit Data"]
            #[inline(always)]
            pub const fn tdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial Transmit Data"]
            #[inline(always)]
            pub fn set_tdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
        }
        impl Default for Tdrhl {
            #[inline(always)]
            fn default() -> Tdrhl {
                Tdrhl(0)
            }
        }
        impl core::fmt::Debug for Tdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tdrhl").field("tdat", &self.tdat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tdrhl {{ tdat: {=u16:?} }}", self.tdat())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcs {
            #[inline(always)]
            fn from(val: u8) -> Abcs {
                Abcs::from_bits(val)
            }
        }
        impl From<Abcs> for u8 {
            #[inline(always)]
            fn from(val: Abcs) -> u8 {
                Abcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcse {
            #[inline(always)]
            fn from(val: u8) -> Abcse {
                Abcse::from_bits(val)
            }
        }
        impl From<Abcse> for u8 {
            #[inline(always)]
            fn from(val: Abcse) -> u8 {
                Abcse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bgdm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bgdm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bgdm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bgdm {
            #[inline(always)]
            fn from(val: u8) -> Bgdm {
                Bgdm::from_bits(val)
            }
        }
        impl From<Bgdm> for u8 {
            #[inline(always)]
            fn from(val: Bgdm) -> u8 {
                Bgdm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Blk {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Blk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Blk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Blk {
            #[inline(always)]
            fn from(val: u8) -> Blk {
                Blk::from_bits(val)
            }
        }
        impl From<Blk> for u8 {
            #[inline(always)]
            fn from(val: Blk) -> u8 {
                Blk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Brme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brme {
            #[inline(always)]
            fn from(val: u8) -> Brme {
                Brme::from_bits(val)
            }
        }
        impl From<Brme> for u8 {
            #[inline(always)]
            fn from(val: Brme) -> u8 {
                Brme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr {
            #[inline(always)]
            fn from(val: u8) -> Chr {
                Chr::from_bits(val)
            }
        }
        impl From<Chr> for u8 {
            #[inline(always)]
            fn from(val: Chr) -> u8 {
                Chr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr1 {
            #[inline(always)]
            fn from(val: u8) -> Chr1 {
                Chr1::from_bits(val)
            }
        }
        impl From<Chr1> for u8 {
            #[inline(always)]
            fn from(val: Chr1) -> u8 {
                Chr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckph {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckph {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckph {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckph {
            #[inline(always)]
            fn from(val: u8) -> Ckph {
                Ckph::from_bits(val)
            }
        }
        impl From<Ckph> for u8 {
            #[inline(always)]
            fn from(val: Ckph) -> u8 {
                Ckph::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckpol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckpol {
            #[inline(always)]
            fn from(val: u8) -> Ckpol {
                Ckpol::from_bits(val)
            }
        }
        impl From<Ckpol> for u8 {
            #[inline(always)]
            fn from(val: Ckpol) -> u8 {
                Ckpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cm {
            #[inline(always)]
            fn from(val: u8) -> Cm {
                Cm::from_bits(val)
            }
        }
        impl From<Cm> for u8 {
            #[inline(always)]
            fn from(val: Cm) -> u8 {
                Cm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctse {
            #[inline(always)]
            fn from(val: u8) -> Ctse {
                Ctse::from_bits(val)
            }
        }
        impl From<Ctse> for u8 {
            #[inline(always)]
            fn from(val: Ctse) -> u8 {
                Ctse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcme {
            #[inline(always)]
            fn from(val: u8) -> Dcme {
                Dcme::from_bits(val)
            }
        }
        impl From<Dcme> for u8 {
            #[inline(always)]
            fn from(val: Dcme) -> u8 {
                Dcme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcmf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcmf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcmf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcmf {
            #[inline(always)]
            fn from(val: u8) -> Dcmf {
                Dcmf::from_bits(val)
            }
        }
        impl From<Dcmf> for u8 {
            #[inline(always)]
            fn from(val: Dcmf) -> u8 {
                Dcmf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dfer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfer {
            #[inline(always)]
            fn from(val: u8) -> Dfer {
                Dfer::from_bits(val)
            }
        }
        impl From<Dfer> for u8 {
            #[inline(always)]
            fn from(val: Dfer) -> u8 {
                Dfer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dper {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dper {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dper {
            #[inline(always)]
            fn from(val: u8) -> Dper {
                Dper::from_bits(val)
            }
        }
        impl From<Dper> for u8 {
            #[inline(always)]
            fn from(val: Dper) -> u8 {
                Dper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dres {
            #[inline(always)]
            fn from(val: u8) -> Dres {
                Dres::from_bits(val)
            }
        }
        impl From<Dres> for u8 {
            #[inline(always)]
            fn from(val: Dres) -> u8 {
                Dres::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ers {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ers {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ers {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ers {
            #[inline(always)]
            fn from(val: u8) -> Ers {
                Ers::from_bits(val)
            }
        }
        impl From<Ers> for u8 {
            #[inline(always)]
            fn from(val: Ers) -> u8 {
                Ers::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fm {
            #[inline(always)]
            fn from(val: u8) -> Fm {
                Fm::from_bits(val)
            }
        }
        impl From<Fm> for u8 {
            #[inline(always)]
            fn from(val: Fm) -> u8 {
                Fm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhDr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhDr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhDr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhDr {
            #[inline(always)]
            fn from(val: u8) -> FrdrhDr {
                FrdrhDr::from_bits(val)
            }
        }
        impl From<FrdrhDr> for u8 {
            #[inline(always)]
            fn from(val: FrdrhDr) -> u8 {
                FrdrhDr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhFer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhFer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhFer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhFer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhFer {
                FrdrhFer::from_bits(val)
            }
        }
        impl From<FrdrhFer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhFer) -> u8 {
                FrdrhFer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhMpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhMpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhMpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhMpb {
            #[inline(always)]
            fn from(val: u8) -> FrdrhMpb {
                FrdrhMpb::from_bits(val)
            }
        }
        impl From<FrdrhMpb> for u8 {
            #[inline(always)]
            fn from(val: FrdrhMpb) -> u8 {
                FrdrhMpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhOrer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhOrer {
                FrdrhOrer::from_bits(val)
            }
        }
        impl From<FrdrhOrer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhOrer) -> u8 {
                FrdrhOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhPer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhPer {
                FrdrhPer::from_bits(val)
            }
        }
        impl From<FrdrhPer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhPer) -> u8 {
                FrdrhPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhRdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhRdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhRdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhRdf {
            #[inline(always)]
            fn from(val: u8) -> FrdrhRdf {
                FrdrhRdf::from_bits(val)
            }
        }
        impl From<FrdrhRdf> for u8 {
            #[inline(always)]
            fn from(val: FrdrhRdf) -> u8 {
                FrdrhRdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlDr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlDr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlDr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlDr {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlDr {
                FrdrhlDr::from_bits(val)
            }
        }
        impl From<FrdrhlDr> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlDr) -> u8 {
                FrdrhlDr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlFer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlFer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlFer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlFer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlFer {
                FrdrhlFer::from_bits(val)
            }
        }
        impl From<FrdrhlFer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlFer) -> u8 {
                FrdrhlFer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlMpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlMpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlMpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlMpb {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlMpb {
                FrdrhlMpb::from_bits(val)
            }
        }
        impl From<FrdrhlMpb> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlMpb) -> u8 {
                FrdrhlMpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlOrer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlOrer {
                FrdrhlOrer::from_bits(val)
            }
        }
        impl From<FrdrhlOrer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlOrer) -> u8 {
                FrdrhlOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlPer {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlPer {
                FrdrhlPer::from_bits(val)
            }
        }
        impl From<FrdrhlPer> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlPer) -> u8 {
                FrdrhlPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FrdrhlRdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FrdrhlRdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FrdrhlRdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FrdrhlRdf {
            #[inline(always)]
            fn from(val: u8) -> FrdrhlRdf {
                FrdrhlRdf::from_bits(val)
            }
        }
        impl From<FrdrhlRdf> for u8 {
            #[inline(always)]
            fn from(val: FrdrhlRdf) -> u8 {
                FrdrhlRdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FtdrhMpbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FtdrhMpbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FtdrhMpbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FtdrhMpbt {
            #[inline(always)]
            fn from(val: u8) -> FtdrhMpbt {
                FtdrhMpbt::from_bits(val)
            }
        }
        impl From<FtdrhMpbt> for u8 {
            #[inline(always)]
            fn from(val: FtdrhMpbt) -> u8 {
                FtdrhMpbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FtdrhlMpbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FtdrhlMpbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FtdrhlMpbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FtdrhlMpbt {
            #[inline(always)]
            fn from(val: u8) -> FtdrhlMpbt {
                FtdrhlMpbt::from_bits(val)
            }
        }
        impl From<FtdrhlMpbt> for u8 {
            #[inline(always)]
            fn from(val: FtdrhlMpbt) -> u8 {
                FtdrhlMpbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gm {
            #[inline(always)]
            fn from(val: u8) -> Gm {
                Gm::from_bits(val)
            }
        }
        impl From<Gm> for u8 {
            #[inline(always)]
            fn from(val: Gm) -> u8 {
                Gm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idsel {
            #[inline(always)]
            fn from(val: u8) -> Idsel {
                Idsel::from_bits(val)
            }
        }
        impl From<Idsel> for u8 {
            #[inline(always)]
            fn from(val: Idsel) -> u8 {
                Idsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackr {
            #[inline(always)]
            fn from(val: u8) -> Iicackr {
                Iicackr::from_bits(val)
            }
        }
        impl From<Iicackr> for u8 {
            #[inline(always)]
            fn from(val: Iicackr) -> u8 {
                Iicackr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackt {
            #[inline(always)]
            fn from(val: u8) -> Iicackt {
                Iicackt::from_bits(val)
            }
        }
        impl From<Iicackt> for u8 {
            #[inline(always)]
            fn from(val: Iicackt) -> u8 {
                Iicackt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iiccsc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iiccsc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iiccsc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iiccsc {
            #[inline(always)]
            fn from(val: u8) -> Iiccsc {
                Iiccsc::from_bits(val)
            }
        }
        impl From<Iiccsc> for u8 {
            #[inline(always)]
            fn from(val: Iiccsc) -> u8 {
                Iiccsc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicdl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Iicdl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicdl {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicdl {
            #[inline(always)]
            fn from(val: u8) -> Iicdl {
                Iicdl::from_bits(val)
            }
        }
        impl From<Iicdl> for u8 {
            #[inline(always)]
            fn from(val: Iicdl) -> u8 {
                Iicdl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicintm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicintm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicintm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicintm {
            #[inline(always)]
            fn from(val: u8) -> Iicintm {
                Iicintm::from_bits(val)
            }
        }
        impl From<Iicintm> for u8 {
            #[inline(always)]
            fn from(val: Iicintm) -> u8 {
                Iicintm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicm {
            #[inline(always)]
            fn from(val: u8) -> Iicm {
                Iicm::from_bits(val)
            }
        }
        impl From<Iicm> for u8 {
            #[inline(always)]
            fn from(val: Iicm) -> u8 {
                Iicm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicrstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicrstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicrstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicrstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicrstareq {
                Iicrstareq::from_bits(val)
            }
        }
        impl From<Iicrstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicrstareq) -> u8 {
                Iicrstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicscls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicscls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicscls {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicscls {
            #[inline(always)]
            fn from(val: u8) -> Iicscls {
                Iicscls::from_bits(val)
            }
        }
        impl From<Iicscls> for u8 {
            #[inline(always)]
            fn from(val: Iicscls) -> u8 {
                Iicscls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicsdas {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicsdas {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicsdas {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicsdas {
            #[inline(always)]
            fn from(val: u8) -> Iicsdas {
                Iicsdas::from_bits(val)
            }
        }
        impl From<Iicsdas> for u8 {
            #[inline(always)]
            fn from(val: Iicsdas) -> u8 {
                Iicsdas::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicstareq {
                Iicstareq::from_bits(val)
            }
        }
        impl From<Iicstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicstareq) -> u8 {
                Iicstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstif {
            #[inline(always)]
            fn from(val: u8) -> Iicstif {
                Iicstif::from_bits(val)
            }
        }
        impl From<Iicstif> for u8 {
            #[inline(always)]
            fn from(val: Iicstif) -> u8 {
                Iicstif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstpreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstpreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstpreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstpreq {
            #[inline(always)]
            fn from(val: u8) -> Iicstpreq {
                Iicstpreq::from_bits(val)
            }
        }
        impl From<Iicstpreq> for u8 {
            #[inline(always)]
            fn from(val: Iicstpreq) -> u8 {
                Iicstpreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum LsrOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl LsrOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> LsrOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for LsrOrer {
            #[inline(always)]
            fn from(val: u8) -> LsrOrer {
                LsrOrer::from_bits(val)
            }
        }
        impl From<LsrOrer> for u8 {
            #[inline(always)]
            fn from(val: LsrOrer) -> u8 {
                LsrOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mff {
            #[inline(always)]
            fn from(val: u8) -> Mff {
                Mff::from_bits(val)
            }
        }
        impl From<Mff> for u8 {
            #[inline(always)]
            fn from(val: Mff) -> u8 {
                Mff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mp {
            #[inline(always)]
            fn from(val: u8) -> Mp {
                Mp::from_bits(val)
            }
        }
        impl From<Mp> for u8 {
            #[inline(always)]
            fn from(val: Mp) -> u8 {
                Mp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpie {
            #[inline(always)]
            fn from(val: u8) -> Mpie {
                Mpie::from_bits(val)
            }
        }
        impl From<Mpie> for u8 {
            #[inline(always)]
            fn from(val: Mpie) -> u8 {
                Mpie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mss {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mss {
            #[inline(always)]
            fn from(val: u8) -> Mss {
                Mss::from_bits(val)
            }
        }
        impl From<Mss> for u8 {
            #[inline(always)]
            fn from(val: Mss) -> u8 {
                Mss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Nfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcs {
            #[inline(always)]
            fn from(val: u8) -> Nfcs {
                Nfcs::from_bits(val)
            }
        }
        impl From<Nfcs> for u8 {
            #[inline(always)]
            fn from(val: Nfcs) -> u8 {
                Nfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfen {
            #[inline(always)]
            fn from(val: u8) -> Nfen {
                Nfen::from_bits(val)
            }
        }
        impl From<Nfen> for u8 {
            #[inline(always)]
            fn from(val: Nfen) -> u8 {
                Nfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pe {
            #[inline(always)]
            fn from(val: u8) -> Pe {
                Pe::from_bits(val)
            }
        }
        impl From<Pe> for u8 {
            #[inline(always)]
            fn from(val: Pe) -> u8 {
                Pe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rfrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rfrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rfrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rfrst {
            #[inline(always)]
            fn from(val: u8) -> Rfrst {
                Rfrst::from_bits(val)
            }
        }
        impl From<Rfrst> for u8 {
            #[inline(always)]
            fn from(val: Rfrst) -> u8 {
                Rfrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdesel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdesel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdesel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdesel {
            #[inline(always)]
            fn from(val: u8) -> Rxdesel {
                Rxdesel::from_bits(val)
            }
        }
        impl From<Rxdesel> for u8 {
            #[inline(always)]
            fn from(val: Rxdesel) -> u8 {
                Rxdesel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdmon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdmon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdmon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdmon {
            #[inline(always)]
            fn from(val: u8) -> Rxdmon {
                Rxdmon::from_bits(val)
            }
        }
        impl From<Rxdmon> for u8 {
            #[inline(always)]
            fn from(val: Rxdmon) -> u8 {
                Rxdmon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrCke {
            #[inline(always)]
            fn from(val: u8) -> ScrCke {
                ScrCke::from_bits(val)
            }
        }
        impl From<ScrCke> for u8 {
            #[inline(always)]
            fn from(val: ScrCke) -> u8 {
                ScrCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRe {
            #[inline(always)]
            fn from(val: u8) -> ScrRe {
                ScrRe::from_bits(val)
            }
        }
        impl From<ScrRe> for u8 {
            #[inline(always)]
            fn from(val: ScrRe) -> u8 {
                ScrRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRie {
            #[inline(always)]
            fn from(val: u8) -> ScrRie {
                ScrRie::from_bits(val)
            }
        }
        impl From<ScrRie> for u8 {
            #[inline(always)]
            fn from(val: ScrRie) -> u8 {
                ScrRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrSmciCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciCke {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciCke {
                ScrSmciCke::from_bits(val)
            }
        }
        impl From<ScrSmciCke> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciCke) -> u8 {
                ScrSmciCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRe {
                ScrSmciRe::from_bits(val)
            }
        }
        impl From<ScrSmciRe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRe) -> u8 {
                ScrSmciRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRie {
                ScrSmciRie::from_bits(val)
            }
        }
        impl From<ScrSmciRie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRie) -> u8 {
                ScrSmciRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTe {
                ScrSmciTe::from_bits(val)
            }
        }
        impl From<ScrSmciTe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTe) -> u8 {
                ScrSmciTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTie {
                ScrSmciTie::from_bits(val)
            }
        }
        impl From<ScrSmciTie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTie) -> u8 {
                ScrSmciTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTe {
            #[inline(always)]
            fn from(val: u8) -> ScrTe {
                ScrTe::from_bits(val)
            }
        }
        impl From<ScrTe> for u8 {
            #[inline(always)]
            fn from(val: ScrTe) -> u8 {
                ScrTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTie {
            #[inline(always)]
            fn from(val: u8) -> ScrTie {
                ScrTie::from_bits(val)
            }
        }
        impl From<ScrTie> for u8 {
            #[inline(always)]
            fn from(val: ScrTie) -> u8 {
                ScrTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdir {
            #[inline(always)]
            fn from(val: u8) -> Sdir {
                Sdir::from_bits(val)
            }
        }
        impl From<Sdir> for u8 {
            #[inline(always)]
            fn from(val: Sdir) -> u8 {
                Sdir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sinv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sinv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sinv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sinv {
            #[inline(always)]
            fn from(val: u8) -> Sinv {
                Sinv::from_bits(val)
            }
        }
        impl From<Sinv> for u8 {
            #[inline(always)]
            fn from(val: Sinv) -> u8 {
                Sinv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smif {
            #[inline(always)]
            fn from(val: u8) -> Smif {
                Smif::from_bits(val)
            }
        }
        impl From<Smif> for u8 {
            #[inline(always)]
            fn from(val: Smif) -> u8 {
                Smif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrCks {
            #[inline(always)]
            fn from(val: u8) -> SmrCks {
                SmrCks::from_bits(val)
            }
        }
        impl From<SmrCks> for u8 {
            #[inline(always)]
            fn from(val: SmrCks) -> u8 {
                SmrCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrPm {
            #[inline(always)]
            fn from(val: u8) -> SmrPm {
                SmrPm::from_bits(val)
            }
        }
        impl From<SmrPm> for u8 {
            #[inline(always)]
            fn from(val: SmrPm) -> u8 {
                SmrPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrSmciCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciCks {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciCks {
                SmrSmciCks::from_bits(val)
            }
        }
        impl From<SmrSmciCks> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciCks) -> u8 {
                SmrSmciCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrSmciPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciPm {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciPm {
                SmrSmciPm::from_bits(val)
            }
        }
        impl From<SmrSmciPm> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciPm) -> u8 {
                SmrSmciPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb2dt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spb2dt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb2dt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb2dt {
            #[inline(always)]
            fn from(val: u8) -> Spb2dt {
                Spb2dt::from_bits(val)
            }
        }
        impl From<Spb2dt> for u8 {
            #[inline(always)]
            fn from(val: Spb2dt) -> u8 {
                Spb2dt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb2io {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spb2io {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb2io {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb2io {
            #[inline(always)]
            fn from(val: u8) -> Spb2io {
                Spb2io::from_bits(val)
            }
        }
        impl From<Spb2io> for u8 {
            #[inline(always)]
            fn from(val: Spb2io) -> u8 {
                Spb2io::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sse {
            #[inline(always)]
            fn from(val: u8) -> Sse {
                Sse::from_bits(val)
            }
        }
        impl From<Sse> for u8 {
            #[inline(always)]
            fn from(val: Sse) -> u8 {
                Sse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFer {
            #[inline(always)]
            fn from(val: u8) -> SsrFer {
                SsrFer::from_bits(val)
            }
        }
        impl From<SsrFer> for u8 {
            #[inline(always)]
            fn from(val: SsrFer) -> u8 {
                SsrFer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoDr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoDr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoDr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoDr {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoDr {
                SsrFifoDr::from_bits(val)
            }
        }
        impl From<SsrFifoDr> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoDr) -> u8 {
                SsrFifoDr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoFer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoFer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoFer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoFer {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoFer {
                SsrFifoFer::from_bits(val)
            }
        }
        impl From<SsrFifoFer> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoFer) -> u8 {
                SsrFifoFer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoOrer {
                SsrFifoOrer::from_bits(val)
            }
        }
        impl From<SsrFifoOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoOrer) -> u8 {
                SsrFifoOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoPer {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoPer {
                SsrFifoPer::from_bits(val)
            }
        }
        impl From<SsrFifoPer> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoPer) -> u8 {
                SsrFifoPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoRdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoRdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoRdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoRdf {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoRdf {
                SsrFifoRdf::from_bits(val)
            }
        }
        impl From<SsrFifoRdf> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoRdf) -> u8 {
                SsrFifoRdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrFifoTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrFifoTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrFifoTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrFifoTend {
            #[inline(always)]
            fn from(val: u8) -> SsrFifoTend {
                SsrFifoTend::from_bits(val)
            }
        }
        impl From<SsrFifoTend> for u8 {
            #[inline(always)]
            fn from(val: SsrFifoTend) -> u8 {
                SsrFifoTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrMpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrMpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrMpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrMpb {
            #[inline(always)]
            fn from(val: u8) -> SsrMpb {
                SsrMpb::from_bits(val)
            }
        }
        impl From<SsrMpb> for u8 {
            #[inline(always)]
            fn from(val: SsrMpb) -> u8 {
                SsrMpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrMpbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrMpbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrMpbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrMpbt {
            #[inline(always)]
            fn from(val: u8) -> SsrMpbt {
                SsrMpbt::from_bits(val)
            }
        }
        impl From<SsrMpbt> for u8 {
            #[inline(always)]
            fn from(val: SsrMpbt) -> u8 {
                SsrMpbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrOrer {
                SsrOrer::from_bits(val)
            }
        }
        impl From<SsrOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrOrer) -> u8 {
                SsrOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrPer {
            #[inline(always)]
            fn from(val: u8) -> SsrPer {
                SsrPer::from_bits(val)
            }
        }
        impl From<SsrPer> for u8 {
            #[inline(always)]
            fn from(val: SsrPer) -> u8 {
                SsrPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrRdrf {
                SsrRdrf::from_bits(val)
            }
        }
        impl From<SsrRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrRdrf) -> u8 {
                SsrRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciOrer {
                SsrSmciOrer::from_bits(val)
            }
        }
        impl From<SsrSmciOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciOrer) -> u8 {
                SsrSmciOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciPer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciPer {
                SsrSmciPer::from_bits(val)
            }
        }
        impl From<SsrSmciPer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciPer) -> u8 {
                SsrSmciPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciRdrf {
                SsrSmciRdrf::from_bits(val)
            }
        }
        impl From<SsrSmciRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciRdrf) -> u8 {
                SsrSmciRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTdre {
                SsrSmciTdre::from_bits(val)
            }
        }
        impl From<SsrSmciTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTdre) -> u8 {
                SsrSmciTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTend {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTend {
                SsrSmciTend::from_bits(val)
            }
        }
        impl From<SsrSmciTend> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTend) -> u8 {
                SsrSmciTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrTdre {
                SsrTdre::from_bits(val)
            }
        }
        impl From<SsrTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrTdre) -> u8 {
                SsrTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTend {
            #[inline(always)]
            fn from(val: u8) -> SsrTend {
                SsrTend::from_bits(val)
            }
        }
        impl From<SsrTend> for u8 {
            #[inline(always)]
            fn from(val: SsrTend) -> u8 {
                SsrTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stop {
            #[inline(always)]
            fn from(val: u8) -> Stop {
                Stop::from_bits(val)
            }
        }
        impl From<Stop> for u8 {
            #[inline(always)]
            fn from(val: Stop) -> u8 {
                Stop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdfe {
            #[inline(always)]
            fn from(val: u8) -> Tdfe {
                Tdfe::from_bits(val)
            }
        }
        impl From<Tdfe> for u8 {
            #[inline(always)]
            fn from(val: Tdfe) -> u8 {
                Tdfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teie {
            #[inline(always)]
            fn from(val: u8) -> Teie {
                Teie::from_bits(val)
            }
        }
        impl From<Teie> for u8 {
            #[inline(always)]
            fn from(val: Teie) -> u8 {
                Teie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tfrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tfrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tfrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tfrst {
            #[inline(always)]
            fn from(val: u8) -> Tfrst {
                Tfrst::from_bits(val)
            }
        }
        impl From<Tfrst> for u8 {
            #[inline(always)]
            fn from(val: Tfrst) -> u8 {
                Tfrst::to_bits(val)
            }
        }
    }
}
pub mod sci1 {
    #[doc = "Serial Communication Interface 1"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sci1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Sci1 {}
    unsafe impl Sync for Sci1 {}
    impl Sci1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Serial Mode Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn smr(self) -> crate::common::Reg<regs::Smr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn smr_smci(self) -> crate::common::Reg<regs::SmrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Bit Rate Register"]
        #[inline(always)]
        pub const fn brr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Serial Control Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<regs::Scr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn scr_smci(self) -> crate::common::Reg<regs::ScrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Transmit Data Register"]
        #[inline(always)]
        pub const fn tdr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Serial Status Register for Non,Smart Card Interface and Non,FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0)"]
        #[inline(always)]
        pub const fn ssr(self) -> crate::common::Reg<regs::Ssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn ssr_smci(self) -> crate::common::Reg<regs::SsrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Receive Data Register"]
        #[inline(always)]
        pub const fn rdr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "Smart Card Mode Register"]
        #[inline(always)]
        pub const fn scmr(self) -> crate::common::Reg<regs::Scmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Serial Extended Mode Register"]
        #[inline(always)]
        pub const fn semr(self) -> crate::common::Reg<regs::Semr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Noise Filter Setting Register"]
        #[inline(always)]
        pub const fn snfr(self) -> crate::common::Reg<regs::Snfr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "IIC Mode Register 1"]
        #[inline(always)]
        pub const fn simr1(self) -> crate::common::Reg<regs::Simr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "IIC Mode Register 2"]
        #[inline(always)]
        pub const fn simr2(self) -> crate::common::Reg<regs::Simr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "IIC Mode Register 3"]
        #[inline(always)]
        pub const fn simr3(self) -> crate::common::Reg<regs::Simr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "IIC Status Register"]
        #[inline(always)]
        pub const fn sisr(self) -> crate::common::Reg<regs::Sisr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Mode Register"]
        #[inline(always)]
        pub const fn spmr(self) -> crate::common::Reg<regs::Spmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "Transmit Data Register"]
        #[inline(always)]
        pub const fn tdrhl(self) -> crate::common::Reg<regs::Tdrhl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Receive Data Register"]
        #[inline(always)]
        pub const fn rdrhl(self) -> crate::common::Reg<regs::Rdrhl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Modulation Duty Register"]
        #[inline(always)]
        pub const fn mddr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "Data Compare Match Control Register"]
        #[inline(always)]
        pub const fn dccr(self) -> crate::common::Reg<regs::Dccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13usize) as _) }
        }
        #[doc = "Compare Match Data Register"]
        #[inline(always)]
        pub const fn cdr(self) -> crate::common::Reg<regs::Cdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "Serial Port Register"]
        #[inline(always)]
        pub const fn sptr(self) -> crate::common::Reg<regs::Sptr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Compare Match Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cdr(pub u16);
        impl Cdr {
            #[doc = "Compare Match Data"]
            #[inline(always)]
            pub const fn cmpd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Compare Match Data"]
            #[inline(always)]
            pub fn set_cmpd(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
        }
        impl Default for Cdr {
            #[inline(always)]
            fn default() -> Cdr {
                Cdr(0)
            }
        }
        impl core::fmt::Debug for Cdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cdr").field("cmpd", &self.cmpd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cdr {{ cmpd: {=u16:?} }}", self.cmpd())
            }
        }
        #[doc = "Data Compare Match Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dccr(pub u8);
        impl Dccr {
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub const fn dcmf(&self) -> super::vals::Dcmf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dcmf::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub fn set_dcmf(&mut self, val: super::vals::Dcmf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub const fn dper(&self) -> super::vals::Dper {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dper::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub fn set_dper(&mut self, val: super::vals::Dper) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub const fn dfer(&self) -> super::vals::Dfer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dfer::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub fn set_dfer(&mut self, val: super::vals::Dfer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "ID Frame Select"]
            #[inline(always)]
            pub const fn idsel(&self) -> super::vals::Idsel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Idsel::from_bits(val as u8)
            }
            #[doc = "ID Frame Select"]
            #[inline(always)]
            pub fn set_idsel(&mut self, val: super::vals::Idsel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Data Compare Match Enable"]
            #[inline(always)]
            pub const fn dcme(&self) -> super::vals::Dcme {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dcme::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Enable"]
            #[inline(always)]
            pub fn set_dcme(&mut self, val: super::vals::Dcme) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Dccr {
            #[inline(always)]
            fn default() -> Dccr {
                Dccr(0)
            }
        }
        impl core::fmt::Debug for Dccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dccr")
                    .field("dcmf", &self.dcmf())
                    .field("dper", &self.dper())
                    .field("dfer", &self.dfer())
                    .field("idsel", &self.idsel())
                    .field("dcme", &self.dcme())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dccr {{ dcmf: {:?}, dper: {:?}, dfer: {:?}, idsel: {:?}, dcme: {:?} }}",
                    self.dcmf(),
                    self.dper(),
                    self.dfer(),
                    self.idsel(),
                    self.dcme()
                )
            }
        }
        #[doc = "Receive Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdrhl(pub u16);
        impl Rdrhl {
            #[doc = "Serial Receive Data"]
            #[inline(always)]
            pub const fn rdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial Receive Data"]
            #[inline(always)]
            pub fn set_rdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
        }
        impl Default for Rdrhl {
            #[inline(always)]
            fn default() -> Rdrhl {
                Rdrhl(0)
            }
        }
        impl core::fmt::Debug for Rdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdrhl").field("rdat", &self.rdat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rdrhl {{ rdat: {=u16:?} }}", self.rdat())
            }
        }
        #[doc = "Smart Card Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scmr(pub u8);
        impl Scmr {
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub const fn smif(&self) -> super::vals::Smif {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smif::from_bits(val as u8)
            }
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub fn set_smif(&mut self, val: super::vals::Smif) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Transmitted/Received Data Invert"]
            #[inline(always)]
            pub const fn sinv(&self) -> super::vals::Sinv {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sinv::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data Invert"]
            #[inline(always)]
            pub fn set_sinv(&mut self, val: super::vals::Sinv) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmitted/Received Data Transfer Direction"]
            #[inline(always)]
            pub const fn sdir(&self) -> super::vals::Sdir {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sdir::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data Transfer Direction"]
            #[inline(always)]
            pub fn set_sdir(&mut self, val: super::vals::Sdir) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Character Length 1"]
            #[inline(always)]
            pub const fn chr1(&self) -> super::vals::Chr1 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Chr1::from_bits(val as u8)
            }
            #[doc = "Character Length 1"]
            #[inline(always)]
            pub fn set_chr1(&mut self, val: super::vals::Chr1) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Base Clock Pulse 2"]
            #[inline(always)]
            pub const fn bcp2(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Base Clock Pulse 2"]
            #[inline(always)]
            pub fn set_bcp2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scmr {
            #[inline(always)]
            fn default() -> Scmr {
                Scmr(0)
            }
        }
        impl core::fmt::Debug for Scmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scmr")
                    .field("smif", &self.smif())
                    .field("sinv", &self.sinv())
                    .field("sdir", &self.sdir())
                    .field("chr1", &self.chr1())
                    .field("bcp2", &self.bcp2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Scmr {{ smif: {:?}, sinv: {:?}, sdir: {:?}, chr1: {:?}, bcp2: {=bool:?} }}",
                    self.smif(),
                    self.sinv(),
                    self.sdir(),
                    self.chr1(),
                    self.bcp2()
                )
            }
        }
        #[doc = "Serial Control Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr(pub u8);
        impl Scr {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> super::vals::Teie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Teie::from_bits(val as u8)
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: super::vals::Teie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub const fn mpie(&self) -> super::vals::Mpie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mpie::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: super::vals::Mpie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scr {
            #[inline(always)]
            fn default() -> Scr {
                Scr(0)
            }
        }
        impl core::fmt::Debug for Scr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scr {{ cke: {:?}, teie: {:?}, mpie: {:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ScrSmci(pub u8);
        impl ScrSmci {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrSmciCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrSmciCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrSmciCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub const fn mpie(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrSmciRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrSmciRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrSmciRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrSmciTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrSmciTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrSmciTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrSmciRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrSmciRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrSmciRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrSmciTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrSmciTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrSmciTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for ScrSmci {
            #[inline(always)]
            fn default() -> ScrSmci {
                ScrSmci(0)
            }
        }
        impl core::fmt::Debug for ScrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ScrSmci")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ScrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ScrSmci {{ cke: {:?}, teie: {=bool:?}, mpie: {=bool:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Extended Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Semr(pub u8);
        impl Semr {
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub const fn brme(&self) -> super::vals::Brme {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Brme::from_bits(val as u8)
            }
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub fn set_brme(&mut self, val: super::vals::Brme) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select 1"]
            #[inline(always)]
            pub const fn abcse(&self) -> super::vals::Abcse {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Abcse::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select 1"]
            #[inline(always)]
            pub fn set_abcse(&mut self, val: super::vals::Abcse) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Asynchronous Mode Base Clock Select"]
            #[inline(always)]
            pub const fn abcs(&self) -> super::vals::Abcs {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Abcs::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Base Clock Select"]
            #[inline(always)]
            pub fn set_abcs(&mut self, val: super::vals::Abcs) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Digital Noise Filter Function Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::Nfen {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Nfen::from_bits(val as u8)
            }
            #[doc = "Digital Noise Filter Function Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::Nfen) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select"]
            #[inline(always)]
            pub const fn bgdm(&self) -> super::vals::Bgdm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Bgdm::from_bits(val as u8)
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select"]
            #[inline(always)]
            pub fn set_bgdm(&mut self, val: super::vals::Bgdm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select"]
            #[inline(always)]
            pub const fn rxdesel(&self) -> super::vals::Rxdesel {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rxdesel::from_bits(val as u8)
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select"]
            #[inline(always)]
            pub fn set_rxdesel(&mut self, val: super::vals::Rxdesel) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Semr {
            #[inline(always)]
            fn default() -> Semr {
                Semr(0)
            }
        }
        impl core::fmt::Debug for Semr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Semr")
                    .field("brme", &self.brme())
                    .field("abcse", &self.abcse())
                    .field("abcs", &self.abcs())
                    .field("nfen", &self.nfen())
                    .field("bgdm", &self.bgdm())
                    .field("rxdesel", &self.rxdesel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Semr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Semr {{ brme: {:?}, abcse: {:?}, abcs: {:?}, nfen: {:?}, bgdm: {:?}, rxdesel: {:?} }}" , self . brme () , self . abcse () , self . abcs () , self . nfen () , self . bgdm () , self . rxdesel ())
            }
        }
        #[doc = "IIC Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr1(pub u8);
        impl Simr1 {
            #[doc = "Simple IIC Mode Select"]
            #[inline(always)]
            pub const fn iicm(&self) -> super::vals::Iicm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicm::from_bits(val as u8)
            }
            #[doc = "Simple IIC Mode Select"]
            #[inline(always)]
            pub fn set_iicm(&mut self, val: super::vals::Iicm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SDAn Delay Output Select"]
            #[inline(always)]
            pub const fn iicdl(&self) -> super::vals::Iicdl {
                let val = (self.0 >> 3usize) & 0x1f;
                super::vals::Iicdl::from_bits(val as u8)
            }
            #[doc = "SDAn Delay Output Select"]
            #[inline(always)]
            pub fn set_iicdl(&mut self, val: super::vals::Iicdl) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val.to_bits() as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Simr1 {
            #[inline(always)]
            fn default() -> Simr1 {
                Simr1(0)
            }
        }
        impl core::fmt::Debug for Simr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr1")
                    .field("iicm", &self.iicm())
                    .field("iicdl", &self.iicdl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Simr1 {{ iicm: {:?}, iicdl: {:?} }}",
                    self.iicm(),
                    self.iicdl()
                )
            }
        }
        #[doc = "IIC Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr2(pub u8);
        impl Simr2 {
            #[doc = "IIC Interrupt Mode Select"]
            #[inline(always)]
            pub const fn iicintm(&self) -> super::vals::Iicintm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicintm::from_bits(val as u8)
            }
            #[doc = "IIC Interrupt Mode Select"]
            #[inline(always)]
            pub fn set_iicintm(&mut self, val: super::vals::Iicintm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub const fn iiccsc(&self) -> super::vals::Iiccsc {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iiccsc::from_bits(val as u8)
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub fn set_iiccsc(&mut self, val: super::vals::Iiccsc) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub const fn iicackt(&self) -> super::vals::Iicackt {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Iicackt::from_bits(val as u8)
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub fn set_iicackt(&mut self, val: super::vals::Iicackt) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Simr2 {
            #[inline(always)]
            fn default() -> Simr2 {
                Simr2(0)
            }
        }
        impl core::fmt::Debug for Simr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr2")
                    .field("iicintm", &self.iicintm())
                    .field("iiccsc", &self.iiccsc())
                    .field("iicackt", &self.iicackt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Simr2 {{ iicintm: {:?}, iiccsc: {:?}, iicackt: {:?} }}",
                    self.iicintm(),
                    self.iiccsc(),
                    self.iicackt()
                )
            }
        }
        #[doc = "IIC Mode Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr3(pub u8);
        impl Simr3 {
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub const fn iicstareq(&self) -> super::vals::Iicstareq {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicstareq::from_bits(val as u8)
            }
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub fn set_iicstareq(&mut self, val: super::vals::Iicstareq) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub const fn iicrstareq(&self) -> super::vals::Iicrstareq {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iicrstareq::from_bits(val as u8)
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub fn set_iicrstareq(&mut self, val: super::vals::Iicrstareq) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub const fn iicstpreq(&self) -> super::vals::Iicstpreq {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Iicstpreq::from_bits(val as u8)
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub fn set_iicstpreq(&mut self, val: super::vals::Iicstpreq) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag"]
            #[inline(always)]
            pub const fn iicstif(&self) -> super::vals::Iicstif {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Iicstif::from_bits(val as u8)
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag"]
            #[inline(always)]
            pub fn set_iicstif(&mut self, val: super::vals::Iicstif) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SDAn Output Select"]
            #[inline(always)]
            pub const fn iicsdas(&self) -> super::vals::Iicsdas {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Iicsdas::from_bits(val as u8)
            }
            #[doc = "SDAn Output Select"]
            #[inline(always)]
            pub fn set_iicsdas(&mut self, val: super::vals::Iicsdas) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "SCLn Output Select"]
            #[inline(always)]
            pub const fn iicscls(&self) -> super::vals::Iicscls {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Iicscls::from_bits(val as u8)
            }
            #[doc = "SCLn Output Select"]
            #[inline(always)]
            pub fn set_iicscls(&mut self, val: super::vals::Iicscls) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Simr3 {
            #[inline(always)]
            fn default() -> Simr3 {
                Simr3(0)
            }
        }
        impl core::fmt::Debug for Simr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr3")
                    .field("iicstareq", &self.iicstareq())
                    .field("iicrstareq", &self.iicrstareq())
                    .field("iicstpreq", &self.iicstpreq())
                    .field("iicstif", &self.iicstif())
                    .field("iicsdas", &self.iicsdas())
                    .field("iicscls", &self.iicscls())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Simr3 {{ iicstareq: {:?}, iicrstareq: {:?}, iicstpreq: {:?}, iicstif: {:?}, iicsdas: {:?}, iicscls: {:?} }}" , self . iicstareq () , self . iicrstareq () , self . iicstpreq () , self . iicstif () , self . iicsdas () , self . iicscls ())
            }
        }
        #[doc = "IIC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sisr(pub u8);
        impl Sisr {
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub const fn iicackr(&self) -> super::vals::Iicackr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicackr::from_bits(val as u8)
            }
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub fn set_iicackr(&mut self, val: super::vals::Iicackr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Sisr {
            #[inline(always)]
            fn default() -> Sisr {
                Sisr(0)
            }
        }
        impl core::fmt::Debug for Sisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sisr")
                    .field("iicackr", &self.iicackr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sisr {{ iicackr: {:?} }}", self.iicackr())
            }
        }
        #[doc = "Serial Mode Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr(pub u8);
        impl Smr {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Multi,Processor Mode"]
            #[inline(always)]
            pub const fn mp(&self) -> super::vals::Mp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mp::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Mode"]
            #[inline(always)]
            pub fn set_mp(&mut self, val: super::vals::Mp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Bit Length"]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::Stop {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Stop::from_bits(val as u8)
            }
            #[doc = "Stop Bit Length"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: super::vals::Stop) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub const fn pe(&self) -> super::vals::Pe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pe::from_bits(val as u8)
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: super::vals::Pe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Character Length"]
            #[inline(always)]
            pub const fn chr(&self) -> super::vals::Chr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Chr::from_bits(val as u8)
            }
            #[doc = "Character Length"]
            #[inline(always)]
            pub fn set_chr(&mut self, val: super::vals::Chr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Communication Mode"]
            #[inline(always)]
            pub const fn cm(&self) -> super::vals::Cm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cm::from_bits(val as u8)
            }
            #[doc = "Communication Mode"]
            #[inline(always)]
            pub fn set_cm(&mut self, val: super::vals::Cm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Smr {
            #[inline(always)]
            fn default() -> Smr {
                Smr(0)
            }
        }
        impl core::fmt::Debug for Smr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr")
                    .field("cks", &self.cks())
                    .field("mp", &self.mp())
                    .field("stop", &self.stop())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("chr", &self.chr())
                    .field("cm", &self.cm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smr {{ cks: {:?}, mp: {:?}, stop: {:?}, pm: {:?}, pe: {:?}, chr: {:?}, cm: {:?} }}" , self . cks () , self . mp () , self . stop () , self . pm () , self . pe () , self . chr () , self . cm ())
            }
        }
        #[doc = "Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SmrSmci(pub u8);
        impl SmrSmci {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrSmciCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrSmciCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrSmciCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub const fn bcp(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub fn set_bcp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrSmciPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrSmciPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrSmciPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub const fn blk(&self) -> super::vals::Blk {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Blk::from_bits(val as u8)
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub fn set_blk(&mut self, val: super::vals::Blk) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub const fn gm(&self) -> super::vals::Gm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Gm::from_bits(val as u8)
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub fn set_gm(&mut self, val: super::vals::Gm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SmrSmci {
            #[inline(always)]
            fn default() -> SmrSmci {
                SmrSmci(0)
            }
        }
        impl core::fmt::Debug for SmrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SmrSmci")
                    .field("cks", &self.cks())
                    .field("bcp", &self.bcp())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("blk", &self.blk())
                    .field("gm", &self.gm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SmrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SmrSmci {{ cks: {:?}, bcp: {=u8:?}, pm: {:?}, pe: {=bool:?}, blk: {:?}, gm: {:?} }}" , self . cks () , self . bcp () , self . pm () , self . pe () , self . blk () , self . gm ())
            }
        }
        #[doc = "Noise Filter Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snfr(pub u8);
        impl Snfr {
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::Nfcs {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Nfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::Nfcs) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Snfr {
            #[inline(always)]
            fn default() -> Snfr {
                Snfr(0)
            }
        }
        impl core::fmt::Debug for Snfr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snfr").field("nfcs", &self.nfcs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snfr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Snfr {{ nfcs: {:?} }}", self.nfcs())
            }
        }
        #[doc = "SPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spmr(pub u8);
        impl Spmr {
            #[doc = "SSn Pin Function Enable"]
            #[inline(always)]
            pub const fn sse(&self) -> super::vals::Sse {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sse::from_bits(val as u8)
            }
            #[doc = "SSn Pin Function Enable"]
            #[inline(always)]
            pub fn set_sse(&mut self, val: super::vals::Sse) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub const fn ctse(&self) -> super::vals::Ctse {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ctse::from_bits(val as u8)
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub fn set_ctse(&mut self, val: super::vals::Ctse) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub const fn mss(&self) -> super::vals::Mss {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mss::from_bits(val as u8)
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub fn set_mss(&mut self, val: super::vals::Mss) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub const fn mff(&self) -> super::vals::Mff {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mff::from_bits(val as u8)
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub fn set_mff(&mut self, val: super::vals::Mff) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub const fn ckpol(&self) -> super::vals::Ckpol {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ckpol::from_bits(val as u8)
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub fn set_ckpol(&mut self, val: super::vals::Ckpol) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub const fn ckph(&self) -> super::vals::Ckph {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ckph::from_bits(val as u8)
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub fn set_ckph(&mut self, val: super::vals::Ckph) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spmr {
            #[inline(always)]
            fn default() -> Spmr {
                Spmr(0)
            }
        }
        impl core::fmt::Debug for Spmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spmr")
                    .field("sse", &self.sse())
                    .field("ctse", &self.ctse())
                    .field("mss", &self.mss())
                    .field("mff", &self.mff())
                    .field("ckpol", &self.ckpol())
                    .field("ckph", &self.ckph())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spmr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spmr {{ sse: {:?}, ctse: {:?}, mss: {:?}, mff: {:?}, ckpol: {:?}, ckph: {:?} }}" , self . sse () , self . ctse () , self . mss () , self . mff () , self . ckpol () , self . ckph ())
            }
        }
        #[doc = "Serial Port Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sptr(pub u8);
        impl Sptr {
            #[doc = "Serial Input Data Monitor"]
            #[inline(always)]
            pub const fn rxdmon(&self) -> super::vals::Rxdmon {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rxdmon::from_bits(val as u8)
            }
            #[doc = "Serial Input Data Monitor"]
            #[inline(always)]
            pub fn set_rxdmon(&mut self, val: super::vals::Rxdmon) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Serial Port Break Data Select"]
            #[inline(always)]
            pub const fn spb2dt(&self) -> super::vals::Spb2dt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spb2dt::from_bits(val as u8)
            }
            #[doc = "Serial Port Break Data Select"]
            #[inline(always)]
            pub fn set_spb2dt(&mut self, val: super::vals::Spb2dt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Serial Port Break I/O"]
            #[inline(always)]
            pub const fn spb2io(&self) -> super::vals::Spb2io {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Spb2io::from_bits(val as u8)
            }
            #[doc = "Serial Port Break I/O"]
            #[inline(always)]
            pub fn set_spb2io(&mut self, val: super::vals::Spb2io) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Sptr {
            #[inline(always)]
            fn default() -> Sptr {
                Sptr(0)
            }
        }
        impl core::fmt::Debug for Sptr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sptr")
                    .field("rxdmon", &self.rxdmon())
                    .field("spb2dt", &self.spb2dt())
                    .field("spb2io", &self.spb2io())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sptr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sptr {{ rxdmon: {:?}, spb2dt: {:?}, spb2io: {:?} }}",
                    self.rxdmon(),
                    self.spb2dt(),
                    self.spb2io()
                )
            }
        }
        #[doc = "Serial Status Register for Non,Smart Card Interface and Non,FIFO Mode (SCMR.SMIF = 0, FCR.FM = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr(pub u8);
        impl Ssr {
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub const fn mpbt(&self) -> super::vals::Mpbt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mpbt::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: super::vals::Mpbt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub const fn mpb(&self) -> super::vals::Mpb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mpb::from_bits(val as u8)
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: super::vals::Mpb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::Fer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Fer::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::Fer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ssr {
            #[inline(always)]
            fn default() -> Ssr {
                Ssr(0)
            }
        }
        impl core::fmt::Debug for Ssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ssr {{ mpbt: {:?}, mpb: {:?}, tend: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . fer () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SsrSmci(pub u8);
        impl SsrSmci {
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub const fn mpbt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub const fn mpb(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrSmciTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrSmciTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrSmciTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrSmciPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrSmciPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrSmciPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub const fn ers(&self) -> super::vals::Ers {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ers::from_bits(val as u8)
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub fn set_ers(&mut self, val: super::vals::Ers) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrSmciOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrSmciOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrSmciOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrSmciRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrSmciRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrSmciRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrSmciTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrSmciTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrSmciTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SsrSmci {
            #[inline(always)]
            fn default() -> SsrSmci {
                SsrSmci(0)
            }
        }
        impl core::fmt::Debug for SsrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SsrSmci")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("ers", &self.ers())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SsrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SsrSmci {{ mpbt: {=bool:?}, mpb: {=bool:?}, tend: {:?}, per: {:?}, ers: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . ers () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Transmit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tdrhl(pub u16);
        impl Tdrhl {
            #[doc = "Serial Transmit Data"]
            #[inline(always)]
            pub const fn tdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial Transmit Data"]
            #[inline(always)]
            pub fn set_tdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
        }
        impl Default for Tdrhl {
            #[inline(always)]
            fn default() -> Tdrhl {
                Tdrhl(0)
            }
        }
        impl core::fmt::Debug for Tdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tdrhl").field("tdat", &self.tdat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tdrhl {{ tdat: {=u16:?} }}", self.tdat())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcs {
            #[inline(always)]
            fn from(val: u8) -> Abcs {
                Abcs::from_bits(val)
            }
        }
        impl From<Abcs> for u8 {
            #[inline(always)]
            fn from(val: Abcs) -> u8 {
                Abcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcse {
            #[inline(always)]
            fn from(val: u8) -> Abcse {
                Abcse::from_bits(val)
            }
        }
        impl From<Abcse> for u8 {
            #[inline(always)]
            fn from(val: Abcse) -> u8 {
                Abcse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bgdm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bgdm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bgdm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bgdm {
            #[inline(always)]
            fn from(val: u8) -> Bgdm {
                Bgdm::from_bits(val)
            }
        }
        impl From<Bgdm> for u8 {
            #[inline(always)]
            fn from(val: Bgdm) -> u8 {
                Bgdm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Blk {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Blk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Blk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Blk {
            #[inline(always)]
            fn from(val: u8) -> Blk {
                Blk::from_bits(val)
            }
        }
        impl From<Blk> for u8 {
            #[inline(always)]
            fn from(val: Blk) -> u8 {
                Blk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Brme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brme {
            #[inline(always)]
            fn from(val: u8) -> Brme {
                Brme::from_bits(val)
            }
        }
        impl From<Brme> for u8 {
            #[inline(always)]
            fn from(val: Brme) -> u8 {
                Brme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr {
            #[inline(always)]
            fn from(val: u8) -> Chr {
                Chr::from_bits(val)
            }
        }
        impl From<Chr> for u8 {
            #[inline(always)]
            fn from(val: Chr) -> u8 {
                Chr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr1 {
            #[inline(always)]
            fn from(val: u8) -> Chr1 {
                Chr1::from_bits(val)
            }
        }
        impl From<Chr1> for u8 {
            #[inline(always)]
            fn from(val: Chr1) -> u8 {
                Chr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckph {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckph {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckph {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckph {
            #[inline(always)]
            fn from(val: u8) -> Ckph {
                Ckph::from_bits(val)
            }
        }
        impl From<Ckph> for u8 {
            #[inline(always)]
            fn from(val: Ckph) -> u8 {
                Ckph::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckpol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckpol {
            #[inline(always)]
            fn from(val: u8) -> Ckpol {
                Ckpol::from_bits(val)
            }
        }
        impl From<Ckpol> for u8 {
            #[inline(always)]
            fn from(val: Ckpol) -> u8 {
                Ckpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cm {
            #[inline(always)]
            fn from(val: u8) -> Cm {
                Cm::from_bits(val)
            }
        }
        impl From<Cm> for u8 {
            #[inline(always)]
            fn from(val: Cm) -> u8 {
                Cm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctse {
            #[inline(always)]
            fn from(val: u8) -> Ctse {
                Ctse::from_bits(val)
            }
        }
        impl From<Ctse> for u8 {
            #[inline(always)]
            fn from(val: Ctse) -> u8 {
                Ctse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcme {
            #[inline(always)]
            fn from(val: u8) -> Dcme {
                Dcme::from_bits(val)
            }
        }
        impl From<Dcme> for u8 {
            #[inline(always)]
            fn from(val: Dcme) -> u8 {
                Dcme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcmf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcmf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcmf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcmf {
            #[inline(always)]
            fn from(val: u8) -> Dcmf {
                Dcmf::from_bits(val)
            }
        }
        impl From<Dcmf> for u8 {
            #[inline(always)]
            fn from(val: Dcmf) -> u8 {
                Dcmf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dfer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfer {
            #[inline(always)]
            fn from(val: u8) -> Dfer {
                Dfer::from_bits(val)
            }
        }
        impl From<Dfer> for u8 {
            #[inline(always)]
            fn from(val: Dfer) -> u8 {
                Dfer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dper {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dper {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dper {
            #[inline(always)]
            fn from(val: u8) -> Dper {
                Dper::from_bits(val)
            }
        }
        impl From<Dper> for u8 {
            #[inline(always)]
            fn from(val: Dper) -> u8 {
                Dper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ers {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ers {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ers {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ers {
            #[inline(always)]
            fn from(val: u8) -> Ers {
                Ers::from_bits(val)
            }
        }
        impl From<Ers> for u8 {
            #[inline(always)]
            fn from(val: Ers) -> u8 {
                Ers::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fer {
            #[inline(always)]
            fn from(val: u8) -> Fer {
                Fer::from_bits(val)
            }
        }
        impl From<Fer> for u8 {
            #[inline(always)]
            fn from(val: Fer) -> u8 {
                Fer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gm {
            #[inline(always)]
            fn from(val: u8) -> Gm {
                Gm::from_bits(val)
            }
        }
        impl From<Gm> for u8 {
            #[inline(always)]
            fn from(val: Gm) -> u8 {
                Gm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idsel {
            #[inline(always)]
            fn from(val: u8) -> Idsel {
                Idsel::from_bits(val)
            }
        }
        impl From<Idsel> for u8 {
            #[inline(always)]
            fn from(val: Idsel) -> u8 {
                Idsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackr {
            #[inline(always)]
            fn from(val: u8) -> Iicackr {
                Iicackr::from_bits(val)
            }
        }
        impl From<Iicackr> for u8 {
            #[inline(always)]
            fn from(val: Iicackr) -> u8 {
                Iicackr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackt {
            #[inline(always)]
            fn from(val: u8) -> Iicackt {
                Iicackt::from_bits(val)
            }
        }
        impl From<Iicackt> for u8 {
            #[inline(always)]
            fn from(val: Iicackt) -> u8 {
                Iicackt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iiccsc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iiccsc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iiccsc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iiccsc {
            #[inline(always)]
            fn from(val: u8) -> Iiccsc {
                Iiccsc::from_bits(val)
            }
        }
        impl From<Iiccsc> for u8 {
            #[inline(always)]
            fn from(val: Iiccsc) -> u8 {
                Iiccsc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicdl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Iicdl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicdl {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicdl {
            #[inline(always)]
            fn from(val: u8) -> Iicdl {
                Iicdl::from_bits(val)
            }
        }
        impl From<Iicdl> for u8 {
            #[inline(always)]
            fn from(val: Iicdl) -> u8 {
                Iicdl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicintm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicintm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicintm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicintm {
            #[inline(always)]
            fn from(val: u8) -> Iicintm {
                Iicintm::from_bits(val)
            }
        }
        impl From<Iicintm> for u8 {
            #[inline(always)]
            fn from(val: Iicintm) -> u8 {
                Iicintm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicm {
            #[inline(always)]
            fn from(val: u8) -> Iicm {
                Iicm::from_bits(val)
            }
        }
        impl From<Iicm> for u8 {
            #[inline(always)]
            fn from(val: Iicm) -> u8 {
                Iicm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicrstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicrstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicrstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicrstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicrstareq {
                Iicrstareq::from_bits(val)
            }
        }
        impl From<Iicrstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicrstareq) -> u8 {
                Iicrstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicscls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicscls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicscls {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicscls {
            #[inline(always)]
            fn from(val: u8) -> Iicscls {
                Iicscls::from_bits(val)
            }
        }
        impl From<Iicscls> for u8 {
            #[inline(always)]
            fn from(val: Iicscls) -> u8 {
                Iicscls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicsdas {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicsdas {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicsdas {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicsdas {
            #[inline(always)]
            fn from(val: u8) -> Iicsdas {
                Iicsdas::from_bits(val)
            }
        }
        impl From<Iicsdas> for u8 {
            #[inline(always)]
            fn from(val: Iicsdas) -> u8 {
                Iicsdas::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicstareq {
                Iicstareq::from_bits(val)
            }
        }
        impl From<Iicstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicstareq) -> u8 {
                Iicstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstif {
            #[inline(always)]
            fn from(val: u8) -> Iicstif {
                Iicstif::from_bits(val)
            }
        }
        impl From<Iicstif> for u8 {
            #[inline(always)]
            fn from(val: Iicstif) -> u8 {
                Iicstif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstpreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstpreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstpreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstpreq {
            #[inline(always)]
            fn from(val: u8) -> Iicstpreq {
                Iicstpreq::from_bits(val)
            }
        }
        impl From<Iicstpreq> for u8 {
            #[inline(always)]
            fn from(val: Iicstpreq) -> u8 {
                Iicstpreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mff {
            #[inline(always)]
            fn from(val: u8) -> Mff {
                Mff::from_bits(val)
            }
        }
        impl From<Mff> for u8 {
            #[inline(always)]
            fn from(val: Mff) -> u8 {
                Mff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mp {
            #[inline(always)]
            fn from(val: u8) -> Mp {
                Mp::from_bits(val)
            }
        }
        impl From<Mp> for u8 {
            #[inline(always)]
            fn from(val: Mp) -> u8 {
                Mp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpb {
            #[inline(always)]
            fn from(val: u8) -> Mpb {
                Mpb::from_bits(val)
            }
        }
        impl From<Mpb> for u8 {
            #[inline(always)]
            fn from(val: Mpb) -> u8 {
                Mpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpbt {
            #[inline(always)]
            fn from(val: u8) -> Mpbt {
                Mpbt::from_bits(val)
            }
        }
        impl From<Mpbt> for u8 {
            #[inline(always)]
            fn from(val: Mpbt) -> u8 {
                Mpbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpie {
            #[inline(always)]
            fn from(val: u8) -> Mpie {
                Mpie::from_bits(val)
            }
        }
        impl From<Mpie> for u8 {
            #[inline(always)]
            fn from(val: Mpie) -> u8 {
                Mpie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mss {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mss {
            #[inline(always)]
            fn from(val: u8) -> Mss {
                Mss::from_bits(val)
            }
        }
        impl From<Mss> for u8 {
            #[inline(always)]
            fn from(val: Mss) -> u8 {
                Mss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Nfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcs {
            #[inline(always)]
            fn from(val: u8) -> Nfcs {
                Nfcs::from_bits(val)
            }
        }
        impl From<Nfcs> for u8 {
            #[inline(always)]
            fn from(val: Nfcs) -> u8 {
                Nfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfen {
            #[inline(always)]
            fn from(val: u8) -> Nfen {
                Nfen::from_bits(val)
            }
        }
        impl From<Nfen> for u8 {
            #[inline(always)]
            fn from(val: Nfen) -> u8 {
                Nfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pe {
            #[inline(always)]
            fn from(val: u8) -> Pe {
                Pe::from_bits(val)
            }
        }
        impl From<Pe> for u8 {
            #[inline(always)]
            fn from(val: Pe) -> u8 {
                Pe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdesel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdesel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdesel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdesel {
            #[inline(always)]
            fn from(val: u8) -> Rxdesel {
                Rxdesel::from_bits(val)
            }
        }
        impl From<Rxdesel> for u8 {
            #[inline(always)]
            fn from(val: Rxdesel) -> u8 {
                Rxdesel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdmon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdmon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdmon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdmon {
            #[inline(always)]
            fn from(val: u8) -> Rxdmon {
                Rxdmon::from_bits(val)
            }
        }
        impl From<Rxdmon> for u8 {
            #[inline(always)]
            fn from(val: Rxdmon) -> u8 {
                Rxdmon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrCke {
            #[inline(always)]
            fn from(val: u8) -> ScrCke {
                ScrCke::from_bits(val)
            }
        }
        impl From<ScrCke> for u8 {
            #[inline(always)]
            fn from(val: ScrCke) -> u8 {
                ScrCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRe {
            #[inline(always)]
            fn from(val: u8) -> ScrRe {
                ScrRe::from_bits(val)
            }
        }
        impl From<ScrRe> for u8 {
            #[inline(always)]
            fn from(val: ScrRe) -> u8 {
                ScrRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRie {
            #[inline(always)]
            fn from(val: u8) -> ScrRie {
                ScrRie::from_bits(val)
            }
        }
        impl From<ScrRie> for u8 {
            #[inline(always)]
            fn from(val: ScrRie) -> u8 {
                ScrRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrSmciCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciCke {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciCke {
                ScrSmciCke::from_bits(val)
            }
        }
        impl From<ScrSmciCke> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciCke) -> u8 {
                ScrSmciCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRe {
                ScrSmciRe::from_bits(val)
            }
        }
        impl From<ScrSmciRe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRe) -> u8 {
                ScrSmciRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRie {
                ScrSmciRie::from_bits(val)
            }
        }
        impl From<ScrSmciRie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRie) -> u8 {
                ScrSmciRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTe {
                ScrSmciTe::from_bits(val)
            }
        }
        impl From<ScrSmciTe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTe) -> u8 {
                ScrSmciTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTie {
                ScrSmciTie::from_bits(val)
            }
        }
        impl From<ScrSmciTie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTie) -> u8 {
                ScrSmciTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTe {
            #[inline(always)]
            fn from(val: u8) -> ScrTe {
                ScrTe::from_bits(val)
            }
        }
        impl From<ScrTe> for u8 {
            #[inline(always)]
            fn from(val: ScrTe) -> u8 {
                ScrTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTie {
            #[inline(always)]
            fn from(val: u8) -> ScrTie {
                ScrTie::from_bits(val)
            }
        }
        impl From<ScrTie> for u8 {
            #[inline(always)]
            fn from(val: ScrTie) -> u8 {
                ScrTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdir {
            #[inline(always)]
            fn from(val: u8) -> Sdir {
                Sdir::from_bits(val)
            }
        }
        impl From<Sdir> for u8 {
            #[inline(always)]
            fn from(val: Sdir) -> u8 {
                Sdir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sinv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sinv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sinv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sinv {
            #[inline(always)]
            fn from(val: u8) -> Sinv {
                Sinv::from_bits(val)
            }
        }
        impl From<Sinv> for u8 {
            #[inline(always)]
            fn from(val: Sinv) -> u8 {
                Sinv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smif {
            #[inline(always)]
            fn from(val: u8) -> Smif {
                Smif::from_bits(val)
            }
        }
        impl From<Smif> for u8 {
            #[inline(always)]
            fn from(val: Smif) -> u8 {
                Smif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrCks {
            #[inline(always)]
            fn from(val: u8) -> SmrCks {
                SmrCks::from_bits(val)
            }
        }
        impl From<SmrCks> for u8 {
            #[inline(always)]
            fn from(val: SmrCks) -> u8 {
                SmrCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrPm {
            #[inline(always)]
            fn from(val: u8) -> SmrPm {
                SmrPm::from_bits(val)
            }
        }
        impl From<SmrPm> for u8 {
            #[inline(always)]
            fn from(val: SmrPm) -> u8 {
                SmrPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrSmciCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciCks {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciCks {
                SmrSmciCks::from_bits(val)
            }
        }
        impl From<SmrSmciCks> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciCks) -> u8 {
                SmrSmciCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrSmciPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciPm {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciPm {
                SmrSmciPm::from_bits(val)
            }
        }
        impl From<SmrSmciPm> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciPm) -> u8 {
                SmrSmciPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb2dt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spb2dt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb2dt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb2dt {
            #[inline(always)]
            fn from(val: u8) -> Spb2dt {
                Spb2dt::from_bits(val)
            }
        }
        impl From<Spb2dt> for u8 {
            #[inline(always)]
            fn from(val: Spb2dt) -> u8 {
                Spb2dt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb2io {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spb2io {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb2io {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb2io {
            #[inline(always)]
            fn from(val: u8) -> Spb2io {
                Spb2io::from_bits(val)
            }
        }
        impl From<Spb2io> for u8 {
            #[inline(always)]
            fn from(val: Spb2io) -> u8 {
                Spb2io::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sse {
            #[inline(always)]
            fn from(val: u8) -> Sse {
                Sse::from_bits(val)
            }
        }
        impl From<Sse> for u8 {
            #[inline(always)]
            fn from(val: Sse) -> u8 {
                Sse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrOrer {
                SsrOrer::from_bits(val)
            }
        }
        impl From<SsrOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrOrer) -> u8 {
                SsrOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrPer {
            #[inline(always)]
            fn from(val: u8) -> SsrPer {
                SsrPer::from_bits(val)
            }
        }
        impl From<SsrPer> for u8 {
            #[inline(always)]
            fn from(val: SsrPer) -> u8 {
                SsrPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrRdrf {
                SsrRdrf::from_bits(val)
            }
        }
        impl From<SsrRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrRdrf) -> u8 {
                SsrRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciOrer {
                SsrSmciOrer::from_bits(val)
            }
        }
        impl From<SsrSmciOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciOrer) -> u8 {
                SsrSmciOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciPer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciPer {
                SsrSmciPer::from_bits(val)
            }
        }
        impl From<SsrSmciPer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciPer) -> u8 {
                SsrSmciPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciRdrf {
                SsrSmciRdrf::from_bits(val)
            }
        }
        impl From<SsrSmciRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciRdrf) -> u8 {
                SsrSmciRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTdre {
                SsrSmciTdre::from_bits(val)
            }
        }
        impl From<SsrSmciTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTdre) -> u8 {
                SsrSmciTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTend {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTend {
                SsrSmciTend::from_bits(val)
            }
        }
        impl From<SsrSmciTend> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTend) -> u8 {
                SsrSmciTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrTdre {
                SsrTdre::from_bits(val)
            }
        }
        impl From<SsrTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrTdre) -> u8 {
                SsrTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTend {
            #[inline(always)]
            fn from(val: u8) -> SsrTend {
                SsrTend::from_bits(val)
            }
        }
        impl From<SsrTend> for u8 {
            #[inline(always)]
            fn from(val: SsrTend) -> u8 {
                SsrTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stop {
            #[inline(always)]
            fn from(val: u8) -> Stop {
                Stop::from_bits(val)
            }
        }
        impl From<Stop> for u8 {
            #[inline(always)]
            fn from(val: Stop) -> u8 {
                Stop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teie {
            #[inline(always)]
            fn from(val: u8) -> Teie {
                Teie::from_bits(val)
            }
        }
        impl From<Teie> for u8 {
            #[inline(always)]
            fn from(val: Teie) -> u8 {
                Teie::to_bits(val)
            }
        }
    }
}
pub mod sdadc24_b {
    #[doc = "24-Bit Sigma,Delta A/D Converter B"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sdadc24B {
        ptr: *mut u8,
    }
    unsafe impl Send for Sdadc24B {}
    unsafe impl Sync for Sdadc24B {}
    impl Sdadc24B {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Sigma,Delta A/D Clock Control Register"]
        #[inline(always)]
        pub const fn sdadccr(self) -> crate::common::Reg<regs::Sdadccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Mode Register"]
        #[inline(always)]
        pub const fn sdadmr(self) -> crate::common::Reg<regs::Sdadmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Reset Register"]
        #[inline(always)]
        pub const fn sdadrr(self) -> crate::common::Reg<regs::Sdadrr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Sigma,Delta A/D Gain Control Register"]
        #[inline(always)]
        pub const fn sdadgcr(self) -> crate::common::Reg<regs::Sdadgcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Sigma,Delta A/D HPF Control Register"]
        #[inline(always)]
        pub const fn sdadhpfcr(self) -> crate::common::Reg<regs::Sdadhpfcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Interrupt Control Register"]
        #[inline(always)]
        pub const fn sdadicr(self) -> crate::common::Reg<regs::Sdadicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Interrupt Clear Register"]
        #[inline(always)]
        pub const fn sdadiclr(self) -> crate::common::Reg<regs::Sdadiclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Interrupt Status Register"]
        #[inline(always)]
        pub const fn sdadisr(self) -> crate::common::Reg<regs::Sdadisr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Phase Control Register %s"]
        #[inline(always)]
        pub const fn sdadphcr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Sdadphcr, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 4usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Conversion Result Register %s Type 1"]
        #[inline(always)]
        pub const fn sdadcr(self, n: usize) -> crate::common::Reg<regs::Sdadcr, crate::common::R> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Conversion Result Register %s Type 2"]
        #[inline(always)]
        pub const fn sdadcrt2(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Sdadcrt2, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize + n * 4usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Conversion Result Register (LPF) %s Type 1"]
        #[inline(always)]
        pub const fn sdadcrlpf(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Sdadcrlpf, crate::common::R> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize + n * 4usize) as _) }
        }
        #[doc = "Sigma,Delta A/D Conversion Result Register (LPF) %s Type 2"]
        #[inline(always)]
        pub const fn sdadcrlpft2(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Sdadcrlpft2, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Sigma,Delta A/D Clock Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadccr(pub u8);
        impl Sdadccr {
            #[doc = "Operating clock of the digital block"]
            #[inline(always)]
            pub const fn ck(&self) -> super::vals::Ck {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Ck::from_bits(val as u8)
            }
            #[doc = "Operating clock of the digital block"]
            #[inline(always)]
            pub fn set_ck(&mut self, val: super::vals::Ck) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Sdadccr {
            #[inline(always)]
            fn default() -> Sdadccr {
                Sdadccr(0)
            }
        }
        impl core::fmt::Debug for Sdadccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadccr").field("ck", &self.ck()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sdadccr {{ ck: {:?} }}", self.ck())
            }
        }
        #[doc = "Sigma,Delta A/D Conversion Result Register %s Type 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadcr(pub u32);
        impl Sdadcr {
            #[doc = "A/D conversion result for channel n Type 1"]
            #[inline(always)]
            pub const fn sdadcr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A/D conversion result for channel n Type 1"]
            #[inline(always)]
            pub fn set_sdadcr(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Sdadcr {
            #[inline(always)]
            fn default() -> Sdadcr {
                Sdadcr(0)
            }
        }
        impl core::fmt::Debug for Sdadcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadcr")
                    .field("sdadcr", &self.sdadcr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sdadcr {{ sdadcr: {=u32:?} }}", self.sdadcr())
            }
        }
        #[doc = "Sigma,Delta A/D Conversion Result Register (LPF) %s Type 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadcrlpf(pub u32);
        impl Sdadcrlpf {
            #[doc = "A/D conversion result for channel n LPF output Type 1"]
            #[inline(always)]
            pub const fn sdadcr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A/D conversion result for channel n LPF output Type 1"]
            #[inline(always)]
            pub fn set_sdadcr(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Sdadcrlpf {
            #[inline(always)]
            fn default() -> Sdadcrlpf {
                Sdadcrlpf(0)
            }
        }
        impl core::fmt::Debug for Sdadcrlpf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadcrlpf")
                    .field("sdadcr", &self.sdadcr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadcrlpf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sdadcrlpf {{ sdadcr: {=u32:?} }}", self.sdadcr())
            }
        }
        #[doc = "Sigma,Delta A/D Conversion Result Register (LPF) %s Type 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadcrlpft2(pub u32);
        impl Sdadcrlpft2 {
            #[doc = "A/D conversion result for channel m LPF output Type 2"]
            #[inline(always)]
            pub const fn sdadcr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A/D conversion result for channel m LPF output Type 2"]
            #[inline(always)]
            pub fn set_sdadcr(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Sdadcrlpft2 {
            #[inline(always)]
            fn default() -> Sdadcrlpft2 {
                Sdadcrlpft2(0)
            }
        }
        impl core::fmt::Debug for Sdadcrlpft2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadcrlpft2")
                    .field("sdadcr", &self.sdadcr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadcrlpft2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sdadcrlpft2 {{ sdadcr: {=u32:?} }}", self.sdadcr())
            }
        }
        #[doc = "Sigma,Delta A/D Conversion Result Register %s Type 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadcrt2(pub u32);
        impl Sdadcrt2 {
            #[doc = "A/D conversion result for channel m Type 2"]
            #[inline(always)]
            pub const fn sdadcr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A/D conversion result for channel m Type 2"]
            #[inline(always)]
            pub fn set_sdadcr(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Sdadcrt2 {
            #[inline(always)]
            fn default() -> Sdadcrt2 {
                Sdadcrt2(0)
            }
        }
        impl core::fmt::Debug for Sdadcrt2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadcrt2")
                    .field("sdadcr", &self.sdadcr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadcrt2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sdadcrt2 {{ sdadcr: {=u32:?} }}", self.sdadcr())
            }
        }
        #[doc = "Sigma,Delta A/D Gain Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadgcr(pub u32);
        impl Sdadgcr {
            #[doc = "Preamplifier gain for channel 0"]
            #[inline(always)]
            pub const fn gain0(&self) -> super::vals::Gain0 {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Gain0::from_bits(val as u8)
            }
            #[doc = "Preamplifier gain for channel 0"]
            #[inline(always)]
            pub fn set_gain0(&mut self, val: super::vals::Gain0) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Preamplifier gain for channel 1"]
            #[inline(always)]
            pub const fn gain1(&self) -> super::vals::Gain1 {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Gain1::from_bits(val as u8)
            }
            #[doc = "Preamplifier gain for channel 1"]
            #[inline(always)]
            pub fn set_gain1(&mut self, val: super::vals::Gain1) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
            }
            #[doc = "Preamplifier gain for channel 2"]
            #[inline(always)]
            pub const fn gain2(&self) -> super::vals::Gain2 {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Gain2::from_bits(val as u8)
            }
            #[doc = "Preamplifier gain for channel 2"]
            #[inline(always)]
            pub fn set_gain2(&mut self, val: super::vals::Gain2) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Preamplifier gain for channel 3"]
            #[inline(always)]
            pub const fn gain3(&self) -> super::vals::Gain3 {
                let val = (self.0 >> 12usize) & 0x07;
                super::vals::Gain3::from_bits(val as u8)
            }
            #[doc = "Preamplifier gain for channel 3"]
            #[inline(always)]
            pub fn set_gain3(&mut self, val: super::vals::Gain3) {
                self.0 =
                    (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
            }
            #[doc = "Preamplifier gain for channel 4"]
            #[inline(always)]
            pub const fn gain4(&self) -> super::vals::Gain4 {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Gain4::from_bits(val as u8)
            }
            #[doc = "Preamplifier gain for channel 4"]
            #[inline(always)]
            pub fn set_gain4(&mut self, val: super::vals::Gain4) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "Preamplifier gain for channel 5"]
            #[inline(always)]
            pub const fn gain5(&self) -> super::vals::Gain5 {
                let val = (self.0 >> 20usize) & 0x07;
                super::vals::Gain5::from_bits(val as u8)
            }
            #[doc = "Preamplifier gain for channel 5"]
            #[inline(always)]
            pub fn set_gain5(&mut self, val: super::vals::Gain5) {
                self.0 =
                    (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
            }
            #[doc = "Preamplifier gain for channel 6"]
            #[inline(always)]
            pub const fn gain6(&self) -> super::vals::Gain6 {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Gain6::from_bits(val as u8)
            }
            #[doc = "Preamplifier gain for channel 6"]
            #[inline(always)]
            pub fn set_gain6(&mut self, val: super::vals::Gain6) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Sdadgcr {
            #[inline(always)]
            fn default() -> Sdadgcr {
                Sdadgcr(0)
            }
        }
        impl core::fmt::Debug for Sdadgcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadgcr")
                    .field("gain0", &self.gain0())
                    .field("gain1", &self.gain1())
                    .field("gain2", &self.gain2())
                    .field("gain3", &self.gain3())
                    .field("gain4", &self.gain4())
                    .field("gain5", &self.gain5())
                    .field("gain6", &self.gain6())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadgcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sdadgcr {{ gain0: {:?}, gain1: {:?}, gain2: {:?}, gain3: {:?}, gain4: {:?}, gain5: {:?}, gain6: {:?} }}" , self . gain0 () , self . gain1 () , self . gain2 () , self . gain3 () , self . gain4 () , self . gain5 () , self . gain6 ())
            }
        }
        #[doc = "Sigma,Delta A/D HPF Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadhpfcr(pub u32);
        impl Sdadhpfcr {
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub const fn dis0(&self) -> super::vals::Dis0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dis0::from_bits(val as u8)
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub fn set_dis0(&mut self, val: super::vals::Dis0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub const fn dis1(&self) -> super::vals::Dis1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Dis1::from_bits(val as u8)
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub fn set_dis1(&mut self, val: super::vals::Dis1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub const fn dis2(&self) -> super::vals::Dis2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dis2::from_bits(val as u8)
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub fn set_dis2(&mut self, val: super::vals::Dis2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub const fn dis3(&self) -> super::vals::Dis3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dis3::from_bits(val as u8)
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub fn set_dis3(&mut self, val: super::vals::Dis3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub const fn dis4(&self) -> super::vals::Dis4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dis4::from_bits(val as u8)
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub fn set_dis4(&mut self, val: super::vals::Dis4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub const fn dis5(&self) -> super::vals::Dis5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Dis5::from_bits(val as u8)
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub fn set_dis5(&mut self, val: super::vals::Dis5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub const fn dis6(&self) -> super::vals::Dis6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Dis6::from_bits(val as u8)
            }
            #[doc = "HPF bypass for channel n Type 1 output"]
            #[inline(always)]
            pub fn set_dis6(&mut self, val: super::vals::Dis6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "HPF bypass for channel m Type 2 output"]
            #[inline(always)]
            pub const fn dis3t2(&self) -> super::vals::Dis3t2 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Dis3t2::from_bits(val as u8)
            }
            #[doc = "HPF bypass for channel m Type 2 output"]
            #[inline(always)]
            pub fn set_dis3t2(&mut self, val: super::vals::Dis3t2) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "HPF bypass for channel m Type 2 output"]
            #[inline(always)]
            pub const fn dis0t2(&self) -> super::vals::Dis0t2 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Dis0t2::from_bits(val as u8)
            }
            #[doc = "HPF bypass for channel m Type 2 output"]
            #[inline(always)]
            pub fn set_dis0t2(&mut self, val: super::vals::Dis0t2) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Cut,off frequency of HPF (see )"]
            #[inline(always)]
            pub const fn cof(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x03;
                val as u8
            }
            #[doc = "Cut,off frequency of HPF (see )"]
            #[inline(always)]
            pub fn set_cof(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 28usize)) | (((val as u32) & 0x03) << 28usize);
            }
        }
        impl Default for Sdadhpfcr {
            #[inline(always)]
            fn default() -> Sdadhpfcr {
                Sdadhpfcr(0)
            }
        }
        impl core::fmt::Debug for Sdadhpfcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadhpfcr")
                    .field("dis0", &self.dis0())
                    .field("dis1", &self.dis1())
                    .field("dis2", &self.dis2())
                    .field("dis3", &self.dis3())
                    .field("dis4", &self.dis4())
                    .field("dis5", &self.dis5())
                    .field("dis6", &self.dis6())
                    .field("dis3t2", &self.dis3t2())
                    .field("dis0t2", &self.dis0t2())
                    .field("cof", &self.cof())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadhpfcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sdadhpfcr {{ dis0: {:?}, dis1: {:?}, dis2: {:?}, dis3: {:?}, dis4: {:?}, dis5: {:?}, dis6: {:?}, dis3t2: {:?}, dis0t2: {:?}, cof: {=u8:?} }}" , self . dis0 () , self . dis1 () , self . dis2 () , self . dis3 () , self . dis4 () , self . dis5 () , self . dis6 () , self . dis3t2 () , self . dis0t2 () , self . cof ())
            }
        }
        #[doc = "Sigma,Delta A/D Interrupt Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadiclr(pub u8);
        impl Sdadiclr {
            #[doc = "Zero,cross detection interrupt 0 clear"]
            #[inline(always)]
            pub const fn icl0(&self) -> super::vals::Icl0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Icl0::from_bits(val as u8)
            }
            #[doc = "Zero,cross detection interrupt 0 clear"]
            #[inline(always)]
            pub fn set_icl0(&mut self, val: super::vals::Icl0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Zero,cross detection interrupt 1 clear"]
            #[inline(always)]
            pub const fn icl1(&self) -> super::vals::Icl1 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Icl1::from_bits(val as u8)
            }
            #[doc = "Zero,cross detection interrupt 1 clear"]
            #[inline(always)]
            pub fn set_icl1(&mut self, val: super::vals::Icl1) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Sdadiclr {
            #[inline(always)]
            fn default() -> Sdadiclr {
                Sdadiclr(0)
            }
        }
        impl core::fmt::Debug for Sdadiclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadiclr")
                    .field("icl0", &self.icl0())
                    .field("icl1", &self.icl1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadiclr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sdadiclr {{ icl0: {:?}, icl1: {:?} }}",
                    self.icl0(),
                    self.icl1()
                )
            }
        }
        #[doc = "Sigma,Delta A/D Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadicr(pub u8);
        impl Sdadicr {
            #[doc = "Detection channel for zero,cross detection 0"]
            #[inline(always)]
            pub const fn zcctl0(&self) -> super::vals::Zcctl0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Zcctl0::from_bits(val as u8)
            }
            #[doc = "Detection channel for zero,cross detection 0"]
            #[inline(always)]
            pub fn set_zcctl0(&mut self, val: super::vals::Zcctl0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Interrupt output mode for zero,cross detection 0"]
            #[inline(always)]
            pub const fn zcmd0(&self) -> super::vals::Zcmd0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Zcmd0::from_bits(val as u8)
            }
            #[doc = "Interrupt output mode for zero,cross detection 0"]
            #[inline(always)]
            pub fn set_zcmd0(&mut self, val: super::vals::Zcmd0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Falling edge detection enable for zero,cross detection 0"]
            #[inline(always)]
            pub const fn zcegn0(&self) -> super::vals::Zcegn0 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Zcegn0::from_bits(val as u8)
            }
            #[doc = "Falling edge detection enable for zero,cross detection 0"]
            #[inline(always)]
            pub fn set_zcegn0(&mut self, val: super::vals::Zcegn0) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Rising edge detection enable for zero,cross detection 0"]
            #[inline(always)]
            pub const fn zcegp0(&self) -> super::vals::Zcegp0 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Zcegp0::from_bits(val as u8)
            }
            #[doc = "Rising edge detection enable for zero,cross detection 0"]
            #[inline(always)]
            pub fn set_zcegp0(&mut self, val: super::vals::Zcegp0) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Detection channel for zero,cross detection 1"]
            #[inline(always)]
            pub const fn zcctl1(&self) -> super::vals::Zcctl1 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Zcctl1::from_bits(val as u8)
            }
            #[doc = "Detection channel for zero,cross detection 1"]
            #[inline(always)]
            pub fn set_zcctl1(&mut self, val: super::vals::Zcctl1) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Interrupt output mode for zero,cross detection 1"]
            #[inline(always)]
            pub const fn zcmd1(&self) -> super::vals::Zcmd1 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Zcmd1::from_bits(val as u8)
            }
            #[doc = "Interrupt output mode for zero,cross detection 1"]
            #[inline(always)]
            pub fn set_zcmd1(&mut self, val: super::vals::Zcmd1) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Falling edge detection enable for zero,cross detection 1"]
            #[inline(always)]
            pub const fn zcegn1(&self) -> super::vals::Zcegn1 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Zcegn1::from_bits(val as u8)
            }
            #[doc = "Falling edge detection enable for zero,cross detection 1"]
            #[inline(always)]
            pub fn set_zcegn1(&mut self, val: super::vals::Zcegn1) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Rising edge detection enable for Zero,cross detection 1"]
            #[inline(always)]
            pub const fn zcegp1(&self) -> super::vals::Zcegp1 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Zcegp1::from_bits(val as u8)
            }
            #[doc = "Rising edge detection enable for Zero,cross detection 1"]
            #[inline(always)]
            pub fn set_zcegp1(&mut self, val: super::vals::Zcegp1) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Sdadicr {
            #[inline(always)]
            fn default() -> Sdadicr {
                Sdadicr(0)
            }
        }
        impl core::fmt::Debug for Sdadicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadicr")
                    .field("zcctl0", &self.zcctl0())
                    .field("zcmd0", &self.zcmd0())
                    .field("zcegn0", &self.zcegn0())
                    .field("zcegp0", &self.zcegp0())
                    .field("zcctl1", &self.zcctl1())
                    .field("zcmd1", &self.zcmd1())
                    .field("zcegn1", &self.zcegn1())
                    .field("zcegp1", &self.zcegp1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadicr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sdadicr {{ zcctl0: {:?}, zcmd0: {:?}, zcegn0: {:?}, zcegp0: {:?}, zcctl1: {:?}, zcmd1: {:?}, zcegn1: {:?}, zcegp1: {:?} }}" , self . zcctl0 () , self . zcmd0 () , self . zcegn0 () , self . zcegp0 () , self . zcctl1 () , self . zcmd1 () , self . zcegn1 () , self . zcegp1 ())
            }
        }
        #[doc = "Sigma,Delta A/D Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadisr(pub u8);
        impl Sdadisr {
            #[doc = "Zero,cross detection interrupt status for zero,cross detection 0"]
            #[inline(always)]
            pub const fn zci0(&self) -> super::vals::Zci0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Zci0::from_bits(val as u8)
            }
            #[doc = "Zero,cross detection interrupt status for zero,cross detection 0"]
            #[inline(always)]
            pub fn set_zci0(&mut self, val: super::vals::Zci0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "DF output status for zero,cross detection 0"]
            #[inline(always)]
            pub const fn zc0(&self) -> super::vals::Zc0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Zc0::from_bits(val as u8)
            }
            #[doc = "DF output status for zero,cross detection 0"]
            #[inline(always)]
            pub fn set_zc0(&mut self, val: super::vals::Zc0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Zero,cross detection interrupt status for zero,cross detection 1"]
            #[inline(always)]
            pub const fn zci1(&self) -> super::vals::Zci1 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Zci1::from_bits(val as u8)
            }
            #[doc = "Zero,cross detection interrupt status for zero,cross detection 1"]
            #[inline(always)]
            pub fn set_zci1(&mut self, val: super::vals::Zci1) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "DF output status for Zero,cross detection 1"]
            #[inline(always)]
            pub const fn zc1(&self) -> super::vals::Zc1 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Zc1::from_bits(val as u8)
            }
            #[doc = "DF output status for Zero,cross detection 1"]
            #[inline(always)]
            pub fn set_zc1(&mut self, val: super::vals::Zc1) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Sdadisr {
            #[inline(always)]
            fn default() -> Sdadisr {
                Sdadisr(0)
            }
        }
        impl core::fmt::Debug for Sdadisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadisr")
                    .field("zci0", &self.zci0())
                    .field("zc0", &self.zc0())
                    .field("zci1", &self.zci1())
                    .field("zc1", &self.zc1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sdadisr {{ zci0: {:?}, zc0: {:?}, zci1: {:?}, zc1: {:?} }}",
                    self.zci0(),
                    self.zc0(),
                    self.zci1(),
                    self.zc1()
                )
            }
        }
        #[doc = "Sigma,Delta A/D Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadmr(pub u32);
        impl Sdadmr {
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub const fn ce0(&self) -> super::vals::Ce0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ce0::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub fn set_ce0(&mut self, val: super::vals::Ce0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub const fn ce1(&self) -> super::vals::Ce1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ce1::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub fn set_ce1(&mut self, val: super::vals::Ce1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub const fn ce2(&self) -> super::vals::Ce2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ce2::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub fn set_ce2(&mut self, val: super::vals::Ce2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub const fn ce3(&self) -> super::vals::Ce3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ce3::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub fn set_ce3(&mut self, val: super::vals::Ce3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub const fn ce4(&self) -> super::vals::Ce4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ce4::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub fn set_ce4(&mut self, val: super::vals::Ce4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub const fn ce5(&self) -> super::vals::Ce5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ce5::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub fn set_ce5(&mut self, val: super::vals::Ce5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub const fn ce6(&self) -> super::vals::Ce6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ce6::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter operation enable for channel n"]
            #[inline(always)]
            pub fn set_ce6(&mut self, val: super::vals::Ce6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub const fn pon0(&self) -> super::vals::Pon0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pon0::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub fn set_pon0(&mut self, val: super::vals::Pon0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub const fn pon1(&self) -> super::vals::Pon1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pon1::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub fn set_pon1(&mut self, val: super::vals::Pon1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub const fn pon2(&self) -> super::vals::Pon2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pon2::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub fn set_pon2(&mut self, val: super::vals::Pon2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub const fn pon3(&self) -> super::vals::Pon3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pon3::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub fn set_pon3(&mut self, val: super::vals::Pon3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub const fn pon4(&self) -> super::vals::Pon4 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pon4::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub fn set_pon4(&mut self, val: super::vals::Pon4) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub const fn pon5(&self) -> super::vals::Pon5 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pon5::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub fn set_pon5(&mut self, val: super::vals::Pon5) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub const fn pon6(&self) -> super::vals::Pon6 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pon6::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter power,on control for channel n"]
            #[inline(always)]
            pub fn set_pon6(&mut self, val: super::vals::Pon6) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Sampling mode select"]
            #[inline(always)]
            pub const fn fr(&self) -> super::vals::Fr {
                let val = (self.0 >> 28usize) & 0x03;
                super::vals::Fr::from_bits(val as u8)
            }
            #[doc = "Sampling mode select"]
            #[inline(always)]
            pub fn set_fr(&mut self, val: super::vals::Fr) {
                self.0 =
                    (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
            }
            #[doc = "Resolution of A/D conversion result reading"]
            #[inline(always)]
            pub const fn typ(&self) -> super::vals::Typ {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Typ::from_bits(val as u8)
            }
            #[doc = "Resolution of A/D conversion result reading"]
            #[inline(always)]
            pub fn set_typ(&mut self, val: super::vals::Typ) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Sdadmr {
            #[inline(always)]
            fn default() -> Sdadmr {
                Sdadmr(0)
            }
        }
        impl core::fmt::Debug for Sdadmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadmr")
                    .field("ce0", &self.ce0())
                    .field("ce1", &self.ce1())
                    .field("ce2", &self.ce2())
                    .field("ce3", &self.ce3())
                    .field("ce4", &self.ce4())
                    .field("ce5", &self.ce5())
                    .field("ce6", &self.ce6())
                    .field("pon0", &self.pon0())
                    .field("pon1", &self.pon1())
                    .field("pon2", &self.pon2())
                    .field("pon3", &self.pon3())
                    .field("pon4", &self.pon4())
                    .field("pon5", &self.pon5())
                    .field("pon6", &self.pon6())
                    .field("fr", &self.fr())
                    .field("typ", &self.typ())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadmr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sdadmr {{ ce0: {:?}, ce1: {:?}, ce2: {:?}, ce3: {:?}, ce4: {:?}, ce5: {:?}, ce6: {:?}, pon0: {:?}, pon1: {:?}, pon2: {:?}, pon3: {:?}, pon4: {:?}, pon5: {:?}, pon6: {:?}, fr: {:?}, typ: {:?} }}" , self . ce0 () , self . ce1 () , self . ce2 () , self . ce3 () , self . ce4 () , self . ce5 () , self . ce6 () , self . pon0 () , self . pon1 () , self . pon2 () , self . pon3 () , self . pon4 () , self . pon5 () , self . pon6 () , self . fr () , self . typ ())
            }
        }
        #[doc = "Sigma,Delta A/D Phase Control Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadphcr(pub u16);
        impl Sdadphcr {
            #[doc = "Phase adjustment for channel n (n = 0 to 6)"]
            #[inline(always)]
            pub const fn ph(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Phase adjustment for channel n (n = 0 to 6)"]
            #[inline(always)]
            pub fn set_ph(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u16) & 0x07ff) << 0usize);
            }
        }
        impl Default for Sdadphcr {
            #[inline(always)]
            fn default() -> Sdadphcr {
                Sdadphcr(0)
            }
        }
        impl core::fmt::Debug for Sdadphcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadphcr").field("ph", &self.ph()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadphcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sdadphcr {{ ph: {=u16:?} }}", self.ph())
            }
        }
        #[doc = "Sigma,Delta A/D Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadrr(pub u8);
        impl Sdadrr {
            #[doc = "Sigma,Delta A/D converter reset"]
            #[inline(always)]
            pub const fn res(&self) -> super::vals::Res {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Res::from_bits(val as u8)
            }
            #[doc = "Sigma,Delta A/D converter reset"]
            #[inline(always)]
            pub fn set_res(&mut self, val: super::vals::Res) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Sdadrr {
            #[inline(always)]
            fn default() -> Sdadrr {
                Sdadrr(0)
            }
        }
        impl core::fmt::Debug for Sdadrr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadrr").field("res", &self.res()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadrr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sdadrr {{ res: {:?} }}", self.res())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ce0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ce0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ce0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ce0 {
            #[inline(always)]
            fn from(val: u8) -> Ce0 {
                Ce0::from_bits(val)
            }
        }
        impl From<Ce0> for u8 {
            #[inline(always)]
            fn from(val: Ce0) -> u8 {
                Ce0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ce1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ce1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ce1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ce1 {
            #[inline(always)]
            fn from(val: u8) -> Ce1 {
                Ce1::from_bits(val)
            }
        }
        impl From<Ce1> for u8 {
            #[inline(always)]
            fn from(val: Ce1) -> u8 {
                Ce1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ce2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ce2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ce2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ce2 {
            #[inline(always)]
            fn from(val: u8) -> Ce2 {
                Ce2::from_bits(val)
            }
        }
        impl From<Ce2> for u8 {
            #[inline(always)]
            fn from(val: Ce2) -> u8 {
                Ce2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ce3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ce3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ce3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ce3 {
            #[inline(always)]
            fn from(val: u8) -> Ce3 {
                Ce3::from_bits(val)
            }
        }
        impl From<Ce3> for u8 {
            #[inline(always)]
            fn from(val: Ce3) -> u8 {
                Ce3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ce4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ce4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ce4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ce4 {
            #[inline(always)]
            fn from(val: u8) -> Ce4 {
                Ce4::from_bits(val)
            }
        }
        impl From<Ce4> for u8 {
            #[inline(always)]
            fn from(val: Ce4) -> u8 {
                Ce4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ce5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ce5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ce5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ce5 {
            #[inline(always)]
            fn from(val: u8) -> Ce5 {
                Ce5::from_bits(val)
            }
        }
        impl From<Ce5> for u8 {
            #[inline(always)]
            fn from(val: Ce5) -> u8 {
                Ce5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ce6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ce6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ce6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ce6 {
            #[inline(always)]
            fn from(val: u8) -> Ce6 {
                Ce6::from_bits(val)
            }
        }
        impl From<Ce6> for u8 {
            #[inline(always)]
            fn from(val: Ce6) -> u8 {
                Ce6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ck {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ck {
            #[inline(always)]
            fn from(val: u8) -> Ck {
                Ck::from_bits(val)
            }
        }
        impl From<Ck> for u8 {
            #[inline(always)]
            fn from(val: Ck) -> u8 {
                Ck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dis0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dis0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dis0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dis0 {
            #[inline(always)]
            fn from(val: u8) -> Dis0 {
                Dis0::from_bits(val)
            }
        }
        impl From<Dis0> for u8 {
            #[inline(always)]
            fn from(val: Dis0) -> u8 {
                Dis0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dis0t2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dis0t2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dis0t2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dis0t2 {
            #[inline(always)]
            fn from(val: u8) -> Dis0t2 {
                Dis0t2::from_bits(val)
            }
        }
        impl From<Dis0t2> for u8 {
            #[inline(always)]
            fn from(val: Dis0t2) -> u8 {
                Dis0t2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dis1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dis1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dis1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dis1 {
            #[inline(always)]
            fn from(val: u8) -> Dis1 {
                Dis1::from_bits(val)
            }
        }
        impl From<Dis1> for u8 {
            #[inline(always)]
            fn from(val: Dis1) -> u8 {
                Dis1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dis2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dis2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dis2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dis2 {
            #[inline(always)]
            fn from(val: u8) -> Dis2 {
                Dis2::from_bits(val)
            }
        }
        impl From<Dis2> for u8 {
            #[inline(always)]
            fn from(val: Dis2) -> u8 {
                Dis2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dis3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dis3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dis3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dis3 {
            #[inline(always)]
            fn from(val: u8) -> Dis3 {
                Dis3::from_bits(val)
            }
        }
        impl From<Dis3> for u8 {
            #[inline(always)]
            fn from(val: Dis3) -> u8 {
                Dis3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dis3t2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dis3t2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dis3t2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dis3t2 {
            #[inline(always)]
            fn from(val: u8) -> Dis3t2 {
                Dis3t2::from_bits(val)
            }
        }
        impl From<Dis3t2> for u8 {
            #[inline(always)]
            fn from(val: Dis3t2) -> u8 {
                Dis3t2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dis4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dis4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dis4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dis4 {
            #[inline(always)]
            fn from(val: u8) -> Dis4 {
                Dis4::from_bits(val)
            }
        }
        impl From<Dis4> for u8 {
            #[inline(always)]
            fn from(val: Dis4) -> u8 {
                Dis4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dis5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dis5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dis5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dis5 {
            #[inline(always)]
            fn from(val: u8) -> Dis5 {
                Dis5::from_bits(val)
            }
        }
        impl From<Dis5> for u8 {
            #[inline(always)]
            fn from(val: Dis5) -> u8 {
                Dis5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dis6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dis6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dis6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dis6 {
            #[inline(always)]
            fn from(val: u8) -> Dis6 {
                Dis6::from_bits(val)
            }
        }
        impl From<Dis6> for u8 {
            #[inline(always)]
            fn from(val: Dis6) -> u8 {
                Dis6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Fr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fr {
            #[inline(always)]
            fn from(val: u8) -> Fr {
                Fr::from_bits(val)
            }
        }
        impl From<Fr> for u8 {
            #[inline(always)]
            fn from(val: Fr) -> u8 {
                Fr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gain0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain0 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain0 {
            #[inline(always)]
            fn from(val: u8) -> Gain0 {
                Gain0::from_bits(val)
            }
        }
        impl From<Gain0> for u8 {
            #[inline(always)]
            fn from(val: Gain0) -> u8 {
                Gain0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gain1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain1 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain1 {
            #[inline(always)]
            fn from(val: u8) -> Gain1 {
                Gain1::from_bits(val)
            }
        }
        impl From<Gain1> for u8 {
            #[inline(always)]
            fn from(val: Gain1) -> u8 {
                Gain1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gain2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain2 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain2 {
            #[inline(always)]
            fn from(val: u8) -> Gain2 {
                Gain2::from_bits(val)
            }
        }
        impl From<Gain2> for u8 {
            #[inline(always)]
            fn from(val: Gain2) -> u8 {
                Gain2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gain3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain3 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain3 {
            #[inline(always)]
            fn from(val: u8) -> Gain3 {
                Gain3::from_bits(val)
            }
        }
        impl From<Gain3> for u8 {
            #[inline(always)]
            fn from(val: Gain3) -> u8 {
                Gain3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gain4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain4 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain4 {
            #[inline(always)]
            fn from(val: u8) -> Gain4 {
                Gain4::from_bits(val)
            }
        }
        impl From<Gain4> for u8 {
            #[inline(always)]
            fn from(val: Gain4) -> u8 {
                Gain4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gain5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain5 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain5 {
            #[inline(always)]
            fn from(val: u8) -> Gain5 {
                Gain5::from_bits(val)
            }
        }
        impl From<Gain5> for u8 {
            #[inline(always)]
            fn from(val: Gain5) -> u8 {
                Gain5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gain6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain6 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain6 {
            #[inline(always)]
            fn from(val: u8) -> Gain6 {
                Gain6::from_bits(val)
            }
        }
        impl From<Gain6> for u8 {
            #[inline(always)]
            fn from(val: Gain6) -> u8 {
                Gain6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Icl0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Icl0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Icl0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Icl0 {
            #[inline(always)]
            fn from(val: u8) -> Icl0 {
                Icl0::from_bits(val)
            }
        }
        impl From<Icl0> for u8 {
            #[inline(always)]
            fn from(val: Icl0) -> u8 {
                Icl0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Icl1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Icl1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Icl1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Icl1 {
            #[inline(always)]
            fn from(val: u8) -> Icl1 {
                Icl1::from_bits(val)
            }
        }
        impl From<Icl1> for u8 {
            #[inline(always)]
            fn from(val: Icl1) -> u8 {
                Icl1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pon0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pon0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pon0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pon0 {
            #[inline(always)]
            fn from(val: u8) -> Pon0 {
                Pon0::from_bits(val)
            }
        }
        impl From<Pon0> for u8 {
            #[inline(always)]
            fn from(val: Pon0) -> u8 {
                Pon0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pon1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pon1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pon1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pon1 {
            #[inline(always)]
            fn from(val: u8) -> Pon1 {
                Pon1::from_bits(val)
            }
        }
        impl From<Pon1> for u8 {
            #[inline(always)]
            fn from(val: Pon1) -> u8 {
                Pon1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pon2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pon2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pon2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pon2 {
            #[inline(always)]
            fn from(val: u8) -> Pon2 {
                Pon2::from_bits(val)
            }
        }
        impl From<Pon2> for u8 {
            #[inline(always)]
            fn from(val: Pon2) -> u8 {
                Pon2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pon3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pon3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pon3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pon3 {
            #[inline(always)]
            fn from(val: u8) -> Pon3 {
                Pon3::from_bits(val)
            }
        }
        impl From<Pon3> for u8 {
            #[inline(always)]
            fn from(val: Pon3) -> u8 {
                Pon3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pon4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pon4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pon4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pon4 {
            #[inline(always)]
            fn from(val: u8) -> Pon4 {
                Pon4::from_bits(val)
            }
        }
        impl From<Pon4> for u8 {
            #[inline(always)]
            fn from(val: Pon4) -> u8 {
                Pon4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pon5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pon5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pon5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pon5 {
            #[inline(always)]
            fn from(val: u8) -> Pon5 {
                Pon5::from_bits(val)
            }
        }
        impl From<Pon5> for u8 {
            #[inline(always)]
            fn from(val: Pon5) -> u8 {
                Pon5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pon6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pon6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pon6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pon6 {
            #[inline(always)]
            fn from(val: u8) -> Pon6 {
                Pon6::from_bits(val)
            }
        }
        impl From<Pon6> for u8 {
            #[inline(always)]
            fn from(val: Pon6) -> u8 {
                Pon6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Res {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Res {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Res {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Res {
            #[inline(always)]
            fn from(val: u8) -> Res {
                Res::from_bits(val)
            }
        }
        impl From<Res> for u8 {
            #[inline(always)]
            fn from(val: Res) -> u8 {
                Res::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Typ {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Typ {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Typ {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Typ {
            #[inline(always)]
            fn from(val: u8) -> Typ {
                Typ::from_bits(val)
            }
        }
        impl From<Typ> for u8 {
            #[inline(always)]
            fn from(val: Typ) -> u8 {
                Typ::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zc0 {
            #[inline(always)]
            fn from(val: u8) -> Zc0 {
                Zc0::from_bits(val)
            }
        }
        impl From<Zc0> for u8 {
            #[inline(always)]
            fn from(val: Zc0) -> u8 {
                Zc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zc1 {
            #[inline(always)]
            fn from(val: u8) -> Zc1 {
                Zc1::from_bits(val)
            }
        }
        impl From<Zc1> for u8 {
            #[inline(always)]
            fn from(val: Zc1) -> u8 {
                Zc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zcctl0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zcctl0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zcctl0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zcctl0 {
            #[inline(always)]
            fn from(val: u8) -> Zcctl0 {
                Zcctl0::from_bits(val)
            }
        }
        impl From<Zcctl0> for u8 {
            #[inline(always)]
            fn from(val: Zcctl0) -> u8 {
                Zcctl0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zcctl1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zcctl1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zcctl1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zcctl1 {
            #[inline(always)]
            fn from(val: u8) -> Zcctl1 {
                Zcctl1::from_bits(val)
            }
        }
        impl From<Zcctl1> for u8 {
            #[inline(always)]
            fn from(val: Zcctl1) -> u8 {
                Zcctl1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zcegn0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zcegn0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zcegn0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zcegn0 {
            #[inline(always)]
            fn from(val: u8) -> Zcegn0 {
                Zcegn0::from_bits(val)
            }
        }
        impl From<Zcegn0> for u8 {
            #[inline(always)]
            fn from(val: Zcegn0) -> u8 {
                Zcegn0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zcegn1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zcegn1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zcegn1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zcegn1 {
            #[inline(always)]
            fn from(val: u8) -> Zcegn1 {
                Zcegn1::from_bits(val)
            }
        }
        impl From<Zcegn1> for u8 {
            #[inline(always)]
            fn from(val: Zcegn1) -> u8 {
                Zcegn1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zcegp0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zcegp0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zcegp0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zcegp0 {
            #[inline(always)]
            fn from(val: u8) -> Zcegp0 {
                Zcegp0::from_bits(val)
            }
        }
        impl From<Zcegp0> for u8 {
            #[inline(always)]
            fn from(val: Zcegp0) -> u8 {
                Zcegp0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zcegp1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zcegp1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zcegp1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zcegp1 {
            #[inline(always)]
            fn from(val: u8) -> Zcegp1 {
                Zcegp1::from_bits(val)
            }
        }
        impl From<Zcegp1> for u8 {
            #[inline(always)]
            fn from(val: Zcegp1) -> u8 {
                Zcegp1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zci0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zci0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zci0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zci0 {
            #[inline(always)]
            fn from(val: u8) -> Zci0 {
                Zci0::from_bits(val)
            }
        }
        impl From<Zci0> for u8 {
            #[inline(always)]
            fn from(val: Zci0) -> u8 {
                Zci0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zci1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zci1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zci1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zci1 {
            #[inline(always)]
            fn from(val: u8) -> Zci1 {
                Zci1::from_bits(val)
            }
        }
        impl From<Zci1> for u8 {
            #[inline(always)]
            fn from(val: Zci1) -> u8 {
                Zci1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zcmd0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zcmd0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zcmd0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zcmd0 {
            #[inline(always)]
            fn from(val: u8) -> Zcmd0 {
                Zcmd0::from_bits(val)
            }
        }
        impl From<Zcmd0> for u8 {
            #[inline(always)]
            fn from(val: Zcmd0) -> u8 {
                Zcmd0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Zcmd1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Zcmd1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Zcmd1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Zcmd1 {
            #[inline(always)]
            fn from(val: u8) -> Zcmd1 {
                Zcmd1::from_bits(val)
            }
        }
        impl From<Zcmd1> for u8 {
            #[inline(always)]
            fn from(val: Zcmd1) -> u8 {
                Zcmd1::to_bits(val)
            }
        }
    }
}
pub mod slcdc {
    #[doc = "Segment LCD Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Slcdc {
        ptr: *mut u8,
    }
    unsafe impl Send for Slcdc {}
    unsafe impl Sync for Slcdc {}
    impl Slcdc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "LCD Mode Register 0"]
        #[inline(always)]
        pub const fn lcdm0(self) -> crate::common::Reg<regs::Lcdm0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "LCD Mode Register 1"]
        #[inline(always)]
        pub const fn lcdm1(self) -> crate::common::Reg<regs::Lcdm1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "LCD Clock Control Register 0"]
        #[inline(always)]
        pub const fn lcdc0(self) -> crate::common::Reg<regs::Lcdc0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "LCD Boost Level Control Register"]
        #[inline(always)]
        pub const fn vlcd(self) -> crate::common::Reg<regs::Vlcd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "LCD Display Data Register %s"]
        #[inline(always)]
        pub const fn seg(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 45usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 1usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "LCD Clock Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lcdc0(pub u8);
        impl Lcdc0 {
            #[doc = "LCD Clock (LCDCL) Setting"]
            #[inline(always)]
            pub const fn lcdc0(&self) -> super::vals::Lcdc0 {
                let val = (self.0 >> 0usize) & 0x3f;
                super::vals::Lcdc0::from_bits(val as u8)
            }
            #[doc = "LCD Clock (LCDCL) Setting"]
            #[inline(always)]
            pub fn set_lcdc0(&mut self, val: super::vals::Lcdc0) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val.to_bits() as u8) & 0x3f) << 0usize);
            }
        }
        impl Default for Lcdc0 {
            #[inline(always)]
            fn default() -> Lcdc0 {
                Lcdc0(0)
            }
        }
        impl core::fmt::Debug for Lcdc0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lcdc0")
                    .field("lcdc0", &self.lcdc0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lcdc0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lcdc0 {{ lcdc0: {:?} }}", self.lcdc0())
            }
        }
        #[doc = "LCD Mode Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lcdm0(pub u8);
        impl Lcdm0 {
            #[doc = "LCD Display Bias Method Select"]
            #[inline(always)]
            pub const fn lbas(&self) -> super::vals::Lbas {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lbas::from_bits(val as u8)
            }
            #[doc = "LCD Display Bias Method Select"]
            #[inline(always)]
            pub fn set_lbas(&mut self, val: super::vals::Lbas) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Time Slice of LCD Display Select"]
            #[inline(always)]
            pub const fn ldty(&self) -> super::vals::Ldty {
                let val = (self.0 >> 2usize) & 0x07;
                super::vals::Ldty::from_bits(val as u8)
            }
            #[doc = "Time Slice of LCD Display Select"]
            #[inline(always)]
            pub fn set_ldty(&mut self, val: super::vals::Ldty) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val.to_bits() as u8) & 0x07) << 2usize);
            }
            #[doc = "LCD Display Waveform Select"]
            #[inline(always)]
            pub const fn lwave(&self) -> super::vals::Lwave {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Lwave::from_bits(val as u8)
            }
            #[doc = "LCD Display Waveform Select"]
            #[inline(always)]
            pub fn set_lwave(&mut self, val: super::vals::Lwave) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "LCD Drive Voltage Generator Select"]
            #[inline(always)]
            pub const fn mdset(&self) -> super::vals::Mdset {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Mdset::from_bits(val as u8)
            }
            #[doc = "LCD Drive Voltage Generator Select"]
            #[inline(always)]
            pub fn set_mdset(&mut self, val: super::vals::Mdset) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Lcdm0 {
            #[inline(always)]
            fn default() -> Lcdm0 {
                Lcdm0(0)
            }
        }
        impl core::fmt::Debug for Lcdm0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lcdm0")
                    .field("lbas", &self.lbas())
                    .field("ldty", &self.ldty())
                    .field("lwave", &self.lwave())
                    .field("mdset", &self.mdset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lcdm0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lcdm0 {{ lbas: {:?}, ldty: {:?}, lwave: {:?}, mdset: {:?} }}",
                    self.lbas(),
                    self.ldty(),
                    self.lwave(),
                    self.mdset()
                )
            }
        }
        #[doc = "LCD Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lcdm1(pub u8);
        impl Lcdm1 {
            #[doc = "Voltage Boosting Pin Initial Value Switching Control"]
            #[inline(always)]
            pub const fn lcdvlm(&self) -> super::vals::Lcdvlm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lcdvlm::from_bits(val as u8)
            }
            #[doc = "Voltage Boosting Pin Initial Value Switching Control"]
            #[inline(always)]
            pub fn set_lcdvlm(&mut self, val: super::vals::Lcdvlm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Display Area Data Selection"]
            #[inline(always)]
            pub const fn lcdsel(&self) -> super::vals::Lcdsel {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lcdsel::from_bits(val as u8)
            }
            #[doc = "Display Area Data Selection"]
            #[inline(always)]
            pub fn set_lcdsel(&mut self, val: super::vals::Lcdsel) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Alternately Display A,pattern and B,pattern Area Data (blinking display) Control"]
            #[inline(always)]
            pub const fn blon(&self) -> super::vals::Blon {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Blon::from_bits(val as u8)
            }
            #[doc = "Alternately Display A,pattern and B,pattern Area Data (blinking display) Control"]
            #[inline(always)]
            pub fn set_blon(&mut self, val: super::vals::Blon) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Voltage Boost Circuit or Capacitor Split Circuit Operation Enable/Disable"]
            #[inline(always)]
            pub const fn vlcon(&self) -> super::vals::Vlcon {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Vlcon::from_bits(val as u8)
            }
            #[doc = "Voltage Boost Circuit or Capacitor Split Circuit Operation Enable/Disable"]
            #[inline(always)]
            pub fn set_vlcon(&mut self, val: super::vals::Vlcon) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "LCD Display Enable/Disable"]
            #[inline(always)]
            pub const fn scoc(&self) -> super::vals::Scoc {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Scoc::from_bits(val as u8)
            }
            #[doc = "LCD Display Enable/Disable"]
            #[inline(always)]
            pub fn set_scoc(&mut self, val: super::vals::Scoc) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "LCD Display Enable/Disable"]
            #[inline(always)]
            pub const fn lcdon(&self) -> super::vals::Lcdon {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lcdon::from_bits(val as u8)
            }
            #[doc = "LCD Display Enable/Disable"]
            #[inline(always)]
            pub fn set_lcdon(&mut self, val: super::vals::Lcdon) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lcdm1 {
            #[inline(always)]
            fn default() -> Lcdm1 {
                Lcdm1(0)
            }
        }
        impl core::fmt::Debug for Lcdm1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lcdm1")
                    .field("lcdvlm", &self.lcdvlm())
                    .field("lcdsel", &self.lcdsel())
                    .field("blon", &self.blon())
                    .field("vlcon", &self.vlcon())
                    .field("scoc", &self.scoc())
                    .field("lcdon", &self.lcdon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lcdm1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Lcdm1 {{ lcdvlm: {:?}, lcdsel: {:?}, blon: {:?}, vlcon: {:?}, scoc: {:?}, lcdon: {:?} }}" , self . lcdvlm () , self . lcdsel () , self . blon () , self . vlcon () , self . scoc () , self . lcdon ())
            }
        }
        #[doc = "LCD Boost Level Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vlcd(pub u8);
        impl Vlcd {
            #[doc = "Reference Voltage Select (Contrast Adjustment)"]
            #[inline(always)]
            pub const fn vlcd(&self) -> super::vals::Vlcd {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Vlcd::from_bits(val as u8)
            }
            #[doc = "Reference Voltage Select (Contrast Adjustment)"]
            #[inline(always)]
            pub fn set_vlcd(&mut self, val: super::vals::Vlcd) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u8) & 0x1f) << 0usize);
            }
            #[doc = "Reference Voltage Selection"]
            #[inline(always)]
            pub const fn mdset2(&self) -> super::vals::Mdset2 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Mdset2::from_bits(val as u8)
            }
            #[doc = "Reference Voltage Selection"]
            #[inline(always)]
            pub fn set_mdset2(&mut self, val: super::vals::Mdset2) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Vlcd {
            #[inline(always)]
            fn default() -> Vlcd {
                Vlcd(0)
            }
        }
        impl core::fmt::Debug for Vlcd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vlcd")
                    .field("vlcd", &self.vlcd())
                    .field("mdset2", &self.mdset2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vlcd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Vlcd {{ vlcd: {:?}, mdset2: {:?} }}",
                    self.vlcd(),
                    self.mdset2()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Blon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Blon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Blon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Blon {
            #[inline(always)]
            fn from(val: u8) -> Blon {
                Blon::from_bits(val)
            }
        }
        impl From<Blon> for u8 {
            #[inline(always)]
            fn from(val: Blon) -> u8 {
                Blon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lbas {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lbas {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lbas {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lbas {
            #[inline(always)]
            fn from(val: u8) -> Lbas {
                Lbas::from_bits(val)
            }
        }
        impl From<Lbas> for u8 {
            #[inline(always)]
            fn from(val: Lbas) -> u8 {
                Lbas::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcdc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
            _RESERVED_20 = 0x20,
            _RESERVED_21 = 0x21,
            _RESERVED_22 = 0x22,
            _RESERVED_23 = 0x23,
            _RESERVED_24 = 0x24,
            _RESERVED_25 = 0x25,
            _RESERVED_26 = 0x26,
            _RESERVED_27 = 0x27,
            _RESERVED_28 = 0x28,
            _RESERVED_29 = 0x29,
            _RESERVED_2a = 0x2a,
            _RESERVED_2b = 0x2b,
            _RESERVED_2c = 0x2c,
            _RESERVED_2d = 0x2d,
            _RESERVED_2e = 0x2e,
            _RESERVED_2f = 0x2f,
            _RESERVED_30 = 0x30,
            _RESERVED_31 = 0x31,
            _RESERVED_32 = 0x32,
            _RESERVED_33 = 0x33,
            _RESERVED_34 = 0x34,
            _RESERVED_35 = 0x35,
            _RESERVED_36 = 0x36,
            _RESERVED_37 = 0x37,
            _RESERVED_38 = 0x38,
            _RESERVED_39 = 0x39,
            _RESERVED_3a = 0x3a,
            _RESERVED_3b = 0x3b,
            _RESERVED_3c = 0x3c,
            _RESERVED_3d = 0x3d,
            _RESERVED_3e = 0x3e,
            _RESERVED_3f = 0x3f,
        }
        impl Lcdc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcdc0 {
                unsafe { core::mem::transmute(val & 0x3f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcdc0 {
            #[inline(always)]
            fn from(val: u8) -> Lcdc0 {
                Lcdc0::from_bits(val)
            }
        }
        impl From<Lcdc0> for u8 {
            #[inline(always)]
            fn from(val: Lcdc0) -> u8 {
                Lcdc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcdon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lcdon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcdon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcdon {
            #[inline(always)]
            fn from(val: u8) -> Lcdon {
                Lcdon::from_bits(val)
            }
        }
        impl From<Lcdon> for u8 {
            #[inline(always)]
            fn from(val: Lcdon) -> u8 {
                Lcdon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcdsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lcdsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcdsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcdsel {
            #[inline(always)]
            fn from(val: u8) -> Lcdsel {
                Lcdsel::from_bits(val)
            }
        }
        impl From<Lcdsel> for u8 {
            #[inline(always)]
            fn from(val: Lcdsel) -> u8 {
                Lcdsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcdvlm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lcdvlm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcdvlm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcdvlm {
            #[inline(always)]
            fn from(val: u8) -> Lcdvlm {
                Lcdvlm::from_bits(val)
            }
        }
        impl From<Lcdvlm> for u8 {
            #[inline(always)]
            fn from(val: Lcdvlm) -> u8 {
                Lcdvlm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ldty {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ldty {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ldty {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ldty {
            #[inline(always)]
            fn from(val: u8) -> Ldty {
                Ldty::from_bits(val)
            }
        }
        impl From<Ldty> for u8 {
            #[inline(always)]
            fn from(val: Ldty) -> u8 {
                Ldty::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lwave {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lwave {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lwave {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lwave {
            #[inline(always)]
            fn from(val: u8) -> Lwave {
                Lwave::from_bits(val)
            }
        }
        impl From<Lwave> for u8 {
            #[inline(always)]
            fn from(val: Lwave) -> u8 {
                Lwave::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mdset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mdset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mdset {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mdset {
            #[inline(always)]
            fn from(val: u8) -> Mdset {
                Mdset::from_bits(val)
            }
        }
        impl From<Mdset> for u8 {
            #[inline(always)]
            fn from(val: Mdset) -> u8 {
                Mdset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mdset2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mdset2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mdset2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mdset2 {
            #[inline(always)]
            fn from(val: u8) -> Mdset2 {
                Mdset2::from_bits(val)
            }
        }
        impl From<Mdset2> for u8 {
            #[inline(always)]
            fn from(val: Mdset2) -> u8 {
                Mdset2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scoc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scoc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scoc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scoc {
            #[inline(always)]
            fn from(val: u8) -> Scoc {
                Scoc::from_bits(val)
            }
        }
        impl From<Scoc> for u8 {
            #[inline(always)]
            fn from(val: Scoc) -> u8 {
                Scoc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vlcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Vlcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vlcd {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vlcd {
            #[inline(always)]
            fn from(val: u8) -> Vlcd {
                Vlcd::from_bits(val)
            }
        }
        impl From<Vlcd> for u8 {
            #[inline(always)]
            fn from(val: Vlcd) -> u8 {
                Vlcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vlcon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vlcon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vlcon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vlcon {
            #[inline(always)]
            fn from(val: u8) -> Vlcon {
                Vlcon::from_bits(val)
            }
        }
        impl From<Vlcon> for u8 {
            #[inline(always)]
            fn from(val: Vlcon) -> u8 {
                Vlcon::to_bits(val)
            }
        }
    }
}
pub mod spi0 {
    #[doc = "Serial Peripheral Interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spi0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Spi0 {}
    unsafe impl Sync for Spi0 {}
    impl Spi0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SPI Control Register"]
        #[inline(always)]
        pub const fn spcr(self) -> crate::common::Reg<regs::Spcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SPI Slave Select Polarity Register"]
        #[inline(always)]
        pub const fn sslp(self) -> crate::common::Reg<regs::Sslp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "SPI Pin Control Register"]
        #[inline(always)]
        pub const fn sppcr(self) -> crate::common::Reg<regs::Sppcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "SPI Status Register"]
        #[inline(always)]
        pub const fn spsr(self) -> crate::common::Reg<regs::Spsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "SPI Data Register"]
        #[inline(always)]
        pub const fn spdr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Data Register"]
        #[inline(always)]
        pub const fn spdr_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Data Register"]
        #[inline(always)]
        pub const fn spdr_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Bit Rate Register"]
        #[inline(always)]
        pub const fn spbr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "SPI Data Control Register"]
        #[inline(always)]
        pub const fn spdcr(self) -> crate::common::Reg<regs::Spdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "SPI Clock Delay Register"]
        #[inline(always)]
        pub const fn spckd(self) -> crate::common::Reg<regs::Spckd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Slave Select Negation Delay Register"]
        #[inline(always)]
        pub const fn sslnd(self) -> crate::common::Reg<regs::Sslnd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "SPI Next,Access Delay Register"]
        #[inline(always)]
        pub const fn spnd(self) -> crate::common::Reg<regs::Spnd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "SPI Control Register 2"]
        #[inline(always)]
        pub const fn spcr2(self) -> crate::common::Reg<regs::Spcr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
        #[doc = "SPI Command Register 0"]
        #[inline(always)]
        pub const fn spcmd0(self) -> crate::common::Reg<regs::Spcmd0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SPI Clock Delay Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spckd(pub u8);
        impl Spckd {
            #[doc = "RSPCK Delay Setting"]
            #[inline(always)]
            pub const fn sckdl(&self) -> super::vals::Sckdl {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Sckdl::from_bits(val as u8)
            }
            #[doc = "RSPCK Delay Setting"]
            #[inline(always)]
            pub fn set_sckdl(&mut self, val: super::vals::Sckdl) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Spckd {
            #[inline(always)]
            fn default() -> Spckd {
                Spckd(0)
            }
        }
        impl core::fmt::Debug for Spckd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spckd")
                    .field("sckdl", &self.sckdl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spckd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Spckd {{ sckdl: {:?} }}", self.sckdl())
            }
        }
        #[doc = "SPI Command Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spcmd0(pub u16);
        impl Spcmd0 {
            #[doc = "RSPCK Phase Setting"]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "RSPCK Phase Setting"]
            #[inline(always)]
            pub fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "RSPCK Polarity Setting"]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "RSPCK Polarity Setting"]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Bit Rate Division Setting"]
            #[inline(always)]
            pub const fn brdv(&self) -> super::vals::Brdv {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Brdv::from_bits(val as u8)
            }
            #[doc = "Bit Rate Division Setting"]
            #[inline(always)]
            pub fn set_brdv(&mut self, val: super::vals::Brdv) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u16) & 0x03) << 2usize);
            }
            #[doc = "SSL Signal Assertion Setting"]
            #[inline(always)]
            pub const fn ssla(&self) -> super::vals::Ssla {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Ssla::from_bits(val as u8)
            }
            #[doc = "SSL Signal Assertion Setting"]
            #[inline(always)]
            pub fn set_ssla(&mut self, val: super::vals::Ssla) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u16) & 0x07) << 4usize);
            }
            #[doc = "SPI Data Length Setting"]
            #[inline(always)]
            pub const fn spb(&self) -> super::vals::Spb {
                let val = (self.0 >> 8usize) & 0x0f;
                super::vals::Spb::from_bits(val as u8)
            }
            #[doc = "SPI Data Length Setting"]
            #[inline(always)]
            pub fn set_spb(&mut self, val: super::vals::Spb) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u16) & 0x0f) << 8usize);
            }
            #[doc = "SPI LSB First"]
            #[inline(always)]
            pub const fn lsbf(&self) -> super::vals::Lsbf {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Lsbf::from_bits(val as u8)
            }
            #[doc = "SPI LSB First"]
            #[inline(always)]
            pub fn set_lsbf(&mut self, val: super::vals::Lsbf) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "SPI Next,Access Delay Enable"]
            #[inline(always)]
            pub const fn spnden(&self) -> super::vals::Spnden {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Spnden::from_bits(val as u8)
            }
            #[doc = "SPI Next,Access Delay Enable"]
            #[inline(always)]
            pub fn set_spnden(&mut self, val: super::vals::Spnden) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "SSL Negation Delay Setting Enable"]
            #[inline(always)]
            pub const fn slnden(&self) -> super::vals::Slnden {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Slnden::from_bits(val as u8)
            }
            #[doc = "SSL Negation Delay Setting Enable"]
            #[inline(always)]
            pub fn set_slnden(&mut self, val: super::vals::Slnden) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "RSPCK Delay Setting Enable"]
            #[inline(always)]
            pub const fn sckden(&self) -> super::vals::Sckden {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sckden::from_bits(val as u8)
            }
            #[doc = "RSPCK Delay Setting Enable"]
            #[inline(always)]
            pub fn set_sckden(&mut self, val: super::vals::Sckden) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Spcmd0 {
            #[inline(always)]
            fn default() -> Spcmd0 {
                Spcmd0(0)
            }
        }
        impl core::fmt::Debug for Spcmd0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spcmd0")
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .field("brdv", &self.brdv())
                    .field("ssla", &self.ssla())
                    .field("spb", &self.spb())
                    .field("lsbf", &self.lsbf())
                    .field("spnden", &self.spnden())
                    .field("slnden", &self.slnden())
                    .field("sckden", &self.sckden())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spcmd0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spcmd0 {{ cpha: {:?}, cpol: {:?}, brdv: {:?}, ssla: {:?}, spb: {:?}, lsbf: {:?}, spnden: {:?}, slnden: {:?}, sckden: {:?} }}" , self . cpha () , self . cpol () , self . brdv () , self . ssla () , self . spb () , self . lsbf () , self . spnden () , self . slnden () , self . sckden ())
            }
        }
        #[doc = "SPI Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spcr(pub u8);
        impl Spcr {
            #[doc = "SPI Mode Select"]
            #[inline(always)]
            pub const fn spms(&self) -> super::vals::Spms {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Spms::from_bits(val as u8)
            }
            #[doc = "SPI Mode Select"]
            #[inline(always)]
            pub fn set_spms(&mut self, val: super::vals::Spms) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Communications Operating Mode Select"]
            #[inline(always)]
            pub const fn txmd(&self) -> super::vals::Txmd {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Txmd::from_bits(val as u8)
            }
            #[doc = "Communications Operating Mode Select"]
            #[inline(always)]
            pub fn set_txmd(&mut self, val: super::vals::Txmd) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Mode Fault Error Detection Enable"]
            #[inline(always)]
            pub const fn modfen(&self) -> super::vals::Modfen {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Modfen::from_bits(val as u8)
            }
            #[doc = "Mode Fault Error Detection Enable"]
            #[inline(always)]
            pub fn set_modfen(&mut self, val: super::vals::Modfen) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "SPI Master/Slave Mode Select"]
            #[inline(always)]
            pub const fn mstr(&self) -> super::vals::Mstr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mstr::from_bits(val as u8)
            }
            #[doc = "SPI Master/Slave Mode Select"]
            #[inline(always)]
            pub fn set_mstr(&mut self, val: super::vals::Mstr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SPI Error Interrupt Enable"]
            #[inline(always)]
            pub const fn speie(&self) -> super::vals::Speie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Speie::from_bits(val as u8)
            }
            #[doc = "SPI Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_speie(&mut self, val: super::vals::Speie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub const fn sptie(&self) -> super::vals::Sptie {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Sptie::from_bits(val as u8)
            }
            #[doc = "Transmit Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub fn set_sptie(&mut self, val: super::vals::Sptie) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SPI Function Enable"]
            #[inline(always)]
            pub const fn spe(&self) -> super::vals::Spe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Spe::from_bits(val as u8)
            }
            #[doc = "SPI Function Enable"]
            #[inline(always)]
            pub fn set_spe(&mut self, val: super::vals::Spe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "SPI Receive Buffer Full Interrupt Enable"]
            #[inline(always)]
            pub const fn sprie(&self) -> super::vals::Sprie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sprie::from_bits(val as u8)
            }
            #[doc = "SPI Receive Buffer Full Interrupt Enable"]
            #[inline(always)]
            pub fn set_sprie(&mut self, val: super::vals::Sprie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spcr {
            #[inline(always)]
            fn default() -> Spcr {
                Spcr(0)
            }
        }
        impl core::fmt::Debug for Spcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spcr")
                    .field("spms", &self.spms())
                    .field("txmd", &self.txmd())
                    .field("modfen", &self.modfen())
                    .field("mstr", &self.mstr())
                    .field("speie", &self.speie())
                    .field("sptie", &self.sptie())
                    .field("spe", &self.spe())
                    .field("sprie", &self.sprie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spcr {{ spms: {:?}, txmd: {:?}, modfen: {:?}, mstr: {:?}, speie: {:?}, sptie: {:?}, spe: {:?}, sprie: {:?} }}" , self . spms () , self . txmd () , self . modfen () , self . mstr () , self . speie () , self . sptie () , self . spe () , self . sprie ())
            }
        }
        #[doc = "SPI Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spcr2(pub u8);
        impl Spcr2 {
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub const fn sppe(&self) -> super::vals::Sppe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sppe::from_bits(val as u8)
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub fn set_sppe(&mut self, val: super::vals::Sppe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub const fn spoe(&self) -> super::vals::Spoe {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spoe::from_bits(val as u8)
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub fn set_spoe(&mut self, val: super::vals::Spoe) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "SPI Idle Interrupt Enable"]
            #[inline(always)]
            pub const fn spiie(&self) -> super::vals::Spiie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Spiie::from_bits(val as u8)
            }
            #[doc = "SPI Idle Interrupt Enable"]
            #[inline(always)]
            pub fn set_spiie(&mut self, val: super::vals::Spiie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Self,Testing"]
            #[inline(always)]
            pub const fn pte(&self) -> super::vals::Pte {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pte::from_bits(val as u8)
            }
            #[doc = "Parity Self,Testing"]
            #[inline(always)]
            pub fn set_pte(&mut self, val: super::vals::Pte) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "RSPCK Auto,Stop Function Enable"]
            #[inline(always)]
            pub const fn sckase(&self) -> super::vals::Sckase {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sckase::from_bits(val as u8)
            }
            #[doc = "RSPCK Auto,Stop Function Enable"]
            #[inline(always)]
            pub fn set_sckase(&mut self, val: super::vals::Sckase) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Spcr2 {
            #[inline(always)]
            fn default() -> Spcr2 {
                Spcr2(0)
            }
        }
        impl core::fmt::Debug for Spcr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spcr2")
                    .field("sppe", &self.sppe())
                    .field("spoe", &self.spoe())
                    .field("spiie", &self.spiie())
                    .field("pte", &self.pte())
                    .field("sckase", &self.sckase())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spcr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Spcr2 {{ sppe: {:?}, spoe: {:?}, spiie: {:?}, pte: {:?}, sckase: {:?} }}",
                    self.sppe(),
                    self.spoe(),
                    self.spiie(),
                    self.pte(),
                    self.sckase()
                )
            }
        }
        #[doc = "SPI Data Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spdcr(pub u8);
        impl Spdcr {
            #[doc = "SPI Receive/Transmit Data Select"]
            #[inline(always)]
            pub const fn sprdtd(&self) -> super::vals::Sprdtd {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sprdtd::from_bits(val as u8)
            }
            #[doc = "SPI Receive/Transmit Data Select"]
            #[inline(always)]
            pub fn set_sprdtd(&mut self, val: super::vals::Sprdtd) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "SPI Word Access/Halfword Access Specification"]
            #[inline(always)]
            pub const fn splw(&self) -> super::vals::Splw {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Splw::from_bits(val as u8)
            }
            #[doc = "SPI Word Access/Halfword Access Specification"]
            #[inline(always)]
            pub fn set_splw(&mut self, val: super::vals::Splw) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SPI Byte Access Specification"]
            #[inline(always)]
            pub const fn spbyt(&self) -> super::vals::Spbyt {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Spbyt::from_bits(val as u8)
            }
            #[doc = "SPI Byte Access Specification"]
            #[inline(always)]
            pub fn set_spbyt(&mut self, val: super::vals::Spbyt) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Spdcr {
            #[inline(always)]
            fn default() -> Spdcr {
                Spdcr(0)
            }
        }
        impl core::fmt::Debug for Spdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spdcr")
                    .field("sprdtd", &self.sprdtd())
                    .field("splw", &self.splw())
                    .field("spbyt", &self.spbyt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Spdcr {{ sprdtd: {:?}, splw: {:?}, spbyt: {:?} }}",
                    self.sprdtd(),
                    self.splw(),
                    self.spbyt()
                )
            }
        }
        #[doc = "SPI Next,Access Delay Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spnd(pub u8);
        impl Spnd {
            #[doc = "SPI Next,Access Delay Setting"]
            #[inline(always)]
            pub const fn spndl(&self) -> super::vals::Spndl {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Spndl::from_bits(val as u8)
            }
            #[doc = "SPI Next,Access Delay Setting"]
            #[inline(always)]
            pub fn set_spndl(&mut self, val: super::vals::Spndl) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Spnd {
            #[inline(always)]
            fn default() -> Spnd {
                Spnd(0)
            }
        }
        impl core::fmt::Debug for Spnd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spnd")
                    .field("spndl", &self.spndl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spnd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Spnd {{ spndl: {:?} }}", self.spndl())
            }
        }
        #[doc = "SPI Pin Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sppcr(pub u8);
        impl Sppcr {
            #[doc = "SPI Loopback"]
            #[inline(always)]
            pub const fn splp(&self) -> super::vals::Splp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Splp::from_bits(val as u8)
            }
            #[doc = "SPI Loopback"]
            #[inline(always)]
            pub fn set_splp(&mut self, val: super::vals::Splp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SPI Loopback 2"]
            #[inline(always)]
            pub const fn splp2(&self) -> super::vals::Splp2 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Splp2::from_bits(val as u8)
            }
            #[doc = "SPI Loopback 2"]
            #[inline(always)]
            pub fn set_splp2(&mut self, val: super::vals::Splp2) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "MOSI Idle Fixed Value"]
            #[inline(always)]
            pub const fn moifv(&self) -> super::vals::Moifv {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Moifv::from_bits(val as u8)
            }
            #[doc = "MOSI Idle Fixed Value"]
            #[inline(always)]
            pub fn set_moifv(&mut self, val: super::vals::Moifv) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "MOSI Idle Value Fixing Enable"]
            #[inline(always)]
            pub const fn moife(&self) -> super::vals::Moife {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Moife::from_bits(val as u8)
            }
            #[doc = "MOSI Idle Value Fixing Enable"]
            #[inline(always)]
            pub fn set_moife(&mut self, val: super::vals::Moife) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Sppcr {
            #[inline(always)]
            fn default() -> Sppcr {
                Sppcr(0)
            }
        }
        impl core::fmt::Debug for Sppcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sppcr")
                    .field("splp", &self.splp())
                    .field("splp2", &self.splp2())
                    .field("moifv", &self.moifv())
                    .field("moife", &self.moife())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sppcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sppcr {{ splp: {:?}, splp2: {:?}, moifv: {:?}, moife: {:?} }}",
                    self.splp(),
                    self.splp2(),
                    self.moifv(),
                    self.moife()
                )
            }
        }
        #[doc = "SPI Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spsr(pub u8);
        impl Spsr {
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn ovrf(&self) -> super::vals::Ovrf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ovrf::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_ovrf(&mut self, val: super::vals::Ovrf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SPI Idle Flag"]
            #[inline(always)]
            pub const fn idlnf(&self) -> super::vals::Idlnf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Idlnf::from_bits(val as u8)
            }
            #[doc = "SPI Idle Flag"]
            #[inline(always)]
            pub fn set_idlnf(&mut self, val: super::vals::Idlnf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Mode Fault Error Flag"]
            #[inline(always)]
            pub const fn modf(&self) -> super::vals::Modf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Modf::from_bits(val as u8)
            }
            #[doc = "Mode Fault Error Flag"]
            #[inline(always)]
            pub fn set_modf(&mut self, val: super::vals::Modf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn perf(&self) -> super::vals::Perf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Perf::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_perf(&mut self, val: super::vals::Perf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Underrun Error Flag"]
            #[inline(always)]
            pub const fn udrf(&self) -> super::vals::Udrf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Udrf::from_bits(val as u8)
            }
            #[doc = "Underrun Error Flag"]
            #[inline(always)]
            pub fn set_udrf(&mut self, val: super::vals::Udrf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "SPI Transmit Buffer Empty Flag"]
            #[inline(always)]
            pub const fn sptef(&self) -> super::vals::Sptef {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Sptef::from_bits(val as u8)
            }
            #[doc = "SPI Transmit Buffer Empty Flag"]
            #[inline(always)]
            pub fn set_sptef(&mut self, val: super::vals::Sptef) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SPI Receive Buffer Full Flag"]
            #[inline(always)]
            pub const fn sprf(&self) -> super::vals::Sprf {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sprf::from_bits(val as u8)
            }
            #[doc = "SPI Receive Buffer Full Flag"]
            #[inline(always)]
            pub fn set_sprf(&mut self, val: super::vals::Sprf) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spsr {
            #[inline(always)]
            fn default() -> Spsr {
                Spsr(0)
            }
        }
        impl core::fmt::Debug for Spsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spsr")
                    .field("ovrf", &self.ovrf())
                    .field("idlnf", &self.idlnf())
                    .field("modf", &self.modf())
                    .field("perf", &self.perf())
                    .field("udrf", &self.udrf())
                    .field("sptef", &self.sptef())
                    .field("sprf", &self.sprf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spsr {{ ovrf: {:?}, idlnf: {:?}, modf: {:?}, perf: {:?}, udrf: {:?}, sptef: {:?}, sprf: {:?} }}" , self . ovrf () , self . idlnf () , self . modf () , self . perf () , self . udrf () , self . sptef () , self . sprf ())
            }
        }
        #[doc = "SPI Slave Select Negation Delay Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sslnd(pub u8);
        impl Sslnd {
            #[doc = "SSL Negation Delay Setting"]
            #[inline(always)]
            pub const fn slndl(&self) -> super::vals::Slndl {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Slndl::from_bits(val as u8)
            }
            #[doc = "SSL Negation Delay Setting"]
            #[inline(always)]
            pub fn set_slndl(&mut self, val: super::vals::Slndl) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Sslnd {
            #[inline(always)]
            fn default() -> Sslnd {
                Sslnd(0)
            }
        }
        impl core::fmt::Debug for Sslnd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sslnd")
                    .field("slndl", &self.slndl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sslnd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sslnd {{ slndl: {:?} }}", self.slndl())
            }
        }
        #[doc = "SPI Slave Select Polarity Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sslp(pub u8);
        impl Sslp {
            #[doc = "SSLn0 Signal Polarity Setting"]
            #[inline(always)]
            pub const fn ssl0p(&self) -> super::vals::Ssl0p {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssl0p::from_bits(val as u8)
            }
            #[doc = "SSLn0 Signal Polarity Setting"]
            #[inline(always)]
            pub fn set_ssl0p(&mut self, val: super::vals::Ssl0p) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SSLn1 Signal Polarity Setting"]
            #[inline(always)]
            pub const fn ssl1p(&self) -> super::vals::Ssl1p {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssl1p::from_bits(val as u8)
            }
            #[doc = "SSLn1 Signal Polarity Setting"]
            #[inline(always)]
            pub fn set_ssl1p(&mut self, val: super::vals::Ssl1p) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "SSLn2 Signal Polarity Setting"]
            #[inline(always)]
            pub const fn ssl2p(&self) -> super::vals::Ssl2p {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ssl2p::from_bits(val as u8)
            }
            #[doc = "SSLn2 Signal Polarity Setting"]
            #[inline(always)]
            pub fn set_ssl2p(&mut self, val: super::vals::Ssl2p) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "SSLn3 Signal Polarity Setting"]
            #[inline(always)]
            pub const fn ssl3p(&self) -> super::vals::Ssl3p {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ssl3p::from_bits(val as u8)
            }
            #[doc = "SSLn3 Signal Polarity Setting"]
            #[inline(always)]
            pub fn set_ssl3p(&mut self, val: super::vals::Ssl3p) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
        }
        impl Default for Sslp {
            #[inline(always)]
            fn default() -> Sslp {
                Sslp(0)
            }
        }
        impl core::fmt::Debug for Sslp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sslp")
                    .field("ssl0p", &self.ssl0p())
                    .field("ssl1p", &self.ssl1p())
                    .field("ssl2p", &self.ssl2p())
                    .field("ssl3p", &self.ssl3p())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sslp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sslp {{ ssl0p: {:?}, ssl1p: {:?}, ssl2p: {:?}, ssl3p: {:?} }}",
                    self.ssl0p(),
                    self.ssl1p(),
                    self.ssl2p(),
                    self.ssl3p()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brdv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Brdv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brdv {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brdv {
            #[inline(always)]
            fn from(val: u8) -> Brdv {
                Brdv::from_bits(val)
            }
        }
        impl From<Brdv> for u8 {
            #[inline(always)]
            fn from(val: Brdv) -> u8 {
                Brdv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idlnf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idlnf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idlnf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idlnf {
            #[inline(always)]
            fn from(val: u8) -> Idlnf {
                Idlnf::from_bits(val)
            }
        }
        impl From<Idlnf> for u8 {
            #[inline(always)]
            fn from(val: Idlnf) -> u8 {
                Idlnf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lsbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lsbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lsbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lsbf {
            #[inline(always)]
            fn from(val: u8) -> Lsbf {
                Lsbf::from_bits(val)
            }
        }
        impl From<Lsbf> for u8 {
            #[inline(always)]
            fn from(val: Lsbf) -> u8 {
                Lsbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Modf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modf {
            #[inline(always)]
            fn from(val: u8) -> Modf {
                Modf::from_bits(val)
            }
        }
        impl From<Modf> for u8 {
            #[inline(always)]
            fn from(val: Modf) -> u8 {
                Modf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Modfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modfen {
            #[inline(always)]
            fn from(val: u8) -> Modfen {
                Modfen::from_bits(val)
            }
        }
        impl From<Modfen> for u8 {
            #[inline(always)]
            fn from(val: Modfen) -> u8 {
                Modfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moife {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moife {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moife {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moife {
            #[inline(always)]
            fn from(val: u8) -> Moife {
                Moife::from_bits(val)
            }
        }
        impl From<Moife> for u8 {
            #[inline(always)]
            fn from(val: Moife) -> u8 {
                Moife::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moifv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moifv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moifv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moifv {
            #[inline(always)]
            fn from(val: u8) -> Moifv {
                Moifv::from_bits(val)
            }
        }
        impl From<Moifv> for u8 {
            #[inline(always)]
            fn from(val: Moifv) -> u8 {
                Moifv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstr {
            #[inline(always)]
            fn from(val: u8) -> Mstr {
                Mstr::from_bits(val)
            }
        }
        impl From<Mstr> for u8 {
            #[inline(always)]
            fn from(val: Mstr) -> u8 {
                Mstr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovrf {
            #[inline(always)]
            fn from(val: u8) -> Ovrf {
                Ovrf::from_bits(val)
            }
        }
        impl From<Ovrf> for u8 {
            #[inline(always)]
            fn from(val: Ovrf) -> u8 {
                Ovrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Perf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Perf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Perf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Perf {
            #[inline(always)]
            fn from(val: u8) -> Perf {
                Perf::from_bits(val)
            }
        }
        impl From<Perf> for u8 {
            #[inline(always)]
            fn from(val: Perf) -> u8 {
                Perf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pte {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pte {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pte {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pte {
            #[inline(always)]
            fn from(val: u8) -> Pte {
                Pte::from_bits(val)
            }
        }
        impl From<Pte> for u8 {
            #[inline(always)]
            fn from(val: Pte) -> u8 {
                Pte::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckase {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sckase {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckase {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckase {
            #[inline(always)]
            fn from(val: u8) -> Sckase {
                Sckase::from_bits(val)
            }
        }
        impl From<Sckase> for u8 {
            #[inline(always)]
            fn from(val: Sckase) -> u8 {
                Sckase::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckden {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sckden {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckden {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckden {
            #[inline(always)]
            fn from(val: u8) -> Sckden {
                Sckden::from_bits(val)
            }
        }
        impl From<Sckden> for u8 {
            #[inline(always)]
            fn from(val: Sckden) -> u8 {
                Sckden::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckdl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sckdl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckdl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckdl {
            #[inline(always)]
            fn from(val: u8) -> Sckdl {
                Sckdl::from_bits(val)
            }
        }
        impl From<Sckdl> for u8 {
            #[inline(always)]
            fn from(val: Sckdl) -> u8 {
                Sckdl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slnden {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Slnden {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slnden {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slnden {
            #[inline(always)]
            fn from(val: u8) -> Slnden {
                Slnden::from_bits(val)
            }
        }
        impl From<Slnden> for u8 {
            #[inline(always)]
            fn from(val: Slnden) -> u8 {
                Slnden::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slndl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Slndl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slndl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slndl {
            #[inline(always)]
            fn from(val: u8) -> Slndl {
                Slndl::from_bits(val)
            }
        }
        impl From<Slndl> for u8 {
            #[inline(always)]
            fn from(val: Slndl) -> u8 {
                Slndl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Spb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb {
            #[inline(always)]
            fn from(val: u8) -> Spb {
                Spb::from_bits(val)
            }
        }
        impl From<Spb> for u8 {
            #[inline(always)]
            fn from(val: Spb) -> u8 {
                Spb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spbyt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spbyt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spbyt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spbyt {
            #[inline(always)]
            fn from(val: u8) -> Spbyt {
                Spbyt::from_bits(val)
            }
        }
        impl From<Spbyt> for u8 {
            #[inline(always)]
            fn from(val: Spbyt) -> u8 {
                Spbyt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spe {
            #[inline(always)]
            fn from(val: u8) -> Spe {
                Spe::from_bits(val)
            }
        }
        impl From<Spe> for u8 {
            #[inline(always)]
            fn from(val: Spe) -> u8 {
                Spe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Speie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Speie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Speie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Speie {
            #[inline(always)]
            fn from(val: u8) -> Speie {
                Speie::from_bits(val)
            }
        }
        impl From<Speie> for u8 {
            #[inline(always)]
            fn from(val: Speie) -> u8 {
                Speie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spiie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spiie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spiie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spiie {
            #[inline(always)]
            fn from(val: u8) -> Spiie {
                Spiie::from_bits(val)
            }
        }
        impl From<Spiie> for u8 {
            #[inline(always)]
            fn from(val: Spiie) -> u8 {
                Spiie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Splp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Splp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Splp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Splp {
            #[inline(always)]
            fn from(val: u8) -> Splp {
                Splp::from_bits(val)
            }
        }
        impl From<Splp> for u8 {
            #[inline(always)]
            fn from(val: Splp) -> u8 {
                Splp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Splp2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Splp2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Splp2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Splp2 {
            #[inline(always)]
            fn from(val: u8) -> Splp2 {
                Splp2::from_bits(val)
            }
        }
        impl From<Splp2> for u8 {
            #[inline(always)]
            fn from(val: Splp2) -> u8 {
                Splp2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Splw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Splw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Splw {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Splw {
            #[inline(always)]
            fn from(val: u8) -> Splw {
                Splw::from_bits(val)
            }
        }
        impl From<Splw> for u8 {
            #[inline(always)]
            fn from(val: Splw) -> u8 {
                Splw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spms {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spms {
            #[inline(always)]
            fn from(val: u8) -> Spms {
                Spms::from_bits(val)
            }
        }
        impl From<Spms> for u8 {
            #[inline(always)]
            fn from(val: Spms) -> u8 {
                Spms::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spnden {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spnden {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spnden {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spnden {
            #[inline(always)]
            fn from(val: u8) -> Spnden {
                Spnden::from_bits(val)
            }
        }
        impl From<Spnden> for u8 {
            #[inline(always)]
            fn from(val: Spnden) -> u8 {
                Spnden::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spndl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Spndl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spndl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spndl {
            #[inline(always)]
            fn from(val: u8) -> Spndl {
                Spndl::from_bits(val)
            }
        }
        impl From<Spndl> for u8 {
            #[inline(always)]
            fn from(val: Spndl) -> u8 {
                Spndl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spoe {
            #[inline(always)]
            fn from(val: u8) -> Spoe {
                Spoe::from_bits(val)
            }
        }
        impl From<Spoe> for u8 {
            #[inline(always)]
            fn from(val: Spoe) -> u8 {
                Spoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sppe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sppe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sppe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sppe {
            #[inline(always)]
            fn from(val: u8) -> Sppe {
                Sppe::from_bits(val)
            }
        }
        impl From<Sppe> for u8 {
            #[inline(always)]
            fn from(val: Sppe) -> u8 {
                Sppe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprdtd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sprdtd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprdtd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprdtd {
            #[inline(always)]
            fn from(val: u8) -> Sprdtd {
                Sprdtd::from_bits(val)
            }
        }
        impl From<Sprdtd> for u8 {
            #[inline(always)]
            fn from(val: Sprdtd) -> u8 {
                Sprdtd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sprf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprf {
            #[inline(always)]
            fn from(val: u8) -> Sprf {
                Sprf::from_bits(val)
            }
        }
        impl From<Sprf> for u8 {
            #[inline(always)]
            fn from(val: Sprf) -> u8 {
                Sprf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sprie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprie {
            #[inline(always)]
            fn from(val: u8) -> Sprie {
                Sprie::from_bits(val)
            }
        }
        impl From<Sprie> for u8 {
            #[inline(always)]
            fn from(val: Sprie) -> u8 {
                Sprie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sptef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sptef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sptef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sptef {
            #[inline(always)]
            fn from(val: u8) -> Sptef {
                Sptef::from_bits(val)
            }
        }
        impl From<Sptef> for u8 {
            #[inline(always)]
            fn from(val: Sptef) -> u8 {
                Sptef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sptie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sptie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sptie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sptie {
            #[inline(always)]
            fn from(val: u8) -> Sptie {
                Sptie::from_bits(val)
            }
        }
        impl From<Sptie> for u8 {
            #[inline(always)]
            fn from(val: Sptie) -> u8 {
                Sptie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssl0p {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssl0p {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssl0p {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssl0p {
            #[inline(always)]
            fn from(val: u8) -> Ssl0p {
                Ssl0p::from_bits(val)
            }
        }
        impl From<Ssl0p> for u8 {
            #[inline(always)]
            fn from(val: Ssl0p) -> u8 {
                Ssl0p::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssl1p {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssl1p {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssl1p {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssl1p {
            #[inline(always)]
            fn from(val: u8) -> Ssl1p {
                Ssl1p::from_bits(val)
            }
        }
        impl From<Ssl1p> for u8 {
            #[inline(always)]
            fn from(val: Ssl1p) -> u8 {
                Ssl1p::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssl2p {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssl2p {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssl2p {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssl2p {
            #[inline(always)]
            fn from(val: u8) -> Ssl2p {
                Ssl2p::from_bits(val)
            }
        }
        impl From<Ssl2p> for u8 {
            #[inline(always)]
            fn from(val: Ssl2p) -> u8 {
                Ssl2p::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssl3p {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssl3p {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssl3p {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssl3p {
            #[inline(always)]
            fn from(val: u8) -> Ssl3p {
                Ssl3p::from_bits(val)
            }
        }
        impl From<Ssl3p> for u8 {
            #[inline(always)]
            fn from(val: Ssl3p) -> u8 {
                Ssl3p::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssla {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ssla {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssla {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssla {
            #[inline(always)]
            fn from(val: u8) -> Ssla {
                Ssla::from_bits(val)
            }
        }
        impl From<Ssla> for u8 {
            #[inline(always)]
            fn from(val: Ssla) -> u8 {
                Ssla::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Txmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txmd {
            #[inline(always)]
            fn from(val: u8) -> Txmd {
                Txmd::from_bits(val)
            }
        }
        impl From<Txmd> for u8 {
            #[inline(always)]
            fn from(val: Txmd) -> u8 {
                Txmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Udrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Udrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Udrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Udrf {
            #[inline(always)]
            fn from(val: u8) -> Udrf {
                Udrf::from_bits(val)
            }
        }
        impl From<Udrf> for u8 {
            #[inline(always)]
            fn from(val: Udrf) -> u8 {
                Udrf::to_bits(val)
            }
        }
    }
}
pub mod sram {
    #[doc = "SRAM Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sram {
        ptr: *mut u8,
    }
    unsafe impl Send for Sram {}
    unsafe impl Sync for Sram {}
    impl Sram {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SRAM Parity Error Operation After Detection Register"]
        #[inline(always)]
        pub const fn parioad(self) -> crate::common::Reg<regs::Parioad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SRAM Protection Register"]
        #[inline(always)]
        pub const fn sramprcr(self) -> crate::common::Reg<regs::Sramprcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "ECC Operating Mode Control Register"]
        #[inline(always)]
        pub const fn eccmode(self) -> crate::common::Reg<regs::Eccmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "ECC 2-Bit Error Status Register"]
        #[inline(always)]
        pub const fn ecc2sts(self) -> crate::common::Reg<regs::Ecc2sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc1usize) as _) }
        }
        #[doc = "ECC 1-Bit Error Information Update Enable Register"]
        #[inline(always)]
        pub const fn ecc1stsen(self) -> crate::common::Reg<regs::Ecc1stsen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc2usize) as _) }
        }
        #[doc = "ECC 1-Bit Error Status Register"]
        #[inline(always)]
        pub const fn ecc1sts(self) -> crate::common::Reg<regs::Ecc1sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc3usize) as _) }
        }
        #[doc = "ECC Protection Register"]
        #[inline(always)]
        pub const fn eccprcr(self) -> crate::common::Reg<regs::Eccprcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc4usize) as _) }
        }
        #[doc = "ECC Protection Register 2"]
        #[inline(always)]
        pub const fn eccprcr2(self) -> crate::common::Reg<regs::Eccprcr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
        }
        #[doc = "ECC Test Control Register"]
        #[inline(always)]
        pub const fn eccetst(self) -> crate::common::Reg<regs::Eccetst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
        }
        #[doc = "SRAM ECC Error Operation After Detection Register"]
        #[inline(always)]
        pub const fn eccoad(self) -> crate::common::Reg<regs::Eccoad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "ECC 1-Bit Error Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ecc1sts(pub u8);
        impl Ecc1sts {
            #[doc = "ECC 1-Bit Error Status"]
            #[inline(always)]
            pub const fn ecc1err(&self) -> super::vals::Ecc1err {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ecc1err::from_bits(val as u8)
            }
            #[doc = "ECC 1-Bit Error Status"]
            #[inline(always)]
            pub fn set_ecc1err(&mut self, val: super::vals::Ecc1err) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Ecc1sts {
            #[inline(always)]
            fn default() -> Ecc1sts {
                Ecc1sts(0)
            }
        }
        impl core::fmt::Debug for Ecc1sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ecc1sts")
                    .field("ecc1err", &self.ecc1err())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ecc1sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ecc1sts {{ ecc1err: {:?} }}", self.ecc1err())
            }
        }
        #[doc = "ECC 1-Bit Error Information Update Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ecc1stsen(pub u8);
        impl Ecc1stsen {
            #[doc = "ECC 1-Bit Error Information Update Enable"]
            #[inline(always)]
            pub const fn e1stsen(&self) -> super::vals::E1stsen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::E1stsen::from_bits(val as u8)
            }
            #[doc = "ECC 1-Bit Error Information Update Enable"]
            #[inline(always)]
            pub fn set_e1stsen(&mut self, val: super::vals::E1stsen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Ecc1stsen {
            #[inline(always)]
            fn default() -> Ecc1stsen {
                Ecc1stsen(0)
            }
        }
        impl core::fmt::Debug for Ecc1stsen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ecc1stsen")
                    .field("e1stsen", &self.e1stsen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ecc1stsen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ecc1stsen {{ e1stsen: {:?} }}", self.e1stsen())
            }
        }
        #[doc = "ECC 2-Bit Error Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ecc2sts(pub u8);
        impl Ecc2sts {
            #[doc = "ECC 2-Bit Error Status"]
            #[inline(always)]
            pub const fn ecc2err(&self) -> super::vals::Ecc2err {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ecc2err::from_bits(val as u8)
            }
            #[doc = "ECC 2-Bit Error Status"]
            #[inline(always)]
            pub fn set_ecc2err(&mut self, val: super::vals::Ecc2err) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Ecc2sts {
            #[inline(always)]
            fn default() -> Ecc2sts {
                Ecc2sts(0)
            }
        }
        impl core::fmt::Debug for Ecc2sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ecc2sts")
                    .field("ecc2err", &self.ecc2err())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ecc2sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ecc2sts {{ ecc2err: {:?} }}", self.ecc2err())
            }
        }
        #[doc = "ECC Test Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccetst(pub u8);
        impl Eccetst {
            #[doc = "ECC Bypass Select"]
            #[inline(always)]
            pub const fn tstbyp(&self) -> super::vals::Tstbyp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tstbyp::from_bits(val as u8)
            }
            #[doc = "ECC Bypass Select"]
            #[inline(always)]
            pub fn set_tstbyp(&mut self, val: super::vals::Tstbyp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Eccetst {
            #[inline(always)]
            fn default() -> Eccetst {
                Eccetst(0)
            }
        }
        impl core::fmt::Debug for Eccetst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccetst")
                    .field("tstbyp", &self.tstbyp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccetst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Eccetst {{ tstbyp: {:?} }}", self.tstbyp())
            }
        }
        #[doc = "ECC Operating Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccmode(pub u8);
        impl Eccmode {
            #[doc = "ECC Operating Mode Select"]
            #[inline(always)]
            pub const fn eccmod(&self) -> super::vals::Eccmod {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Eccmod::from_bits(val as u8)
            }
            #[doc = "ECC Operating Mode Select"]
            #[inline(always)]
            pub fn set_eccmod(&mut self, val: super::vals::Eccmod) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Eccmode {
            #[inline(always)]
            fn default() -> Eccmode {
                Eccmode(0)
            }
        }
        impl core::fmt::Debug for Eccmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccmode")
                    .field("eccmod", &self.eccmod())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccmode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Eccmode {{ eccmod: {:?} }}", self.eccmod())
            }
        }
        #[doc = "SRAM ECC Error Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccoad(pub u8);
        impl Eccoad {
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::EccoadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EccoadOad::from_bits(val as u8)
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::EccoadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Eccoad {
            #[inline(always)]
            fn default() -> Eccoad {
                Eccoad(0)
            }
        }
        impl core::fmt::Debug for Eccoad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccoad").field("oad", &self.oad()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccoad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Eccoad {{ oad: {:?} }}", self.oad())
            }
        }
        #[doc = "ECC Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccprcr(pub u8);
        impl Eccprcr {
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub const fn eccprcr(&self) -> super::vals::Eccprcr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Eccprcr::from_bits(val as u8)
            }
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub fn set_eccprcr(&mut self, val: super::vals::Eccprcr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub const fn kw(&self) -> super::vals::Kw {
                let val = (self.0 >> 1usize) & 0x7f;
                super::vals::Kw::from_bits(val as u8)
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub fn set_kw(&mut self, val: super::vals::Kw) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val.to_bits() as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Eccprcr {
            #[inline(always)]
            fn default() -> Eccprcr {
                Eccprcr(0)
            }
        }
        impl core::fmt::Debug for Eccprcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccprcr")
                    .field("eccprcr", &self.eccprcr())
                    .field("kw", &self.kw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccprcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Eccprcr {{ eccprcr: {:?}, kw: {:?} }}",
                    self.eccprcr(),
                    self.kw()
                )
            }
        }
        #[doc = "ECC Protection Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccprcr2(pub u8);
        impl Eccprcr2 {
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub const fn eccprcr2(&self) -> super::vals::Eccprcr2 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Eccprcr2::from_bits(val as u8)
            }
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub fn set_eccprcr2(&mut self, val: super::vals::Eccprcr2) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub const fn kw2(&self) -> super::vals::Kw2 {
                let val = (self.0 >> 1usize) & 0x7f;
                super::vals::Kw2::from_bits(val as u8)
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub fn set_kw2(&mut self, val: super::vals::Kw2) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val.to_bits() as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Eccprcr2 {
            #[inline(always)]
            fn default() -> Eccprcr2 {
                Eccprcr2(0)
            }
        }
        impl core::fmt::Debug for Eccprcr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccprcr2")
                    .field("eccprcr2", &self.eccprcr2())
                    .field("kw2", &self.kw2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccprcr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Eccprcr2 {{ eccprcr2: {:?}, kw2: {:?} }}",
                    self.eccprcr2(),
                    self.kw2()
                )
            }
        }
        #[doc = "SRAM Parity Error Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Parioad(pub u8);
        impl Parioad {
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::ParioadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ParioadOad::from_bits(val as u8)
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::ParioadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Parioad {
            #[inline(always)]
            fn default() -> Parioad {
                Parioad(0)
            }
        }
        impl core::fmt::Debug for Parioad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Parioad").field("oad", &self.oad()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Parioad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Parioad {{ oad: {:?} }}", self.oad())
            }
        }
        #[doc = "SRAM Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sramprcr(pub u8);
        impl Sramprcr {
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub const fn sramprcr(&self) -> super::vals::Sramprcr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sramprcr::from_bits(val as u8)
            }
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub fn set_sramprcr(&mut self, val: super::vals::Sramprcr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub const fn kw(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub fn set_kw(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Sramprcr {
            #[inline(always)]
            fn default() -> Sramprcr {
                Sramprcr(0)
            }
        }
        impl core::fmt::Debug for Sramprcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sramprcr")
                    .field("sramprcr", &self.sramprcr())
                    .field("kw", &self.kw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sramprcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sramprcr {{ sramprcr: {:?}, kw: {=u8:?} }}",
                    self.sramprcr(),
                    self.kw()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum E1stsen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl E1stsen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> E1stsen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for E1stsen {
            #[inline(always)]
            fn from(val: u8) -> E1stsen {
                E1stsen::from_bits(val)
            }
        }
        impl From<E1stsen> for u8 {
            #[inline(always)]
            fn from(val: E1stsen) -> u8 {
                E1stsen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ecc1err {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ecc1err {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ecc1err {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ecc1err {
            #[inline(always)]
            fn from(val: u8) -> Ecc1err {
                Ecc1err::from_bits(val)
            }
        }
        impl From<Ecc1err> for u8 {
            #[inline(always)]
            fn from(val: Ecc1err) -> u8 {
                Ecc1err::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ecc2err {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ecc2err {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ecc2err {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ecc2err {
            #[inline(always)]
            fn from(val: u8) -> Ecc2err {
                Ecc2err::from_bits(val)
            }
        }
        impl From<Ecc2err> for u8 {
            #[inline(always)]
            fn from(val: Ecc2err) -> u8 {
                Ecc2err::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eccmod {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Eccmod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eccmod {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eccmod {
            #[inline(always)]
            fn from(val: u8) -> Eccmod {
                Eccmod::from_bits(val)
            }
        }
        impl From<Eccmod> for u8 {
            #[inline(always)]
            fn from(val: Eccmod) -> u8 {
                Eccmod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EccoadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EccoadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EccoadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EccoadOad {
            #[inline(always)]
            fn from(val: u8) -> EccoadOad {
                EccoadOad::from_bits(val)
            }
        }
        impl From<EccoadOad> for u8 {
            #[inline(always)]
            fn from(val: EccoadOad) -> u8 {
                EccoadOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eccprcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eccprcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eccprcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eccprcr {
            #[inline(always)]
            fn from(val: u8) -> Eccprcr {
                Eccprcr::from_bits(val)
            }
        }
        impl From<Eccprcr> for u8 {
            #[inline(always)]
            fn from(val: Eccprcr) -> u8 {
                Eccprcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eccprcr2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eccprcr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eccprcr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eccprcr2 {
            #[inline(always)]
            fn from(val: u8) -> Eccprcr2 {
                Eccprcr2::from_bits(val)
            }
        }
        impl From<Eccprcr2> for u8 {
            #[inline(always)]
            fn from(val: Eccprcr2) -> u8 {
                Eccprcr2::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Kw(u8);
        impl Kw {}
        impl Kw {
            pub const fn from_bits(val: u8) -> Kw {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Kw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Kw {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Kw {
            #[inline(always)]
            fn from(val: u8) -> Kw {
                Kw::from_bits(val)
            }
        }
        impl From<Kw> for u8 {
            #[inline(always)]
            fn from(val: Kw) -> u8 {
                Kw::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Kw2(u8);
        impl Kw2 {}
        impl Kw2 {
            pub const fn from_bits(val: u8) -> Kw2 {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Kw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Kw2 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Kw2 {
            #[inline(always)]
            fn from(val: u8) -> Kw2 {
                Kw2::from_bits(val)
            }
        }
        impl From<Kw2> for u8 {
            #[inline(always)]
            fn from(val: Kw2) -> u8 {
                Kw2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ParioadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ParioadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ParioadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ParioadOad {
            #[inline(always)]
            fn from(val: u8) -> ParioadOad {
                ParioadOad::from_bits(val)
            }
        }
        impl From<ParioadOad> for u8 {
            #[inline(always)]
            fn from(val: ParioadOad) -> u8 {
                ParioadOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sramprcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sramprcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sramprcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sramprcr {
            #[inline(always)]
            fn from(val: u8) -> Sramprcr {
                Sramprcr::from_bits(val)
            }
        }
        impl From<Sramprcr> for u8 {
            #[inline(always)]
            fn from(val: Sramprcr) -> u8 {
                Sramprcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstbyp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstbyp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstbyp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstbyp {
            #[inline(always)]
            fn from(val: u8) -> Tstbyp {
                Tstbyp::from_bits(val)
            }
        }
        impl From<Tstbyp> for u8 {
            #[inline(always)]
            fn from(val: Tstbyp) -> u8 {
                Tstbyp::to_bits(val)
            }
        }
    }
}
pub mod sysc {
    #[doc = "System Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysc {
        ptr: *mut u8,
    }
    unsafe impl Send for Sysc {}
    unsafe impl Sync for Sysc {}
    impl Sysc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Standby Control Register"]
        #[inline(always)]
        pub const fn sbycr(self) -> crate::common::Reg<regs::Sbycr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Module Stop Control Register A"]
        #[inline(always)]
        pub const fn mstpcra(self) -> crate::common::Reg<regs::Mstpcra, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "System Clock Division Control Register"]
        #[inline(always)]
        pub const fn sckdivcr(self) -> crate::common::Reg<regs::Sckdivcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "System Clock Source Control Register"]
        #[inline(always)]
        pub const fn sckscr(self) -> crate::common::Reg<regs::Sckscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x26usize) as _) }
        }
        #[doc = "PLL Clock Control Register"]
        #[inline(always)]
        pub const fn pllccr(self) -> crate::common::Reg<regs::Pllccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "PLL Control Register"]
        #[inline(always)]
        pub const fn pllcr(self) -> crate::common::Reg<regs::Pllcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2ausize) as _) }
        }
        #[doc = "Memory Wait Cycle Control Register for Code Flash"]
        #[inline(always)]
        pub const fn memwait(self) -> crate::common::Reg<regs::Memwait, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x31usize) as _) }
        }
        #[doc = "Main Clock Oscillator Control Register"]
        #[inline(always)]
        pub const fn mosccr(self) -> crate::common::Reg<regs::Mosccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x32usize) as _) }
        }
        #[doc = "High,Speed On,Chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn hococr(self) -> crate::common::Reg<regs::Hococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x36usize) as _) }
        }
        #[doc = "Middle,Speed On,Chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn mococr(self) -> crate::common::Reg<regs::Mococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Oscillation Stabilization Flag Register"]
        #[inline(always)]
        pub const fn oscsf(self) -> crate::common::Reg<regs::Oscsf, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Clock Out Control Register"]
        #[inline(always)]
        pub const fn ckocr(self) -> crate::common::Reg<regs::Ckocr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3eusize) as _) }
        }
        #[doc = "Oscillation Stop Detection Control Register"]
        #[inline(always)]
        pub const fn ostdcr(self) -> crate::common::Reg<regs::Ostdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Oscillation Stop Detection Status Register"]
        #[inline(always)]
        pub const fn ostdsr(self) -> crate::common::Reg<regs::Ostdsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x41usize) as _) }
        }
        #[doc = "Lower Power Operation Control Register"]
        #[inline(always)]
        pub const fn lpopt(self) -> crate::common::Reg<regs::Lpopt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "Segment LCD Source Clock Control Register"]
        #[inline(always)]
        pub const fn slcdsckcr(self) -> crate::common::Reg<regs::Slcdsckcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "MOCO User Trimming Control Register"]
        #[inline(always)]
        pub const fn mocoutcr(self) -> crate::common::Reg<regs::Mocoutcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x61usize) as _) }
        }
        #[doc = "HOCO User Trimming Control Register"]
        #[inline(always)]
        pub const fn hocoutcr(self) -> crate::common::Reg<regs::Hocoutcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x62usize) as _) }
        }
        #[doc = "Snooze Control Register"]
        #[inline(always)]
        pub const fn snzcr(self) -> crate::common::Reg<regs::Snzcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x92usize) as _) }
        }
        #[doc = "Snooze End Control Register 0"]
        #[inline(always)]
        pub const fn snzedcr0(self) -> crate::common::Reg<regs::Snzedcr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Snooze Request Control Register 0"]
        #[inline(always)]
        pub const fn snzreqcr0(self) -> crate::common::Reg<regs::Snzreqcr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "Power Save Memory Control Register"]
        #[inline(always)]
        pub const fn psmcr(self) -> crate::common::Reg<regs::Psmcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9fusize) as _) }
        }
        #[doc = "Operating Power Control Register"]
        #[inline(always)]
        pub const fn opccr(self) -> crate::common::Reg<regs::Opccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "Main Clock Oscillator Wait Control Register"]
        #[inline(always)]
        pub const fn moscwtcr(self) -> crate::common::Reg<regs::Moscwtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa2usize) as _) }
        }
        #[doc = "High,Speed On,Chip Oscillator Wait Control Register"]
        #[inline(always)]
        pub const fn hocowtcr(self) -> crate::common::Reg<regs::Hocowtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa5usize) as _) }
        }
        #[doc = "Sub Operating Power Control Register"]
        #[inline(always)]
        pub const fn sopccr(self) -> crate::common::Reg<regs::Sopccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xaausize) as _) }
        }
        #[doc = "Reset Status Register 1"]
        #[inline(always)]
        pub const fn rstsr1(self) -> crate::common::Reg<regs::Rstsr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "24-bit Sigma,delta A/D Converter Clock Control Register"]
        #[inline(always)]
        pub const fn sdadcckcr(self) -> crate::common::Reg<regs::Sdadcckcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd1usize) as _) }
        }
        #[doc = "Sub Clock Oscillation Stop Detection Control Register"]
        #[inline(always)]
        pub const fn sostd(self) -> crate::common::Reg<regs::Sostd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd8usize) as _) }
        }
        #[doc = "Main Oscillation Stop Detection Control Register"]
        #[inline(always)]
        pub const fn mostd(self) -> crate::common::Reg<regs::Mostd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdausize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register"]
        #[inline(always)]
        pub const fn lvd1cr1(self) -> crate::common::Reg<regs::Lvd1cr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Status Register"]
        #[inline(always)]
        pub const fn lvd1sr(self) -> crate::common::Reg<regs::Lvd1sr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe1usize) as _) }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 1"]
        #[inline(always)]
        pub const fn lvd2cr1(self) -> crate::common::Reg<regs::Lvd2cr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe2usize) as _) }
        }
        #[doc = "Voltage Monitor 2 Circuit Status Register"]
        #[inline(always)]
        pub const fn lvd2sr(self) -> crate::common::Reg<regs::Lvd2sr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe3usize) as _) }
        }
        #[doc = "Protect Register"]
        #[inline(always)]
        pub const fn prcr(self) -> crate::common::Reg<regs::Prcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03feusize) as _) }
        }
        #[doc = "System Control OCD Control Register"]
        #[inline(always)]
        pub const fn syocdcr(self) -> crate::common::Reg<regs::Syocdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x040eusize) as _) }
        }
        #[doc = "Reset Status Register 0"]
        #[inline(always)]
        pub const fn rstsr0(self) -> crate::common::Reg<regs::Rstsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Reset Status Register 2"]
        #[inline(always)]
        pub const fn rstsr2(self) -> crate::common::Reg<regs::Rstsr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0411usize) as _) }
        }
        #[doc = "Main Clock Oscillator Mode Oscillation Control Register"]
        #[inline(always)]
        pub const fn momcr(self) -> crate::common::Reg<regs::Momcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0413usize) as _) }
        }
        #[doc = "Voltage Monitor Circuit Control Register"]
        #[inline(always)]
        pub const fn lvcmpcr(self) -> crate::common::Reg<regs::Lvcmpcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0417usize) as _) }
        }
        #[doc = "Voltage Detection Level Select Register"]
        #[inline(always)]
        pub const fn lvdlvlr(self) -> crate::common::Reg<regs::Lvdlvlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0418usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register 0"]
        #[inline(always)]
        pub const fn lvd1cr0(self) -> crate::common::Reg<regs::Lvd1cr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x041ausize) as _) }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 0"]
        #[inline(always)]
        pub const fn lvd2cr0(self) -> crate::common::Reg<regs::Lvd2cr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x041busize) as _) }
        }
        #[doc = "Sub,Clock Oscillator Control Register"]
        #[inline(always)]
        pub const fn sosccr(self) -> crate::common::Reg<regs::Sosccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0480usize) as _) }
        }
        #[doc = "Sub,Clock Oscillator Mode Control Register"]
        #[inline(always)]
        pub const fn somcr(self) -> crate::common::Reg<regs::Somcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0481usize) as _) }
        }
        #[doc = "Sub,Clock Oscillator Margin Check Register"]
        #[inline(always)]
        pub const fn somrg(self) -> crate::common::Reg<regs::Somrg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0482usize) as _) }
        }
        #[doc = "Low,Speed On,Chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn lococr(self) -> crate::common::Reg<regs::Lococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0490usize) as _) }
        }
        #[doc = "LOCO User Trimming Control Register"]
        #[inline(always)]
        pub const fn locoutcr(self) -> crate::common::Reg<regs::Locoutcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0492usize) as _) }
        }
        #[doc = "EXLVDVBAT Circuit Control Register"]
        #[inline(always)]
        pub const fn vbtlvdcr(self) -> crate::common::Reg<regs::Vbtlvdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c0usize) as _) }
        }
        #[doc = "EXLVDVBAT Circuit Status Register"]
        #[inline(always)]
        pub const fn vbtlvdsr(self) -> crate::common::Reg<regs::Vbtlvdsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c1usize) as _) }
        }
        #[doc = "EXLVDVBAT Comparator Control Register"]
        #[inline(always)]
        pub const fn vbtcmpcr(self) -> crate::common::Reg<regs::Vbtcmpcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c2usize) as _) }
        }
        #[doc = "EXLVDVBAT Pin Low Voltage Detect Interrupt Control Register"]
        #[inline(always)]
        pub const fn vbtlvdicr(self) -> crate::common::Reg<regs::Vbtlvdicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c3usize) as _) }
        }
        #[doc = "LVDVRTC Circuit Control Register"]
        #[inline(always)]
        pub const fn vrtlvdcr(self) -> crate::common::Reg<regs::Vrtlvdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c4usize) as _) }
        }
        #[doc = "VRTC Status Register"]
        #[inline(always)]
        pub const fn vrtsr(self) -> crate::common::Reg<regs::Vrtsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c5usize) as _) }
        }
        #[doc = "VRTC Comparator Control Register"]
        #[inline(always)]
        pub const fn vrtcmpcr(self) -> crate::common::Reg<regs::Vrtcmpcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c6usize) as _) }
        }
        #[doc = "VRTC Pin Low Voltage Detect Interrupt Control Register"]
        #[inline(always)]
        pub const fn vrtlvdicr(self) -> crate::common::Reg<regs::Vrtlvdicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c7usize) as _) }
        }
        #[doc = "EXLVD Circuit Control Register"]
        #[inline(always)]
        pub const fn exlvdcr(self) -> crate::common::Reg<regs::Exlvdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c8usize) as _) }
        }
        #[doc = "EXLVD Circuit Status Register"]
        #[inline(always)]
        pub const fn exlvdsr(self) -> crate::common::Reg<regs::Exlvdsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c9usize) as _) }
        }
        #[doc = "EXLVD Comparator Control Register"]
        #[inline(always)]
        pub const fn exlvdcmpcr(self) -> crate::common::Reg<regs::Exlvdcmpcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04causize) as _) }
        }
        #[doc = "EXLVD Pin Low Voltage Detect Interrupt Control Register"]
        #[inline(always)]
        pub const fn exlvdicr(self) -> crate::common::Reg<regs::Exlvdicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04cbusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Clock Out Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ckocr(pub u8);
        impl Ckocr {
            #[doc = "Clock Out Source Select"]
            #[inline(always)]
            pub const fn ckosel(&self) -> super::vals::Ckosel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ckosel::from_bits(val as u8)
            }
            #[doc = "Clock Out Source Select"]
            #[inline(always)]
            pub fn set_ckosel(&mut self, val: super::vals::Ckosel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Clock Output Frequency Division Ratio"]
            #[inline(always)]
            pub const fn ckodiv(&self) -> super::vals::Ckodiv {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Ckodiv::from_bits(val as u8)
            }
            #[doc = "Clock Output Frequency Division Ratio"]
            #[inline(always)]
            pub fn set_ckodiv(&mut self, val: super::vals::Ckodiv) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "Clock Out Enable"]
            #[inline(always)]
            pub const fn ckoen(&self) -> super::vals::Ckoen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ckoen::from_bits(val as u8)
            }
            #[doc = "Clock Out Enable"]
            #[inline(always)]
            pub fn set_ckoen(&mut self, val: super::vals::Ckoen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ckocr {
            #[inline(always)]
            fn default() -> Ckocr {
                Ckocr(0)
            }
        }
        impl core::fmt::Debug for Ckocr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ckocr")
                    .field("ckosel", &self.ckosel())
                    .field("ckodiv", &self.ckodiv())
                    .field("ckoen", &self.ckoen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ckocr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ckocr {{ ckosel: {:?}, ckodiv: {:?}, ckoen: {:?} }}",
                    self.ckosel(),
                    self.ckodiv(),
                    self.ckoen()
                )
            }
        }
        #[doc = "EXLVD Comparator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Exlvdcmpcr(pub u8);
        impl Exlvdcmpcr {
            #[doc = "EXLVD Pin Low Voltage Detect Circuit Output Enable"]
            #[inline(always)]
            pub const fn cmpe(&self) -> super::vals::ExlvdcmpcrCmpe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ExlvdcmpcrCmpe::from_bits(val as u8)
            }
            #[doc = "EXLVD Pin Low Voltage Detect Circuit Output Enable"]
            #[inline(always)]
            pub fn set_cmpe(&mut self, val: super::vals::ExlvdcmpcrCmpe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Exlvdcmpcr {
            #[inline(always)]
            fn default() -> Exlvdcmpcr {
                Exlvdcmpcr(0)
            }
        }
        impl core::fmt::Debug for Exlvdcmpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Exlvdcmpcr")
                    .field("cmpe", &self.cmpe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Exlvdcmpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Exlvdcmpcr {{ cmpe: {:?} }}", self.cmpe())
            }
        }
        #[doc = "EXLVD Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Exlvdcr(pub u8);
        impl Exlvdcr {
            #[doc = "EXLVD Pin Low Voltage Detect Enable"]
            #[inline(always)]
            pub const fn lvde(&self) -> super::vals::ExlvdcrLvde {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ExlvdcrLvde::from_bits(val as u8)
            }
            #[doc = "EXLVD Pin Low Voltage Detect Enable"]
            #[inline(always)]
            pub fn set_lvde(&mut self, val: super::vals::ExlvdcrLvde) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Exlvdcr {
            #[inline(always)]
            fn default() -> Exlvdcr {
                Exlvdcr(0)
            }
        }
        impl core::fmt::Debug for Exlvdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Exlvdcr")
                    .field("lvde", &self.lvde())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Exlvdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Exlvdcr {{ lvde: {:?} }}", self.lvde())
            }
        }
        #[doc = "EXLVD Pin Low Voltage Detect Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Exlvdicr(pub u8);
        impl Exlvdicr {
            #[doc = "EXLVD Pin Low Voltage Detect Interrupt Enable"]
            #[inline(always)]
            pub const fn ie(&self) -> super::vals::ExlvdicrIe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ExlvdicrIe::from_bits(val as u8)
            }
            #[doc = "EXLVD Pin Low Voltage Detect Interrupt Enable"]
            #[inline(always)]
            pub fn set_ie(&mut self, val: super::vals::ExlvdicrIe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "EXLVD Pin Low Voltage Detect Interrupt Generation Condition Select"]
            #[inline(always)]
            pub const fn idtsel(&self) -> super::vals::ExlvdicrIdtsel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::ExlvdicrIdtsel::from_bits(val as u8)
            }
            #[doc = "EXLVD Pin Low Voltage Detect Interrupt Generation Condition Select"]
            #[inline(always)]
            pub fn set_idtsel(&mut self, val: super::vals::ExlvdicrIdtsel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Exlvdicr {
            #[inline(always)]
            fn default() -> Exlvdicr {
                Exlvdicr(0)
            }
        }
        impl core::fmt::Debug for Exlvdicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Exlvdicr")
                    .field("ie", &self.ie())
                    .field("idtsel", &self.idtsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Exlvdicr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Exlvdicr {{ ie: {:?}, idtsel: {:?} }}",
                    self.ie(),
                    self.idtsel()
                )
            }
        }
        #[doc = "EXLVD Circuit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Exlvdsr(pub u8);
        impl Exlvdsr {
            #[doc = "EXLVD pin Low Voltage Detect Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::ExlvdsrDet {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ExlvdsrDet::from_bits(val as u8)
            }
            #[doc = "EXLVD pin Low Voltage Detect Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::ExlvdsrDet) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "EXLVD pin Low Voltage Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::ExlvdsrMon {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ExlvdsrMon::from_bits(val as u8)
            }
            #[doc = "EXLVD pin Low Voltage Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::ExlvdsrMon) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Exlvdsr {
            #[inline(always)]
            fn default() -> Exlvdsr {
                Exlvdsr(0)
            }
        }
        impl core::fmt::Debug for Exlvdsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Exlvdsr")
                    .field("det", &self.det())
                    .field("mon", &self.mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Exlvdsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Exlvdsr {{ det: {:?}, mon: {:?} }}",
                    self.det(),
                    self.mon()
                )
            }
        }
        #[doc = "High,Speed On,Chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hococr(pub u8);
        impl Hococr {
            #[doc = "HOCO Stop"]
            #[inline(always)]
            pub const fn hcstp(&self) -> super::vals::Hcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hcstp::from_bits(val as u8)
            }
            #[doc = "HOCO Stop"]
            #[inline(always)]
            pub fn set_hcstp(&mut self, val: super::vals::Hcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Hococr {
            #[inline(always)]
            fn default() -> Hococr {
                Hococr(0)
            }
        }
        impl core::fmt::Debug for Hococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hococr")
                    .field("hcstp", &self.hcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hococr {{ hcstp: {:?} }}", self.hcstp())
            }
        }
        #[doc = "HOCO User Trimming Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hocoutcr(pub u8);
        impl Hocoutcr {
            #[doc = "HOCO User Trimming"]
            #[inline(always)]
            pub const fn hocoutrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "HOCO User Trimming"]
            #[inline(always)]
            pub fn set_hocoutrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Hocoutcr {
            #[inline(always)]
            fn default() -> Hocoutcr {
                Hocoutcr(0)
            }
        }
        impl core::fmt::Debug for Hocoutcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hocoutcr")
                    .field("hocoutrm", &self.hocoutrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hocoutcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hocoutcr {{ hocoutrm: {=u8:?} }}", self.hocoutrm())
            }
        }
        #[doc = "High,Speed On,Chip Oscillator Wait Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hocowtcr(pub u8);
        impl Hocowtcr {
            #[doc = "HOCO Wait Time Setting"]
            #[inline(always)]
            pub const fn hsts(&self) -> super::vals::Hsts {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Hsts::from_bits(val as u8)
            }
            #[doc = "HOCO Wait Time Setting"]
            #[inline(always)]
            pub fn set_hsts(&mut self, val: super::vals::Hsts) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Hocowtcr {
            #[inline(always)]
            fn default() -> Hocowtcr {
                Hocowtcr(0)
            }
        }
        impl core::fmt::Debug for Hocowtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hocowtcr")
                    .field("hsts", &self.hsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hocowtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hocowtcr {{ hsts: {:?} }}", self.hsts())
            }
        }
        #[doc = "Low,Speed On,Chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lococr(pub u8);
        impl Lococr {
            #[doc = "LOCO Stop"]
            #[inline(always)]
            pub const fn lcstp(&self) -> super::vals::Lcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lcstp::from_bits(val as u8)
            }
            #[doc = "LOCO Stop"]
            #[inline(always)]
            pub fn set_lcstp(&mut self, val: super::vals::Lcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Lococr {
            #[inline(always)]
            fn default() -> Lococr {
                Lococr(0)
            }
        }
        impl core::fmt::Debug for Lococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lococr")
                    .field("lcstp", &self.lcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lococr {{ lcstp: {:?} }}", self.lcstp())
            }
        }
        #[doc = "LOCO User Trimming Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Locoutcr(pub u8);
        impl Locoutcr {
            #[doc = "LOCO User Trimming"]
            #[inline(always)]
            pub const fn locoutrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "LOCO User Trimming"]
            #[inline(always)]
            pub fn set_locoutrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Locoutcr {
            #[inline(always)]
            fn default() -> Locoutcr {
                Locoutcr(0)
            }
        }
        impl core::fmt::Debug for Locoutcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Locoutcr")
                    .field("locoutrm", &self.locoutrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Locoutcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Locoutcr {{ locoutrm: {=u8:?} }}", self.locoutrm())
            }
        }
        #[doc = "Lower Power Operation Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lpopt(pub u8);
        impl Lpopt {
            #[doc = "MPU Clock Disable Control"]
            #[inline(always)]
            pub const fn mpudis(&self) -> super::vals::Mpudis {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mpudis::from_bits(val as u8)
            }
            #[doc = "MPU Clock Disable Control"]
            #[inline(always)]
            pub fn set_mpudis(&mut self, val: super::vals::Mpudis) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Debug Clock Disable Control"]
            #[inline(always)]
            pub const fn dclkdis(&self) -> super::vals::Dclkdis {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Dclkdis::from_bits(val as u8)
            }
            #[doc = "Debug Clock Disable Control"]
            #[inline(always)]
            pub fn set_dclkdis(&mut self, val: super::vals::Dclkdis) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u8) & 0x03) << 1usize);
            }
            #[doc = "BPF Clock Disable Control"]
            #[inline(always)]
            pub const fn bpfclkdis(&self) -> super::vals::Bpfclkdis {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bpfclkdis::from_bits(val as u8)
            }
            #[doc = "BPF Clock Disable Control"]
            #[inline(always)]
            pub fn set_bpfclkdis(&mut self, val: super::vals::Bpfclkdis) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Lower Power Operation Enable"]
            #[inline(always)]
            pub const fn lpopten(&self) -> super::vals::Lpopten {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lpopten::from_bits(val as u8)
            }
            #[doc = "Lower Power Operation Enable"]
            #[inline(always)]
            pub fn set_lpopten(&mut self, val: super::vals::Lpopten) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lpopt {
            #[inline(always)]
            fn default() -> Lpopt {
                Lpopt(0)
            }
        }
        impl core::fmt::Debug for Lpopt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lpopt")
                    .field("mpudis", &self.mpudis())
                    .field("dclkdis", &self.dclkdis())
                    .field("bpfclkdis", &self.bpfclkdis())
                    .field("lpopten", &self.lpopten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lpopt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lpopt {{ mpudis: {:?}, dclkdis: {:?}, bpfclkdis: {:?}, lpopten: {:?} }}",
                    self.mpudis(),
                    self.dclkdis(),
                    self.bpfclkdis(),
                    self.lpopten()
                )
            }
        }
        #[doc = "Voltage Monitor Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvcmpcr(pub u8);
        impl Lvcmpcr {
            #[doc = "Voltage Detection 1 Enable"]
            #[inline(always)]
            pub const fn lvd1e(&self) -> super::vals::Lvd1e {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Lvd1e::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 1 Enable"]
            #[inline(always)]
            pub fn set_lvd1e(&mut self, val: super::vals::Lvd1e) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Voltage Detection 2 Enable"]
            #[inline(always)]
            pub const fn lvd2e(&self) -> super::vals::Lvd2e {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd2e::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 2 Enable"]
            #[inline(always)]
            pub fn set_lvd2e(&mut self, val: super::vals::Lvd2e) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Lvcmpcr {
            #[inline(always)]
            fn default() -> Lvcmpcr {
                Lvcmpcr(0)
            }
        }
        impl core::fmt::Debug for Lvcmpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvcmpcr")
                    .field("lvd1e", &self.lvd1e())
                    .field("lvd2e", &self.lvd2e())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvcmpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvcmpcr {{ lvd1e: {:?}, lvd2e: {:?} }}",
                    self.lvd1e(),
                    self.lvd2e()
                )
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1cr0(pub u8);
        impl Lvd1cr0 {
            #[doc = "Voltage Monitor 1 Interrupt/Reset Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::Lvd1cr0Rie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd1cr0Rie::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt/Reset Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::Lvd1cr0Rie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub const fn cmpe(&self) -> super::vals::Lvd1cr0Cmpe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1cr0Cmpe::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub fn set_cmpe(&mut self, val: super::vals::Lvd1cr0Cmpe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 1 Circuit Mode Select"]
            #[inline(always)]
            pub const fn ri(&self) -> super::vals::Lvd1cr0Ri {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd1cr0Ri::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Circuit Mode Select"]
            #[inline(always)]
            pub fn set_ri(&mut self, val: super::vals::Lvd1cr0Ri) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Voltage Monitor 1 Reset Negate Select"]
            #[inline(always)]
            pub const fn rn(&self) -> super::vals::Lvd1cr0Rn {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lvd1cr0Rn::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Reset Negate Select"]
            #[inline(always)]
            pub fn set_rn(&mut self, val: super::vals::Lvd1cr0Rn) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lvd1cr0 {
            #[inline(always)]
            fn default() -> Lvd1cr0 {
                Lvd1cr0(0)
            }
        }
        impl core::fmt::Debug for Lvd1cr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1cr0")
                    .field("rie", &self.rie())
                    .field("cmpe", &self.cmpe())
                    .field("ri", &self.ri())
                    .field("rn", &self.rn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1cr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1cr0 {{ rie: {:?}, cmpe: {:?}, ri: {:?}, rn: {:?} }}",
                    self.rie(),
                    self.cmpe(),
                    self.ri(),
                    self.rn()
                )
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1cr1(pub u8);
        impl Lvd1cr1 {
            #[doc = "Voltage Monitor 1 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub const fn idtsel(&self) -> super::vals::Lvd1cr1Idtsel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lvd1cr1Idtsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub fn set_idtsel(&mut self, val: super::vals::Lvd1cr1Idtsel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Type Select"]
            #[inline(always)]
            pub const fn irqsel(&self) -> super::vals::Lvd1cr1Irqsel {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1cr1Irqsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Type Select"]
            #[inline(always)]
            pub fn set_irqsel(&mut self, val: super::vals::Lvd1cr1Irqsel) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Lvd1cr1 {
            #[inline(always)]
            fn default() -> Lvd1cr1 {
                Lvd1cr1(0)
            }
        }
        impl core::fmt::Debug for Lvd1cr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1cr1")
                    .field("idtsel", &self.idtsel())
                    .field("irqsel", &self.irqsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1cr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1cr1 {{ idtsel: {:?}, irqsel: {:?} }}",
                    self.idtsel(),
                    self.irqsel()
                )
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1sr(pub u8);
        impl Lvd1sr {
            #[doc = "Voltage Monitor 1 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::Lvd1srDet {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd1srDet::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::Lvd1srDet) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Signal Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::Lvd1srMon {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd1srMon::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Signal Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::Lvd1srMon) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Lvd1sr {
            #[inline(always)]
            fn default() -> Lvd1sr {
                Lvd1sr(0)
            }
        }
        impl core::fmt::Debug for Lvd1sr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1sr")
                    .field("det", &self.det())
                    .field("mon", &self.mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1sr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1sr {{ det: {:?}, mon: {:?} }}",
                    self.det(),
                    self.mon()
                )
            }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd2cr0(pub u8);
        impl Lvd2cr0 {
            #[doc = "Voltage Monitor 2 Interrupt/Reset Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::Lvd2cr0Rie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd2cr0Rie::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt/Reset Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::Lvd2cr0Rie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 2 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub const fn cmpe(&self) -> super::vals::Lvd2cr0Cmpe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd2cr0Cmpe::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub fn set_cmpe(&mut self, val: super::vals::Lvd2cr0Cmpe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 2 Circuit Mode Select"]
            #[inline(always)]
            pub const fn ri(&self) -> super::vals::Lvd2cr0Ri {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd2cr0Ri::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Circuit Mode Select"]
            #[inline(always)]
            pub fn set_ri(&mut self, val: super::vals::Lvd2cr0Ri) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Voltage Monitor 2 Reset Negate Select"]
            #[inline(always)]
            pub const fn rn(&self) -> super::vals::Lvd2cr0Rn {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lvd2cr0Rn::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Reset Negate Select"]
            #[inline(always)]
            pub fn set_rn(&mut self, val: super::vals::Lvd2cr0Rn) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lvd2cr0 {
            #[inline(always)]
            fn default() -> Lvd2cr0 {
                Lvd2cr0(0)
            }
        }
        impl core::fmt::Debug for Lvd2cr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd2cr0")
                    .field("rie", &self.rie())
                    .field("cmpe", &self.cmpe())
                    .field("ri", &self.ri())
                    .field("rn", &self.rn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd2cr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd2cr0 {{ rie: {:?}, cmpe: {:?}, ri: {:?}, rn: {:?} }}",
                    self.rie(),
                    self.cmpe(),
                    self.ri(),
                    self.rn()
                )
            }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd2cr1(pub u8);
        impl Lvd2cr1 {
            #[doc = "Voltage Monitor 2 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub const fn idtsel(&self) -> super::vals::Lvd2cr1Idtsel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lvd2cr1Idtsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub fn set_idtsel(&mut self, val: super::vals::Lvd2cr1Idtsel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Voltage Monitor 2 Interrupt Type Select"]
            #[inline(always)]
            pub const fn irqsel(&self) -> super::vals::Lvd2cr1Irqsel {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd2cr1Irqsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Type Select"]
            #[inline(always)]
            pub fn set_irqsel(&mut self, val: super::vals::Lvd2cr1Irqsel) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Lvd2cr1 {
            #[inline(always)]
            fn default() -> Lvd2cr1 {
                Lvd2cr1(0)
            }
        }
        impl core::fmt::Debug for Lvd2cr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd2cr1")
                    .field("idtsel", &self.idtsel())
                    .field("irqsel", &self.irqsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd2cr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd2cr1 {{ idtsel: {:?}, irqsel: {:?} }}",
                    self.idtsel(),
                    self.irqsel()
                )
            }
        }
        #[doc = "Voltage Monitor 2 Circuit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd2sr(pub u8);
        impl Lvd2sr {
            #[doc = "Voltage Monitor 2 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::Lvd2srDet {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd2srDet::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::Lvd2srDet) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 2 Signal Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::Lvd2srMon {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd2srMon::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Signal Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::Lvd2srMon) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Lvd2sr {
            #[inline(always)]
            fn default() -> Lvd2sr {
                Lvd2sr(0)
            }
        }
        impl core::fmt::Debug for Lvd2sr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd2sr")
                    .field("det", &self.det())
                    .field("mon", &self.mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd2sr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd2sr {{ det: {:?}, mon: {:?} }}",
                    self.det(),
                    self.mon()
                )
            }
        }
        #[doc = "Voltage Detection Level Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvdlvlr(pub u8);
        impl Lvdlvlr {
            #[doc = "Voltage Detection 1 Level Select (Standard voltage during fall in voltage)"]
            #[inline(always)]
            pub const fn lvd1lvl(&self) -> super::vals::Lvd1lvl {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Lvd1lvl::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 1 Level Select (Standard voltage during fall in voltage)"]
            #[inline(always)]
            pub fn set_lvd1lvl(&mut self, val: super::vals::Lvd1lvl) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u8) & 0x1f) << 0usize);
            }
            #[doc = "Voltage Detection 2 Level Select (Standard voltage during fall in voltage)"]
            #[inline(always)]
            pub const fn lvd2lvl(&self) -> super::vals::Lvd2lvl {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::Lvd2lvl::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 2 Level Select (Standard voltage during fall in voltage)"]
            #[inline(always)]
            pub fn set_lvd2lvl(&mut self, val: super::vals::Lvd2lvl) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Lvdlvlr {
            #[inline(always)]
            fn default() -> Lvdlvlr {
                Lvdlvlr(0)
            }
        }
        impl core::fmt::Debug for Lvdlvlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvdlvlr")
                    .field("lvd1lvl", &self.lvd1lvl())
                    .field("lvd2lvl", &self.lvd2lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvdlvlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvdlvlr {{ lvd1lvl: {:?}, lvd2lvl: {:?} }}",
                    self.lvd1lvl(),
                    self.lvd2lvl()
                )
            }
        }
        #[doc = "Memory Wait Cycle Control Register for Code Flash"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Memwait(pub u8);
        impl Memwait {
            #[doc = "Memory Wait Cycle Select for Code Flash"]
            #[inline(always)]
            pub const fn memwait(&self) -> super::vals::Memwait {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Memwait::from_bits(val as u8)
            }
            #[doc = "Memory Wait Cycle Select for Code Flash"]
            #[inline(always)]
            pub fn set_memwait(&mut self, val: super::vals::Memwait) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Memwait {
            #[inline(always)]
            fn default() -> Memwait {
                Memwait(0)
            }
        }
        impl core::fmt::Debug for Memwait {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Memwait")
                    .field("memwait", &self.memwait())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Memwait {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Memwait {{ memwait: {:?} }}", self.memwait())
            }
        }
        #[doc = "Middle,Speed On,Chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mococr(pub u8);
        impl Mococr {
            #[doc = "MOCO Stop"]
            #[inline(always)]
            pub const fn mcstp(&self) -> super::vals::Mcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mcstp::from_bits(val as u8)
            }
            #[doc = "MOCO Stop"]
            #[inline(always)]
            pub fn set_mcstp(&mut self, val: super::vals::Mcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Mococr {
            #[inline(always)]
            fn default() -> Mococr {
                Mococr(0)
            }
        }
        impl core::fmt::Debug for Mococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mococr")
                    .field("mcstp", &self.mcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mococr {{ mcstp: {:?} }}", self.mcstp())
            }
        }
        #[doc = "MOCO User Trimming Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mocoutcr(pub u8);
        impl Mocoutcr {
            #[doc = "MOCO User Trimming"]
            #[inline(always)]
            pub const fn mocoutrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MOCO User Trimming"]
            #[inline(always)]
            pub fn set_mocoutrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Mocoutcr {
            #[inline(always)]
            fn default() -> Mocoutcr {
                Mocoutcr(0)
            }
        }
        impl core::fmt::Debug for Mocoutcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mocoutcr")
                    .field("mocoutrm", &self.mocoutrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mocoutcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mocoutcr {{ mocoutrm: {=u8:?} }}", self.mocoutrm())
            }
        }
        #[doc = "Main Clock Oscillator Mode Oscillation Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Momcr(pub u8);
        impl Momcr {
            #[doc = "Main Clock Oscillator Drive Capability 1 Switching"]
            #[inline(always)]
            pub const fn modrv1(&self) -> super::vals::Modrv1 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Modrv1::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Drive Capability 1 Switching"]
            #[inline(always)]
            pub fn set_modrv1(&mut self, val: super::vals::Modrv1) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Main Clock Oscillator Switching"]
            #[inline(always)]
            pub const fn mosel(&self) -> super::vals::Mosel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mosel::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Switching"]
            #[inline(always)]
            pub fn set_mosel(&mut self, val: super::vals::Mosel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Momcr {
            #[inline(always)]
            fn default() -> Momcr {
                Momcr(0)
            }
        }
        impl core::fmt::Debug for Momcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Momcr")
                    .field("modrv1", &self.modrv1())
                    .field("mosel", &self.mosel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Momcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Momcr {{ modrv1: {:?}, mosel: {:?} }}",
                    self.modrv1(),
                    self.mosel()
                )
            }
        }
        #[doc = "Main Clock Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mosccr(pub u8);
        impl Mosccr {
            #[doc = "Main Clock Oscillator Stop"]
            #[inline(always)]
            pub const fn mostp(&self) -> super::vals::Mostp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mostp::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Stop"]
            #[inline(always)]
            pub fn set_mostp(&mut self, val: super::vals::Mostp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Mosccr {
            #[inline(always)]
            fn default() -> Mosccr {
                Mosccr(0)
            }
        }
        impl core::fmt::Debug for Mosccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mosccr")
                    .field("mostp", &self.mostp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mosccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mosccr {{ mostp: {:?} }}", self.mostp())
            }
        }
        #[doc = "Main Clock Oscillator Wait Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Moscwtcr(pub u8);
        impl Moscwtcr {
            #[doc = "Main Clock Oscillator Wait Time Setting"]
            #[inline(always)]
            pub const fn msts(&self) -> super::vals::Msts {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Msts::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillator Wait Time Setting"]
            #[inline(always)]
            pub fn set_msts(&mut self, val: super::vals::Msts) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u8) & 0x0f) << 0usize);
            }
        }
        impl Default for Moscwtcr {
            #[inline(always)]
            fn default() -> Moscwtcr {
                Moscwtcr(0)
            }
        }
        impl core::fmt::Debug for Moscwtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Moscwtcr")
                    .field("msts", &self.msts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Moscwtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Moscwtcr {{ msts: {:?} }}", self.msts())
            }
        }
        #[doc = "Main Oscillation Stop Detection Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mostd(pub u16);
        impl Mostd {
            #[doc = "Oscillation Stop Detection Time"]
            #[inline(always)]
            pub const fn osdccmp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Oscillation Stop Detection Time"]
            #[inline(always)]
            pub fn set_osdccmp(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u16) & 0x0fff) << 0usize);
            }
            #[doc = "Status of Oscillation Stop Detector Operation"]
            #[inline(always)]
            pub const fn osdcf(&self) -> super::vals::MostdOsdcf {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::MostdOsdcf::from_bits(val as u8)
            }
            #[doc = "Status of Oscillation Stop Detector Operation"]
            #[inline(always)]
            pub fn set_osdcf(&mut self, val: super::vals::MostdOsdcf) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Control of Oscillation Stop Detector Operation"]
            #[inline(always)]
            pub const fn osdce(&self) -> super::vals::MostdOsdce {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::MostdOsdce::from_bits(val as u8)
            }
            #[doc = "Control of Oscillation Stop Detector Operation"]
            #[inline(always)]
            pub fn set_osdce(&mut self, val: super::vals::MostdOsdce) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Mostd {
            #[inline(always)]
            fn default() -> Mostd {
                Mostd(0)
            }
        }
        impl core::fmt::Debug for Mostd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mostd")
                    .field("osdccmp", &self.osdccmp())
                    .field("osdcf", &self.osdcf())
                    .field("osdce", &self.osdce())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mostd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mostd {{ osdccmp: {=u16:?}, osdcf: {:?}, osdce: {:?} }}",
                    self.osdccmp(),
                    self.osdcf(),
                    self.osdce()
                )
            }
        }
        #[doc = "Module Stop Control Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcra(pub u32);
        impl Mstpcra {
            #[doc = "Sub Oscillation Stop Detection for SDADCCLK Module Stop"]
            #[inline(always)]
            pub const fn mstpa16(&self) -> super::vals::Mstpa16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Mstpa16::from_bits(val as u8)
            }
            #[doc = "Sub Oscillation Stop Detection for SDADCCLK Module Stop"]
            #[inline(always)]
            pub fn set_mstpa16(&mut self, val: super::vals::Mstpa16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Main Oscillation Stop Detection for SDADCCLK Module Stop"]
            #[inline(always)]
            pub const fn mstpa17(&self) -> super::vals::Mstpa17 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Mstpa17::from_bits(val as u8)
            }
            #[doc = "Main Oscillation Stop Detection for SDADCCLK Module Stop"]
            #[inline(always)]
            pub fn set_mstpa17(&mut self, val: super::vals::Mstpa17) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "DTC Module Stop"]
            #[inline(always)]
            pub const fn mstpa22(&self) -> super::vals::Mstpa22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Mstpa22::from_bits(val as u8)
            }
            #[doc = "DTC Module Stop"]
            #[inline(always)]
            pub fn set_mstpa22(&mut self, val: super::vals::Mstpa22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Mstpcra {
            #[inline(always)]
            fn default() -> Mstpcra {
                Mstpcra(0)
            }
        }
        impl core::fmt::Debug for Mstpcra {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcra")
                    .field("mstpa16", &self.mstpa16())
                    .field("mstpa17", &self.mstpa17())
                    .field("mstpa22", &self.mstpa22())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcra {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mstpcra {{ mstpa16: {:?}, mstpa17: {:?}, mstpa22: {:?} }}",
                    self.mstpa16(),
                    self.mstpa17(),
                    self.mstpa22()
                )
            }
        }
        #[doc = "Operating Power Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opccr(pub u8);
        impl Opccr {
            #[doc = "Operating Power Control Mode Select"]
            #[inline(always)]
            pub const fn opcm(&self) -> super::vals::Opcm {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Opcm::from_bits(val as u8)
            }
            #[doc = "Operating Power Control Mode Select"]
            #[inline(always)]
            pub fn set_opcm(&mut self, val: super::vals::Opcm) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub const fn opcmtsf(&self) -> super::vals::Opcmtsf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Opcmtsf::from_bits(val as u8)
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub fn set_opcmtsf(&mut self, val: super::vals::Opcmtsf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Opccr {
            #[inline(always)]
            fn default() -> Opccr {
                Opccr(0)
            }
        }
        impl core::fmt::Debug for Opccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opccr")
                    .field("opcm", &self.opcm())
                    .field("opcmtsf", &self.opcmtsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Opccr {{ opcm: {:?}, opcmtsf: {:?} }}",
                    self.opcm(),
                    self.opcmtsf()
                )
            }
        }
        #[doc = "Oscillation Stabilization Flag Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oscsf(pub u8);
        impl Oscsf {
            #[doc = "HOCO Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub const fn hocosf(&self) -> super::vals::Hocosf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hocosf::from_bits(val as u8)
            }
            #[doc = "HOCO Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub fn set_hocosf(&mut self, val: super::vals::Hocosf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Main Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub const fn moscsf(&self) -> super::vals::Moscsf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Moscsf::from_bits(val as u8)
            }
            #[doc = "Main Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub fn set_moscsf(&mut self, val: super::vals::Moscsf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "PLL Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub const fn pllsf(&self) -> super::vals::Pllsf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pllsf::from_bits(val as u8)
            }
            #[doc = "PLL Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub fn set_pllsf(&mut self, val: super::vals::Pllsf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Oscsf {
            #[inline(always)]
            fn default() -> Oscsf {
                Oscsf(0)
            }
        }
        impl core::fmt::Debug for Oscsf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oscsf")
                    .field("hocosf", &self.hocosf())
                    .field("moscsf", &self.moscsf())
                    .field("pllsf", &self.pllsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oscsf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Oscsf {{ hocosf: {:?}, moscsf: {:?}, pllsf: {:?} }}",
                    self.hocosf(),
                    self.moscsf(),
                    self.pllsf()
                )
            }
        }
        #[doc = "Oscillation Stop Detection Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ostdcr(pub u8);
        impl Ostdcr {
            #[doc = "Oscillation Stop Detection Interrupt Enable"]
            #[inline(always)]
            pub const fn ostdie(&self) -> super::vals::Ostdie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ostdie::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Interrupt Enable"]
            #[inline(always)]
            pub fn set_ostdie(&mut self, val: super::vals::Ostdie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Oscillation Stop Detection Function Enable"]
            #[inline(always)]
            pub const fn ostde(&self) -> super::vals::Ostde {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ostde::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Function Enable"]
            #[inline(always)]
            pub fn set_ostde(&mut self, val: super::vals::Ostde) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ostdcr {
            #[inline(always)]
            fn default() -> Ostdcr {
                Ostdcr(0)
            }
        }
        impl core::fmt::Debug for Ostdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ostdcr")
                    .field("ostdie", &self.ostdie())
                    .field("ostde", &self.ostde())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ostdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ostdcr {{ ostdie: {:?}, ostde: {:?} }}",
                    self.ostdie(),
                    self.ostde()
                )
            }
        }
        #[doc = "Oscillation Stop Detection Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ostdsr(pub u8);
        impl Ostdsr {
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub const fn ostdf(&self) -> super::vals::Ostdf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ostdf::from_bits(val as u8)
            }
            #[doc = "Oscillation Stop Detection Flag"]
            #[inline(always)]
            pub fn set_ostdf(&mut self, val: super::vals::Ostdf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Ostdsr {
            #[inline(always)]
            fn default() -> Ostdsr {
                Ostdsr(0)
            }
        }
        impl core::fmt::Debug for Ostdsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ostdsr")
                    .field("ostdf", &self.ostdf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ostdsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ostdsr {{ ostdf: {:?} }}", self.ostdf())
            }
        }
        #[doc = "PLL Clock Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pllccr(pub u16);
        impl Pllccr {
            #[doc = "PLL Frequency Multiplication Factor Select"]
            #[inline(always)]
            pub const fn pllmul(&self) -> super::vals::Pllmul {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::Pllmul::from_bits(val as u8)
            }
            #[doc = "PLL Frequency Multiplication Factor Select"]
            #[inline(always)]
            pub fn set_pllmul(&mut self, val: super::vals::Pllmul) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Pllccr {
            #[inline(always)]
            fn default() -> Pllccr {
                Pllccr(0)
            }
        }
        impl core::fmt::Debug for Pllccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pllccr")
                    .field("pllmul", &self.pllmul())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pllccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pllccr {{ pllmul: {:?} }}", self.pllmul())
            }
        }
        #[doc = "PLL Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pllcr(pub u8);
        impl Pllcr {
            #[doc = "PLL Stop Control"]
            #[inline(always)]
            pub const fn pllstp(&self) -> super::vals::Pllstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pllstp::from_bits(val as u8)
            }
            #[doc = "PLL Stop Control"]
            #[inline(always)]
            pub fn set_pllstp(&mut self, val: super::vals::Pllstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Pllcr {
            #[inline(always)]
            fn default() -> Pllcr {
                Pllcr(0)
            }
        }
        impl core::fmt::Debug for Pllcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pllcr")
                    .field("pllstp", &self.pllstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pllcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pllcr {{ pllstp: {:?} }}", self.pllstp())
            }
        }
        #[doc = "Protect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prcr(pub u16);
        impl Prcr {
            #[doc = "Enable writing to the registers related to the clock generation circuit"]
            #[inline(always)]
            pub const fn prc0(&self) -> super::vals::Prc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Prc0::from_bits(val as u8)
            }
            #[doc = "Enable writing to the registers related to the clock generation circuit"]
            #[inline(always)]
            pub fn set_prc0(&mut self, val: super::vals::Prc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Enable writing to the registers related to the low power modes"]
            #[inline(always)]
            pub const fn prc1(&self) -> super::vals::Prc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Prc1::from_bits(val as u8)
            }
            #[doc = "Enable writing to the registers related to the low power modes"]
            #[inline(always)]
            pub fn set_prc1(&mut self, val: super::vals::Prc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Enable writing to the registers related to the LVD"]
            #[inline(always)]
            pub const fn prc3(&self) -> super::vals::Prc3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Prc3::from_bits(val as u8)
            }
            #[doc = "Enable writing to the registers related to the LVD"]
            #[inline(always)]
            pub fn set_prc3(&mut self, val: super::vals::Prc3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "PRC Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "PRC Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Prcr {
            #[inline(always)]
            fn default() -> Prcr {
                Prcr(0)
            }
        }
        impl core::fmt::Debug for Prcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prcr")
                    .field("prc0", &self.prc0())
                    .field("prc1", &self.prc1())
                    .field("prc3", &self.prc3())
                    .field("prkey", &self.prkey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prcr {{ prc0: {:?}, prc1: {:?}, prc3: {:?}, prkey: {=u8:?} }}",
                    self.prc0(),
                    self.prc1(),
                    self.prc3(),
                    self.prkey()
                )
            }
        }
        #[doc = "Power Save Memory Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psmcr(pub u8);
        impl Psmcr {
            #[doc = "Power Save Memory Control"]
            #[inline(always)]
            pub const fn psmc(&self) -> super::vals::Psmc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Psmc::from_bits(val as u8)
            }
            #[doc = "Power Save Memory Control"]
            #[inline(always)]
            pub fn set_psmc(&mut self, val: super::vals::Psmc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Psmcr {
            #[inline(always)]
            fn default() -> Psmcr {
                Psmcr(0)
            }
        }
        impl core::fmt::Debug for Psmcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psmcr").field("psmc", &self.psmc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psmcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Psmcr {{ psmc: {:?} }}", self.psmc())
            }
        }
        #[doc = "Reset Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstsr0(pub u8);
        impl Rstsr0 {
            #[doc = "Power,On Reset Detect Flag"]
            #[inline(always)]
            pub const fn porf(&self) -> super::vals::Porf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Porf::from_bits(val as u8)
            }
            #[doc = "Power,On Reset Detect Flag"]
            #[inline(always)]
            pub fn set_porf(&mut self, val: super::vals::Porf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 0 Reset Detect Flag"]
            #[inline(always)]
            pub const fn lvd0rf(&self) -> super::vals::Lvd0rf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd0rf::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 0 Reset Detect Flag"]
            #[inline(always)]
            pub fn set_lvd0rf(&mut self, val: super::vals::Lvd0rf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Voltage Monitor 1 Reset Detect Flag"]
            #[inline(always)]
            pub const fn lvd1rf(&self) -> super::vals::Lvd1rf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1rf::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Reset Detect Flag"]
            #[inline(always)]
            pub fn set_lvd1rf(&mut self, val: super::vals::Lvd1rf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 2 Reset Detect Flag"]
            #[inline(always)]
            pub const fn lvd2rf(&self) -> super::vals::Lvd2rf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2rf::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Reset Detect Flag"]
            #[inline(always)]
            pub fn set_lvd2rf(&mut self, val: super::vals::Lvd2rf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
        }
        impl Default for Rstsr0 {
            #[inline(always)]
            fn default() -> Rstsr0 {
                Rstsr0(0)
            }
        }
        impl core::fmt::Debug for Rstsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstsr0")
                    .field("porf", &self.porf())
                    .field("lvd0rf", &self.lvd0rf())
                    .field("lvd1rf", &self.lvd1rf())
                    .field("lvd2rf", &self.lvd2rf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rstsr0 {{ porf: {:?}, lvd0rf: {:?}, lvd1rf: {:?}, lvd2rf: {:?} }}",
                    self.porf(),
                    self.lvd0rf(),
                    self.lvd1rf(),
                    self.lvd2rf()
                )
            }
        }
        #[doc = "Reset Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstsr1(pub u16);
        impl Rstsr1 {
            #[doc = "Independent Watchdog Timer Reset Detect Flag"]
            #[inline(always)]
            pub const fn iwdtrf(&self) -> super::vals::Iwdtrf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtrf::from_bits(val as u8)
            }
            #[doc = "Independent Watchdog Timer Reset Detect Flag"]
            #[inline(always)]
            pub fn set_iwdtrf(&mut self, val: super::vals::Iwdtrf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Watchdog Timer Reset Detect Flag"]
            #[inline(always)]
            pub const fn wdtrf(&self) -> super::vals::Wdtrf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtrf::from_bits(val as u8)
            }
            #[doc = "Watchdog Timer Reset Detect Flag"]
            #[inline(always)]
            pub fn set_wdtrf(&mut self, val: super::vals::Wdtrf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Software Reset Detect Flag"]
            #[inline(always)]
            pub const fn swrf(&self) -> super::vals::Swrf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Swrf::from_bits(val as u8)
            }
            #[doc = "Software Reset Detect Flag"]
            #[inline(always)]
            pub fn set_swrf(&mut self, val: super::vals::Swrf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "SRAM Parity Error Reset Detect Flag"]
            #[inline(always)]
            pub const fn rperf(&self) -> super::vals::Rperf {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rperf::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Reset Detect Flag"]
            #[inline(always)]
            pub fn set_rperf(&mut self, val: super::vals::Rperf) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "SRAM ECC Error Reset Detect Flag"]
            #[inline(always)]
            pub const fn reerf(&self) -> super::vals::Reerf {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Reerf::from_bits(val as u8)
            }
            #[doc = "SRAM ECC Error Reset Detect Flag"]
            #[inline(always)]
            pub fn set_reerf(&mut self, val: super::vals::Reerf) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Bus Slave MPU Error Reset Detect Flag"]
            #[inline(always)]
            pub const fn bussrf(&self) -> super::vals::Bussrf {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussrf::from_bits(val as u8)
            }
            #[doc = "Bus Slave MPU Error Reset Detect Flag"]
            #[inline(always)]
            pub fn set_bussrf(&mut self, val: super::vals::Bussrf) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus Master MPU Error Reset Detect Flag"]
            #[inline(always)]
            pub const fn busmrf(&self) -> super::vals::Busmrf {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmrf::from_bits(val as u8)
            }
            #[doc = "Bus Master MPU Error Reset Detect Flag"]
            #[inline(always)]
            pub fn set_busmrf(&mut self, val: super::vals::Busmrf) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Error Reset Detect Flag"]
            #[inline(always)]
            pub const fn sperf(&self) -> super::vals::Sperf {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Sperf::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Error Reset Detect Flag"]
            #[inline(always)]
            pub fn set_sperf(&mut self, val: super::vals::Sperf) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Rstsr1 {
            #[inline(always)]
            fn default() -> Rstsr1 {
                Rstsr1(0)
            }
        }
        impl core::fmt::Debug for Rstsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstsr1")
                    .field("iwdtrf", &self.iwdtrf())
                    .field("wdtrf", &self.wdtrf())
                    .field("swrf", &self.swrf())
                    .field("rperf", &self.rperf())
                    .field("reerf", &self.reerf())
                    .field("bussrf", &self.bussrf())
                    .field("busmrf", &self.busmrf())
                    .field("sperf", &self.sperf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rstsr1 {{ iwdtrf: {:?}, wdtrf: {:?}, swrf: {:?}, rperf: {:?}, reerf: {:?}, bussrf: {:?}, busmrf: {:?}, sperf: {:?} }}" , self . iwdtrf () , self . wdtrf () , self . swrf () , self . rperf () , self . reerf () , self . bussrf () , self . busmrf () , self . sperf ())
            }
        }
        #[doc = "Reset Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstsr2(pub u8);
        impl Rstsr2 {
            #[doc = "Cold/Warm Start Determination Flag"]
            #[inline(always)]
            pub const fn cwsf(&self) -> super::vals::Cwsf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cwsf::from_bits(val as u8)
            }
            #[doc = "Cold/Warm Start Determination Flag"]
            #[inline(always)]
            pub fn set_cwsf(&mut self, val: super::vals::Cwsf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Rstsr2 {
            #[inline(always)]
            fn default() -> Rstsr2 {
                Rstsr2(0)
            }
        }
        impl core::fmt::Debug for Rstsr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstsr2")
                    .field("cwsf", &self.cwsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstsr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rstsr2 {{ cwsf: {:?} }}", self.cwsf())
            }
        }
        #[doc = "Standby Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sbycr(pub u16);
        impl Sbycr {
            #[doc = "Software Standby Mode Select"]
            #[inline(always)]
            pub const fn ssby(&self) -> super::vals::Ssby {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ssby::from_bits(val as u8)
            }
            #[doc = "Software Standby Mode Select"]
            #[inline(always)]
            pub fn set_ssby(&mut self, val: super::vals::Ssby) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Sbycr {
            #[inline(always)]
            fn default() -> Sbycr {
                Sbycr(0)
            }
        }
        impl core::fmt::Debug for Sbycr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sbycr").field("ssby", &self.ssby()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sbycr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sbycr {{ ssby: {:?} }}", self.ssby())
            }
        }
        #[doc = "System Clock Division Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sckdivcr(pub u32);
        impl Sckdivcr {
            #[doc = "Peripheral Module Clock D (PCLKD) Select"]
            #[inline(always)]
            pub const fn pckd(&self) -> super::vals::Pckd {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Pckd::from_bits(val as u8)
            }
            #[doc = "Peripheral Module Clock D (PCLKD) Select"]
            #[inline(always)]
            pub fn set_pckd(&mut self, val: super::vals::Pckd) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Peripheral Module Clock B (PCLKB) Select"]
            #[inline(always)]
            pub const fn pckb(&self) -> super::vals::Pckb {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Pckb::from_bits(val as u8)
            }
            #[doc = "Peripheral Module Clock B (PCLKB) Select"]
            #[inline(always)]
            pub fn set_pckb(&mut self, val: super::vals::Pckb) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "System Clock (ICLK) Select"]
            #[inline(always)]
            pub const fn ick(&self) -> super::vals::Ick {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Ick::from_bits(val as u8)
            }
            #[doc = "System Clock (ICLK) Select"]
            #[inline(always)]
            pub fn set_ick(&mut self, val: super::vals::Ick) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Sckdivcr {
            #[inline(always)]
            fn default() -> Sckdivcr {
                Sckdivcr(0)
            }
        }
        impl core::fmt::Debug for Sckdivcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sckdivcr")
                    .field("pckd", &self.pckd())
                    .field("pckb", &self.pckb())
                    .field("ick", &self.ick())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sckdivcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sckdivcr {{ pckd: {:?}, pckb: {:?}, ick: {:?} }}",
                    self.pckd(),
                    self.pckb(),
                    self.ick()
                )
            }
        }
        #[doc = "System Clock Source Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sckscr(pub u8);
        impl Sckscr {
            #[doc = "Clock Source Select"]
            #[inline(always)]
            pub const fn cksel(&self) -> super::vals::SckscrCksel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::SckscrCksel::from_bits(val as u8)
            }
            #[doc = "Clock Source Select"]
            #[inline(always)]
            pub fn set_cksel(&mut self, val: super::vals::SckscrCksel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Sckscr {
            #[inline(always)]
            fn default() -> Sckscr {
                Sckscr(0)
            }
        }
        impl core::fmt::Debug for Sckscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sckscr")
                    .field("cksel", &self.cksel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sckscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sckscr {{ cksel: {:?} }}", self.cksel())
            }
        }
        #[doc = "24-bit Sigma,delta A/D Converter Clock Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdadcckcr(pub u8);
        impl Sdadcckcr {
            #[doc = "24-bit Sigma,delta A/D Converter Clock Select"]
            #[inline(always)]
            pub const fn cksel(&self) -> super::vals::SdadcckcrCksel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SdadcckcrCksel::from_bits(val as u8)
            }
            #[doc = "24-bit Sigma,delta A/D Converter Clock Select"]
            #[inline(always)]
            pub fn set_cksel(&mut self, val: super::vals::SdadcckcrCksel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Clock Switch Enable for Oscillation Stop Detected"]
            #[inline(always)]
            pub const fn ostdcse(&self) -> super::vals::Ostdcse {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ostdcse::from_bits(val as u8)
            }
            #[doc = "Clock Switch Enable for Oscillation Stop Detected"]
            #[inline(always)]
            pub fn set_ostdcse(&mut self, val: super::vals::Ostdcse) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Sdadcckcr {
            #[inline(always)]
            fn default() -> Sdadcckcr {
                Sdadcckcr(0)
            }
        }
        impl core::fmt::Debug for Sdadcckcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdadcckcr")
                    .field("cksel", &self.cksel())
                    .field("ostdcse", &self.ostdcse())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdadcckcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sdadcckcr {{ cksel: {:?}, ostdcse: {:?} }}",
                    self.cksel(),
                    self.ostdcse()
                )
            }
        }
        #[doc = "Segment LCD Source Clock Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Slcdsckcr(pub u8);
        impl Slcdsckcr {
            #[doc = "LCD Source Clock (LCDSRCCLK) Select"]
            #[inline(always)]
            pub const fn lcdscksel(&self) -> super::vals::Lcdscksel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Lcdscksel::from_bits(val as u8)
            }
            #[doc = "LCD Source Clock (LCDSRCCLK) Select"]
            #[inline(always)]
            pub fn set_lcdscksel(&mut self, val: super::vals::Lcdscksel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "LCD Source Clock Out Enable"]
            #[inline(always)]
            pub const fn lcdscken(&self) -> super::vals::Lcdscken {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lcdscken::from_bits(val as u8)
            }
            #[doc = "LCD Source Clock Out Enable"]
            #[inline(always)]
            pub fn set_lcdscken(&mut self, val: super::vals::Lcdscken) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Slcdsckcr {
            #[inline(always)]
            fn default() -> Slcdsckcr {
                Slcdsckcr(0)
            }
        }
        impl core::fmt::Debug for Slcdsckcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Slcdsckcr")
                    .field("lcdscksel", &self.lcdscksel())
                    .field("lcdscken", &self.lcdscken())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Slcdsckcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Slcdsckcr {{ lcdscksel: {:?}, lcdscken: {:?} }}",
                    self.lcdscksel(),
                    self.lcdscken()
                )
            }
        }
        #[doc = "Snooze Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snzcr(pub u8);
        impl Snzcr {
            #[doc = "RXD0 Snooze Request Enable"]
            #[inline(always)]
            pub const fn rxdreqen(&self) -> super::vals::Rxdreqen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rxdreqen::from_bits(val as u8)
            }
            #[doc = "RXD0 Snooze Request Enable"]
            #[inline(always)]
            pub fn set_rxdreqen(&mut self, val: super::vals::Rxdreqen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "DTC Enable in Snooze mode"]
            #[inline(always)]
            pub const fn snzdtcen(&self) -> super::vals::Snzdtcen {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Snzdtcen::from_bits(val as u8)
            }
            #[doc = "DTC Enable in Snooze mode"]
            #[inline(always)]
            pub fn set_snzdtcen(&mut self, val: super::vals::Snzdtcen) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Snooze mode Enable"]
            #[inline(always)]
            pub const fn snze(&self) -> super::vals::Snze {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Snze::from_bits(val as u8)
            }
            #[doc = "Snooze mode Enable"]
            #[inline(always)]
            pub fn set_snze(&mut self, val: super::vals::Snze) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Snzcr {
            #[inline(always)]
            fn default() -> Snzcr {
                Snzcr(0)
            }
        }
        impl core::fmt::Debug for Snzcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snzcr")
                    .field("rxdreqen", &self.rxdreqen())
                    .field("snzdtcen", &self.snzdtcen())
                    .field("snze", &self.snze())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snzcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Snzcr {{ rxdreqen: {:?}, snzdtcen: {:?}, snze: {:?} }}",
                    self.rxdreqen(),
                    self.snzdtcen(),
                    self.snze()
                )
            }
        }
        #[doc = "Snooze End Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snzedcr0(pub u8);
        impl Snzedcr0 {
            #[doc = "AGTW1 Underflow Snooze End Enable"]
            #[inline(always)]
            pub const fn agtwunfed(&self) -> super::vals::Agtwunfed {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Agtwunfed::from_bits(val as u8)
            }
            #[doc = "AGTW1 Underflow Snooze End Enable"]
            #[inline(always)]
            pub fn set_agtwunfed(&mut self, val: super::vals::Agtwunfed) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Last DTC Transmission Completion Snooze End Enable"]
            #[inline(always)]
            pub const fn dtczred(&self) -> super::vals::Dtczred {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Dtczred::from_bits(val as u8)
            }
            #[doc = "Last DTC Transmission Completion Snooze End Enable"]
            #[inline(always)]
            pub fn set_dtczred(&mut self, val: super::vals::Dtczred) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Not Last DTC Transmission Completion Snooze End Enable"]
            #[inline(always)]
            pub const fn dtcnzred(&self) -> super::vals::Dtcnzred {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dtcnzred::from_bits(val as u8)
            }
            #[doc = "Not Last DTC Transmission Completion Snooze End Enable"]
            #[inline(always)]
            pub fn set_dtcnzred(&mut self, val: super::vals::Dtcnzred) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "ADC12 Compare Match Snooze End Enable"]
            #[inline(always)]
            pub const fn ad0mated(&self) -> super::vals::Ad0mated {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ad0mated::from_bits(val as u8)
            }
            #[doc = "ADC12 Compare Match Snooze End Enable"]
            #[inline(always)]
            pub fn set_ad0mated(&mut self, val: super::vals::Ad0mated) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "ADC12 Compare Mismatch Snooze End Enable"]
            #[inline(always)]
            pub const fn ad0umted(&self) -> super::vals::Ad0umted {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ad0umted::from_bits(val as u8)
            }
            #[doc = "ADC12 Compare Mismatch Snooze End Enable"]
            #[inline(always)]
            pub fn set_ad0umted(&mut self, val: super::vals::Ad0umted) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "SCI0 Address Mismatch Snooze End Enable"]
            #[inline(always)]
            pub const fn sci0umted(&self) -> super::vals::Sci0umted {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sci0umted::from_bits(val as u8)
            }
            #[doc = "SCI0 Address Mismatch Snooze End Enable"]
            #[inline(always)]
            pub fn set_sci0umted(&mut self, val: super::vals::Sci0umted) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Snzedcr0 {
            #[inline(always)]
            fn default() -> Snzedcr0 {
                Snzedcr0(0)
            }
        }
        impl core::fmt::Debug for Snzedcr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snzedcr0")
                    .field("agtwunfed", &self.agtwunfed())
                    .field("dtczred", &self.dtczred())
                    .field("dtcnzred", &self.dtcnzred())
                    .field("ad0mated", &self.ad0mated())
                    .field("ad0umted", &self.ad0umted())
                    .field("sci0umted", &self.sci0umted())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snzedcr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Snzedcr0 {{ agtwunfed: {:?}, dtczred: {:?}, dtcnzred: {:?}, ad0mated: {:?}, ad0umted: {:?}, sci0umted: {:?} }}" , self . agtwunfed () , self . dtczred () , self . dtcnzred () , self . ad0mated () , self . ad0umted () , self . sci0umted ())
            }
        }
        #[doc = "Snooze Request Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snzreqcr0(pub u32);
        impl Snzreqcr0 {
            #[doc = "Enable IRQ0 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen0(&self) -> super::vals::Snzreqen0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Snzreqen0::from_bits(val as u8)
            }
            #[doc = "Enable IRQ0 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen0(&mut self, val: super::vals::Snzreqen0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable IRQ1 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen1(&self) -> super::vals::Snzreqen1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Snzreqen1::from_bits(val as u8)
            }
            #[doc = "Enable IRQ1 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen1(&mut self, val: super::vals::Snzreqen1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable IRQ2 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen2(&self) -> super::vals::Snzreqen2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Snzreqen2::from_bits(val as u8)
            }
            #[doc = "Enable IRQ2 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen2(&mut self, val: super::vals::Snzreqen2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable IRQ3 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen3(&self) -> super::vals::Snzreqen3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Snzreqen3::from_bits(val as u8)
            }
            #[doc = "Enable IRQ3 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen3(&mut self, val: super::vals::Snzreqen3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable IRQ4 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen4(&self) -> super::vals::Snzreqen4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Snzreqen4::from_bits(val as u8)
            }
            #[doc = "Enable IRQ4 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen4(&mut self, val: super::vals::Snzreqen4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable IRQ5 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen5(&self) -> super::vals::Snzreqen5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Snzreqen5::from_bits(val as u8)
            }
            #[doc = "Enable IRQ5 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen5(&mut self, val: super::vals::Snzreqen5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable IRQ6 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen6(&self) -> super::vals::Snzreqen6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Snzreqen6::from_bits(val as u8)
            }
            #[doc = "Enable IRQ6 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen6(&mut self, val: super::vals::Snzreqen6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable IRQ7 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen7(&self) -> super::vals::Snzreqen7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Snzreqen7::from_bits(val as u8)
            }
            #[doc = "Enable IRQ7 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen7(&mut self, val: super::vals::Snzreqen7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable IRQ8 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen8(&self) -> super::vals::Snzreqen8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Snzreqen8::from_bits(val as u8)
            }
            #[doc = "Enable IRQ8 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen8(&mut self, val: super::vals::Snzreqen8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable IRQ9 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen9(&self) -> super::vals::Snzreqen9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Snzreqen9::from_bits(val as u8)
            }
            #[doc = "Enable IRQ9 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen9(&mut self, val: super::vals::Snzreqen9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable IRQ10 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen10(&self) -> super::vals::Snzreqen10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Snzreqen10::from_bits(val as u8)
            }
            #[doc = "Enable IRQ10 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen10(&mut self, val: super::vals::Snzreqen10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable IRQ11 Pin Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen11(&self) -> super::vals::Snzreqen11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Snzreqen11::from_bits(val as u8)
            }
            #[doc = "Enable IRQ11 Pin Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen11(&mut self, val: super::vals::Snzreqen11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable RTC Alarm 1 Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen23(&self) -> super::vals::Snzreqen23 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Snzreqen23::from_bits(val as u8)
            }
            #[doc = "Enable RTC Alarm 1 Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen23(&mut self, val: super::vals::Snzreqen23) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable RTC Alarm 0 Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen24(&self) -> super::vals::Snzreqen24 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Snzreqen24::from_bits(val as u8)
            }
            #[doc = "Enable RTC Alarm 0 Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen24(&mut self, val: super::vals::Snzreqen24) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable RTC Period Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen25(&self) -> super::vals::Snzreqen25 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Snzreqen25::from_bits(val as u8)
            }
            #[doc = "Enable RTC Period Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen25(&mut self, val: super::vals::Snzreqen25) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable AGTW1 Underflow Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen28(&self) -> super::vals::Snzreqen28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Snzreqen28::from_bits(val as u8)
            }
            #[doc = "Enable AGTW1 Underflow Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen28(&mut self, val: super::vals::Snzreqen28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Enable AGTW1 Compare Match A Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen29(&self) -> super::vals::Snzreqen29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Snzreqen29::from_bits(val as u8)
            }
            #[doc = "Enable AGTW1 Compare Match A Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen29(&mut self, val: super::vals::Snzreqen29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Enable AGTW1 Compare Match B Snooze Request"]
            #[inline(always)]
            pub const fn snzreqen30(&self) -> super::vals::Snzreqen30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Snzreqen30::from_bits(val as u8)
            }
            #[doc = "Enable AGTW1 Compare Match B Snooze Request"]
            #[inline(always)]
            pub fn set_snzreqen30(&mut self, val: super::vals::Snzreqen30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Snzreqcr0 {
            #[inline(always)]
            fn default() -> Snzreqcr0 {
                Snzreqcr0(0)
            }
        }
        impl core::fmt::Debug for Snzreqcr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snzreqcr0")
                    .field("snzreqen0", &self.snzreqen0())
                    .field("snzreqen1", &self.snzreqen1())
                    .field("snzreqen2", &self.snzreqen2())
                    .field("snzreqen3", &self.snzreqen3())
                    .field("snzreqen4", &self.snzreqen4())
                    .field("snzreqen5", &self.snzreqen5())
                    .field("snzreqen6", &self.snzreqen6())
                    .field("snzreqen7", &self.snzreqen7())
                    .field("snzreqen8", &self.snzreqen8())
                    .field("snzreqen9", &self.snzreqen9())
                    .field("snzreqen10", &self.snzreqen10())
                    .field("snzreqen11", &self.snzreqen11())
                    .field("snzreqen23", &self.snzreqen23())
                    .field("snzreqen24", &self.snzreqen24())
                    .field("snzreqen25", &self.snzreqen25())
                    .field("snzreqen28", &self.snzreqen28())
                    .field("snzreqen29", &self.snzreqen29())
                    .field("snzreqen30", &self.snzreqen30())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snzreqcr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Snzreqcr0 {{ snzreqen0: {:?}, snzreqen1: {:?}, snzreqen2: {:?}, snzreqen3: {:?}, snzreqen4: {:?}, snzreqen5: {:?}, snzreqen6: {:?}, snzreqen7: {:?}, snzreqen8: {:?}, snzreqen9: {:?}, snzreqen10: {:?}, snzreqen11: {:?}, snzreqen23: {:?}, snzreqen24: {:?}, snzreqen25: {:?}, snzreqen28: {:?}, snzreqen29: {:?}, snzreqen30: {:?} }}" , self . snzreqen0 () , self . snzreqen1 () , self . snzreqen2 () , self . snzreqen3 () , self . snzreqen4 () , self . snzreqen5 () , self . snzreqen6 () , self . snzreqen7 () , self . snzreqen8 () , self . snzreqen9 () , self . snzreqen10 () , self . snzreqen11 () , self . snzreqen23 () , self . snzreqen24 () , self . snzreqen25 () , self . snzreqen28 () , self . snzreqen29 () , self . snzreqen30 ())
            }
        }
        #[doc = "Sub,Clock Oscillator Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Somcr(pub u8);
        impl Somcr {
            #[doc = "Sub,Clock Oscillator Drive Capability Switching"]
            #[inline(always)]
            pub const fn sodrv(&self) -> super::vals::Sodrv {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Sodrv::from_bits(val as u8)
            }
            #[doc = "Sub,Clock Oscillator Drive Capability Switching"]
            #[inline(always)]
            pub fn set_sodrv(&mut self, val: super::vals::Sodrv) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Somcr {
            #[inline(always)]
            fn default() -> Somcr {
                Somcr(0)
            }
        }
        impl core::fmt::Debug for Somcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Somcr")
                    .field("sodrv", &self.sodrv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Somcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Somcr {{ sodrv: {:?} }}", self.sodrv())
            }
        }
        #[doc = "Sub,Clock Oscillator Margin Check Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Somrg(pub u8);
        impl Somrg {
            #[doc = "Sub Clock Oscillator Margin Check Switching"]
            #[inline(always)]
            pub const fn soscmrg(&self) -> super::vals::Soscmrg {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Soscmrg::from_bits(val as u8)
            }
            #[doc = "Sub Clock Oscillator Margin Check Switching"]
            #[inline(always)]
            pub fn set_soscmrg(&mut self, val: super::vals::Soscmrg) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Somrg {
            #[inline(always)]
            fn default() -> Somrg {
                Somrg(0)
            }
        }
        impl core::fmt::Debug for Somrg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Somrg")
                    .field("soscmrg", &self.soscmrg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Somrg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Somrg {{ soscmrg: {:?} }}", self.soscmrg())
            }
        }
        #[doc = "Sub Operating Power Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sopccr(pub u8);
        impl Sopccr {
            #[doc = "Sub Operating Power Control Mode Select"]
            #[inline(always)]
            pub const fn sopcm(&self) -> super::vals::Sopcm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sopcm::from_bits(val as u8)
            }
            #[doc = "Sub Operating Power Control Mode Select"]
            #[inline(always)]
            pub fn set_sopcm(&mut self, val: super::vals::Sopcm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub const fn sopcmtsf(&self) -> super::vals::Sopcmtsf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sopcmtsf::from_bits(val as u8)
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub fn set_sopcmtsf(&mut self, val: super::vals::Sopcmtsf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Sopccr {
            #[inline(always)]
            fn default() -> Sopccr {
                Sopccr(0)
            }
        }
        impl core::fmt::Debug for Sopccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sopccr")
                    .field("sopcm", &self.sopcm())
                    .field("sopcmtsf", &self.sopcmtsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sopccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sopccr {{ sopcm: {:?}, sopcmtsf: {:?} }}",
                    self.sopcm(),
                    self.sopcmtsf()
                )
            }
        }
        #[doc = "Sub,Clock Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sosccr(pub u8);
        impl Sosccr {
            #[doc = "Sub Clock Oscillator Stop"]
            #[inline(always)]
            pub const fn sostp(&self) -> super::vals::Sostp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sostp::from_bits(val as u8)
            }
            #[doc = "Sub Clock Oscillator Stop"]
            #[inline(always)]
            pub fn set_sostp(&mut self, val: super::vals::Sostp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Sosccr {
            #[inline(always)]
            fn default() -> Sosccr {
                Sosccr(0)
            }
        }
        impl core::fmt::Debug for Sosccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sosccr")
                    .field("sostp", &self.sostp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sosccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sosccr {{ sostp: {:?} }}", self.sostp())
            }
        }
        #[doc = "Sub Clock Oscillation Stop Detection Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sostd(pub u16);
        impl Sostd {
            #[doc = "Oscillation Stop Detection Time"]
            #[inline(always)]
            pub const fn osdccmp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Oscillation Stop Detection Time"]
            #[inline(always)]
            pub fn set_osdccmp(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u16) & 0x0fff) << 0usize);
            }
            #[doc = "Status of Oscillation Stop Detector Operation"]
            #[inline(always)]
            pub const fn osdcf(&self) -> super::vals::SostdOsdcf {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::SostdOsdcf::from_bits(val as u8)
            }
            #[doc = "Status of Oscillation Stop Detector Operation"]
            #[inline(always)]
            pub fn set_osdcf(&mut self, val: super::vals::SostdOsdcf) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Control of Oscillation Stop Detector Operation"]
            #[inline(always)]
            pub const fn osdce(&self) -> super::vals::SostdOsdce {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::SostdOsdce::from_bits(val as u8)
            }
            #[doc = "Control of Oscillation Stop Detector Operation"]
            #[inline(always)]
            pub fn set_osdce(&mut self, val: super::vals::SostdOsdce) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Sostd {
            #[inline(always)]
            fn default() -> Sostd {
                Sostd(0)
            }
        }
        impl core::fmt::Debug for Sostd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sostd")
                    .field("osdccmp", &self.osdccmp())
                    .field("osdcf", &self.osdcf())
                    .field("osdce", &self.osdce())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sostd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sostd {{ osdccmp: {=u16:?}, osdcf: {:?}, osdce: {:?} }}",
                    self.osdccmp(),
                    self.osdcf(),
                    self.osdce()
                )
            }
        }
        #[doc = "System Control OCD Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syocdcr(pub u8);
        impl Syocdcr {
            #[doc = "Debugger Enable bit"]
            #[inline(always)]
            pub const fn dbgen(&self) -> super::vals::Dbgen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dbgen::from_bits(val as u8)
            }
            #[doc = "Debugger Enable bit"]
            #[inline(always)]
            pub fn set_dbgen(&mut self, val: super::vals::Dbgen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Syocdcr {
            #[inline(always)]
            fn default() -> Syocdcr {
                Syocdcr(0)
            }
        }
        impl core::fmt::Debug for Syocdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syocdcr")
                    .field("dbgen", &self.dbgen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syocdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Syocdcr {{ dbgen: {:?} }}", self.dbgen())
            }
        }
        #[doc = "EXLVDVBAT Comparator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vbtcmpcr(pub u8);
        impl Vbtcmpcr {
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Circuit Output Enable"]
            #[inline(always)]
            pub const fn cmpe(&self) -> super::vals::VbtcmpcrCmpe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::VbtcmpcrCmpe::from_bits(val as u8)
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Circuit Output Enable"]
            #[inline(always)]
            pub fn set_cmpe(&mut self, val: super::vals::VbtcmpcrCmpe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Vbtcmpcr {
            #[inline(always)]
            fn default() -> Vbtcmpcr {
                Vbtcmpcr(0)
            }
        }
        impl core::fmt::Debug for Vbtcmpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vbtcmpcr")
                    .field("cmpe", &self.cmpe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vbtcmpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Vbtcmpcr {{ cmpe: {:?} }}", self.cmpe())
            }
        }
        #[doc = "EXLVDVBAT Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vbtlvdcr(pub u8);
        impl Vbtlvdcr {
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Enable"]
            #[inline(always)]
            pub const fn lvde(&self) -> super::vals::VbtlvdcrLvde {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::VbtlvdcrLvde::from_bits(val as u8)
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Enable"]
            #[inline(always)]
            pub fn set_lvde(&mut self, val: super::vals::VbtlvdcrLvde) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Level Select"]
            #[inline(always)]
            pub const fn lvl(&self) -> super::vals::VbtlvdcrLvl {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::VbtlvdcrLvl::from_bits(val as u8)
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Level Select"]
            #[inline(always)]
            pub fn set_lvl(&mut self, val: super::vals::VbtlvdcrLvl) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Vbtlvdcr {
            #[inline(always)]
            fn default() -> Vbtlvdcr {
                Vbtlvdcr(0)
            }
        }
        impl core::fmt::Debug for Vbtlvdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vbtlvdcr")
                    .field("lvde", &self.lvde())
                    .field("lvl", &self.lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vbtlvdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Vbtlvdcr {{ lvde: {:?}, lvl: {:?} }}",
                    self.lvde(),
                    self.lvl()
                )
            }
        }
        #[doc = "EXLVDVBAT Pin Low Voltage Detect Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vbtlvdicr(pub u8);
        impl Vbtlvdicr {
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Interrupt Enable"]
            #[inline(always)]
            pub const fn ie(&self) -> super::vals::VbtlvdicrIe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::VbtlvdicrIe::from_bits(val as u8)
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Interrupt Enable"]
            #[inline(always)]
            pub fn set_ie(&mut self, val: super::vals::VbtlvdicrIe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Interrupt Generation Condition Select"]
            #[inline(always)]
            pub const fn idtsel(&self) -> super::vals::VbtlvdicrIdtsel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::VbtlvdicrIdtsel::from_bits(val as u8)
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Interrupt Generation Condition Select"]
            #[inline(always)]
            pub fn set_idtsel(&mut self, val: super::vals::VbtlvdicrIdtsel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Vbtlvdicr {
            #[inline(always)]
            fn default() -> Vbtlvdicr {
                Vbtlvdicr(0)
            }
        }
        impl core::fmt::Debug for Vbtlvdicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vbtlvdicr")
                    .field("ie", &self.ie())
                    .field("idtsel", &self.idtsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vbtlvdicr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Vbtlvdicr {{ ie: {:?}, idtsel: {:?} }}",
                    self.ie(),
                    self.idtsel()
                )
            }
        }
        #[doc = "EXLVDVBAT Circuit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vbtlvdsr(pub u8);
        impl Vbtlvdsr {
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::VbtlvdsrDet {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::VbtlvdsrDet::from_bits(val as u8)
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Detect Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::VbtlvdsrDet) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::VbtlvdsrMon {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::VbtlvdsrMon::from_bits(val as u8)
            }
            #[doc = "EXLVDVBAT Pin Low Voltage Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::VbtlvdsrMon) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Vbtlvdsr {
            #[inline(always)]
            fn default() -> Vbtlvdsr {
                Vbtlvdsr(0)
            }
        }
        impl core::fmt::Debug for Vbtlvdsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vbtlvdsr")
                    .field("det", &self.det())
                    .field("mon", &self.mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vbtlvdsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Vbtlvdsr {{ det: {:?}, mon: {:?} }}",
                    self.det(),
                    self.mon()
                )
            }
        }
        #[doc = "VRTC Comparator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vrtcmpcr(pub u8);
        impl Vrtcmpcr {
            #[doc = "VRTC Pin Low Voltage Detect Circuit Output Enable"]
            #[inline(always)]
            pub const fn cmpe(&self) -> super::vals::VrtcmpcrCmpe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::VrtcmpcrCmpe::from_bits(val as u8)
            }
            #[doc = "VRTC Pin Low Voltage Detect Circuit Output Enable"]
            #[inline(always)]
            pub fn set_cmpe(&mut self, val: super::vals::VrtcmpcrCmpe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Vrtcmpcr {
            #[inline(always)]
            fn default() -> Vrtcmpcr {
                Vrtcmpcr(0)
            }
        }
        impl core::fmt::Debug for Vrtcmpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vrtcmpcr")
                    .field("cmpe", &self.cmpe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vrtcmpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Vrtcmpcr {{ cmpe: {:?} }}", self.cmpe())
            }
        }
        #[doc = "LVDVRTC Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vrtlvdcr(pub u8);
        impl Vrtlvdcr {
            #[doc = "VRTC Pin Low Voltage Detect Enable"]
            #[inline(always)]
            pub const fn lvde(&self) -> super::vals::VrtlvdcrLvde {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::VrtlvdcrLvde::from_bits(val as u8)
            }
            #[doc = "VRTC Pin Low Voltage Detect Enable"]
            #[inline(always)]
            pub fn set_lvde(&mut self, val: super::vals::VrtlvdcrLvde) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "VRTC Pin Low Voltage Detect Level Select"]
            #[inline(always)]
            pub const fn lvl(&self) -> super::vals::VrtlvdcrLvl {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::VrtlvdcrLvl::from_bits(val as u8)
            }
            #[doc = "VRTC Pin Low Voltage Detect Level Select"]
            #[inline(always)]
            pub fn set_lvl(&mut self, val: super::vals::VrtlvdcrLvl) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Vrtlvdcr {
            #[inline(always)]
            fn default() -> Vrtlvdcr {
                Vrtlvdcr(0)
            }
        }
        impl core::fmt::Debug for Vrtlvdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vrtlvdcr")
                    .field("lvde", &self.lvde())
                    .field("lvl", &self.lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vrtlvdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Vrtlvdcr {{ lvde: {:?}, lvl: {:?} }}",
                    self.lvde(),
                    self.lvl()
                )
            }
        }
        #[doc = "VRTC Pin Low Voltage Detect Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vrtlvdicr(pub u8);
        impl Vrtlvdicr {
            #[doc = "VRTC Pin Low Voltage Detect Interrupt Enable"]
            #[inline(always)]
            pub const fn ie(&self) -> super::vals::VrtlvdicrIe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::VrtlvdicrIe::from_bits(val as u8)
            }
            #[doc = "VRTC Pin Low Voltage Detect Interrupt Enable"]
            #[inline(always)]
            pub fn set_ie(&mut self, val: super::vals::VrtlvdicrIe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "VRTC Pin Low Voltage Detect Interrupt Generation Condition Select"]
            #[inline(always)]
            pub const fn idtsel(&self) -> super::vals::VrtlvdicrIdtsel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::VrtlvdicrIdtsel::from_bits(val as u8)
            }
            #[doc = "VRTC Pin Low Voltage Detect Interrupt Generation Condition Select"]
            #[inline(always)]
            pub fn set_idtsel(&mut self, val: super::vals::VrtlvdicrIdtsel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Vrtlvdicr {
            #[inline(always)]
            fn default() -> Vrtlvdicr {
                Vrtlvdicr(0)
            }
        }
        impl core::fmt::Debug for Vrtlvdicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vrtlvdicr")
                    .field("ie", &self.ie())
                    .field("idtsel", &self.idtsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vrtlvdicr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Vrtlvdicr {{ ie: {:?}, idtsel: {:?} }}",
                    self.ie(),
                    self.idtsel()
                )
            }
        }
        #[doc = "VRTC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vrtsr(pub u8);
        impl Vrtsr {
            #[doc = "VRTC,domain Power,on Reset Detect Flag"]
            #[inline(always)]
            pub const fn pordet(&self) -> super::vals::Pordet {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pordet::from_bits(val as u8)
            }
            #[doc = "VRTC,domain Power,on Reset Detect Flag"]
            #[inline(always)]
            pub fn set_pordet(&mut self, val: super::vals::Pordet) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "VRTC Voltage Variation Detection Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::VrtsrDet {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::VrtsrDet::from_bits(val as u8)
            }
            #[doc = "VRTC Voltage Variation Detection Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::VrtsrDet) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "VRTC,domain Valid"]
            #[inline(always)]
            pub const fn vrtvld(&self) -> super::vals::Vrtvld {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Vrtvld::from_bits(val as u8)
            }
            #[doc = "VRTC,domain Valid"]
            #[inline(always)]
            pub fn set_vrtvld(&mut self, val: super::vals::Vrtvld) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "VRTC Signal Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::VrtsrMon {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::VrtsrMon::from_bits(val as u8)
            }
            #[doc = "VRTC Signal Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::VrtsrMon) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Vrtsr {
            #[inline(always)]
            fn default() -> Vrtsr {
                Vrtsr(0)
            }
        }
        impl core::fmt::Debug for Vrtsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vrtsr")
                    .field("pordet", &self.pordet())
                    .field("det", &self.det())
                    .field("vrtvld", &self.vrtvld())
                    .field("mon", &self.mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vrtsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Vrtsr {{ pordet: {:?}, det: {:?}, vrtvld: {:?}, mon: {:?} }}",
                    self.pordet(),
                    self.det(),
                    self.vrtvld(),
                    self.mon()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ad0mated {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ad0mated {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ad0mated {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ad0mated {
            #[inline(always)]
            fn from(val: u8) -> Ad0mated {
                Ad0mated::from_bits(val)
            }
        }
        impl From<Ad0mated> for u8 {
            #[inline(always)]
            fn from(val: Ad0mated) -> u8 {
                Ad0mated::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ad0umted {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ad0umted {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ad0umted {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ad0umted {
            #[inline(always)]
            fn from(val: u8) -> Ad0umted {
                Ad0umted::from_bits(val)
            }
        }
        impl From<Ad0umted> for u8 {
            #[inline(always)]
            fn from(val: Ad0umted) -> u8 {
                Ad0umted::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agtwunfed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agtwunfed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agtwunfed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agtwunfed {
            #[inline(always)]
            fn from(val: u8) -> Agtwunfed {
                Agtwunfed::from_bits(val)
            }
        }
        impl From<Agtwunfed> for u8 {
            #[inline(always)]
            fn from(val: Agtwunfed) -> u8 {
                Agtwunfed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bpfclkdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bpfclkdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bpfclkdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bpfclkdis {
            #[inline(always)]
            fn from(val: u8) -> Bpfclkdis {
                Bpfclkdis::from_bits(val)
            }
        }
        impl From<Bpfclkdis> for u8 {
            #[inline(always)]
            fn from(val: Bpfclkdis) -> u8 {
                Bpfclkdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmrf {
            #[inline(always)]
            fn from(val: u8) -> Busmrf {
                Busmrf::from_bits(val)
            }
        }
        impl From<Busmrf> for u8 {
            #[inline(always)]
            fn from(val: Busmrf) -> u8 {
                Busmrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussrf {
            #[inline(always)]
            fn from(val: u8) -> Bussrf {
                Bussrf::from_bits(val)
            }
        }
        impl From<Bussrf> for u8 {
            #[inline(always)]
            fn from(val: Bussrf) -> u8 {
                Bussrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckodiv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ckodiv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckodiv {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckodiv {
            #[inline(always)]
            fn from(val: u8) -> Ckodiv {
                Ckodiv::from_bits(val)
            }
        }
        impl From<Ckodiv> for u8 {
            #[inline(always)]
            fn from(val: Ckodiv) -> u8 {
                Ckodiv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckoen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckoen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckoen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckoen {
            #[inline(always)]
            fn from(val: u8) -> Ckoen {
                Ckoen::from_bits(val)
            }
        }
        impl From<Ckoen> for u8 {
            #[inline(always)]
            fn from(val: Ckoen) -> u8 {
                Ckoen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckosel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ckosel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckosel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckosel {
            #[inline(always)]
            fn from(val: u8) -> Ckosel {
                Ckosel::from_bits(val)
            }
        }
        impl From<Ckosel> for u8 {
            #[inline(always)]
            fn from(val: Ckosel) -> u8 {
                Ckosel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cwsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cwsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cwsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cwsf {
            #[inline(always)]
            fn from(val: u8) -> Cwsf {
                Cwsf::from_bits(val)
            }
        }
        impl From<Cwsf> for u8 {
            #[inline(always)]
            fn from(val: Cwsf) -> u8 {
                Cwsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dbgen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dbgen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dbgen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dbgen {
            #[inline(always)]
            fn from(val: u8) -> Dbgen {
                Dbgen::from_bits(val)
            }
        }
        impl From<Dbgen> for u8 {
            #[inline(always)]
            fn from(val: Dbgen) -> u8 {
                Dbgen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dclkdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Dclkdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dclkdis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dclkdis {
            #[inline(always)]
            fn from(val: u8) -> Dclkdis {
                Dclkdis::from_bits(val)
            }
        }
        impl From<Dclkdis> for u8 {
            #[inline(always)]
            fn from(val: Dclkdis) -> u8 {
                Dclkdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtcnzred {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtcnzred {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtcnzred {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtcnzred {
            #[inline(always)]
            fn from(val: u8) -> Dtcnzred {
                Dtcnzred::from_bits(val)
            }
        }
        impl From<Dtcnzred> for u8 {
            #[inline(always)]
            fn from(val: Dtcnzred) -> u8 {
                Dtcnzred::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtczred {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtczred {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtczred {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtczred {
            #[inline(always)]
            fn from(val: u8) -> Dtczred {
                Dtczred::from_bits(val)
            }
        }
        impl From<Dtczred> for u8 {
            #[inline(always)]
            fn from(val: Dtczred) -> u8 {
                Dtczred::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExlvdcmpcrCmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ExlvdcmpcrCmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExlvdcmpcrCmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExlvdcmpcrCmpe {
            #[inline(always)]
            fn from(val: u8) -> ExlvdcmpcrCmpe {
                ExlvdcmpcrCmpe::from_bits(val)
            }
        }
        impl From<ExlvdcmpcrCmpe> for u8 {
            #[inline(always)]
            fn from(val: ExlvdcmpcrCmpe) -> u8 {
                ExlvdcmpcrCmpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExlvdcrLvde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ExlvdcrLvde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExlvdcrLvde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExlvdcrLvde {
            #[inline(always)]
            fn from(val: u8) -> ExlvdcrLvde {
                ExlvdcrLvde::from_bits(val)
            }
        }
        impl From<ExlvdcrLvde> for u8 {
            #[inline(always)]
            fn from(val: ExlvdcrLvde) -> u8 {
                ExlvdcrLvde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExlvdicrIdtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ExlvdicrIdtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExlvdicrIdtsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExlvdicrIdtsel {
            #[inline(always)]
            fn from(val: u8) -> ExlvdicrIdtsel {
                ExlvdicrIdtsel::from_bits(val)
            }
        }
        impl From<ExlvdicrIdtsel> for u8 {
            #[inline(always)]
            fn from(val: ExlvdicrIdtsel) -> u8 {
                ExlvdicrIdtsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExlvdicrIe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ExlvdicrIe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExlvdicrIe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExlvdicrIe {
            #[inline(always)]
            fn from(val: u8) -> ExlvdicrIe {
                ExlvdicrIe::from_bits(val)
            }
        }
        impl From<ExlvdicrIe> for u8 {
            #[inline(always)]
            fn from(val: ExlvdicrIe) -> u8 {
                ExlvdicrIe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExlvdsrDet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ExlvdsrDet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExlvdsrDet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExlvdsrDet {
            #[inline(always)]
            fn from(val: u8) -> ExlvdsrDet {
                ExlvdsrDet::from_bits(val)
            }
        }
        impl From<ExlvdsrDet> for u8 {
            #[inline(always)]
            fn from(val: ExlvdsrDet) -> u8 {
                ExlvdsrDet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExlvdsrMon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ExlvdsrMon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExlvdsrMon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExlvdsrMon {
            #[inline(always)]
            fn from(val: u8) -> ExlvdsrMon {
                ExlvdsrMon::from_bits(val)
            }
        }
        impl From<ExlvdsrMon> for u8 {
            #[inline(always)]
            fn from(val: ExlvdsrMon) -> u8 {
                ExlvdsrMon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hcstp {
            #[inline(always)]
            fn from(val: u8) -> Hcstp {
                Hcstp::from_bits(val)
            }
        }
        impl From<Hcstp> for u8 {
            #[inline(always)]
            fn from(val: Hcstp) -> u8 {
                Hcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hocosf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hocosf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hocosf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hocosf {
            #[inline(always)]
            fn from(val: u8) -> Hocosf {
                Hocosf::from_bits(val)
            }
        }
        impl From<Hocosf> for u8 {
            #[inline(always)]
            fn from(val: Hocosf) -> u8 {
                Hocosf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hsts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Hsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hsts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hsts {
            #[inline(always)]
            fn from(val: u8) -> Hsts {
                Hsts::from_bits(val)
            }
        }
        impl From<Hsts> for u8 {
            #[inline(always)]
            fn from(val: Hsts) -> u8 {
                Hsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ick {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ick {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ick {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ick {
            #[inline(always)]
            fn from(val: u8) -> Ick {
                Ick::from_bits(val)
            }
        }
        impl From<Ick> for u8 {
            #[inline(always)]
            fn from(val: Ick) -> u8 {
                Ick::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtrf {
            #[inline(always)]
            fn from(val: u8) -> Iwdtrf {
                Iwdtrf::from_bits(val)
            }
        }
        impl From<Iwdtrf> for u8 {
            #[inline(always)]
            fn from(val: Iwdtrf) -> u8 {
                Iwdtrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcdscken {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lcdscken {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcdscken {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcdscken {
            #[inline(always)]
            fn from(val: u8) -> Lcdscken {
                Lcdscken::from_bits(val)
            }
        }
        impl From<Lcdscken> for u8 {
            #[inline(always)]
            fn from(val: Lcdscken) -> u8 {
                Lcdscken::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcdscksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Lcdscksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcdscksel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcdscksel {
            #[inline(always)]
            fn from(val: u8) -> Lcdscksel {
                Lcdscksel::from_bits(val)
            }
        }
        impl From<Lcdscksel> for u8 {
            #[inline(always)]
            fn from(val: Lcdscksel) -> u8 {
                Lcdscksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcstp {
            #[inline(always)]
            fn from(val: u8) -> Lcstp {
                Lcstp::from_bits(val)
            }
        }
        impl From<Lcstp> for u8 {
            #[inline(always)]
            fn from(val: Lcstp) -> u8 {
                Lcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpopten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lpopten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpopten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpopten {
            #[inline(always)]
            fn from(val: u8) -> Lpopten {
                Lpopten::from_bits(val)
            }
        }
        impl From<Lpopten> for u8 {
            #[inline(always)]
            fn from(val: Lpopten) -> u8 {
                Lpopten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd0rf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd0rf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd0rf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd0rf {
            #[inline(always)]
            fn from(val: u8) -> Lvd0rf {
                Lvd0rf::from_bits(val)
            }
        }
        impl From<Lvd0rf> for u8 {
            #[inline(always)]
            fn from(val: Lvd0rf) -> u8 {
                Lvd0rf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Cmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Cmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Cmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Cmpe {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Cmpe {
                Lvd1cr0Cmpe::from_bits(val)
            }
        }
        impl From<Lvd1cr0Cmpe> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Cmpe) -> u8 {
                Lvd1cr0Cmpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Ri {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Ri {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Ri {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Ri {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Ri {
                Lvd1cr0Ri::from_bits(val)
            }
        }
        impl From<Lvd1cr0Ri> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Ri) -> u8 {
                Lvd1cr0Ri::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Rie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Rie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Rie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Rie {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Rie {
                Lvd1cr0Rie::from_bits(val)
            }
        }
        impl From<Lvd1cr0Rie> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Rie) -> u8 {
                Lvd1cr0Rie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Rn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Rn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Rn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Rn {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Rn {
                Lvd1cr0Rn::from_bits(val)
            }
        }
        impl From<Lvd1cr0Rn> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Rn) -> u8 {
                Lvd1cr0Rn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr1Idtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lvd1cr1Idtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr1Idtsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr1Idtsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr1Idtsel {
                Lvd1cr1Idtsel::from_bits(val)
            }
        }
        impl From<Lvd1cr1Idtsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr1Idtsel) -> u8 {
                Lvd1cr1Idtsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr1Irqsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr1Irqsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr1Irqsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr1Irqsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr1Irqsel {
                Lvd1cr1Irqsel::from_bits(val)
            }
        }
        impl From<Lvd1cr1Irqsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr1Irqsel) -> u8 {
                Lvd1cr1Irqsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1e {
            #[inline(always)]
            fn from(val: u8) -> Lvd1e {
                Lvd1e::from_bits(val)
            }
        }
        impl From<Lvd1e> for u8 {
            #[inline(always)]
            fn from(val: Lvd1e) -> u8 {
                Lvd1e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1lvl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Lvd1lvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1lvl {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1lvl {
            #[inline(always)]
            fn from(val: u8) -> Lvd1lvl {
                Lvd1lvl::from_bits(val)
            }
        }
        impl From<Lvd1lvl> for u8 {
            #[inline(always)]
            fn from(val: Lvd1lvl) -> u8 {
                Lvd1lvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1rf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1rf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1rf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1rf {
            #[inline(always)]
            fn from(val: u8) -> Lvd1rf {
                Lvd1rf::from_bits(val)
            }
        }
        impl From<Lvd1rf> for u8 {
            #[inline(always)]
            fn from(val: Lvd1rf) -> u8 {
                Lvd1rf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1srDet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1srDet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1srDet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1srDet {
            #[inline(always)]
            fn from(val: u8) -> Lvd1srDet {
                Lvd1srDet::from_bits(val)
            }
        }
        impl From<Lvd1srDet> for u8 {
            #[inline(always)]
            fn from(val: Lvd1srDet) -> u8 {
                Lvd1srDet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1srMon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1srMon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1srMon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1srMon {
            #[inline(always)]
            fn from(val: u8) -> Lvd1srMon {
                Lvd1srMon::from_bits(val)
            }
        }
        impl From<Lvd1srMon> for u8 {
            #[inline(always)]
            fn from(val: Lvd1srMon) -> u8 {
                Lvd1srMon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Cmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Cmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Cmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Cmpe {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Cmpe {
                Lvd2cr0Cmpe::from_bits(val)
            }
        }
        impl From<Lvd2cr0Cmpe> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Cmpe) -> u8 {
                Lvd2cr0Cmpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Ri {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Ri {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Ri {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Ri {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Ri {
                Lvd2cr0Ri::from_bits(val)
            }
        }
        impl From<Lvd2cr0Ri> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Ri) -> u8 {
                Lvd2cr0Ri::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Rie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Rie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Rie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Rie {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Rie {
                Lvd2cr0Rie::from_bits(val)
            }
        }
        impl From<Lvd2cr0Rie> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Rie) -> u8 {
                Lvd2cr0Rie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Rn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Rn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Rn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Rn {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Rn {
                Lvd2cr0Rn::from_bits(val)
            }
        }
        impl From<Lvd2cr0Rn> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Rn) -> u8 {
                Lvd2cr0Rn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr1Idtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lvd2cr1Idtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr1Idtsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr1Idtsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr1Idtsel {
                Lvd2cr1Idtsel::from_bits(val)
            }
        }
        impl From<Lvd2cr1Idtsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr1Idtsel) -> u8 {
                Lvd2cr1Idtsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr1Irqsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr1Irqsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr1Irqsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr1Irqsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr1Irqsel {
                Lvd2cr1Irqsel::from_bits(val)
            }
        }
        impl From<Lvd2cr1Irqsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr1Irqsel) -> u8 {
                Lvd2cr1Irqsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2e {
            #[inline(always)]
            fn from(val: u8) -> Lvd2e {
                Lvd2e::from_bits(val)
            }
        }
        impl From<Lvd2e> for u8 {
            #[inline(always)]
            fn from(val: Lvd2e) -> u8 {
                Lvd2e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2lvl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Lvd2lvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2lvl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2lvl {
            #[inline(always)]
            fn from(val: u8) -> Lvd2lvl {
                Lvd2lvl::from_bits(val)
            }
        }
        impl From<Lvd2lvl> for u8 {
            #[inline(always)]
            fn from(val: Lvd2lvl) -> u8 {
                Lvd2lvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2rf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2rf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2rf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2rf {
            #[inline(always)]
            fn from(val: u8) -> Lvd2rf {
                Lvd2rf::from_bits(val)
            }
        }
        impl From<Lvd2rf> for u8 {
            #[inline(always)]
            fn from(val: Lvd2rf) -> u8 {
                Lvd2rf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2srDet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2srDet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2srDet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2srDet {
            #[inline(always)]
            fn from(val: u8) -> Lvd2srDet {
                Lvd2srDet::from_bits(val)
            }
        }
        impl From<Lvd2srDet> for u8 {
            #[inline(always)]
            fn from(val: Lvd2srDet) -> u8 {
                Lvd2srDet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2srMon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2srMon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2srMon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2srMon {
            #[inline(always)]
            fn from(val: u8) -> Lvd2srMon {
                Lvd2srMon::from_bits(val)
            }
        }
        impl From<Lvd2srMon> for u8 {
            #[inline(always)]
            fn from(val: Lvd2srMon) -> u8 {
                Lvd2srMon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mcstp {
            #[inline(always)]
            fn from(val: u8) -> Mcstp {
                Mcstp::from_bits(val)
            }
        }
        impl From<Mcstp> for u8 {
            #[inline(always)]
            fn from(val: Mcstp) -> u8 {
                Mcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Memwait {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Memwait {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Memwait {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Memwait {
            #[inline(always)]
            fn from(val: u8) -> Memwait {
                Memwait::from_bits(val)
            }
        }
        impl From<Memwait> for u8 {
            #[inline(always)]
            fn from(val: Memwait) -> u8 {
                Memwait::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modrv1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Modrv1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modrv1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modrv1 {
            #[inline(always)]
            fn from(val: u8) -> Modrv1 {
                Modrv1::from_bits(val)
            }
        }
        impl From<Modrv1> for u8 {
            #[inline(always)]
            fn from(val: Modrv1) -> u8 {
                Modrv1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moscsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moscsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moscsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moscsf {
            #[inline(always)]
            fn from(val: u8) -> Moscsf {
                Moscsf::from_bits(val)
            }
        }
        impl From<Moscsf> for u8 {
            #[inline(always)]
            fn from(val: Moscsf) -> u8 {
                Moscsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mosel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mosel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mosel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mosel {
            #[inline(always)]
            fn from(val: u8) -> Mosel {
                Mosel::from_bits(val)
            }
        }
        impl From<Mosel> for u8 {
            #[inline(always)]
            fn from(val: Mosel) -> u8 {
                Mosel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MostdOsdce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MostdOsdce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MostdOsdce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MostdOsdce {
            #[inline(always)]
            fn from(val: u8) -> MostdOsdce {
                MostdOsdce::from_bits(val)
            }
        }
        impl From<MostdOsdce> for u8 {
            #[inline(always)]
            fn from(val: MostdOsdce) -> u8 {
                MostdOsdce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MostdOsdcf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MostdOsdcf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MostdOsdcf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MostdOsdcf {
            #[inline(always)]
            fn from(val: u8) -> MostdOsdcf {
                MostdOsdcf::from_bits(val)
            }
        }
        impl From<MostdOsdcf> for u8 {
            #[inline(always)]
            fn from(val: MostdOsdcf) -> u8 {
                MostdOsdcf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mostp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mostp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mostp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mostp {
            #[inline(always)]
            fn from(val: u8) -> Mostp {
                Mostp::from_bits(val)
            }
        }
        impl From<Mostp> for u8 {
            #[inline(always)]
            fn from(val: Mostp) -> u8 {
                Mostp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpudis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpudis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpudis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpudis {
            #[inline(always)]
            fn from(val: u8) -> Mpudis {
                Mpudis::from_bits(val)
            }
        }
        impl From<Mpudis> for u8 {
            #[inline(always)]
            fn from(val: Mpudis) -> u8 {
                Mpudis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpa16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpa16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpa16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpa16 {
            #[inline(always)]
            fn from(val: u8) -> Mstpa16 {
                Mstpa16::from_bits(val)
            }
        }
        impl From<Mstpa16> for u8 {
            #[inline(always)]
            fn from(val: Mstpa16) -> u8 {
                Mstpa16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpa17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpa17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpa17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpa17 {
            #[inline(always)]
            fn from(val: u8) -> Mstpa17 {
                Mstpa17::from_bits(val)
            }
        }
        impl From<Mstpa17> for u8 {
            #[inline(always)]
            fn from(val: Mstpa17) -> u8 {
                Mstpa17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpa22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpa22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpa22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpa22 {
            #[inline(always)]
            fn from(val: u8) -> Mstpa22 {
                Mstpa22::from_bits(val)
            }
        }
        impl From<Mstpa22> for u8 {
            #[inline(always)]
            fn from(val: Mstpa22) -> u8 {
                Mstpa22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Msts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Msts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Msts {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Msts {
            #[inline(always)]
            fn from(val: u8) -> Msts {
                Msts::from_bits(val)
            }
        }
        impl From<Msts> for u8 {
            #[inline(always)]
            fn from(val: Msts) -> u8 {
                Msts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opcm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Opcm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opcm {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opcm {
            #[inline(always)]
            fn from(val: u8) -> Opcm {
                Opcm::from_bits(val)
            }
        }
        impl From<Opcm> for u8 {
            #[inline(always)]
            fn from(val: Opcm) -> u8 {
                Opcm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opcmtsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Opcmtsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opcmtsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opcmtsf {
            #[inline(always)]
            fn from(val: u8) -> Opcmtsf {
                Opcmtsf::from_bits(val)
            }
        }
        impl From<Opcmtsf> for u8 {
            #[inline(always)]
            fn from(val: Opcmtsf) -> u8 {
                Opcmtsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostdcse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostdcse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostdcse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostdcse {
            #[inline(always)]
            fn from(val: u8) -> Ostdcse {
                Ostdcse::from_bits(val)
            }
        }
        impl From<Ostdcse> for u8 {
            #[inline(always)]
            fn from(val: Ostdcse) -> u8 {
                Ostdcse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostde {
            #[inline(always)]
            fn from(val: u8) -> Ostde {
                Ostde::from_bits(val)
            }
        }
        impl From<Ostde> for u8 {
            #[inline(always)]
            fn from(val: Ostde) -> u8 {
                Ostde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostdf {
            #[inline(always)]
            fn from(val: u8) -> Ostdf {
                Ostdf::from_bits(val)
            }
        }
        impl From<Ostdf> for u8 {
            #[inline(always)]
            fn from(val: Ostdf) -> u8 {
                Ostdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ostdie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ostdie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ostdie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ostdie {
            #[inline(always)]
            fn from(val: u8) -> Ostdie {
                Ostdie::from_bits(val)
            }
        }
        impl From<Ostdie> for u8 {
            #[inline(always)]
            fn from(val: Ostdie) -> u8 {
                Ostdie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pckb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Pckb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pckb {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pckb {
            #[inline(always)]
            fn from(val: u8) -> Pckb {
                Pckb::from_bits(val)
            }
        }
        impl From<Pckb> for u8 {
            #[inline(always)]
            fn from(val: Pckb) -> u8 {
                Pckb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pckd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Pckd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pckd {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pckd {
            #[inline(always)]
            fn from(val: u8) -> Pckd {
                Pckd::from_bits(val)
            }
        }
        impl From<Pckd> for u8 {
            #[inline(always)]
            fn from(val: Pckd) -> u8 {
                Pckd::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Pllmul(u8);
        impl Pllmul {}
        impl Pllmul {
            pub const fn from_bits(val: u8) -> Pllmul {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Pllmul {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pllmul {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Pllmul {
            #[inline(always)]
            fn from(val: u8) -> Pllmul {
                Pllmul::from_bits(val)
            }
        }
        impl From<Pllmul> for u8 {
            #[inline(always)]
            fn from(val: Pllmul) -> u8 {
                Pllmul::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pllsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pllsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pllsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pllsf {
            #[inline(always)]
            fn from(val: u8) -> Pllsf {
                Pllsf::from_bits(val)
            }
        }
        impl From<Pllsf> for u8 {
            #[inline(always)]
            fn from(val: Pllsf) -> u8 {
                Pllsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pllstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pllstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pllstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pllstp {
            #[inline(always)]
            fn from(val: u8) -> Pllstp {
                Pllstp::from_bits(val)
            }
        }
        impl From<Pllstp> for u8 {
            #[inline(always)]
            fn from(val: Pllstp) -> u8 {
                Pllstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pordet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pordet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pordet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pordet {
            #[inline(always)]
            fn from(val: u8) -> Pordet {
                Pordet::from_bits(val)
            }
        }
        impl From<Pordet> for u8 {
            #[inline(always)]
            fn from(val: Pordet) -> u8 {
                Pordet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porf {
            #[inline(always)]
            fn from(val: u8) -> Porf {
                Porf::from_bits(val)
            }
        }
        impl From<Porf> for u8 {
            #[inline(always)]
            fn from(val: Porf) -> u8 {
                Porf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc0 {
            #[inline(always)]
            fn from(val: u8) -> Prc0 {
                Prc0::from_bits(val)
            }
        }
        impl From<Prc0> for u8 {
            #[inline(always)]
            fn from(val: Prc0) -> u8 {
                Prc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc1 {
            #[inline(always)]
            fn from(val: u8) -> Prc1 {
                Prc1::from_bits(val)
            }
        }
        impl From<Prc1> for u8 {
            #[inline(always)]
            fn from(val: Prc1) -> u8 {
                Prc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc3 {
            #[inline(always)]
            fn from(val: u8) -> Prc3 {
                Prc3::from_bits(val)
            }
        }
        impl From<Prc3> for u8 {
            #[inline(always)]
            fn from(val: Prc3) -> u8 {
                Prc3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Psmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psmc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psmc {
            #[inline(always)]
            fn from(val: u8) -> Psmc {
                Psmc::from_bits(val)
            }
        }
        impl From<Psmc> for u8 {
            #[inline(always)]
            fn from(val: Psmc) -> u8 {
                Psmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reerf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Reerf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reerf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reerf {
            #[inline(always)]
            fn from(val: u8) -> Reerf {
                Reerf::from_bits(val)
            }
        }
        impl From<Reerf> for u8 {
            #[inline(always)]
            fn from(val: Reerf) -> u8 {
                Reerf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rperf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rperf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rperf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rperf {
            #[inline(always)]
            fn from(val: u8) -> Rperf {
                Rperf::from_bits(val)
            }
        }
        impl From<Rperf> for u8 {
            #[inline(always)]
            fn from(val: Rperf) -> u8 {
                Rperf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdreqen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdreqen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdreqen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdreqen {
            #[inline(always)]
            fn from(val: u8) -> Rxdreqen {
                Rxdreqen::from_bits(val)
            }
        }
        impl From<Rxdreqen> for u8 {
            #[inline(always)]
            fn from(val: Rxdreqen) -> u8 {
                Rxdreqen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sci0umted {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sci0umted {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sci0umted {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sci0umted {
            #[inline(always)]
            fn from(val: u8) -> Sci0umted {
                Sci0umted::from_bits(val)
            }
        }
        impl From<Sci0umted> for u8 {
            #[inline(always)]
            fn from(val: Sci0umted) -> u8 {
                Sci0umted::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SckscrCksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl SckscrCksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SckscrCksel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SckscrCksel {
            #[inline(always)]
            fn from(val: u8) -> SckscrCksel {
                SckscrCksel::from_bits(val)
            }
        }
        impl From<SckscrCksel> for u8 {
            #[inline(always)]
            fn from(val: SckscrCksel) -> u8 {
                SckscrCksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SdadcckcrCksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SdadcckcrCksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SdadcckcrCksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SdadcckcrCksel {
            #[inline(always)]
            fn from(val: u8) -> SdadcckcrCksel {
                SdadcckcrCksel::from_bits(val)
            }
        }
        impl From<SdadcckcrCksel> for u8 {
            #[inline(always)]
            fn from(val: SdadcckcrCksel) -> u8 {
                SdadcckcrCksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzdtcen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzdtcen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzdtcen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzdtcen {
            #[inline(always)]
            fn from(val: u8) -> Snzdtcen {
                Snzdtcen::from_bits(val)
            }
        }
        impl From<Snzdtcen> for u8 {
            #[inline(always)]
            fn from(val: Snzdtcen) -> u8 {
                Snzdtcen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snze {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snze {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snze {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snze {
            #[inline(always)]
            fn from(val: u8) -> Snze {
                Snze::from_bits(val)
            }
        }
        impl From<Snze> for u8 {
            #[inline(always)]
            fn from(val: Snze) -> u8 {
                Snze::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen0 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen0 {
                Snzreqen0::from_bits(val)
            }
        }
        impl From<Snzreqen0> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen0) -> u8 {
                Snzreqen0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen1 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen1 {
                Snzreqen1::from_bits(val)
            }
        }
        impl From<Snzreqen1> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen1) -> u8 {
                Snzreqen1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen10 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen10 {
                Snzreqen10::from_bits(val)
            }
        }
        impl From<Snzreqen10> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen10) -> u8 {
                Snzreqen10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen11 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen11 {
                Snzreqen11::from_bits(val)
            }
        }
        impl From<Snzreqen11> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen11) -> u8 {
                Snzreqen11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen2 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen2 {
                Snzreqen2::from_bits(val)
            }
        }
        impl From<Snzreqen2> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen2) -> u8 {
                Snzreqen2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen23 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen23 {
                Snzreqen23::from_bits(val)
            }
        }
        impl From<Snzreqen23> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen23) -> u8 {
                Snzreqen23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen24 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen24 {
                Snzreqen24::from_bits(val)
            }
        }
        impl From<Snzreqen24> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen24) -> u8 {
                Snzreqen24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen25 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen25 {
                Snzreqen25::from_bits(val)
            }
        }
        impl From<Snzreqen25> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen25) -> u8 {
                Snzreqen25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen28 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen28 {
                Snzreqen28::from_bits(val)
            }
        }
        impl From<Snzreqen28> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen28) -> u8 {
                Snzreqen28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen29 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen29 {
                Snzreqen29::from_bits(val)
            }
        }
        impl From<Snzreqen29> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen29) -> u8 {
                Snzreqen29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen3 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen3 {
                Snzreqen3::from_bits(val)
            }
        }
        impl From<Snzreqen3> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen3) -> u8 {
                Snzreqen3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen30 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen30 {
                Snzreqen30::from_bits(val)
            }
        }
        impl From<Snzreqen30> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen30) -> u8 {
                Snzreqen30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen4 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen4 {
                Snzreqen4::from_bits(val)
            }
        }
        impl From<Snzreqen4> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen4) -> u8 {
                Snzreqen4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen5 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen5 {
                Snzreqen5::from_bits(val)
            }
        }
        impl From<Snzreqen5> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen5) -> u8 {
                Snzreqen5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen6 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen6 {
                Snzreqen6::from_bits(val)
            }
        }
        impl From<Snzreqen6> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen6) -> u8 {
                Snzreqen6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen7 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen7 {
                Snzreqen7::from_bits(val)
            }
        }
        impl From<Snzreqen7> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen7) -> u8 {
                Snzreqen7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen8 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen8 {
                Snzreqen8::from_bits(val)
            }
        }
        impl From<Snzreqen8> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen8) -> u8 {
                Snzreqen8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen9 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen9 {
                Snzreqen9::from_bits(val)
            }
        }
        impl From<Snzreqen9> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen9) -> u8 {
                Snzreqen9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sodrv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sodrv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sodrv {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sodrv {
            #[inline(always)]
            fn from(val: u8) -> Sodrv {
                Sodrv::from_bits(val)
            }
        }
        impl From<Sodrv> for u8 {
            #[inline(always)]
            fn from(val: Sodrv) -> u8 {
                Sodrv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sopcm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sopcm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sopcm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sopcm {
            #[inline(always)]
            fn from(val: u8) -> Sopcm {
                Sopcm::from_bits(val)
            }
        }
        impl From<Sopcm> for u8 {
            #[inline(always)]
            fn from(val: Sopcm) -> u8 {
                Sopcm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sopcmtsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sopcmtsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sopcmtsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sopcmtsf {
            #[inline(always)]
            fn from(val: u8) -> Sopcmtsf {
                Sopcmtsf::from_bits(val)
            }
        }
        impl From<Sopcmtsf> for u8 {
            #[inline(always)]
            fn from(val: Sopcmtsf) -> u8 {
                Sopcmtsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Soscmrg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Soscmrg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Soscmrg {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Soscmrg {
            #[inline(always)]
            fn from(val: u8) -> Soscmrg {
                Soscmrg::from_bits(val)
            }
        }
        impl From<Soscmrg> for u8 {
            #[inline(always)]
            fn from(val: Soscmrg) -> u8 {
                Soscmrg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SostdOsdce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SostdOsdce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SostdOsdce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SostdOsdce {
            #[inline(always)]
            fn from(val: u8) -> SostdOsdce {
                SostdOsdce::from_bits(val)
            }
        }
        impl From<SostdOsdce> for u8 {
            #[inline(always)]
            fn from(val: SostdOsdce) -> u8 {
                SostdOsdce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SostdOsdcf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SostdOsdcf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SostdOsdcf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SostdOsdcf {
            #[inline(always)]
            fn from(val: u8) -> SostdOsdcf {
                SostdOsdcf::from_bits(val)
            }
        }
        impl From<SostdOsdcf> for u8 {
            #[inline(always)]
            fn from(val: SostdOsdcf) -> u8 {
                SostdOsdcf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sostp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sostp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sostp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sostp {
            #[inline(always)]
            fn from(val: u8) -> Sostp {
                Sostp::from_bits(val)
            }
        }
        impl From<Sostp> for u8 {
            #[inline(always)]
            fn from(val: Sostp) -> u8 {
                Sostp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sperf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sperf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sperf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sperf {
            #[inline(always)]
            fn from(val: u8) -> Sperf {
                Sperf::from_bits(val)
            }
        }
        impl From<Sperf> for u8 {
            #[inline(always)]
            fn from(val: Sperf) -> u8 {
                Sperf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssby {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssby {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssby {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssby {
            #[inline(always)]
            fn from(val: u8) -> Ssby {
                Ssby::from_bits(val)
            }
        }
        impl From<Ssby> for u8 {
            #[inline(always)]
            fn from(val: Ssby) -> u8 {
                Ssby::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Swrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swrf {
            #[inline(always)]
            fn from(val: u8) -> Swrf {
                Swrf::from_bits(val)
            }
        }
        impl From<Swrf> for u8 {
            #[inline(always)]
            fn from(val: Swrf) -> u8 {
                Swrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VbtcmpcrCmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VbtcmpcrCmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VbtcmpcrCmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VbtcmpcrCmpe {
            #[inline(always)]
            fn from(val: u8) -> VbtcmpcrCmpe {
                VbtcmpcrCmpe::from_bits(val)
            }
        }
        impl From<VbtcmpcrCmpe> for u8 {
            #[inline(always)]
            fn from(val: VbtcmpcrCmpe) -> u8 {
                VbtcmpcrCmpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VbtlvdcrLvde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VbtlvdcrLvde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VbtlvdcrLvde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VbtlvdcrLvde {
            #[inline(always)]
            fn from(val: u8) -> VbtlvdcrLvde {
                VbtlvdcrLvde::from_bits(val)
            }
        }
        impl From<VbtlvdcrLvde> for u8 {
            #[inline(always)]
            fn from(val: VbtlvdcrLvde) -> u8 {
                VbtlvdcrLvde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VbtlvdcrLvl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl VbtlvdcrLvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VbtlvdcrLvl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VbtlvdcrLvl {
            #[inline(always)]
            fn from(val: u8) -> VbtlvdcrLvl {
                VbtlvdcrLvl::from_bits(val)
            }
        }
        impl From<VbtlvdcrLvl> for u8 {
            #[inline(always)]
            fn from(val: VbtlvdcrLvl) -> u8 {
                VbtlvdcrLvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VbtlvdicrIdtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl VbtlvdicrIdtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VbtlvdicrIdtsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VbtlvdicrIdtsel {
            #[inline(always)]
            fn from(val: u8) -> VbtlvdicrIdtsel {
                VbtlvdicrIdtsel::from_bits(val)
            }
        }
        impl From<VbtlvdicrIdtsel> for u8 {
            #[inline(always)]
            fn from(val: VbtlvdicrIdtsel) -> u8 {
                VbtlvdicrIdtsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VbtlvdicrIe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VbtlvdicrIe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VbtlvdicrIe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VbtlvdicrIe {
            #[inline(always)]
            fn from(val: u8) -> VbtlvdicrIe {
                VbtlvdicrIe::from_bits(val)
            }
        }
        impl From<VbtlvdicrIe> for u8 {
            #[inline(always)]
            fn from(val: VbtlvdicrIe) -> u8 {
                VbtlvdicrIe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VbtlvdsrDet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VbtlvdsrDet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VbtlvdsrDet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VbtlvdsrDet {
            #[inline(always)]
            fn from(val: u8) -> VbtlvdsrDet {
                VbtlvdsrDet::from_bits(val)
            }
        }
        impl From<VbtlvdsrDet> for u8 {
            #[inline(always)]
            fn from(val: VbtlvdsrDet) -> u8 {
                VbtlvdsrDet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VbtlvdsrMon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VbtlvdsrMon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VbtlvdsrMon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VbtlvdsrMon {
            #[inline(always)]
            fn from(val: u8) -> VbtlvdsrMon {
                VbtlvdsrMon::from_bits(val)
            }
        }
        impl From<VbtlvdsrMon> for u8 {
            #[inline(always)]
            fn from(val: VbtlvdsrMon) -> u8 {
                VbtlvdsrMon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VrtcmpcrCmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VrtcmpcrCmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VrtcmpcrCmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VrtcmpcrCmpe {
            #[inline(always)]
            fn from(val: u8) -> VrtcmpcrCmpe {
                VrtcmpcrCmpe::from_bits(val)
            }
        }
        impl From<VrtcmpcrCmpe> for u8 {
            #[inline(always)]
            fn from(val: VrtcmpcrCmpe) -> u8 {
                VrtcmpcrCmpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VrtlvdcrLvde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VrtlvdcrLvde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VrtlvdcrLvde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VrtlvdcrLvde {
            #[inline(always)]
            fn from(val: u8) -> VrtlvdcrLvde {
                VrtlvdcrLvde::from_bits(val)
            }
        }
        impl From<VrtlvdcrLvde> for u8 {
            #[inline(always)]
            fn from(val: VrtlvdcrLvde) -> u8 {
                VrtlvdcrLvde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VrtlvdcrLvl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl VrtlvdcrLvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VrtlvdcrLvl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VrtlvdcrLvl {
            #[inline(always)]
            fn from(val: u8) -> VrtlvdcrLvl {
                VrtlvdcrLvl::from_bits(val)
            }
        }
        impl From<VrtlvdcrLvl> for u8 {
            #[inline(always)]
            fn from(val: VrtlvdcrLvl) -> u8 {
                VrtlvdcrLvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VrtlvdicrIdtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl VrtlvdicrIdtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VrtlvdicrIdtsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VrtlvdicrIdtsel {
            #[inline(always)]
            fn from(val: u8) -> VrtlvdicrIdtsel {
                VrtlvdicrIdtsel::from_bits(val)
            }
        }
        impl From<VrtlvdicrIdtsel> for u8 {
            #[inline(always)]
            fn from(val: VrtlvdicrIdtsel) -> u8 {
                VrtlvdicrIdtsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VrtlvdicrIe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VrtlvdicrIe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VrtlvdicrIe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VrtlvdicrIe {
            #[inline(always)]
            fn from(val: u8) -> VrtlvdicrIe {
                VrtlvdicrIe::from_bits(val)
            }
        }
        impl From<VrtlvdicrIe> for u8 {
            #[inline(always)]
            fn from(val: VrtlvdicrIe) -> u8 {
                VrtlvdicrIe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VrtsrDet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VrtsrDet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VrtsrDet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VrtsrDet {
            #[inline(always)]
            fn from(val: u8) -> VrtsrDet {
                VrtsrDet::from_bits(val)
            }
        }
        impl From<VrtsrDet> for u8 {
            #[inline(always)]
            fn from(val: VrtsrDet) -> u8 {
                VrtsrDet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VrtsrMon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl VrtsrMon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VrtsrMon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VrtsrMon {
            #[inline(always)]
            fn from(val: u8) -> VrtsrMon {
                VrtsrMon::from_bits(val)
            }
        }
        impl From<VrtsrMon> for u8 {
            #[inline(always)]
            fn from(val: VrtsrMon) -> u8 {
                VrtsrMon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vrtvld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Vrtvld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vrtvld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vrtvld {
            #[inline(always)]
            fn from(val: u8) -> Vrtvld {
                Vrtvld::from_bits(val)
            }
        }
        impl From<Vrtvld> for u8 {
            #[inline(always)]
            fn from(val: Vrtvld) -> u8 {
                Vrtvld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtrf {
            #[inline(always)]
            fn from(val: u8) -> Wdtrf {
                Wdtrf::from_bits(val)
            }
        }
        impl From<Wdtrf> for u8 {
            #[inline(always)]
            fn from(val: Wdtrf) -> u8 {
                Wdtrf::to_bits(val)
            }
        }
    }
}
pub mod wdt {
    #[doc = "Watchdog Timer"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "WDT Refresh Register"]
        #[inline(always)]
        pub const fn wdtrr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "WDT Control Register"]
        #[inline(always)]
        pub const fn wdtcr(self) -> crate::common::Reg<regs::Wdtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "WDT Status Register"]
        #[inline(always)]
        pub const fn wdtsr(self) -> crate::common::Reg<regs::Wdtsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "WDT Reset Control Register"]
        #[inline(always)]
        pub const fn wdtrcr(self) -> crate::common::Reg<regs::Wdtrcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "WDT Count Stop Control Register"]
        #[inline(always)]
        pub const fn wdtcstpr(self) -> crate::common::Reg<regs::Wdtcstpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "WDT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtcr(pub u16);
        impl Wdtcr {
            #[doc = "Timeout Period Select"]
            #[inline(always)]
            pub const fn tops(&self) -> super::vals::Tops {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Tops::from_bits(val as u8)
            }
            #[doc = "Timeout Period Select"]
            #[inline(always)]
            pub fn set_tops(&mut self, val: super::vals::Tops) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Clock Division Ratio Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Cks {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Cks::from_bits(val as u8)
            }
            #[doc = "Clock Division Ratio Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Cks) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u16) & 0x0f) << 4usize);
            }
            #[doc = "Window End Position Select"]
            #[inline(always)]
            pub const fn rpes(&self) -> super::vals::Rpes {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Rpes::from_bits(val as u8)
            }
            #[doc = "Window End Position Select"]
            #[inline(always)]
            pub fn set_rpes(&mut self, val: super::vals::Rpes) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Window Start Position Select"]
            #[inline(always)]
            pub const fn rpss(&self) -> super::vals::Rpss {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Rpss::from_bits(val as u8)
            }
            #[doc = "Window Start Position Select"]
            #[inline(always)]
            pub fn set_rpss(&mut self, val: super::vals::Rpss) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
        }
        impl Default for Wdtcr {
            #[inline(always)]
            fn default() -> Wdtcr {
                Wdtcr(0)
            }
        }
        impl core::fmt::Debug for Wdtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtcr")
                    .field("tops", &self.tops())
                    .field("cks", &self.cks())
                    .field("rpes", &self.rpes())
                    .field("rpss", &self.rpss())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Wdtcr {{ tops: {:?}, cks: {:?}, rpes: {:?}, rpss: {:?} }}",
                    self.tops(),
                    self.cks(),
                    self.rpes(),
                    self.rpss()
                )
            }
        }
        #[doc = "WDT Count Stop Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtcstpr(pub u8);
        impl Wdtcstpr {
            #[doc = "Sleep,Mode Count Stop Control Register"]
            #[inline(always)]
            pub const fn slcstp(&self) -> super::vals::Slcstp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Slcstp::from_bits(val as u8)
            }
            #[doc = "Sleep,Mode Count Stop Control Register"]
            #[inline(always)]
            pub fn set_slcstp(&mut self, val: super::vals::Slcstp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Wdtcstpr {
            #[inline(always)]
            fn default() -> Wdtcstpr {
                Wdtcstpr(0)
            }
        }
        impl core::fmt::Debug for Wdtcstpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtcstpr")
                    .field("slcstp", &self.slcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtcstpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Wdtcstpr {{ slcstp: {:?} }}", self.slcstp())
            }
        }
        #[doc = "WDT Reset Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtrcr(pub u8);
        impl Wdtrcr {
            #[doc = "WDT Behavior Selection"]
            #[inline(always)]
            pub const fn rstirqs(&self) -> super::vals::Rstirqs {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rstirqs::from_bits(val as u8)
            }
            #[doc = "WDT Behavior Selection"]
            #[inline(always)]
            pub fn set_rstirqs(&mut self, val: super::vals::Rstirqs) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Wdtrcr {
            #[inline(always)]
            fn default() -> Wdtrcr {
                Wdtrcr(0)
            }
        }
        impl core::fmt::Debug for Wdtrcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtrcr")
                    .field("rstirqs", &self.rstirqs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtrcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Wdtrcr {{ rstirqs: {:?} }}", self.rstirqs())
            }
        }
        #[doc = "WDT Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtsr(pub u16);
        impl Wdtsr {
            #[doc = "Down,Counter Value"]
            #[inline(always)]
            pub const fn cntval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Down,Counter Value"]
            #[inline(always)]
            pub fn set_cntval(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u16) & 0x3fff) << 0usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn undff(&self) -> super::vals::Undff {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Undff::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_undff(&mut self, val: super::vals::Undff) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub const fn refef(&self) -> super::vals::Refef {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Refef::from_bits(val as u8)
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub fn set_refef(&mut self, val: super::vals::Refef) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Wdtsr {
            #[inline(always)]
            fn default() -> Wdtsr {
                Wdtsr(0)
            }
        }
        impl core::fmt::Debug for Wdtsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtsr")
                    .field("cntval", &self.cntval())
                    .field("undff", &self.undff())
                    .field("refef", &self.refef())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Wdtsr {{ cntval: {=u16:?}, undff: {:?}, refef: {:?} }}",
                    self.cntval(),
                    self.undff(),
                    self.refef()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cks {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cks {
            #[inline(always)]
            fn from(val: u8) -> Cks {
                Cks::from_bits(val)
            }
        }
        impl From<Cks> for u8 {
            #[inline(always)]
            fn from(val: Cks) -> u8 {
                Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Refef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refef {
            #[inline(always)]
            fn from(val: u8) -> Refef {
                Refef::from_bits(val)
            }
        }
        impl From<Refef> for u8 {
            #[inline(always)]
            fn from(val: Refef) -> u8 {
                Refef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpes {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rpes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpes {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpes {
            #[inline(always)]
            fn from(val: u8) -> Rpes {
                Rpes::from_bits(val)
            }
        }
        impl From<Rpes> for u8 {
            #[inline(always)]
            fn from(val: Rpes) -> u8 {
                Rpes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rpss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpss {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpss {
            #[inline(always)]
            fn from(val: u8) -> Rpss {
                Rpss::from_bits(val)
            }
        }
        impl From<Rpss> for u8 {
            #[inline(always)]
            fn from(val: Rpss) -> u8 {
                Rpss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rstirqs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rstirqs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rstirqs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rstirqs {
            #[inline(always)]
            fn from(val: u8) -> Rstirqs {
                Rstirqs::from_bits(val)
            }
        }
        impl From<Rstirqs> for u8 {
            #[inline(always)]
            fn from(val: Rstirqs) -> u8 {
                Rstirqs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Slcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slcstp {
            #[inline(always)]
            fn from(val: u8) -> Slcstp {
                Slcstp::from_bits(val)
            }
        }
        impl From<Slcstp> for u8 {
            #[inline(always)]
            fn from(val: Slcstp) -> u8 {
                Slcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tops {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tops {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tops {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tops {
            #[inline(always)]
            fn from(val: u8) -> Tops {
                Tops::from_bits(val)
            }
        }
        impl From<Tops> for u8 {
            #[inline(always)]
            fn from(val: Tops) -> u8 {
                Tops::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Undff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Undff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Undff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Undff {
            #[inline(always)]
            fn from(val: u8) -> Undff {
                Undff::from_bits(val)
            }
        }
        impl From<Undff> for u8 {
            #[inline(always)]
            fn from(val: Undff) -> u8 {
                Undff::to_bits(val)
            }
        }
    }
}
